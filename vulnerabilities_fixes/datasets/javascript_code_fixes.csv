vulnerable_code,fixed_code
"var INVALID_ESCAPES = /[^\\]\\[^.*+?^${}()|[\]\\bBcdDfnrsStvwWxu0-9]/;
var validators = require('./'),
	formats = {
		'date-time': /^\d{4}-(0[0-9]{1}|1[0-2]{1})-[0-9]{2}[t ]\d{2}:\d{2}:\d{2}(\.\d+)?([zZ]|[+-]\d{2}:\d{2})$/i,
		'date': /^\d{4}-(0[0-9]{1}|1[0-2]{1})-[0-9]{2}$/,
		'time': /^\d{2}:\d{2}:\d{2}$/,
		'color': /^(#[0-9a-f]{3}|#[0-9a-f]{6}|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow)$/i,
		'style': /^(?:\s*-?[_A-Z]+[_A-Z0-9-]*:[^\n\r\f;]+;)*\s*-?[_A-Z]+[_A-Z0-9-]*:[^\n\r\f;]+;?\s*$/i,
		'phone': /^(?:(?:\(?(?:00|\+)(?:[1-4]\d\d|[1-9]\d?)\)?)?[\-\.\ \\\/]?)?(?:(?:\(?\d{1,}\)?[\-\.\ \\\/]?){0,})(?:[\-\.\ \\\/]?(?:#|ext\.?|extension|x)[\-\.\ \\\/]?(?:\d+))?$/i,
		'uri': /^(?:([a-z0-9+.-]+:\/\/)((?:(?:[a-z0-9-._~!$&'()*+,;=:]|%[0-9A-F]{2})*)@)?((?:[a-z0-9-._~!$&'()*+,;=]|%[0-9A-F]{2})*)(:(?:\d*))?(\/(?:[a-z0-9-._~!$&'()*+,;=:@\/]|%[0-9A-F]{2})*)?|([a-z0-9+.-]+:)(\/?(?:[a-z0-9-._~!$&'()*+,;=:@]|%[0-9A-F]{2})+(?:[a-z0-9-._~!$&'()*+,;=:@\/]|%[0-9A-F]{2})*)?)(\?(?:[a-z0-9-._~!$&'()*+,;=:\/?@]|%[0-9A-F]{2})*)?(#(?:[a-z0-9-._~!$&'()*+,;=:\/?@]|%[0-9A-F]{2})*)?$/i,
		'email': /^[A-Z0-9._%+-]+@(?:[A-Z0-9-]+\.)+[A-Z]{2,}$/i,
		'ipv4': /^(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])$/,
		'ipv6': /^\s*((([0-9A-F]{1,4}:){7}([0-9A-F]{1,4}|:))|(([0-9A-F]{1,4}:){6}(:[0-9A-F]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-F]{1,4}:){5}(((:[0-9A-F]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-F]{1,4}:){4}(((:[0-9A-F]{1,4}){1,3})|((:[0-9A-F]{1,4})((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-F]{1,4}:){3}(((:[0-9A-F]{1,4}){1,4})|((:[0-9A-F]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-F]{1,4}:){2}(((:[0-9A-F]{1,4}){1,5})|((:[0-9A-F]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-F]{1,4}:){1}(((:[0-9A-F]{1,4}){1,6})|((:[0-9A-F]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-F]{1,4}){1,7})|((:[0-9A-F]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/i,

		// hostname regex from: http://stackoverflow.com/a/1420225/5628
		'hostname': /^(?=.{1,255}$)[0-9A-Z](?:(?:[0-9A-Z]|-){0,61}[0-9A-Z])?(?:\.[0-9A-Z](?:(?:[0-9A-Z]|-){0,61}[0-9A-Z])?)*\.?$/i,

		'utc-millisec': function(subject) {
			var parsed = parseInt(subject, 10);
			return !isNaN(parsed) && parsed.toString() === subject.toString();
		},
		'regex': function (subject) {
			if(INVALID_ESCAPES.test(subject)) return false;
			try {
				new RegExp(subject);
				return true;
			}
			catch(e) {
				return false;
			}
		}
	};

// aliases
formats['host-name'] = formats.hostname;
formats['ip-address'] = formats.ipv4;


function getType(subject) {
	var type = typeof subject;

	if(type === 'object') {
		if(subject === null) return 'null';
		if(Array.isArray(subject)) return 'array';
	}

	if(type === 'number' && subject === Math.round(subject)) return 'integer';

	return type;
}

function format(context, subject, schema) {
	var fmt = schema.format,
		validator = formats[fmt];

	if(!validator)
		throw new Error('Invalid schema: unknown format (' + fmt + ')');

	var valid = validator.test ? validator.test(subject) : validator(subject);
	if(!valid) {
		context.addError('Failed ""format"" criteria (' + fmt + ')', subject, schema);
	}

	return valid;
}

function validateTypes(context, subject, type, validTypes) {
	var i = validTypes.length,
		validType, valid;
	while(i--) {
		validType = validTypes[i];

		if(validType === 'any') return true;

		if(typeof validType === 'object') {
			valid = context.silently(function() {
				return validateBase(context, subject, validType);
			}); // jshint ignore:line
			if(valid) return true;
			else continue;
		}

		if(!(validType in validators.types))
			throw new Error('Invalid schema: invalid type (' + validType + ')');

		if(validType === 'number' && type === 'integer') return true;

		if(type === validType) return true;
	}

	return false;
}

function allOf(context, subject, schema) {
	var schemas = schema.allOf;

	if(!Array.isArray(schemas))
		throw new Error('Invalid schema: ""allOf"" value must be an array');

	var i = schemas.length,
		invalidCount = 0;
	while(i--) {
		if(!validateBase(context, subject, schemas[i])) {
			invalidCount += 1;
		}
	}

	if(invalidCount === 0) return true;

	context.addError('Failed ""allOf"" criteria', subject, schemas);
	return false;
}

function anyOf(context, subject, schema) {
	var schemas = schema.anyOf;

	if(!Array.isArray(schemas))
		throw new Error('Invalid schema: ""anyOf"" value must be an array');

	var matched = context.silently(function() {
		var i = schemas.length;
		while(i--) {
			if(validateBase(context, subject, schemas[i])) return true;
		}
		return false;
	});

	if(matched) return true;

	context.addError('Failed ""anyOf"" criteria', subject, schemas);
	return false;
}

function oneOf(context, subject, schema) {
	var schemas = schema.oneOf;

	if(!Array.isArray(schemas))
		throw new Error('Invalid schema: ""oneOf"" value must be an array');

	var i = schemas.length,
		validCount = 0;
	context.silently(function() {
		while(i--) {
			if(validateBase(context, subject, schemas[i])) validCount += 1;
		}
	});

	if(validCount === 1) return true;

	context.addError('Failed ""oneOf"" criteria', subject, schemas);
	return false;
}

function not(context, subject, schema) {
	var badSchema = schema.not,
		valid = context.silently(function() {
			return !validateBase(context, subject, badSchema);
		});

	if(valid) return true;

	context.addError('Failed ""not"" criteria', subject, schema);
	return false;
}

function disallow(context, subject, schema, type) {
	var invalidTypes = Array.isArray(schema.disallow) ? schema.disallow : [ schema.disallow ],
		valid = !validateTypes(context, subject, type, invalidTypes);

	if(!valid) {
		context.addError('Failed ""disallow"" criteria: expecting ' + invalidTypes.join(' or ') + ', found ' + type, subject, schema);
	}

	return valid;
}

function validateExtends(context, subject, schema) {
	var schemas = Array.isArray(schema[""extends""]) ? schema[""extends""] : [ schema[""extends""] ];

	var i = schemas.length,
		invalidCount = 0;
	while(i--) {
		if(!validateBase(context, subject, schemas[i])) {
			invalidCount += 1;
		}
	}

	return invalidCount === 0;
}

function validateEnum(context, subject, schema) {
	var values = schema['enum'];

	if(!Array.isArray(values))
		throw new Error('Invalid schema: ""enum"" value must be an array');

	var i = values.length;
	while(i--) {
		if(validators.deepEqual(subject, values[i])) return true;
	}

	context.addError('Failed ""enum"" criteria', subject, values);
	return false;
}

function validateType(context, subject, schema, type) {
	var validTypes = Array.isArray(schema.type) ? schema.type : [ schema.type ],
		valid = validateTypes(context, subject, type, validTypes);

	if(!valid) {
		context.addError('Failed ""type"" criteria: expecting ' + validTypes.join(' or ') + ', found ' + type, subject, schema);
	}

	return valid;
}

function typeValidations(context, subject, schema, type) {
	return validators.types[type](context, subject, schema);
}

function pathFromIds(ids) {
	return ids.map(function(id) {
		var lastSlash = id.lastIndexOf(""/"");
		if(lastSlash === -1) return id;
		return id.substr(0, lastSlash + 1);
	}).join('');
}

function $ref(context, subject, schema) {
	var absolute = /^(#|\/)/.test(schema.$ref),
		ref = absolute ? schema.$ref : pathFromIds(context.id) + schema.$ref,
		refSchema = context.refs.get(ref, context.schema),
		ctx = context;

	if(schema.$ref[0] !== '#') {
		ctx = context.subcontext(context.refs.get(ref, context.schema, true));
	}

	var valid = validateBase(ctx, subject, refSchema);

	context.cleanSubject = ctx.cleanSubject;

	return valid;
}



function validateBase(context, subject, schema) {
	if(schema.$ref) {
		return $ref(context, subject, schema);
	}

	if(schema.id) context.id.push(schema.id);

	var valid = context.runValidations([
		[ 'type' in schema, validateType ],
		[ 'disallow' in schema, disallow ],
		[ 'enum' in schema, validateEnum ],
		[ true, typeValidations ],
		[ 'format' in schema, format ],
		[ 'extends' in schema, validateExtends ],
		[ 'allOf' in schema, allOf ],
		[ 'anyOf' in schema, anyOf ],
		[ 'oneOf' in schema, oneOf ],
		[ 'not' in schema, not ]
	], subject, schema, getType(subject));

	if(schema.id) context.id.pop();

	return valid;
}

module.exports = validateBase;
","var INVALID_ESCAPES = /[^\\]\\[^.*+?^${}()|[\]\\bBcdDfnrsStvwWxu0-9]/;
var validators = require('./'),
	formats = {
		'date-time': /^\d{4}-(0[0-9]{1}|1[0-2]{1})-[0-9]{2}[t ]\d{2}:\d{2}:\d{2}(\.\d+)?([zZ]|[+-]\d{2}:\d{2})$/i,
		'date': /^\d{4}-(0[0-9]{1}|1[0-2]{1})-[0-9]{2}$/,
		'time': /^\d{2}:\d{2}:\d{2}$/,
		'color': /^(#[0-9a-f]{3}|#[0-9a-f]{6}|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow)$/i,
		'style': /^(?:\s*-?[_A-Z]+[_A-Z0-9-]*:[^\n\r\f;]+;)*\s*-?[_A-Z]+[_A-Z0-9-]*:[^\n\r\f;]+;?\s*$/i,
		'phone': /^(?:(?:\(?(?:00|\+)(?:[1-4]\d\d|[1-9]\d?)\)?)?[\-\.\ \\\/]?)?(?:(?:\(?\d{1,}\)?[\-\.\ \\\/]?){0,})(?:[\-\.\ \\\/]?(?:#|ext\.?|extension|x)[\-\.\ \\\/]?(?:\d+))?$/i,
		'uri': /^(?:([a-z0-9+.-]+:\/\/)((?:(?:[a-z0-9-._~!$&'()*+,;=:]|%[0-9A-F]{2})*)@)?((?:[a-z0-9-._~!$&'()*+,;=]|%[0-9A-F]{2})*)(:(?:\d*))?(\/(?:[a-z0-9-._~!$&'()*+,;=:@\/]|%[0-9A-F]{2})*)?|([a-z0-9+.-]+:)(\/?(?:[a-z0-9-._~!$&'()*+,;=:@]|%[0-9A-F]{2})(?:[a-z0-9-._~!$&'()*+,;=:@\/]|%[0-9A-F]{2})*)?)(\?(?:[a-z0-9-._~!$&'()*+,;=:\/?@]|%[0-9A-F]{2})*)?(#(?:[a-z0-9-._~!$&'()*+,;=:\/?@]|%[0-9A-F]{2})*)?$/i,
		'email': /^[A-Z0-9._%+-]+@(?:[A-Z0-9-]+\.)+[A-Z]{2,}$/i,
		'ipv4': /^(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])$/,
		'ipv6': /^\s*((([0-9A-F]{1,4}:){7}([0-9A-F]{1,4}|:))|(([0-9A-F]{1,4}:){6}(:[0-9A-F]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-F]{1,4}:){5}(((:[0-9A-F]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-F]{1,4}:){4}(((:[0-9A-F]{1,4}){1,3})|((:[0-9A-F]{1,4})((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-F]{1,4}:){3}(((:[0-9A-F]{1,4}){1,4})|((:[0-9A-F]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-F]{1,4}:){2}(((:[0-9A-F]{1,4}){1,5})|((:[0-9A-F]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-F]{1,4}:){1}(((:[0-9A-F]{1,4}){1,6})|((:[0-9A-F]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-F]{1,4}){1,7})|((:[0-9A-F]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/i,

		// hostname regex from: http://stackoverflow.com/a/1420225/5628
		'hostname': /^(?=.{1,255}$)[0-9A-Z](?:(?:[0-9A-Z]|-){0,61}[0-9A-Z])?(?:\.[0-9A-Z](?:(?:[0-9A-Z]|-){0,61}[0-9A-Z])?)*\.?$/i,

		'utc-millisec': function(subject) {
			var parsed = parseInt(subject, 10);
			return !isNaN(parsed) && parsed.toString() === subject.toString();
		},
		'regex': function (subject) {
			if(INVALID_ESCAPES.test(subject)) return false;
			try {
				new RegExp(subject);
				return true;
			}
			catch(e) {
				return false;
			}
		}
	};

// aliases
formats['host-name'] = formats.hostname;
formats['ip-address'] = formats.ipv4;


function getType(subject) {
	var type = typeof subject;

	if(type === 'object') {
		if(subject === null) return 'null';
		if(Array.isArray(subject)) return 'array';
	}

	if(type === 'number' && subject === Math.round(subject)) return 'integer';

	return type;
}

function format(context, subject, schema) {
	var fmt = schema.format,
		validator = formats[fmt];

	if(!validator)
		throw new Error('Invalid schema: unknown format (' + fmt + ')');

	var valid = validator.test ? validator.test(subject) : validator(subject);
	if(!valid) {
		context.addError('Failed ""format"" criteria (' + fmt + ')', subject, schema);
	}

	return valid;
}

function validateTypes(context, subject, type, validTypes) {
	var i = validTypes.length,
		validType, valid;
	while(i--) {
		validType = validTypes[i];

		if(validType === 'any') return true;

		if(typeof validType === 'object') {
			valid = context.silently(function() {
				return validateBase(context, subject, validType);
			}); // jshint ignore:line
			if(valid) return true;
			else continue;
		}

		if(!(validType in validators.types))
			throw new Error('Invalid schema: invalid type (' + validType + ')');

		if(validType === 'number' && type === 'integer') return true;

		if(type === validType) return true;
	}

	return false;
}

function allOf(context, subject, schema) {
	var schemas = schema.allOf;

	if(!Array.isArray(schemas))
		throw new Error('Invalid schema: ""allOf"" value must be an array');

	var i = schemas.length,
		invalidCount = 0;
	while(i--) {
		if(!validateBase(context, subject, schemas[i])) {
			invalidCount += 1;
		}
	}

	if(invalidCount === 0) return true;

	context.addError('Failed ""allOf"" criteria', subject, schemas);
	return false;
}

function anyOf(context, subject, schema) {
	var schemas = schema.anyOf;

	if(!Array.isArray(schemas))
		throw new Error('Invalid schema: ""anyOf"" value must be an array');

	var matched = context.silently(function() {
		var i = schemas.length;
		while(i--) {
			if(validateBase(context, subject, schemas[i])) return true;
		}
		return false;
	});

	if(matched) return true;

	context.addError('Failed ""anyOf"" criteria', subject, schemas);
	return false;
}

function oneOf(context, subject, schema) {
	var schemas = schema.oneOf;

	if(!Array.isArray(schemas))
		throw new Error('Invalid schema: ""oneOf"" value must be an array');

	var i = schemas.length,
		validCount = 0;
	context.silently(function() {
		while(i--) {
			if(validateBase(context, subject, schemas[i])) validCount += 1;
		}
	});

	if(validCount === 1) return true;

	context.addError('Failed ""oneOf"" criteria', subject, schemas);
	return false;
}

function not(context, subject, schema) {
	var badSchema = schema.not,
		valid = context.silently(function() {
			return !validateBase(context, subject, badSchema);
		});

	if(valid) return true;

	context.addError('Failed ""not"" criteria', subject, schema);
	return false;
}

function disallow(context, subject, schema, type) {
	var invalidTypes = Array.isArray(schema.disallow) ? schema.disallow : [ schema.disallow ],
		valid = !validateTypes(context, subject, type, invalidTypes);

	if(!valid) {
		context.addError('Failed ""disallow"" criteria: expecting ' + invalidTypes.join(' or ') + ', found ' + type, subject, schema);
	}

	return valid;
}

function validateExtends(context, subject, schema) {
	var schemas = Array.isArray(schema[""extends""]) ? schema[""extends""] : [ schema[""extends""] ];

	var i = schemas.length,
		invalidCount = 0;
	while(i--) {
		if(!validateBase(context, subject, schemas[i])) {
			invalidCount += 1;
		}
	}

	return invalidCount === 0;
}

function validateEnum(context, subject, schema) {
	var values = schema['enum'];

	if(!Array.isArray(values))
		throw new Error('Invalid schema: ""enum"" value must be an array');

	var i = values.length;
	while(i--) {
		if(validators.deepEqual(subject, values[i])) return true;
	}

	context.addError('Failed ""enum"" criteria', subject, values);
	return false;
}

function validateType(context, subject, schema, type) {
	var validTypes = Array.isArray(schema.type) ? schema.type : [ schema.type ],
		valid = validateTypes(context, subject, type, validTypes);

	if(!valid) {
		context.addError('Failed ""type"" criteria: expecting ' + validTypes.join(' or ') + ', found ' + type, subject, schema);
	}

	return valid;
}

function typeValidations(context, subject, schema, type) {
	return validators.types[type](context, subject, schema);
}

function pathFromIds(ids) {
	return ids.map(function(id) {
		var lastSlash = id.lastIndexOf(""/"");
		if(lastSlash === -1) return id;
		return id.substr(0, lastSlash + 1);
	}).join('');
}

function $ref(context, subject, schema) {
	var absolute = /^(#|\/)/.test(schema.$ref),
		ref = absolute ? schema.$ref : pathFromIds(context.id) + schema.$ref,
		refSchema = context.refs.get(ref, context.schema),
		ctx = context;

	if(schema.$ref[0] !== '#') {
		ctx = context.subcontext(context.refs.get(ref, context.schema, true));
	}

	var valid = validateBase(ctx, subject, refSchema);

	context.cleanSubject = ctx.cleanSubject;

	return valid;
}



function validateBase(context, subject, schema) {
	if(schema.$ref) {
		return $ref(context, subject, schema);
	}

	if(schema.id) context.id.push(schema.id);

	var valid = context.runValidations([
		[ 'type' in schema, validateType ],
		[ 'disallow' in schema, disallow ],
		[ 'enum' in schema, validateEnum ],
		[ true, typeValidations ],
		[ 'format' in schema, format ],
		[ 'extends' in schema, validateExtends ],
		[ 'allOf' in schema, allOf ],
		[ 'anyOf' in schema, anyOf ],
		[ 'oneOf' in schema, oneOf ],
		[ 'not' in schema, not ]
	], subject, schema, getType(subject));

	if(schema.id) context.id.pop();

	return valid;
}

module.exports = validateBase;
"
"/**
 * kronolith.js - Base application logic.
 *
 * TODO: loadingImg()
 *
 * Copyright 2008-2017 Horde LLC (http://www.horde.org/)
 *
 * See the enclosed file COPYING for license information (GPL). If you
 * did not receive this file, see http://www.horde.org/licenses/gpl.
 *
 * @author Jan Schneider <jan@horde.org>
 */

/* Kronolith object. */
KronolithCore = {
    // Vars used and defaulting to null/false:
    //   weekSizes, daySizes,
    //   groupLoading, colorPicker, duration, timeMarker, monthDays,
    //   allDays, eventsWeek, initialized

    view: '',
    ecache: $H(),
    cacheStart: null,
    cacheEnd: null,
    holidays: [],
    tcache: $H(),
    eventsLoading: {},
    loading: 0,
    viewLoading: [],
    fbLoading: 0,
    redBoxLoading: false,
    date: Date.today(),
    tasktype: 'incomplete',
    knl: {},
    wrongFormat: $H(),
    mapMarker: null,
    map: null,
    mapInitialized: false,
    freeBusy: $H(),
    search: 'future',
    effectDur: 0.4,
    macos: navigator.appVersion.indexOf('Mac') != -1,
    orstart: null,
    orend: null,
    lastRecurType: 'None',
    uatts: null,
    ucb: null,
    resourceACCache: { choices: [], map: $H() },
    paramsCache: null,
    attendees: [],
    resources: [],

    /**
     * Flag that indicates if the event currently displayed in the event
     * properties window is a recurring event.
     *
     * @type boolean
     */
    recurs: false,

    /**
     * The location that was open before the current location.
     *
     * @var string
     */
    lastLocation: '',

    /**
     * The currently open location.
     *
     * @var string
     */
    openLocation: '',

    /**
     * The current (main) location.
     *
     * This is different from openLocation as it isn't updated for any
     * locations that are opened in a popup view, e.g. events.
     *
     * @var string
     */
    currentLocation: '',

    kronolithBody: $('kronolithBody'),

    onException: function(parentfunc, r, e)
    {
        /* Make sure loading images are closed. */
        this.loading--;
        if (!this.loading) {
            $('kronolithLoading').hide();
        }
        this.closeRedBox();
        HordeCore.notify(HordeCore.text.ajax_error, 'horde.error');
        parentfunc(r, e);
    },

    setTitle: function(title)
    {
        document.title = Kronolith.conf.name + ' :: ' + title;
        return title;
    },

    // url = (string) URL to redirect to
    // hash = (boolean) If true, url is treated as hash information to alter
    //        on the current page
    redirect: function(url, hash)
    {
        if (hash) {
            window.location.hash = escape(url);
            window.location.reload();
        } else {
            HordeCore.redirect(url);
        }
    },

    go: function(fullloc, data)
    {
        if (!this.initialized) {
            this.go.bind(this, fullloc, data).defer();
            return;
        }

        if (this.viewLoading.size()) {
            this.viewLoading.push([ fullloc, data ]);
            return;
        }

        var locParts = fullloc.split(':');
        var loc = locParts.shift();

        if (this.openLocation == fullloc) {
            return;
        }

        this.viewLoading.push([ fullloc, data ]);

        if (loc != 'search') {
            HordeTopbar.searchGhost.reset();
        }

        this.switchTaskView(false);

        switch (loc) {
        case 'day':
        case 'week':
        case 'workweek':
        case 'month':
        case 'year':
        case 'agenda':
        case 'tasks':
            this.closeView(loc);
            var locCap = loc.capitalize();
            $('kronolithNav' + locCap).up().addClassName('horde-active');

            switch (loc) {
            case 'day':
            case 'agenda':
            case 'week':
            case 'workweek':
            case 'month':
            case 'year':
                var date = locParts.shift();
                if (date) {
                    date = this.parseDate(date);
                } else {
                    date = this.date;
                }

                if (this.view != 'agenda' &&
                    this.view == loc &&
                    date.getYear() == this.date.getYear() &&
                    ((loc == 'year') ||
                     (loc == 'month' && date.getMonth() == this.date.getMonth()) ||
                     ((loc == 'week' || loc == 'workweek') && date.getRealWeek() == this.date.getRealWeek()) ||
                     ((loc == 'day'  || loc == 'agenda') && date.dateString() == this.date.dateString()))) {
                         this.setViewTitle(date, loc);
                         this.addHistory(fullloc);
                         this.loadNextView();
                         return;
                }

                this.addHistory(fullloc);
                this.view = loc;
                this.date = date;
                this.updateView(date, loc);
                var dates = this.viewDates(date, loc);
                this.loadEvents(dates[0], dates[1], loc);
                $('kronolithView' + locCap).appear({
                        duration: this.effectDur,
                        queue: 'end',
                        afterFinish: function() {
                            if (loc == 'week' || loc == 'workweek' || loc == 'day') {
                                this.calculateRowSizes(loc + 'Sizes', 'kronolithView' + locCap);
                                if ($('kronolithTimeMarker')) {
                                    this.positionTimeMarker();
                                }
                                if ($('kronolithTimeMarker')) {
                                    $('kronolithTimeMarker').show();
                                }
                                // Scroll to the work day start time.
                                $('kronolithView' + locCap).down('.kronolithViewBody').scrollTop = 9 * this[loc + 'Sizes'].height;
                            }
                            this.loadNextView();
                        }.bind(this)
                });
                $('kronolithLoading' + loc).insert($('kronolithLoading').remove());
                this.updateMinical(date, loc);

                break;

            case 'tasks':
                var tasktype = locParts.shift() || this.tasktype;


                this.switchTaskView(true);
                $('kronolithCurrent')
                    .update(this.setTitle(Kronolith.text.tasks));
                if (this.view == loc && this.tasktype == tasktype) {
                    this.addHistory(fullloc);
                    this.loadNextView();
                    return;
                }
                if (!$w('all complete incomplete future').include(tasktype)) {
                    this.loadNextView();
                    return;
                }

                this.addHistory(fullloc);
                this.view = loc;
                this.tasktype = tasktype;
                $w('All Complete Incomplete Future').each(function(tasktype) {
                    $('kronolithTasks' + tasktype).up().removeClassName('horde-active');
                });
                $('kronolithTasks' + this.tasktype.capitalize()).up().addClassName('horde-active');
                this.loadTasks(this.tasktype);
                $('kronolithView' + locCap).appear({
                    duration: this.effectDur,
                    queue: 'end',
                    afterFinish: function() {
                        this.loadNextView();
                    }.bind(this) });
                $('kronolithLoading' + loc).insert($('kronolithLoading').remove());
                this.updateMinical(this.date);

                break;

            default:
                if (!$('kronolithView' + locCap)) {
                    break;
                }
                this.addHistory(fullloc);
                this.view = loc;
                $('kronolithView' + locCap).appear({
                    duration: this.effectDur,
                    queue: 'end',
                    afterFinish: function() {
                        this.loadNextView();
                    }.bind(this) });
                break;
            }

            break;

        case 'search':
            var cals = [], time = locParts[0], term = locParts[1],
                query = Object.toJSON({ title: term });

            if (!($w('all past future').include(time))) {
                this.loadNextView();
                return;
            }

            this.addHistory(fullloc);
            this.search = time;
            $w('All Past Future').each(function(time) {
                $('kronolithSearch' + time).up().removeClassName('horde-active');
            });
            $('kronolithSearch' + this.search.capitalize()).up().addClassName('horde-active');
            this.closeView('agenda');
            this.view = 'agenda';
            this.updateView(null, 'search', term);
            $H(Kronolith.conf.calendars).each(function(type) {
                $H(type.value).each(function(calendar) {
                    if (calendar.value.show) {
                        cals.push(type.key + '|' + calendar.key);
                    }
                });
            });
            $('kronolithAgendaNoItems').hide();
            this.startLoading('search', query);

            HordeCore.doAction('searchEvents', {
                cals: Object.toJSON(cals),
                query: query,
                time: this.search
            }, {
                callback: function(r) {
                    // Hide spinner.
                    this.loading--;
                    if (!this.loading) {
                        $('kronolithLoading').hide();
                    }
                    if (r.view != 'search' ||
                        r.query != this.eventsLoading.search) {
                        return;
                    }
                    if (Object.isUndefined(r.events)) {
                        $('kronolithAgendaNoItems').show();
                        return;
                    }
                    delete this.eventsLoading.search;
                    $H(r.events).each(function(calendars) {
                        $H(calendars.value).each(function(events) {
                            this.createAgendaDay(events.key);
                            $H(events.value).each(function(event) {
                                event.value.calendar = calendars.key;
                                event.value.start = Date.parse(event.value.s);
                                event.value.end = Date.parse(event.value.e);
                                this.insertEvent(event, events.key, 'agenda');
                            }, this);
                        }, this);
                    }, this);
                }.bind(this)
            });

            $('kronolithViewAgenda').appear({
                duration: this.effectDur,
                queue: 'end',
                afterFinish: function() {
                    this.loadNextView();
                }.bind(this) });
            $('kronolithLoadingagenda').insert($('kronolithLoading').remove());
            this.updateMinical(this.date);
            break;

        case 'event':
            // Load view first if necessary.
            if (!this.view ) {
                this.viewLoading.pop();
                this.go(Kronolith.conf.login_view);
                this.go.bind(this, fullloc, data).defer();
                return;
            }

            if (this.currentLocation == fullloc) {
                this.loadNextView();
                return;
            }

            this.addHistory(fullloc, false);
            switch (locParts.length) {
            case 0:
                // New event.
                this.editEvent();
                break;
            case 1:
                // New event on a certain date.
                this.editEvent(null, null, locParts[0]);
                break;
            default:
                // Editing event.
                var date = locParts.pop(),
                    event = locParts.pop(),
                    calendar = locParts.join(':');
                this.editEvent(calendar, event, date);
                break;
            }
            this.loadNextView();
            break;

        case 'task':
            // Load view first if necessary.
            if (!this.view ) {
                this.viewLoading.pop();
                this.go('tasks');
                this.go.bind(this, fullloc, data).defer();
                return;
            }

            this.switchTaskView(true);
            switch (locParts.length) {
            case 0:
                this.addHistory(fullloc, false);
                this.editTask();
                break;
            case 2:
                this.addHistory(fullloc, false);
                this.editTask(locParts[0], locParts[1]);
                break;
            }
            this.loadNextView();
            break;

        case 'calendar':
            if (!this.view) {
                this.viewLoading.pop();
                this.go(Kronolith.conf.login_view);
                this.go.bind(this, fullloc, data).defer();
                return;
            }
            this.addHistory(fullloc, false);
            this.editCalendar(locParts.join(':'));
            this.loadNextView();
            break;

        default:
            this.loadNextView();
            break;
        }
    },

    /**
     * Removes the last loaded view from the stack and loads the last added
     * view, if the stack is still not empty.
     *
     * We want to load views from a LIFO queue, because the queue is only
     * building up if the user switches to another view while the current view
     * still loads. In that case we can go directly to the most recently
     * clicked view and drop the remaining queue.
     */
    loadNextView: function()
    {
        var current = this.viewLoading.shift();
        if (this.viewLoading.size()) {
            var next = this.viewLoading.pop();
            this.viewLoading = [];
            if (current[0] != next[0] || current[1] || next[1]) {
                this.go(next[0], next[1]);
            }
        }
    },

    /**
     * Rebuilds one of the calendar views for a new date.
     *
     * @param Date date    The date to show in the calendar.
     * @param string view  The view that's rebuilt.
     * @param mixed data   Any additional data that might be required.
     */
    updateView: function(date, view, data)
    {
        this.holidays = [];

        switch (view) {
        case 'day':
            var today = Date.today();
            this.dayEvents = [];
            this.dayGroups = [];
            this.allDayEvents = [];
            $('kronolithCurrent')
                .update(this.setViewTitle(date, view, data));
            $('kronolithViewDay')
                .down('.kronolithAllDayContainer')
                .store('date', date.dateString());
            $('kronolithEventsDay').store('date', date.dateString());
            if (date.equals(today)) {
                this.addTimeMarker('kronolithEventsDay');
            }
            break;

        case 'week':
        case 'workweek':
            this.dayEvents = [];
            this.dayGroups = [];
            this.allDayEvents = [];
            this.allDays = {};
            this.eventsWeek = {};
            var what = view == 'week' ? 'Week' : 'Workweek',
                div = $('kronolithEvents' + what).down('div'),
                th = $('kronolithView' + what + 'Head').down('.kronolithWeekDay'),
                td = $('kronolithView' + what + 'Head').down('tbody td').next('td'),
                hourRow = $('kronolithView' + what + 'Body').down('tr'),
                dates = this.viewDates(date, view),
                today = Date.today(),
                day, dateString, i, hourCol;

            $('kronolithCurrent')
                .update(this.setViewTitle(date, view, data));

            for (i = 0; i < 24; i++) {
                day = dates[0].clone();
                hourCol = hourRow.down('td').next('td');
                while (hourCol) {
                    hourCol.removeClassName('kronolith-today');
                    if (day.equals(today)) {
                        hourCol.addClassName('kronolith-today');
                    }
                    hourCol = hourCol.next('td');
                    day.next().day();
                }
                hourRow = hourRow.next('tr');
            }
            day = dates[0].clone();

            for (i = 0; i < (view == 'week' ? 7 : 5); i++) {
                dateString = day.dateString();
                this.allDays['kronolithAllDay' + dateString] = td.down('div');
                this.eventsWeek['kronolithEvents' + what + dateString] = div;
                div.store('date', dateString)
                    .writeAttribute('id', 'kronolithEvents' + what + dateString);
                th.store('date', dateString)
                    .down('span').update(day.toString('dddd, d'));
                td.removeClassName('kronolith-today');
                this.allDays['kronolithAllDay' + dateString]
                    .writeAttribute('id', 'kronolithAllDay' + dateString)
                    .store('date', dateString);
                if (day.equals(today)) {
                    td.addClassName('kronolith-today');
                    this.addTimeMarker('kronolithEvents' + what + dateString);
                }
                new Drop(td.down('div'));
                div = div.next('div');
                th = th.next('td');
                td = td.next('td');
                day.next().day();
            }
            break;

        case 'month':
            var tbody = $('kronolith-month-body'),
                dates = this.viewDates(date, view),
                day = dates[0].clone();

            $('kronolithCurrent')
                .update(this.setViewTitle(date, view, data));

            // Remove old rows. Maybe we should only rebuild the calendars if
            // necessary.
            tbody.childElements().each(function(row) {
                if (row.identify() != 'kronolithRowTemplate') {
                    row.purge();
                    row.remove();
                }
            });

            // Build new calendar view.
            this.monthDays = {};
            while (!day.isAfter(dates[1])) {
                tbody.insert(this.createWeekRow(day, date.getMonth(), dates).show());
                day.next().week();
            }
            this.equalRowHeights(tbody);

            break;

        case 'year':
            var month;

            $('kronolithCurrent').update(this.setViewTitle(date, view, data));

            // Build new calendar view.
            for (month = 0; month < 12; month++) {
                $('kronolithYear' + month).update(this.createYearMonth(date.getFullYear(), month, 'kronolithYear').show());
            }

            break;

        case 'agenda':
        case 'search':
            // Agenda days are only created on demand, if there are any events
            // to add.
            if (view == 'agenda') {
                var dates = this.viewDates(date, view);
                $('kronolithCurrent')
                    .update(this.setViewTitle(date, view, data));
                $('kronolithSearchNavigation').up().up().hide();
            } else {
                $('kronolithCurrent')
                    .update(this.setViewTitle(date, view, data));
                $('kronolithSearchNavigation').up().up().show();
            }

            // Remove old rows. Maybe we should only rebuild the calendars if
            // necessary.
            tbody = $('kronolithViewAgendaBody').childElements().each(function(row) {
                if (row.identify() != 'kronolithAgendaTemplate' &&
                    row.identify() != 'kronolithAgendaNoItems') {
                    row.purge();
                    row.remove();
                }
            });

            break;
        }
    },

    /**
     * Sets the browser title of the calendar views.
     *
     * @param Date date    The date to show in the calendar.
     * @param string view  The view that's displayed.
     * @param mixed data   Any additional data that might be required.
     */
    setViewTitle: function(date, view, data)
    {
        switch (view) {
        case 'day':
            return this.setTitle(date.toString('D'));

        case 'week':
        case 'workweek':
            var dates = this.viewDates(date, view);
            return this.setTitle(dates[0].toString(Kronolith.conf.date_format) + ' - ' + dates[1].toString(Kronolith.conf.date_format));

        case 'month':
            return this.setTitle(date.toString('MMMM yyyy'));

        case 'year':
            return this.setTitle(date.toString('yyyy'));

        case 'agenda':
            var dates = this.viewDates(date, view);
            return this.setTitle(dates[0].toString(Kronolith.conf.date_format) + ' - ' + dates[1].toString(Kronolith.conf.date_format));

        case 'search':
            return this.setTitle(Kronolith.text.searching.interpolate({ term: data })).escapeHTML();
        }
    },

    /**
     * Closes the currently active view.
     */
    closeView: function(loc)
    {
        $w('Day Workweek Week Month Year Tasks Agenda').each(function(a) {
            a = $('kronolithNav' + a);
            if (a) {
                a.up().removeClassName('horde-active');
            }
        });
        if (this.view && this.view != loc) {
            $('kronolithView' + this.view.capitalize()).fade({
                duration: this.effectDur,
                queue: 'end'
            });
            this.view = null;
        }
    },

    /**
     * Creates a single row of day cells for usage in the month and multi-week
     * views.
     *
     * @param Date date        The first day to show in the row.
     * @param integer month    The current month. Days not from the current
     *                         month get the kronolith-other-month CSS class
     *                         assigned.
     * @param array viewDates  Array of Date objects with the start and end
     *                         dates of the view.
     *
     * @return Element  The element rendering a week row.
     */
    createWeekRow: function(date, month, viewDates)
    {
        var day = date.clone(), today = new Date().dateString(),
            row, cell, dateString;

        // Create a copy of the row template.
        row = $('kronolithRowTemplate').clone(true);
        row.removeAttribute('id');

        // Fill week number and day cells.
        cell = row.down()
            .setText(date.getRealWeek())
            .store('date', date.dateString())
            .next();
        while (cell) {
            dateString = day.dateString();
            this.monthDays['kronolithMonthDay' + dateString] = cell;
            cell.id = 'kronolithMonthDay' + dateString;
            cell.store('date', dateString);
            cell.removeClassName('kronolith-other-month').removeClassName('kronolith-today');
            if (day.getMonth() != month) {
                cell.addClassName('kronolith-other-month');
            }
            if (dateString == today) {
                cell.addClassName('kronolith-today');
            }
            new Drop(cell);
            cell.store('date', dateString)
                .down('.kronolith-day')
                .store('date', dateString)
                .update(day.getDate());

            cell = cell.next();
            day.add(1).day();
        }

        return row;
    },

    /**
     * Creates a table row for a single day in the agenda view, if it doesn't
     * exist yet.
     *
     * @param string date    The day to show in the row.
     *
     * @return Element  The element rendering a week row.
     */
    createAgendaDay: function(date)
    {
        // Exit if row exists already.
        if ($('kronolithAgendaDay' + date)) {
            return;
        }

        // Create a copy of the row template.
        var body = $('kronolithViewAgendaBody'),
            row = $('kronolithAgendaTemplate').clone(true);

        // Fill week number and day cells.
        row.store('date', date)
            .down()
            .setText(this.parseDate(date).toString('D'))
            .next()
            .writeAttribute('id', 'kronolithAgendaDay' + date);
        row.removeAttribute('id');

        // Insert row.
        var nextRow;
        body.childElements().each(function(elm) {
            if (elm.retrieve('date') > date) {
                nextRow = elm;
                throw $break;
            }
        });
        if (nextRow) {
            nextRow.insert({ before: row.show() });
        } else {
            body.insert(row.show());
        }

        return row;
    },

    /**
     * Creates a table for a single month in the year view.
     *
     * @param integer year     The year.
     * @param integer month    The month.
     * @param string idPrefix  If present, each day will get a DOM ID with this
     *                         prefix
     *
     * @return Element  The element rendering a month table.
     */
    createYearMonth: function(year, month, idPrefix)
    {
        // Create a copy of the month template.
        var table = $('kronolithYearTemplate').clone(true),
            tbody = table.down('tbody');
        table.removeAttribute('id');
        tbody.writeAttribute('id', 'kronolithYearTable' + month);

        // Set month name.
        table.down('tr.kronolith-minical-nav th')
            .store('date', year.toPaddedString(4) + (month + 1).toPaddedString(2) + '01')
            .update(Date.CultureInfo.monthNames[month]);

        // Build month table.
        this.buildMinical(tbody, new Date(year, month, 1), null, idPrefix, year);

        return table;
    },

    equalRowHeights: function(tbody)
    {
        var children = tbody.childElements();
        children.invoke('setStyle', { height: (100 / (children.size() - 1)) + '%' });
    },

    /**
     * Calculates some dimensions for the day and week view.
     *
     * @param string storage  Property name where the dimensions are stored.
     * @param string view     DOM node ID of the view.
     */
    calculateRowSizes: function(storage, view)
    {
        if (!Object.isUndefined(this[storage])) {
            return;
        }

        var td = $(view).down('.kronolithViewBody tr td').next('td'),
            layout = td.getLayout(),
            spacing = td.up('table').getStyle('borderSpacing');

        // FIXME: spacing is hardcoded for IE 7 because it doesn't know about
        // border-spacing, but still uses it. WTF?
        spacing = spacing ? parseInt($w(spacing)[1], 10) : 2;
        this[storage] = {};
        this[storage].height = layout.get('margin-box-height') + spacing;
        this[storage].spacing = this[storage].height - layout.get('padding-box-height') - layout.get('border-bottom');
    },

    /**
     * Adds a horizontal ruler representing the current time to the specified
     * container.
     *
     * @param string|Element  The container of the current day.
     */
    addTimeMarker: function(container)
    {
        if ($('kronolithTimeMarker')) {
            $('kronolithTimeMarker').remove();
            this.timeMarker.stop();
        }
        $(container).insert(new Element('div', { id: 'kronolithTimeMarker' }).setStyle({ position: 'absolute' }).hide());
        this.timeMarker = new PeriodicalExecuter(this.positionTimeMarker.bind(this), 60);
    },

    /**
     * Updates the horizontal ruler representing the current time.
     */
    positionTimeMarker: function()
    {
        var today = Date.today(), now;

        switch (this.view) {
        case 'day':
            if (!this.date.equals(today)) {
                $('kronolithTimeMarker').remove();
                this.timeMarker.stop();
                return;
            }
            break;
        case 'week':
        case 'workweek':
            if ($('kronolithTimeMarker').up().retrieve('date') != today.dateString()) {
                var newContainer = this.eventsWeek['kronolithEvents' + (this.view == 'week' ? 'Week' : 'Workweek') + today.dateString()];
                $('kronolithTimeMarker').remove();
                if (newContainer) {
                    this.addTimeMarker(newContainer);
                } else {
                    this.timeMarker.stop();
                }
                return;
            }
            break;
        default:
            $('kronolithTimeMarker').remove();
            this.timeMarker.stop();
            return;
        }

        now = new Date();
        $('kronolithTimeMarker').setStyle({ top: ((now.getHours() * 60 + now.getMinutes()) * this[this.view + 'Sizes'].height / 60 | 0) + 'px' });
    },

    /**
     * Rebuilds the mini calendar.
     *
     * @param Date date    The date to show in the calendar.
     * @param string view  The view that's displayed, determines which days in
     *                     the mini calendar are highlighted.
     */
    updateMinical: function(date, view)
    {
        // Update header.
        $('kronolithMinicalDate')
            .store('date', date.dateString())
            .update(date.toString('MMMM yyyy'));

        this.buildMinical($('kronolith-minical').down('tbody'), date, view);
    },

    /**
     * Creates a mini calendar suitable for the navigation calendar and the
     * year view.
     *
     * @param Element tbody    The table body to add the days to.
     * @param Date date        The date to show in the calendar.
     * @param string view      The view that's displayed, determines which days
     *                         in the mini calendar are highlighted.
     * @param string idPrefix  If present, each day will get a DOM ID with this
     *                         prefix
     * @param integer year     If present, generating mini calendars for the
     *                         year view of this year.
     */
    buildMinical: function(tbody, date, view, idPrefix, year)
    {
        var dates = this.viewDates(date, 'month'),
            day = dates[0].clone(),
            date7 = date.clone().add(1).week(),
            today = Date.today(),
            week = this.viewDates(this.date, 'week'),
            workweek = this.viewDates(this.date, 'workweek'),
            dateString, td, tr, i;

        // Remove old calendar rows. Maybe we should only rebuild the minical
        // if necessary.
        tbody.childElements().invoke('remove');

        for (i = 0; i < 42; i++) {
            dateString = day.dateString();
            // Create calendar row and insert week number.
            if (day.getDay() == Kronolith.conf.week_start) {
                tr = new Element('tr');
                tbody.insert(tr);
                td = new Element('td', { className: 'kronolith-minical-week' })
                    .store('weekdate', dateString);
                td.update(day.getRealWeek());
                tr.insert(td);
                weekStart = day.clone();
                weekEnd = day.clone();
                weekEnd.add(6).days();
            }

            // Insert day cell.
            td = new Element('td').store('date', dateString);
            if (day.getMonth() != date.getMonth()) {
                td.addClassName('kronolith-other-month');
            } else if (!Object.isUndefined(idPrefix)) {
                td.id = idPrefix + dateString;
            }

            // Highlight days currently being displayed.
            if (view &&
                ((view == 'month' && this.date.between(dates[0], dates[1])) ||
                 (view == 'week' && day.between(week[0], week[1])) ||
                 (view == 'workweek' && day.between(workweek[0], workweek[1])) ||
                 (view == 'day' && day.equals(this.date)) ||
                 (view == 'agenda' && !day.isBefore(date) && day.isBefore(date7)))) {
                td.addClassName('kronolith-selected');
            }

            // Highlight today.
            if (day.equals(today) &&
                (Object.isUndefined(year) ||
                 (day.getYear() + 1900 == year &&
                  date.getMonth() == day.getMonth()))) {
                td.addClassName('kronolith-today');
            }
            td.insert(new Element('a').update(day.getDate()));
            tr.insert(td);
            day.next().day();
        }
    },

    /**
     * Inserts a calendar entry in the sidebar menu.
     *
     * @param string type  The calendar type.
     * @param string id    The calendar id.
     * @param object cal   The calendar object.
     * @param Element div  Container DIV where to add the entry (optional).
     */
    insertCalendarInList: function(type, id, cal, div)
    {
        var noItems, calendar, link;
        if (!div) {
            div = this.getCalendarList(type, cal.owner);
        }
        noItems = div.previous();
        if (noItems &&
            noItems.tagName == 'DIV' &&
            noItems.className == 'horde-info') {
            noItems.hide();
        }
        link = new Element('span', { className: type != 'resourcegroup' ? (cal.show ? 'horde-resource-on' : 'horde-resource-off') : 'horde-resource-none' })
            .insert(cal.name.escapeHTML());
        calendar = new Element('div')
            .store('calendar', id)
            .store('calendarclass', type)
            .setStyle({ backgroundColor: cal.bg, color: cal.fg });
        if (type != 'holiday' && type != 'external') {
            calendar.insert(
                new Element('span', { className: 'horde-resource-edit-' + cal.fg.substring(1) })
                    .setStyle({ backgroundColor: cal.bg, color: cal.fg })
                    .insert('&#9658;'));
        }
        calendar.insert(
            new Element('div', { className: 'horde-resource-link' })
                .insert(link));
        this.addShareIcon(cal, link);
        div.insert(calendar);
        if (cal.show) {
            this.addCalendarLegend(type, id, cal);
        }
    },

    /**
     * Add the share icon after the calendar name in the calendar list.
     *
     * @param object cal       A calendar object from Kronolith.conf.calendars.
     * @param Element element  The calendar element in the list.
     */
    addShareIcon: function(cal, element)
    {
        if (cal.owner && cal.perms) {
            $H(cal.perms).each(function(perm) {
                if (perm.key != 'type' &&
                    ((Object.isArray(perm.value) && perm.value.size()) ||
                     (!Object.isArray(perm.value) && perm.value))) {
                    element.insert(' ').insert(new Element('img', { src: Kronolith.conf.images.attendees.replace(/fff/, cal.fg.substring(1)), title: Kronolith.text.shared }));
                    throw $break;
                }
            });
        }
    },

    /**
     * Rebuilds the list of calendars.
     */
    updateCalendarList: function()
    {
        var ext = $H(), extNames = $H(),
            extContainer = $('kronolithExternalCalendars');

        $H(Kronolith.conf.calendars.internal).each(function(cal) {
            this.insertCalendarInList('internal', cal.key, cal.value);
        }, this);

        if (Kronolith.conf.tasks) {
            $H(Kronolith.conf.calendars.tasklists).each(function(cal) {
                this.insertCalendarInList('tasklists', cal.key, cal.value);
            }, this);
        }

        if (Kronolith.conf.calendars.resource) {
            $H(Kronolith.conf.calendars.resource).each(function(cal) {
               this.insertCalendarInList('resource', cal.key, cal.value);
            }, this);
        }

        if (Kronolith.conf.calendars.resourcegroup) {
            $H(Kronolith.conf.calendars.resourcegroup).each(function(cal) {
                this.insertCalendarInList('resourcegroup', cal.key, cal.value);
            }, this);
        }

        $H(Kronolith.conf.calendars.external).each(function(cal) {
            var parts = cal.key.split('/'), api = parts.shift();
            if (!ext.get(api)) {
                ext.set(api, $H());
            }
            ext.get(api).set(parts.join('/'), cal.value);
            extNames.set(api, cal.value.api ? cal.value.api : Kronolith.text.external_category);
        });
        ext.each(function(api) {
            extContainer
                .insert(new Element('div', { className: 'horde-sidebar-split' }))
                .insert(new Element('div')
                        .insert(new Element('h3')
                                .insert(new Element('span', { className: 'horde-expand', title: HordeSidebar.text.expand })
                                        .insert({ bottom: extNames.get(api.key).escapeHTML() })))
                        .insert(new Element('div', { id: 'kronolithExternalCalendar' + api.key, className: 'horde-resources', style: 'display:none' })));
            api.value.each(function(cal) {
                this.insertCalendarInList('external', api.key + '/' + cal.key, cal.value, $('kronolithExternalCalendar' + api.key));
            }, this);
        }, this);

        $H(Kronolith.conf.calendars.remote).each(function(cal) {
            this.insertCalendarInList('remote', cal.key, cal.value);
        }, this);

        if (Kronolith.conf.calendars.holiday) {
            $H(Kronolith.conf.calendars.holiday).each(function(cal) {
                if (cal.value.show) {
                   this.insertCalendarInList('holiday', cal.key, cal.value);
                }
            }, this);
        } else {
            $('kronolithAddholiday').up().hide();
            $('kronolithHolidayCalendars').hide();
        }
    },

    /**
     * Returns the DIV container that holds all calendars of a certain type.
     *
     * @param string type  A calendar type
     *
     * @return Element  The container of the calendar type.
     */
    getCalendarList: function(type, personal)
    {
        switch (type) {
        case 'internal':
            return personal
                ? $('kronolithMyCalendars')
                : $('kronolithSharedCalendars');
        case 'resource':
            return $('kronolithResourceCalendars');
        case 'resourcegroup':
            return $('kronolithResourceGroups');
        case 'tasklists':
            return personal
                ? $('kronolithMyTasklists')
                : $('kronolithSharedTasklists');
        case 'external':
            return $('kronolithExternalCalendars');
        case 'remote':
            return $('kronolithRemoteCalendars');
        case 'holiday':
            return $('kronolithHolidayCalendars');
        }
    },

    /**
     * Loads a certain calendar, if the current view is still a calendar view.
     *
     * @param string type      The calendar type.
     * @param string calendar  The calendar id.
     */
    loadCalendar: function(type, calendar)
    {
        if (Kronolith.conf.calendars[type][calendar].show &&
            $w('day workweek week month year agenda').include(this.view)) {
            var dates = this.viewDates(this.date, this.view);
            this.deleteCache([type, calendar]);
            this.loadEvents(dates[0], dates[1], this.view, [[type, calendar]]);
        }
    },

    /**
     * Toggles a calendars visibility.
     *
     * @param string type      The calendar type.
     * @param string calendar  The calendar id.
     */
    toggleCalendar: function(type, calendar)
    {
        var elt = $('kronolithMenuCalendars').select('div').find(function(div) {
            return div.retrieve('calendarclass') == type &&
            div.retrieve('calendar') == calendar;
        }).down('.horde-resource-link').down('span');

        Kronolith.conf.calendars[type][calendar].show = !Kronolith.conf.calendars[type][calendar].show;
        elt.toggleClassName('horde-resource-on');
        elt.toggleClassName('horde-resource-off');

        if (Kronolith.conf.calendars[type][calendar].show) {
            this.addCalendarLegend(type, calendar, Kronolith.conf.calendars[type][calendar]);
        } else {
            this.deleteCalendarLegend(type, calendar);
        }

        switch (this.view) {
        case 'month':
        case 'agenda':
            if (Object.isUndefined(this.ecache.get(type)) ||
                Object.isUndefined(this.ecache.get(type).get(calendar))) {
                this.loadCalendar(type, calendar);
            } else {
                var allEvents = this.kronolithBody.select('div').findAll(function(el) {
                    return el.retrieve('calendar') == type + '|' + calendar;
                });
                if (this.view == 'month' && Kronolith.conf.max_events) {
                    var dates = this.viewDates(this.date, this.view);
                    if (elt.hasClassName('horde-resource-off')) {
                        var day, more, events, calendars = [];
                        $H(Kronolith.conf.calendars).each(function(type) {
                            $H(type.value).each(function(cal) {
                                if (cal.value.show) {
                                    calendars.push(type.key + '|' + cal.key);
                                }
                            });
                        });
                        allEvents.each(function(el) {
                            if (el.retrieve('calendar').startsWith('holiday|')) {
                                this.holidays = this.holidays.without(el.retrieve('eventid'));
                            }
                            el.remove();
                        }, this);
                        for (var date = dates[0]; !date.isAfter(dates[1]); date.add(1).days()) {
                            day = this.monthDays['kronolithMonthDay' + date.dateString()];
                            more = day.select('.kronolithMore');
                            events = day.select('.kronolith-event');
                            if (more.size() &&
                                events.size() < Kronolith.conf.max_events) {
                                more[0].purge();
                                more[0].remove();
                                events.invoke('remove');
                                calendars.each(function(calendar) {
                                    this.insertEvents([date, date], 'month', calendar);
                                }, this);
                            }
                        }
                    } else {
                        this.insertEvents(dates, 'month', type + '|' + calendar);
                    }
                } else {
                    allEvents.invoke('toggle');
                }
            }
            break;

        case 'year':
        case 'week':
        case 'workweek':
        case 'day':
            if (Object.isUndefined(this.ecache.get(type)) ||
                Object.isUndefined(this.ecache.get(type).get(calendar))) {
                this.loadCalendar(type, calendar);
            } else {
                this.insertEvents(this.viewDates(this.date, this.view), this.view);
            }
            break;

        case 'tasks':
            if (type != 'tasklists') {
                break;
            }
            var tasklist = calendar.substr(6);
            if (elt.hasClassName('horde-resource-off')) {
                $('kronolithViewTasksBody').select('tr').findAll(function(el) {
                    return el.retrieve('tasklist') == tasklist;
                }).invoke('remove');
            } else {
                this.loadTasks(this.tasktype, [ tasklist ]);
            }
            break;
        }

        if ($w('tasklists remote external holiday resource').include(type)) {
            calendar = type + '_' + calendar;
        }
        HordeCore.doAction('saveCalPref', { toggle_calendar: calendar });
    },

    /**
     * Propagates a SELECT drop down list with the editable calendars.
     *
     * @param string id  The id of the SELECT element.
     */
    updateCalendarDropDown: function(id)
    {
        $(id).update();
        ['internal', 'remote'].each(function(type) {
            $H(Kronolith.conf.calendars[type]).each(function(cal) {
                if (cal.value.edit) {
                    $(id).insert(new Element('option', { value: type + '|' + cal.key })
                                 .setStyle({ backgroundColor: cal.value.bg, color: cal.value.fg })
                                 .update(cal.value.name.escapeHTML()));
                }
            });
        });
    },

    /**
     * Adds a calendar entry to the print legend.
     *
     * @param string type  The calendar type.
     * @param string id    The calendar id.
     * @param object cal   The calendar object.
     */
    addCalendarLegend: function(type, id, cal)
    {
        $('kronolith-legend').insert(
            new Element('span')
                .insert(cal.name.escapeHTML())
                .store('calendar', id)
                .store('calendarclass', type)
                .setStyle({ backgroundColor: cal.bg, color: cal.fg })
        );
    },

    /**
     * Deletes a calendar entry from the print legend.
     *
     * @param string type  The calendar type.
     * @param string id    The calendar id.
     */
    deleteCalendarLegend: function(type, id)
    {
        var legend = $('kronolith-legend').select('span').find(function(span) {
            return span.retrieve('calendarclass') == type &&
                span.retrieve('calendar') == id;
        });
        if (legend) {
            legend.remove();
        }
    },

    /**
     * Opens a tab in a form.
     *
     * @param Element  The A element of a tab.
     */
    openTab: function(elt)
    {
        var dialog = elt.up('form'), tab = $(elt.id.replace(/Link/, 'Tab')),
            field;
        dialog.select('.kronolithTabsOption').invoke('hide');
        dialog.select('.tabset li').invoke('removeClassName', 'horde-active');
        tab.show();
        elt.up().addClassName('horde-active');
        if (elt.id == 'kronolithEventLinkMap') {
            if (!this.mapInitialized) {
                this.initializeMap();
            }
        }
        field = tab.down('textarea');
        if (!field) {
            field = tab.down('input');
        }
        if (field) {
            try {
                field.focus();
            } catch (e) {}
        }
        switch (tab.identify()) {
        case 'kronolithEventTabAttendees':
            this.attendeeStartDateHandler(this.getFBDate());
            break;
        case 'kronolithEventTabResources':
            this.resourceStartDateHandler(this.getFBDate());
            break;
        }
    },

    /**
     * Sets the load signature and show the loading spinner.
     *
     * @param string resource   The loading resource.
     * @param string signatrue  The signature for this request.
     */
    startLoading: function(resource, signature)
    {
        this.eventsLoading[resource] = signature;
        this.loading++;
        $('kronolithLoading').show();
    },

    /**
     */
    loadEvents: function(firstDay, lastDay, view, calendars)
    {
        var loading = false;

        if (typeof calendars == 'undefined') {
            calendars = [];
            $H(Kronolith.conf.calendars).each(function(type) {
                $H(type.value).each(function(cal) {
                    if (cal.value.show) {
                        calendars.push([type.key, cal.key]);
                    }
                });
            });
        }

        calendars.each(function(cal) {
            var startDay = firstDay.clone(), endDay = lastDay.clone(),
                cals = this.ecache.get(cal[0]);

            if (typeof cals != 'undefined' &&
                typeof cals.get(cal[1]) != 'undefined') {
                cals = cals.get(cal[1]);
                while (!Object.isUndefined(cals.get(startDay.dateString())) &&
                       startDay.isBefore(endDay)) {
                    if (view != 'year') {
                        this.insertEvents([startDay, startDay], view, cal.join('|'));
                    }
                    startDay.add(1).day();
                }
                while (!Object.isUndefined(cals.get(endDay.dateString())) &&
                       (!startDay.isAfter(endDay))) {
                    if (view != 'year') {
                        this.insertEvents([endDay, endDay], view, cal.join('|'));
                    }
                    endDay.add(-1).day();
                }
                if (startDay.compareTo(endDay) > 0) {
                    return;
                }
            }
            var start = startDay.dateString(), end = endDay.dateString(),
                calendar = cal.join('|');
            loading = true;
            this.startLoading(calendar, start + end);
            this.storeCache($H(), calendar, null, true);

            HordeCore.doAction('listEvents', {
                start: start,
                end: end,
                cal: calendar,
                sig: start + end,
                view: view
            }, {
                callback: function(r) {
                    this.loadEventsCallback(r, true);
                }.bind(this)
            });
        }, this);

        if (!loading && view == 'year') {
            this.insertEvents([firstDay, lastDay], 'year');
        }
    },

    /**
     * Callback method for inserting events in the current view.
     *
     * @param object r             The ajax response object.
     * @param boolean createCache  Whether to create a cache list entry for the
     *                             response, if none exists yet. Useful for
     *                             (not) adding individual events to the cache
     *                             if it doesn't match any cached views.
     */
    loadEventsCallback: function(r, createCache)
    {
        // Hide spinner.
        this.loading--;
        if (!this.loading) {
            $('kronolithLoading').hide();
        }

        var start = this.parseDate(r.sig.substr(0, 8)),
            end = this.parseDate(r.sig.substr(8, 8)),
            dates = [start, end],
            currentDates;

        this.storeCache(r.events || {}, r.cal, dates, createCache);

        // Check if this is the still the result of the most current request.
        if (r.sig != this.eventsLoading[r.cal]) {
            return;
        }
        delete this.eventsLoading[r.cal];

        // Check if the calendar is still visible.
        var calendar = r.cal.split('|');
        if (!Kronolith.conf.calendars[calendar[0]][calendar[1]].show) {
            return;
        }

        // Check if the result is still for the current view.
        currentDates = this.viewDates(this.date, this.view);
        if (r.view != this.view ||
            !start.between(currentDates[0], currentDates[1])) {

            return;
        }

        if (this.view == 'day' ||
            this.view == 'week' ||
            this.view == 'workweek' ||
            this.view == 'month' ||
            this.view == 'agenda' ||
            (this.view == 'year' && !$H(this.eventsLoading).size())) {
            this.insertEvents(dates, this.view, r.cal);
        }
    },

    /**
     * Reads events from the cache and inserts them into the view.
     *
     * If inserting events into day and week views, the calendar parameter is
     * ignored, and events from all visible calendars are inserted instead.
     * This is necessary because the complete view has to be re-rendered if
     * events are not in chronological order.
     * The year view is specially handled too because there are no individual
     * events, only a summary of all events per day.
     *
     * @param Array dates      Start and end of dates to process.
     * @param string view      The view to update.
     * @param string calendar  The calendar to update.
     */
    insertEvents: function(dates, view, calendar)
    {
        switch (view) {
        case 'day':
        case 'week':
        case 'workweek':
            // The day and week views require the view to be completely
            // loaded, to correctly calculate the dimensions.
            if (this.viewLoading.size() || this.view != view) {
                this.insertEvents.bind(this, [dates[0].clone(), dates[1].clone()], view, calendar).defer();
                return;
            }
            break;
        }

        var day = dates[0].clone(),
                  viewDates = this.viewDates(this.date, this.view),
                  date, more, title, titles, events, monthDay, busyHours;
        while (!day.isAfter(dates[1])) {
            // Skip if somehow events slipped in though the view is gone.
            if (!day.between(viewDates[0], viewDates[1])) {
                if (window.console) {
                    window.console.trace();
                }
                day.next().day();
                continue;
            }

            date = day.dateString();
            switch (view) {
            case 'day':
            case 'week':
            case 'workweek':
                this.dayEvents = [];
                this.dayGroups = [];
                this.allDayEvents = [];
                if (view == 'day') {
                    $$('.kronolith-event').invoke('remove');
                } else {
                    this.eventsWeek['kronolithEvents' + (view == 'week' ? 'Week' : 'Workweek') + date]
                        .select('.kronolith-event')
                        .invoke('remove');
                    this.allDays['kronolithAllDay' + date]
                        .childElements()
                        .invoke('remove');
                }
                break;

            case 'month':
                monthDay = this.monthDays['kronolithMonthDay' + date];
                monthDay.select('div')
                    .findAll(function(el) { return el.retrieve('calendar') == calendar; })
                    .invoke('remove');
                break;

            case 'year':
                titles = [];
                busyHours = 0;
            }

            if (view == 'month' || view == 'agenda') {
                events = this.getCacheForDate(date, calendar);
            } else {
                events = this.getCacheForDate(date);
            }
            events.sortBy(this.sortEvents).each(function(event) {
                var insertBefore;
                switch (view) {
                case 'month':
                case 'agenda':
                    if (calendar.startsWith('holiday|')) {
                        if (this.holidays.include(event.key)) {
                            return;
                        }
                        this.holidays.push(event.key);
                    }
                    if (view == 'month' && Kronolith.conf.max_events) {
                        more = monthDay.down('.kronolithMore');
                        if (more) {
                            more.purge();
                            more.remove();
                        }
                    }
                    if (view == 'month') {
                        if (Kronolith.conf.max_events) {
                        var events = monthDay.select('.kronolith-event');
                        if (events.size() >= Kronolith.conf.max_events) {
                            if (date == (new Date().dateString())) {
                                // This is today.
                                if (event.value.al || event.value.end.isBefore()) {
                                    // No room for all-day or finished events.
                                    this.insertMore(date);
                                    return;
                                }
                                var remove, max;
                                // Find an event that is earlier than now or
                                // later then the current event.
                                events.each(function(elm) {
                                    var calendar = elm.retrieve('calendar').split('|'),
                                        event = this.ecache.get(calendar[0]).get(calendar[1]).get(date).get(elm.retrieve('eventid'));
                                    if (event.start.isBefore()) {
                                        remove = elm;
                                        throw $break;
                                    }
                                    if (!max || event.start.isAfter(max)) {
                                        max = event.start;
                                        remove = elm;
                                    }
                                }, this);
                                if (remove) {
                                    remove.purge();
                                    remove.remove();
                                    insertBefore = this.findInsertBefore(events.without(remove), event, date);
                                } else {
                                    this.insertMore(date);
                                    return;
                                }
                            } else {
                                // Not today.
                                var allDays = events.findAll(function(elm) {
                                    var calendar = elm.retrieve('calendar').split('|');
                                    return this.ecache.get(calendar[0]).get(calendar[1]).get(date).get(elm.retrieve('eventid')).al;
                                }.bind(this));
                                if (event.value.al) {
                                    // We want one all-day event.
                                    if (allDays.size()) {
                                        // There already is an all-day event.
                                        if (event.value.x == Kronolith.conf.status.confirmed ||
                                            event.value.x == Kronolith.conf.status.tentative) {
                                            // But is there a less important
                                            // one?
                                            var status = [Kronolith.conf.status.free, Kronolith.conf.status.cancelled];
                                            if (event.value.x == Kronolith.conf.status.confirmed) {
                                                status.push(Kronolith.conf.status.tentative);
                                            }
                                            var free = allDays.detect(function(elm) {
                                                var calendar = elm.retrieve('calendar').split('|');
                                                return status.include(this.ecache.get(calendar[0]).get(calendar[1]).get(date).get(elm.retrieve('eventid')).x);
                                            }.bind(this));
                                            if (!free) {
                                                this.insertMore(date);
                                                return;
                                            }
                                            insertBefore = free.next();
                                            free.purge();
                                            free.remove();
                                        } else {
                                            // No.
                                            this.insertMore(date);
                                            return;
                                        }
                                    } else {
                                        // Remove the last event to make room
                                        // for this one.
                                        var elm = events.pop();
                                        elm.purge();
                                        elm.remove();
                                        insertBefore = events.first();
                                    }
                                } else {
                                    if (allDays.size() > 1) {
                                        // We don't want more than one all-day
                                        // event.
                                        var elm = allDays.pop();
                                        // Remove element from events as well.
                                        events = events.without(elm);
                                        elm.purge();
                                        elm.remove();
                                        insertBefore = this.findInsertBefore(events, event, date);
                                    } else {
                                        // This day is full.
                                        this.insertMore(date);
                                        return;
                                    }
                                }
                            }
                            this.insertMore(date);
                        } else {
                            insertBefore = this.findInsertBefore(events, event, date);
                        }
                        } else {
                            var events = monthDay.select('.kronolith-event');
                            insertBefore = this.findInsertBefore(events, event, date);
                        }
                    }
                    break;

                case 'year':
                    title = '';
                    if (event.value.al) {
                        title += Kronolith.text.allday;
                    } else {
                        title += event.value.start.toString('t') + '-' + event.value.end.toString('t');
                    }
                    if (event.value.t) {
                        title += ': ' + event.value.t.escapeHTML();
                    }
                    if (event.value.x == Kronolith.conf.status.tentative ||
                        event.value.x == Kronolith.conf.status.confirmed) {
                        busyHours += event.value.start.getElapsed(event.value.end) / 3600000;
                    }
                    titles.push(title);
                    return;
                }
                this.insertEvent(event, date, view, insertBefore);
            }, this);

            switch (view) {
            case 'agenda':
                if ($('kronolithViewAgendaBody').select('tr').length > 2) {
                    $('kronolithAgendaNoItems').hide();
                } else {
                    $('kronolithAgendaNoItems').show();
                }
                break;

            case 'year':
                var td = $('kronolithYear' + date);
                if (td.className == 'kronolith-minical-empty') {
                    continue;
                }
                if (td.hasClassName('kronolith-today')) {
                    td.className = 'kronolith-today';
                } else {
                    td.className = '';
                }
                if (titles.length) {
                    td.addClassName('kronolithHasEvents');
                    if (busyHours > 0) {
                        td.addClassName(this.getHeatmapClass(busyHours));
                        busyHours = 0;
                    }
                    td.down('a').writeAttribute('nicetitle', Object.toJSON(titles));
                }
            }

            day.next().day();
        }
        // Workaround Firebug bug.
        Prototype.emptyFunction();
    },

    findInsertBefore: function(events, event, date)
    {
        var insertBefore, insertSort;
        events.each(function(elm) {
            var calendar = elm.retrieve('calendar').split('|'),
                existing = this.ecache
                    .get(calendar[0])
                    .get(calendar[1])
                    .get(date)
                    .get(elm.retrieve('eventid'));
            if (event.value.sort < existing.sort &&
                (!insertSort || existing.sort < insertSort)) {
                insertBefore = elm;
                insertSort = existing.sort;
            }
        }, this);
        return insertBefore;
    },

    getHeatmapClass: function(hours)
    {
        return 'heat' + Math.min(Math.ceil(hours / 2), 6);
    },

    /**
     * Creates the DOM node for an event bubble and inserts it into the view.
     *
     * @param object event    A Hash member with the event to insert.
     * @param string date     The day to update.
     * @param string view     The view to update.
     * @param Element before  Insert the event before this element (month view).
     */
    insertEvent: function(event, date, view, before)
    {
        var calendar = event.value.calendar.split('|');
        event.value.nodeId = ('kronolithEvent' + view + event.value.calendar + date + event.key).replace(new RegExp('[^a-zA-Z0-9]', 'g'), '');

        var _createElement = function(event) {
            var className ='kronolith-event';
            switch (event.value.x) {
            case 3:
                className += ' kronolith-event-cancelled';
                break;
            case 1:
            case 4:
                className += ' kronolith-event-tentative';
                break;
            }
            var el = new Element('div', { id: event.value.nodeId, className: className })
                .store('calendar', event.value.calendar)
                .store('eventid', event.key);
            if (!Object.isUndefined(event.value.aj)) {
                el.store('ajax', event.value.aj);
            }
            return el;
        };

        switch (view) {
        case 'day':
        case 'week':
        case 'workweek':
            var storage = view + 'Sizes',
                what = view == 'week' ? 'Week' : 'Workweek',
                div = _createElement(event),
                margin = view == 'day' ? 1 : 3,
                style = { backgroundColor: Kronolith.conf.calendars[calendar[0]][calendar[1]].bg,
                          color: Kronolith.conf.calendars[calendar[0]][calendar[1]].fg };

            div.writeAttribute('title', event.value.t);

            if (event.value.al) {
                if (view == 'day') {
                    $('kronolithViewDay').down('.kronolithAllDayContainer').insert(div.setStyle(style));
                } else {
                    var allDay = this.allDays['kronolithAllDay' + date],
                        existing = allDay.childElements(),
                        weekHead = $('kronolithView' + what + 'Head');
                    if (existing.size() == 3) {
                        if (existing[2].className != 'kronolithMore') {
                            existing[2].purge();
                            existing[2].remove();
                            allDay.insert({ bottom: new Element('span', { className: 'kronolithMore' }).store('date', date).insert(Kronolith.text.more) });
                        }
                    } else {
                        allDay.insert(div.setStyle(style));
                        if (event.value.pe) {
                            div.addClassName('kronolithEditable');
                            var layout = div.getLayout(),
                                minLeft = weekHead.down('.kronolith-first-col').getWidth() + this[storage].spacing + (parseInt(div.getStyle('marginLeft'), 10) || 0),
                                minTop = weekHead.down('thead').getHeight() + this[storage].spacing + (parseInt(div.getStyle('marginTop'), 10) || 0),
                                maxLeft = weekHead.getWidth() - layout.get('margin-box-width'),
                                maxTop = weekHead.down('thead').getHeight() + weekHead.down('.kronolith-all-day').getHeight(),
                                opts = {
                                    threshold: 5,
                                    parentElement: function() {
                                        return $('kronolithView' + what).down('.kronolith-view-head');
                                    },
                                    snap: function(x, y) {
                                        return [Math.min(Math.max(x, minLeft), maxLeft),
                                                Math.min(Math.max(y, minTop), maxTop - div.getHeight())];
                                    }
                                };
                            var d = new Drag(event.value.nodeId, opts);
                            div.store('drags', []);
                            Object.extend(d, {
                                event: event,
                                innerDiv: new Element('div'),
                                midnight: this.parseDate(date)
                            });
                            div.retrieve('drags').push(d);
                        }
                    }
                }
                break;
            }

            var midnight = this.parseDate(date),
                resizable = event.value.pe && (Object.isUndefined(event.value.vl) || event.value.vl),
                innerDiv = new Element('div', { className: 'kronolith-event-info' }),
                minHeight = 0, parentElement, draggerTop, draggerBottom,
                elapsed = (event.value.start.getHours() - midnight.getHours()) * 60 + (event.value.start.getMinutes() - midnight.getMinutes());
            switch (view) {
            case 'day':
                parentElement = $('kronolithEventsDay');
                break;
            case 'week':
                parentElement = this.eventsWeek['kronolithEventsWeek' + date];
                break;
            case 'workweek':
                parentElement = this.eventsWeek['kronolithEventsWorkweek' + date];
                break;
            }
            if (event.value.fi) {
                div.addClassName('kronolithFirst');
                if (resizable) {
                    draggerTop = new Element('div', { id: event.value.nodeId + 'top', className: 'kronolithDragger kronolithDraggerTop' }).setStyle(style);
                }
            } else {
                innerDiv.setStyle({ top: 0 });
            }
            if (event.value.la) {
                div.addClassName('kronolithLast');
                if (resizable) {
                    draggerBottom = new Element('div', { id: event.value.nodeId + 'bottom', className: 'kronolithDragger kronolithDraggerBottom' }).setStyle(style);
                }
            } else {
                innerDiv.setStyle({ bottom: 0 });
            }

            div.setStyle({
                top: (elapsed * this[storage].height / 60 | 0) + 'px',
                width: 100 - margin + '%'
            })
                .insert(innerDiv.setStyle(style));
            if (draggerTop) {
                div.insert(draggerTop);
            }
            if (draggerBottom) {
                div.insert(draggerBottom);
            }
            parentElement.insert(div);
            if (draggerTop) {
                minHeight += draggerTop.getHeight();
            }
            if (draggerBottom) {
                minHeight += draggerBottom.getHeight();
            }
            if (!minHeight) {
                minHeight = parseInt(innerDiv.getStyle('lineHeight'), 10)
                    + (parseInt(innerDiv.getStyle('paddingTop'), 10) || 0)
                    + (parseInt(innerDiv.getStyle('paddingBottom'), 10) || 0);
            }
            div.setStyle({ height: Math.max(Math.round(event.value.start.getElapsed(event.value.end) / 60000) * this[storage].height / 60 - this[storage].spacing | 0, minHeight) + 'px' });

            if (event.value.pe) {
                div.addClassName('kronolithEditable');
                div.store('drags', []);
                // Number of pixels that cover 10 minutes.
                var step = this[storage].height / 6,
                    stepX, minLeft, maxLeft, maxTop,
                    minBottom, maxBottom, dragBottomHeight;
                if (draggerBottom) {
                    // Height of bottom dragger
                    dragBottomHeight = draggerBottom.getHeight();
                }
                if (draggerTop) {
                    // Bottom-most position (maximum y) of top dragger
                    maxTop = div.offsetTop
                        - draggerTop.getHeight()
                        - parseInt(innerDiv.getStyle('lineHeight'), 10);
                    if (draggerBottom) {
                        maxTop += draggerBottom.offsetTop;
                    }
                }
                if (draggerBottom) {
                    // Top-most position (minimum y) of bottom dragger (upper
                    // edge)
                    minBottom = div.offsetTop
                        + parseInt(innerDiv.getStyle('lineHeight'), 10);
                    // Bottom-most position (maximum y) of bottom dragger
                    // (upper edge)
                    maxBottom = 24 * this[storage].height
                        + dragBottomHeight;
                    if (draggerTop) {
                        minBottom += draggerTop.getHeight();
                    }
                }
                    // Height of the whole event div
                var divHeight = div.getHeight(),
                    // Maximum height of the whole event div
                    maxDiv = 24 * this[storage].height - divHeight,
                    // Whether the top dragger is dragged, vs. the bottom
                    // dragger
                    opts = {
                        threshold: 5,
                        constraint: 'vertical',
                        scroll: this.kronolithBody,
                        nodrop: true,
                        parentElement: function() {
                            return parentElement;
                        }
                    };

                if (draggerTop) {
                    opts.snap = function(x, y) {
                        y = Math.max(0, step * (Math.min(maxTop, y - this.scrollTop) / step | 0));
                        return [0, y];
                    }.bind(this);
                    var d = new Drag(event.value.nodeId + 'top', opts);
                    Object.extend(d, {
                        event: event,
                        innerDiv: innerDiv,
                        midnight: midnight
                    });
                    div.retrieve('drags').push(d);
                }

                if (draggerBottom) {
                    opts.snap = function(x, y) {
                        y = Math.min(maxBottom + dragBottomHeight + KronolithCore[storage].spacing, step * ((Math.max(minBottom, y - this.scrollTop) + dragBottomHeight + KronolithCore[storage].spacing) / step | 0)) - dragBottomHeight - KronolithCore[storage].spacing;
                        return [0, y];
                    }.bind(this);
                    var d = new Drag(event.value.nodeId + 'bottom', opts);
                    Object.extend(d, {
                        event: event,
                        innerDiv: innerDiv,
                        midnight: midnight
                    });
                    div.retrieve('drags').push(d);
                }

                if (view == 'week' || view == 'workweek') {
                    var dates = this.viewDates(midnight, view);
                    minLeft = this.eventsWeek['kronolithEvents' + what + dates[0].dateString()].offsetLeft - this.eventsWeek['kronolithEvents' + what + date].offsetLeft;
                    maxLeft = this.eventsWeek['kronolithEvents' + what + dates[1].dateString()].offsetLeft - this.eventsWeek['kronolithEvents' + what + date].offsetLeft;
                    stepX = (maxLeft - minLeft) / (view == 'week' ? 6 : 4);
                }
                var d = new Drag(div, {
                    threshold: 5,
                    nodrop: true,
                    parentElement: function() { return parentElement; },
                    snap: function(x, y) {
                        x = (view == 'week' || view == 'workweek')
                            ? Math.max(minLeft, stepX * ((Math.min(maxLeft, x - (x < 0 ? stepX : 0)) + stepX / 2) / stepX | 0))
                            : 0;
                        y = Math.max(0, step * (Math.min(maxDiv, y - this.scrollTop) / step | 0));
                        return [x, y];
                    }.bind(this)
                });
                Object.extend(d, {
                    divHeight: divHeight,
                    startTop: div.offsetTop,
                    event: event,
                    midnight: midnight,
                    stepX: stepX
                });
                div.retrieve('drags').push(d);
            }

            var
                // The current column that we're probing for available space.
                column = 1,
                // The number of columns in the current conflict group.
                columns,
                // The column width in the current conflict group.
                width,
                // The first event that conflict with the current event.
                conflict = false,
                // The conflict group where this event should go.
                pos = this.dayGroups.length,
                // The event below that the current event fits.
                placeFound = false,
                // The minimum (virtual) duration of each event, defined by the
                // minimum height of an event DIV.
                minMinutes = (minHeight + this[storage].spacing) * 60 / this[storage].height;

            // this.dayEvents contains all events of the current day.
            // this.dayGroups contains conflict groups, i.e. all events that
            // conflict with each other and share a set of columns.
            //
            // Go through all events that have been added to this day already.
            this.dayEvents.each(function(ev) {
                // Due to the minimum height of an event DIV, events might
                // visually overlap, even if they physically don't.
                var minEnd = ev.start.clone().add(minMinutes).minutes(),
                    end = ev.end.isAfter(minEnd) ? ev.end : minEnd;

                // If it doesn't conflict with the current event, go ahead.
                if (!end.isAfter(event.value.start)) {
                    return;
                }

                // Found a conflicting event, now find its conflict group.
                for (pos = 0; pos < this.dayGroups.length; pos++) {
                    if (this.dayGroups[pos].indexOf(ev) != -1) {
                        // Increase column for each conflicting event in this
                        // group.
                        this.dayGroups[pos].each(function(ce) {
                            var minEnd = ce.start.clone().add(minMinutes).minutes(),
                                end = ce.end.isAfter(minEnd) ? ce.end : minEnd;
                            if (end.isAfter(event.value.start)) {
                                column++;
                            }
                        });
                        throw $break;
                    }
                }
            }, this);
            event.value.column = event.value.columns = column;

            if (Object.isUndefined(this.dayGroups[pos])) {
                this.dayGroups[pos] = [];
            }
            this.dayGroups[pos].push(event.value);

            // See if the current event had to add yet another column.
            columns = Math.max(this.dayGroups[pos][0].columns, column);

            // Update the widths of all events in a conflict group.
            width = 100 / columns;
            this.dayGroups[pos].each(function(ev) {
                ev.columns = columns;
                $(ev.nodeId).setStyle({ width: width - margin + '%', left: (width * (ev.column - 1)) + '%' });
            });
            this.dayEvents.push(event.value);

            div = innerDiv;
            break;

        case 'month':
            var monthDay = this.monthDays['kronolithMonthDay' + date],
                div = _createElement(event)
                .setStyle({ backgroundColor: Kronolith.conf.calendars[calendar[0]][calendar[1]].bg,
                            color: Kronolith.conf.calendars[calendar[0]][calendar[1]].fg });
            div.writeAttribute('title', event.value.t);
            if (before) {
                before.insert({ before: div });
            } else {
                monthDay.insert(div);
            }
            if (event.value.pe) {
                div.setStyle({ cursor: 'move' });
                new Drag(event.value.nodeId, { threshold: 5, parentElement: function() { return $('kronolith-month-body'); }, snapToParent: true });
            }
            if (Kronolith.conf.max_events) {
                var more = monthDay.down('.kronolithMore');
                if (more) {
                    monthDay.insert({ bottom: more.remove() });
                }
            }
            break;

        case 'agenda':
            var div = _createElement(event)
                .setStyle({ backgroundColor: Kronolith.conf.calendars[calendar[0]][calendar[1]].bg,
                            color: Kronolith.conf.calendars[calendar[0]][calendar[1]].fg });
            this.createAgendaDay(date);
            $('kronolithAgendaDay' + date).insert(div);
            break;
        }

        this.setEventText(div, event.value,
                          { time: view == 'agenda' || Kronolith.conf.show_time })
            .observe('mouseover', div.addClassName.curry('kronolith-selected'))
            .observe('mouseout', div.removeClassName.curry('kronolith-selected'));
    },

    /**
     * Re-renders the necessary parts of the current view, if any event changes
     * in those parts require re-rendering.
     *
     * @param Array dates  The date strings of days to re-render.
     */
    reRender: function(dates)
    {
        switch (this.view) {
        case 'week':
        case 'workweek':
        case 'day':
            dates.each(function(date) {
                date = this.parseDate(date);
                this.insertEvents([ date, date ], this.view);
            }, this);
            break;
        case 'month':
            dates.each(function(date) {
                var day = this.monthDays['kronolithMonthDay' + date];
                day.select('.kronolith-event').each(function(event) {
                    if (event.retrieve('calendar').startsWith('holiday')) {
                        delete this.holidays[event.retrieve('eventid')];
                    }
                    event.remove();
                }, this);
                day.select('.kronolithMore').invoke('remove');
                date = this.parseDate(date);
                this.loadEvents(date, date, 'month');
            }, this);
            break;
        }
    },

    /**
     * Returns all dates of the current view that contain (recurrences) of a
     * certain event.
     *
     * @param String cal      A calendar string.
     * @param String eventid  An event id.
     *
     * @return Array  A list of date strings that contain a recurrence of the
     *                event.
     */
    findEventDays: function(cal, eventid)
    {
        cal = cal.split('|');
        var cache = this.ecache.get(cal[0]).get(cal[1]),
            dates = this.viewDates(this.date, this.view),
            day = dates[0], days = [], dateString;
        while (!day.isAfter(dates[1])) {
            dateString = day.dateString();
            if (cache.get(dateString).get(eventid)) {
                days.push(dateString);
            }
            day.add(1).days();
        }
        return days;
    },

    /**
     * Adds a ""more..."" button to the month view cell that links to the days,
     * or moves it to the buttom.
     *
     * @param string date  The date string of the day cell.
     */
    insertMore: function(date)
    {
        var monthDay = this.monthDays['kronolithMonthDay' + date],
            more = monthDay.down('.kronolithMore');
        if (more) {
            monthDay.insert({ bottom: more.remove() });
        } else {
            monthDay.insert({ bottom: new Element('span', { className: 'kronolithMore' }).store('date', date).insert(Kronolith.text.more) });
        }
    },

    setEventText: function(div, event, opts)
    {
        var calendar = event.calendar.split('|'),
            span = new Element('span'),
            time, end;
        opts = Object.extend({ time: false }, opts || {});

        div.update();
        if (event.ic) {
            div.insert(new Element('img', { src: event.ic, className: 'kronolithEventIcon' }));
        }
        if (opts.time && !event.al) {
            time = new Element('span', { className: 'kronolith-time' })
                .insert(event.start.toString(Kronolith.conf.time_format));
            if (!event.start.equals(event.end)) {
                end = event.end.clone();
                if (end.getHours() == 23 &&
                    end.getMinutes() == 59 &&
                    end.getSeconds() == 59) {
                    end.add(1).second();
                }
                time.insert('-' + end.toString(Kronolith.conf.time_format));
            }
            div.insert(time).insert(' ');
        }
        div.insert(event.t.escapeHTML());
        div.insert(span);
        if (event.a) {
            span.insert(' ')
                .insert(new Element('img', { src: Kronolith.conf.images.alarm.replace(/fff/, Kronolith.conf.calendars[calendar[0]][calendar[1]].fg.substr(1)), title: Kronolith.text.alarm + ' ' + event.a }));
        }
        if (event.r) {
            span.insert(' ')
                .insert(new Element('img', { src: Kronolith.conf.images.recur.replace(/fff/, Kronolith.conf.calendars[calendar[0]][calendar[1]].fg.substr(1)), title: Kronolith.text.recur[event.r] }));
        } else if (event.bid) {
            div.store('bid', event.bid);
            span.insert(' ')
                .insert(new Element('img', { src: Kronolith.conf.images.exception.replace(/fff/, Kronolith.conf.calendars[calendar[0]][calendar[1]].fg.substr(1)), title: Kronolith.text.recur.exception }));
        }
        return div;
    },

    /**
     * Finally removes events from the DOM and the cache.
     *
     * @param string calendar  A calendar name.
     * @param string event     An event id. If empty, all events from the
     *                         calendar are deleted.
     */
    removeEvent: function(calendar, event)
    {
        this.deleteCache(calendar, event);
        this.kronolithBody.select('div.kronolith-event').findAll(function(el) {
            return el.retrieve('calendar') == calendar &&
                (!event || el.retrieve('eventid') == event);
        }).invoke('remove');
    },

    /**
     * Removes all events that reprensent exceptions to the event series
     * represented by uid.
     *
     * @param string calendar  A calendar name.
     * @param string uid       An event uid.
     */
    removeException: function(calendar, uid)
    {
        this.kronolithBody.select('div.kronolith-event').findAll(function(el) {
            if (el.retrieve('calendar') == calendar && el.retrieve('bid') == uid) {
                this.removeEvent(calendar, el.retrieve('eventid'));
            }
        }.bind(this));
    },

    /**
     * Calculates the event's start and end dates based on some drag and drop
     * information.
     */
    calculateEventDates: function(event, storage, step, offset, height, start, end)
    {
        if (!Object.isUndefined(start)) {
            event.start = start;
            event.end = end;
        }
        event.start.set({
            hour: offset / this[storage].height | 0,
            minute: Math.round(offset % this[storage].height / step) * 10
        });
        var hour = (offset + height + this[storage].spacing) / this[storage].height | 0,
            minute = Math.round((offset + height + this[storage].spacing) % this[storage].height / step) * 10,
            second = 0;
        if (hour == 24) {
            hour = 23;
            minute = 59;
            second = 59;
        }
        event.end.set({
            hour: hour,
            minute: minute,
            second: second
        });
    },

    switchTaskView: function(on)
    {
        if (on) {
            $('kronolithNewEvent', 'kronolithNewTask').compact()[0]
                .replace(Kronolith.conf.new_task);
            $('kronolithQuickEvent').addClassName('kronolithNewTask');
            $('kronolithHeader').down('.kronolithPrev').up().addClassName('disabled');
            $('kronolithHeader').down('.kronolithNext').up().addClassName('disabled');
        } else {
            $('kronolithNewEvent', 'kronolithNewTask').compact()[0]
                .replace(Kronolith.conf.new_event);
            $('kronolithQuickEvent').removeClassName('kronolithNewTask');
            $('kronolithHeader').down('.kronolithPrev').up().removeClassName('disabled');
            $('kronolithHeader').down('.kronolithNext').up().removeClassName('disabled');
        }
    },

    /**
     * Returns the task cache storage names that hold the tasks of the
     * requested task type.
     *
     * @param string tasktype  The task type.
     *
     * @return array  The list of task cache storage names.
     */
    getTaskStorage: function(tasktype)
    {
        var tasktypes;
        if (tasktype == 'all' || tasktype == 'future') {
            tasktypes = [ 'complete', 'incomplete' ];
        } else {
            tasktypes = [ tasktype ];
        }
        return tasktypes;
    },

    /**
     * Loads tasks, either from cache or from the server.
     *
     * @param integer tasktype  The tasks type (all, incomplete, complete, or
     *                          future).
     * @param Array tasksLists  The lists from where to obtain the tasks.
     */
    loadTasks: function(tasktype, tasklists)
    {
        var tasktypes = this.getTaskStorage(tasktype), loading = false,
            spinner = $('kronolithLoading');

        if (Object.isUndefined(tasklists)) {
            tasklists = [];
            $H(Kronolith.conf.calendars.tasklists).each(function(tasklist) {
                if (tasklist.value.show)
                {
                    tasklists.push(tasklist.key.substring(6));
                }
            });
        }

        tasktypes.each(function(type) {
            tasklists.each(function(list) {
                if (Object.isUndefined(this.tcache.get(type)) ||
                    Object.isUndefined(this.tcache.get(type).get(list))) {
                    loading = true;
                    this.loading++;
                    spinner.show();
                    HordeCore.doAction('listTasks', {
                        type: type,
                        list: list
                    }, {
                        callback: function(r) {
                            this.loadTasksCallback(r, true);
                        }.bind(this)
                    });
                }
            }, this);
        }, this);

        if (!loading) {
            tasklists.each(function(list) {
                this.insertTasks(tasktype, list);
            }, this);
        }
    },

    /**
     * Callback method for inserting tasks in the current view.
     *
     * @param object r             The ajax response object.
     * @param boolean createCache  Whether to create a cache list entry for the
     *                             response, if none exists yet. Useful for
     *                             (not) adding individual tasks to the cache
     *                             without assuming to have all tasks of the
     *                             list.
     */
    loadTasksCallback: function(r, createCache)
    {
        // Hide spinner.
        this.loading--;
        if (!this.loading) {
            $('kronolithLoading').hide();
        }

        this.storeTasksCache(r.tasks || {}, r.type, r.list, createCache);

        // Check if result is still valid for the current view.
        // There could be a rare race condition where two responses for the
        // same task(s) arrive in the wrong order. Checking this too, like we
        // do for events seems not worth it.
        var tasktypes = this.getTaskStorage(this.tasktype),
            tasklist = Kronolith.conf.calendars.tasklists['tasks/' + r.list];
        if (this.view != 'tasks' ||
            !tasklist || !tasklist.show ||
            !tasktypes.include(r.type)) {
            return;
        }
        this.insertTasks(this.tasktype, r.list);
    },

    /**
     * Reads tasks from the cache and inserts them into the view.
     *
     * @param integer tasktype  The tasks type (all, incomplete, complete, or
     *                          future).
     * @param string tasksList  The task list to be drawn.
     */
    insertTasks: function(tasktype, tasklist)
    {
        var tasktypes = this.getTaskStorage(tasktype), now = new Date();

        $('kronolithViewTasksBody').select('tr').findAll(function(el) {
            return el.retrieve('tasklist') == tasklist;
        }).invoke('remove');

        tasktypes.each(function(type) {
            if (!this.tcache.get(type)) {
                return;
            }
            var tasks = this.tcache.get(type).get(tasklist);
            $H(tasks).each(function(task) {
                switch (tasktype) {
                case 'complete':
                    if (!task.value.cp) {
                        return;
                    }
                    break;
                case 'incomplete':
                    if (task.value.cp ||
                        (!Object.isUndefined(task.value.start) &&
                         task.value.start.isAfter(now))) {
                        return;
                    }
                    break;
                case 'future':
                    if (task.value.cp ||
                        Object.isUndefined(task.value.start) ||
                        !task.value.start.isAfter(now)) {
                        return;
                    }
                    break;
                }
                this.insertTask(task);
            }, this);
        }, this);

        if ($('kronolithViewTasksBody').select('tr').length > 2) {
            $('kronolithTasksNoItems').hide();
        } else {
            $('kronolithTasksNoItems').show();
        }
    },

    /**
     * Creates the DOM node for a task and inserts it into the view.
     *
     * @param object task  A Hash with the task to insert
     */
    insertTask: function(task)
    {
        var row = $('kronolithTasksTemplate').clone(true),
            col = row.down(), tagc;


        row.removeAttribute('id');
        row.store('tasklist', task.value.l);
        row.store('taskid', task.key);
        col.addClassName('kronolithTask' + (!!task.value.cp ? 'Completed' : ''));
        col.setStyle({
            backgroundColor: Kronolith.conf.calendars.tasklists['tasks/' + task.value.l].bg,
            color: Kronolith.conf.calendars.tasklists['tasks/' + task.value.l].fg,
            textIndent: task.value.i + 'em'
        });
        col.insert(task.value.n.escapeHTML());
        if (!Object.isUndefined(task.value.due)) {
            var now = new Date();
            if (!now.isBefore(task.value.due)) {
                col.addClassName('kronolithTaskDue');
            }
            col.insert(new Element('span', { className: 'kronolithSeparator' }).update(' &middot; '));
            col.insert(new Element('span', { className: 'kronolithDate' }).update(task.value.due.toString(Kronolith.conf.date_format)));
            if (task.value.r) {
                col.insert(' ')
                    .insert(new Element('img', { src: Kronolith.conf.images.recur.replace(/fff/, Kronolith.conf.calendars.tasklists['tasks/' + task.value.l].fg.substr(1)), title: Kronolith.text.recur[task.value.r] }));
            }
        }

        if (!Object.isUndefined(task.value.sd)) {
            col.insert(new Element('span', { className: 'kronolithSeparator' }).update(' &middot; '));
            col.insert(new Element('span', { className: 'kronolithInfo' }).update(task.value.sd.escapeHTML()));
        }

        if (task.value.t && task.value.t.size() > 0) {
            tagc = new Element('ul', { className: 'horde-tags' });
            task.value.t.each(function(x) {
                tagc.insert(new Element('li').update(x.escapeHTML()));
            });
            col.insert(tagc);
        }
        row.insert(col.show());
        this.insertTaskPosition(row, task);
    },

    /**
     * Inserts the task row in the correct position.
     *
     * @param Element newRow  The new row to be inserted.
     * @param object newTask  A Hash with the task being added.
     */
    insertTaskPosition: function(newRow, newTask)
    {
        var rows = $('kronolithViewTasksBody').select('tr'),
            rowTasklist, rowTaskId, rowTask, parentFound;
        // The first row is a template, ignoring.
        for (var i = 2; i < rows.length; i++) {
            rowTasklist = rows[i].retrieve('tasklist');
            rowTaskId = rows[i].retrieve('taskid');
            if (newTask.value.p) {
                if (rowTaskId == newTask.value.p) {
                    parentFound = true;
                    continue;
                }
                if (!parentFound) {
                    continue;
                }
            }
            rowTask = this.tcache.inject(null, function(acc, list) {
                if (acc) {
                    return acc;
                }
                if (!Object.isUndefined(list.value.get(rowTasklist))) {
                    return list.value.get(rowTasklist).get(rowTaskId);
                }
            });

            if (Object.isUndefined(rowTask)) {
                // TODO: Throw error
                return;
            }
            if (!this.isTaskAfter(newTask.value, rowTask)) {
                break;
            }
        }
        rows[--i].insert({ after: newRow.show() });
    },

    /**
     * Analyzes which task should be drawn first.
     *
     * TODO: Very incomplete, only a dummy version
     */
    isTaskAfter: function(taskA, taskB)
    {
        // TODO: Make all ordering system
        if ((taskA.p || taskB.p) && taskA.p != taskB.p) {
            return !taskA.p;
        }
        return (taskA.pr >= taskB.pr);
    },

    /**
     * Completes/uncompletes a task.
     *
     * @param string tasklist          The task list to which the tasks belongs.
     * @param string taskid            The id of the task.
     * @param boolean|string complete  True if the task is completed, a
     *                                 due date if there are still
     *                                 incomplete recurrences.
     */
    toggleCompletion: function(tasklist, taskid, complete)
    {
        // Update the cache.
        var task = this.tcache.inject(null, function(acc, list) {
            if (acc) {
                return acc;
            }
            if (!Object.isUndefined(list.value.get(tasklist))) {
                return list.value.get(tasklist).get(taskid);
            }
        });
        if (Object.isUndefined(task)) {
            // This shouldn't happen.
            this.toggleCompletionClass(taskid);
            return;
        }
        if (Object.isUndefined(complete) || complete === true) {
            task.cp = !task.cp;
        }

        if (this.tcache.get(task.cp ? 'complete' : 'incomplete')) {
            this.tcache.get(task.cp ? 'complete' : 'incomplete').get(tasklist).set(taskid, task);
        }
        if (this.tcache.get(task.cp ? 'incomplete' : 'complete')) {
            this.tcache.get(task.cp ? 'incomplete' : 'complete').get(tasklist).unset(taskid);
        }

        // Remove row if necessary.
        var row = this.getTaskRow(taskid);
        if (!row) {
            return;
        }
        if ((this.tasktype == 'complete' && !task.cp) ||
            ((this.tasktype == 'incomplete' || this.tasktype == 'future_incomplete') && task.cp) ||
            ((complete === true) && (this.tasktype == 'future'))) {

            row.fade({
                duration: this.effectDur,
                afterFinish: function() {
                    row.purge();
                    row.remove();

                    //Check if items remained in interface
                    if ($('kronolithViewTasksBody').select('tr').length < 3) {
                        $('kronolithTasksNoItems').show();
                    }
                }
            });
        }

        // Update due date if necessary.
        if (!Object.isUndefined(complete) && complete !== true) {
            var now = new Date(), due = Date.parse(complete);
            row.down('span.kronolithDate')
                .update(due.toString(Kronolith.conf.date_format));
            if (now.isBefore(due)) {
                row.down('td.kronolithTaskCol')
                    .removeClassName('kronolithTaskDue');
            }
        }
    },

    /**
     * Toggles the CSS class to show that a task is completed/uncompleted.
     *
     * @param string taskid  The id of the task.
     */
    toggleCompletionClass: function(taskid)
    {
        var row = this.getTaskRow(taskid);
        if (!row) {
            return;
        }
        var col = row.down('td.kronolithTaskCol');
        col.toggleClassName('kronolithTask');
        col.toggleClassName('kronolithTaskCompleted');
    },

    /**
     * Returns the table row of a task.
     *
     * @param string taskid  The id of the task.
     *
     * @return Element  The table row of the task list, if found.
     */
    getTaskRow: function(taskid)
    {
        return $('kronolithViewTasksBody').select('tr').find(function(el) {
            return el.retrieve('taskid') == taskid;
        });
    },

    editTask: function(tasklist, id, desc)
    {
        if (this.redBoxLoading) {
            return;
        }

        if (Object.isUndefined(HordeImple.AutoCompleter.kronolithTaskTags)) {
            this.editTask.bind(this, tasklist, id, desc).defer();
            return;
        }

        this.closeRedBox();
        this.quickClose();
        this.redBoxOnDisplay = RedBox.onDisplay;
        RedBox.onDisplay = function() {
            if (this.redBoxOnDisplay) {
                this.redBoxOnDisplay();
            }
            try {
                $('kronolithTaskForm').focusFirstElement();
            } catch(e) {}
            RedBox.onDisplay = this.redBoxOnDisplay;
        }.bind(this);

        this.openTab($('kronolithTaskForm').down('.tabset a.kronolithTabLink'));
        $('kronolithTaskForm').enable();
        $('kronolithTaskForm').reset();
        HordeImple.AutoCompleter.kronolithTaskTags.reset();
        $('kronolithTaskSave').show().enable();
        $('kronolithTaskDelete').show().enable();
        $('kronolithTaskForm').down('.kronolithFormActions .kronolithSeparator').show();
        this.updateTasklistDropDown();
        this.disableAlarmMethods('Task');
        this.knl.kronolithTaskDueTime.markSelected();
        if (id) {
            RedBox.loading();
            this.updateTaskParentDropDown(tasklist);
            this.updateTaskAssigneeDropDown(tasklist);
            HordeCore.doAction('getTask', {
                list: tasklist,
                id: id
            }, {
                callback: this.editTaskCallback.bind(this)
            });
            $('kronolithTaskTopTags').update();
        } else {
            $('kronolithTaskId').clear();
            $('kronolithTaskOldList').clear();
            $('kronolithTaskList').setValue(Kronolith.conf.tasks.default_tasklist);
            this.updateTaskParentDropDown(Kronolith.conf.tasks.default_tasklist);
            this.updateTaskAssigneeDropDown(Kronolith.conf.tasks.default_tasklist);
            $('kronolithTaskParent').setValue('');
            $('kronolithTaskAssignee').setValue('');
            //$('kronolithTaskLocation').setValue('http://');
            HordeCore.doAction('listTopTags', {}, {
                callback: this.topTagsCallback.curry('kronolithTaskTopTags', 'kronolithTaskTag')
            });
            $('kronolithTaskPriority').setValue(3);
            if (Kronolith.conf.tasks.default_due) {
                this.setDefaultDue();
            }
            if (desc) {
                $('kronolithTaskDescription').setValue(desc);
            }
            this.toggleRecurrence(false, 'None');
            $('kronolithTaskDelete').hide();
            this.redBoxLoading = true;
            RedBox.showHtml($('kronolithTaskDialog').show());
        }
    },

    /**
     * Callback method for showing task forms.
     *
     * @param object r  The ajax response object.
     */
    editTaskCallback: function(r)
    {
        if (!r.task) {
            RedBox.close();
            this.go(this.lastLocation);
            return;
        }

        var task = r.task;

        /* Basic information */
        $('kronolithTaskId').setValue(task.id);
        $('kronolithTaskOldList').setValue(task.l);
        $('kronolithTaskList').setValue(task.l);
        $('kronolithTaskTitle').setValue(task.n);
        $('kronolithTaskParent').setValue(task.p);
        $('kronolithTaskAssignee').setValue(task.as);
        //$('kronolithTaskLocation').setValue(task.l);
        if (task.dd) {
            $('kronolithTaskDueDate').setValue(task.dd);
        }
        if (task.dt) {
            $('kronolithTaskDueTime').setValue(task.dt);
            this.knl.kronolithTaskDueTime.setSelected(task.dt);
        }
        $('kronolithTaskDescription').setValue(task.de);
        $('kronolithTaskPriority').setValue(task.pr);
        $('kronolithTaskCompleted').setValue(task.cp);

        /* Alarm */
        if (task.a) {
            this.enableAlarm('Task', task.a);
            if (task.m) {
                $('kronolithTaskAlarmDefaultOff').checked = true;
                $H(task.m).each(function(method) {
                    if (!$('kronolithTaskAlarm' + method.key)) {
                        return;
                    }
                    $('kronolithTaskAlarm' + method.key).setValue(1);
                    if ($('kronolithTaskAlarm' + method.key + 'Params')) {
                        $('kronolithTaskAlarm' + method.key + 'Params').show();
                    }
                    $H(method.value).each(function(param) {
                        var input = $('kronolithTaskAlarmParam' + param.key);
                        if (!input) {
                            return;
                        }
                        if (input.type == 'radio') {
                            input.up('form').select('input[type=radio]').each(function(radio) {
                                if (radio.name == input.name &&
                                    radio.value == param.value) {
                                    radio.setValue(1);
                                    throw $break;
                                }
                            });
                        } else {
                            input.setValue(param.value);
                        }
                    });
                });
            }
        } else {
            $('kronolithTaskAlarmOff').setValue(true);
        }

        /* Recurrence */
        if (task.r) {
            this.setRecurrenceFields(false, task.r);
        } else {
            this.toggleRecurrence(false, 'None');
        }

        HordeImple.AutoCompleter.kronolithTaskTags.reset(task.t);

        if (!task.pe) {
            $('kronolithTaskSave').hide();
            $('kronolithTaskForm').disable();
        } else {
            HordeCore.doAction('listTopTags', {}, {
                callback: this.topTagsCallback.curry('kronolithTaskTopTags', 'kronolithTaskTag')
            });
        }

        if (!task.pd) {
            $('kronolithTaskDelete').show();
        }
        if (!task.pe && !task.pd) {
            $('kronolithTaskForm').down('.kronolithFormActions .kronolithSeparator').hide();
        }

        this.setTitle(task.n);
        this.redBoxLoading = true;
        RedBox.showHtml($('kronolithTaskDialog').show());

        /* Hide alarm message for this task. */
        if (r.msgs) {
            r.msgs = r.msgs.reject(function(msg) {
                if (msg.type != 'horde.alarm') {
                    return false;
                }
                var alarm = msg.flags.alarm;
                if (alarm.params && alarm.params.notify &&
                    alarm.params.notify.show &&
                    alarm.params.notify.show.tasklist &&
                    alarm.params.notify.show.task &&
                    alarm.params.notify.show.tasklist == task.l &&
                    alarm.params.notify.show.task == task.id) {
                    return true;
                }
                return false;
            });
        }
    },

    /**
     * Propagates a SELECT drop down list with the editable task lists.
     */
    updateTasklistDropDown: function()
    {
        var tasklist = $('kronolithTaskList');
        tasklist.update();
        $H(Kronolith.conf.calendars.tasklists).each(function(cal) {
            if (cal.value.edit) {
                tasklist.insert(new Element('option', { value: cal.key.substring(6) })
                                .setStyle({ backgroundColor: cal.value.bg, color: cal.value.fg })
                                .update(cal.value.name.escapeHTML()));
            }
        });
    },

    /**
     * Propagates a SELECT drop down list with the tasks of a task list.
     *
     * @param string list  A task list ID.
     */
    updateTaskParentDropDown: function(list)
    {
        var parents = $('kronolithTaskParent');
        parents.update(new Element('option', { value: '' })
                       .update(Kronolith.text.no_parent));
        HordeCore.doAction('listTasks', {
            type: 'future_incomplete',
            list: list
        }, {
            ajaxopts: { asynchronuous: false },
            callback: function(r) {
                $H(r.tasks).each(function(task) {
                    parents.insert(new Element('option', { value: task.key })
                                .setStyle({ textIndent: task.value.i + 'em' })
                                .update(task.value.n.escapeHTML()));
                });
            }.bind(this)
        });
    },

    /**
     * Propagates a SELECT drop down list with the users of a task list.
     *
     * @param string list  A task list ID.
     */
    updateTaskAssigneeDropDown: function(list)
    {
        var assignee = $('kronolithTaskAssignee');
        assignee.update(new Element('option', { value: '' })
                       .update(Kronolith.text.no_assignee));
        $H(Kronolith.conf.calendars.tasklists['tasks/' + list].users).each(function(user) {
            assignee.insert(new Element('option', { value: user.key })
                            .update(user.value.escapeHTML()));
        });
    },

    /**
     * Sets the default due date and time for tasks.
     */
    setDefaultDue: function()
    {
        if ($F('kronolithTaskDueDate') || $F('kronolithTaskDueTime')) {
            return;
        }
        $('kronolithTaskDueDate').setValue(new Date().add(Kronolith.conf.tasks.default_due_days).days().toString(Kronolith.conf.date_format));
        if (Kronolith.conf.tasks.default_due_time == 'now') {
            $('kronolithTaskDueTime').setValue(new Date().toString(Kronolith.conf.time_format));
        } else {
            var date = new Date();
            date.setHours(Kronolith.conf.tasks.default_due_time.replace(/:.*$/, ''));
            date.setMinutes(0);
            $('kronolithTaskDueTime').setValue(date.toString(Kronolith.conf.time_format));
        }
    },

    /**
     * Finally removes tasks from the DOM and the cache.
     *
     * @param string list  A task list name.
     * @param string task  A task id. If empty, all tasks from the list are
     *                     deleted.
     */
    removeTask: function(list, task)
    {
        this.deleteTasksCache(list, task);
        $('kronolithViewTasksBody').select('tr').findAll(function(el) {
            return el.retrieve('tasklist') == list &&
                (!task || el.retrieve('taskid') == task);
        }).invoke('remove');
        this.removeEvent('tasklists|tasks/' + list, task ? '_tasks' + task : null);
        if ($('kronolithViewTasksBody').select('tr').length > 2) {
            $('kronolithTasksNoItems').hide();
        } else {
            $('kronolithTasksNoItems').show();
        }
    },

    /**
     * Submits the task edit form to create or update a task.
     */
    saveTask: function()
    {
        if (this.wrongFormat.size() ||
            (($F('kronolithTaskAlarmOn')) && $F('kronolithTaskDueDate').length == 0)) {
            HordeCore.notify(Kronolith.text.fix_form_values, 'horde.warning');
            return;
        }

        var tasklist = $F('kronolithTaskOldList'),
            target = $F('kronolithTaskList'),
            taskid = $F('kronolithTaskId'),
            viewDates = this.viewDates(this.date, this.view),
            start = viewDates[0].dateString(),
            end = viewDates[1].dateString();

        HordeImple.AutoCompleter.kronolithTaskTags.shutdown();
        $('kronolithTaskSave').disable();
        this.startLoading('tasklists|tasks/' + target, start + end + this.tasktype);
        this.loading++;
        HordeCore.doAction(
            'saveTask',
            $H($('kronolithTaskForm').serialize({ hash: true })).merge({
                sig: start + end + this.tasktype,
                view: this.view,
                view_start: start,
                view_end: end
            }), {
                callback: function(r) {
                    if (r.tasks && taskid) {
                        this.removeTask(tasklist, taskid);
                    }
                    this.loadTasksCallback(r, false);
                    this.loadEventsCallback(r, false);
                    if (r.tasks) {
                        this.closeRedBox();
                        this.go(this.lastLocation);
                    } else {
                        $('kronolithTaskSave').enable();
                    }
                }.bind(this)
            }
        );
    },

    quickSaveTask: function()
    {
        var text = $F('kronolithQuicktaskQ'),
            viewDates = this.viewDates(this.date, 'tasks'),
            start = viewDates[0].dateString(),
            end = viewDates[1].dateString(),
            params = {
                sig: start + end + this.tasktype,
                view: 'tasks',
                view_start: start,
                view_end: end,
                tasklist: Kronolith.conf.tasks.default_tasklist,
                text: text
            };

        this.closeRedBox();
        this.startLoading('tasklists|tasks/' + Kronolith.conf.tasks.default_tasklist,
                          params.sig);
        this.loading++;
        HordeCore.doAction('quickSaveTask', params, {
            callback: function(r) {
                this.loadTasksCallback(r, false);
                this.loadEventsCallback(r, false);
                if (!r.tasks || !$H(r.tasks).size()) {
                    this.editTask(null, null, text);
                } else {
                    $('kronolithQuicktaskQ').value = '';
                }
            }.bind(this)
         });
    },

    /**
     * Opens the form for editing a calendar.
     *
     * @param string calendar  Calendar type and calendar id, separated by '|'.
     */
    editCalendar: function(calendar)
    {
        if (this.redBoxLoading) {
            return;
        }

        this.closeRedBox();
        this.quickClose();

        var type = calendar.split('|')[0], cal = calendar.split('|')[1];
        if (!$w('internal tasklists remote holiday resource resourcegroup').include(type)) {
            return;
        }

        if (cal &&
            (Object.isUndefined(Kronolith.conf.calendars[type]) ||
             Object.isUndefined(Kronolith.conf.calendars[type][cal])) &&
            (type == 'internal' || type == 'tasklists')) {
            HordeCore.doAction('getCalendar', {
                cal: cal
            }, {
                callback: function(r) {
                    if (r.calendar) {
                        Kronolith.conf.calendars[type][cal] = r.calendar;
                        this.insertCalendarInList(type, cal, r.calendar);
                        $('kronolithSharedCalendars').show();
                        this.editCalendar(type + '|' + cal);
                    } else {
                        this.go(this.lastLocation);
                    }
                }.bind(this)
            });
            return;
        }

        this.redBoxOnDisplay = RedBox.onDisplay;
        RedBox.onDisplay = function() {
            if (this.redBoxOnDisplay) {
                this.redBoxOnDisplay();
            }
            try {
                $('kronolithCalendarForm' + type).focusFirstElement();
            } catch(e) {}
            RedBox.onDisplay = this.redBoxOnDisplay;
        }.bind(this);

        if ($('kronolithCalendarDialog')) {
            this.redBoxLoading = true;
            RedBox.showHtml($('kronolithCalendarDialog').show());
            this.editCalendarCallback(calendar);
        } else {
            RedBox.loading();
            HordeCore.doAction('chunkContent', {
                chunk: 'calendar'
            }, {
                callback: function(r) {
                    if (r.chunk) {
                        this.redBoxLoading = true;
                        RedBox.showHtml(r.chunk);
                        ['internal', 'tasklists'].each(function(type) {
                            $('kronolithC' + type + 'PGList').observe('change', function() {
                                $('kronolithC' + type + 'PG').setValue(1);
                                this.permsClickHandler(type, 'G');
                            }.bind(this));
                        }, this);
                        this.editCalendarCallback(calendar);
                    } else {
                        this.closeRedBox();
                    }
                }.bind(this)
            });
        }
    },

    /**
     * Callback for editing a calendar. Fills the edit form with the correct
     * values.
     *
     * @param string calendar  Calendar type and calendar id, separated by '|'.
     */
    editCalendarCallback: function(calendar)
    {
        calendar = calendar.split('|');
        var type = calendar[0];
        calendar = calendar.length == 1 ? null : calendar[1];

        var form = $('kronolithCalendarForm' + type),
            firstTab = form.down('.tabset a.kronolithTabLink'),
            info;

        form.enable();
        form.reset();
        if (firstTab) {
            this.openTab(firstTab);
        }
        $('kronolithCalendarDialog').select('.kronolithCalendarDiv').invoke('hide');
        $('kronolithCalendar' + type + '1').show();
        form.select('.kronolithCalendarContinue').invoke('enable');
        $('kronolithC' + type + 'PUNew', 'kronolithC' + type + 'PGNew').compact().each(function(elm) {
            if (elm.tagName == 'SELECT') {
                $A(elm.options).each(function(option) {
                    option.writeAttribute('disabled', false);
                });
            }
        });

        var newCalendar = !calendar;
        if (calendar &&
            (Object.isUndefined(Kronolith.conf.calendars[type]) ||
             Object.isUndefined(Kronolith.conf.calendars[type][calendar]))) {
            if (type != 'remote') {
                this.closeRedBox();
                this.go(this.lastLocation);
                return;
            }
            newCalendar = true;
        }
        if (type == 'resourcegroup') {
            this.updateResourcegroupSelect();
        }
        if (newCalendar) {
            switch (type) {
            case 'internal':
                HordeImple.AutoCompleter.kronolithCalendarinternalTags.reset();
                // Fall through.
            case 'tasklists':
                $('kronolithCalendar' + type + 'LinkExport').up('span').hide();
                break;
            case 'remote':
                if (calendar) {
                    $('kronolithCalendarremoteUrl').setValue(calendar);
                    $('kronolithCalendarremoteId').setValue(calendar);
                }
                break;
            case 'holiday':
                $('kronolithCalendarholidayDriver').update();
                $H(Kronolith.conf.calendars.holiday).each(function(calendar) {
                    if (calendar.value.show) {
                        return;
                    }
                    $('kronolithCalendarholidayDriver').insert(
                        new Element('option', { value: calendar.key })
                            .setStyle({ color: calendar.value.fg, backgroundColor: calendar.value.bg })
                            .insert(calendar.value.name.escapeHTML())
                    );
                });
                break;
            }
            $('kronolithCalendar' + type + 'Id').clear();
            var color = '#', i;
            for (i = 0; i < 3; i++) {
                color += (Math.random() * 256 | 0).toColorPart();
            }
            $('kronolithCalendar' + type + 'Color').setValue(color).setStyle({ backgroundColor: color, color: Color.brightness(Color.hex2rgb(color)) < 125 ? '#fff' : '#000' });
            form.down('.kronolithCalendarDelete').hide();
            $('kronolithCalendarinternalImportButton').hide();
        } else {
            info = Kronolith.conf.calendars[type][calendar];

            $('kronolithCalendar' + type + 'Id').setValue(calendar);
            $('kronolithCalendar' + type + 'Name').setValue(info.name);
            $('kronolithCalendar' + type + 'Color').setValue(info.bg).setStyle({ backgroundColor: info.bg, color: info.fg });
            $('kronolithCalendarinternalImportButton').hide();

            switch (type) {
            case 'internal':
                HordeImple.AutoCompleter.kronolithCalendarinternalTags.reset(Kronolith.conf.calendars.internal[calendar].tg);
                $('kronolithCalendar' + type + 'ImportCal').setValue('internal_' + calendar);
                if ($('kronolithCalendar' + type + 'LinkImport')) {
                    if (info.edit) {
                        $('kronolithCalendar' + type + 'LinkImport').up('li').show();
                    } else {
                        $('kronolithCalendar' + type + 'LinkImport').up('li').hide();
                    }
                }
                $('kronolithCalendar' + type + 'UrlFeed').setValue(info.feed);
                $('kronolithCalendar' + type + 'EmbedUrl').setValue(info.embed);
                // Fall through.
            case 'tasklists':
                $('kronolithCalendar' + type + 'Description').setValue(info.desc);
                if ($('kronolithCalendar' + type + 'LinkExport')) {
                    $('kronolithCalendar' + type + 'LinkExport').up('span').show();
                    $('kronolithCalendar' + type + 'Export').href = type == 'internal'
                        ? Kronolith.conf.URI_CALENDAR_EXPORT.interpolate({ calendar: calendar })
                        : Kronolith.conf.tasks.URI_TASKLIST_EXPORT.interpolate({ tasklist: calendar.substring(6) });
                }
                $('kronolithCalendar' + type + 'LinkUrls').up().show();
                if (info.caldav) {
                    $('kronolithCalendar' + type + 'UrlCaldav').setValue(info.caldav);
                    $('kronolithCalendar' + type + 'Caldav').show();
                } else {
                    $('kronolithCalendar' + type + 'Caldav').hide();
                }
                $('kronolithCalendar' + type + 'UrlWebdav').setValue(info.sub);
                break;
            case 'remote':
                $('kronolithCalendarremoteUrl').setValue(calendar);
                $('kronolithCalendarremoteDescription').setValue(info.desc);
                $('kronolithCalendarremoteUsername').setValue(info.user);
                $('kronolithCalendarremotePassword').setValue(info.password);
                break;
            case 'resourcegroup':
                $('kronolithCalendarresourcegroupDescription').setValue(info.desc);
                $('kronolithCalendarresourcegroupmembers').setValue(info.members);
                break;
            case 'resource':
                $('kronolithCalendarresourceDescription').setValue(info.desc);
                $('kronolithCalendarresourceResponseType').setValue(info.response_type);
                $('kronolithCalendarresourceExport').href = Kronolith.conf.URI_RESOURCE_EXPORT.interpolate({ calendar: calendar });
            }
        }

        if (newCalendar || info.owner) {
            if (type == 'internal' || type == 'tasklists') {
                this.updateGroupDropDown([['kronolithC' + type + 'PGList', this.updateGroupPerms.bind(this, type)],
                                          ['kronolithC' + type + 'PGNew']]);
                $('kronolithC' + type + 'PBasic').show();
                $('kronolithC' + type + 'PAdvanced').hide();
                $('kronolithC' + type + 'PNone').setValue(1);
                if ($('kronolithC' + type + 'PAllShow')) {
                    $('kronolithC' + type + 'PAllShow').disable();
                }
                $('kronolithC' + type + 'PGList').disable();
                $('kronolithC' + type + 'PGPerms').disable();
                $('kronolithC' + type + 'PUList').disable();
                $('kronolithC' + type + 'PUPerms').disable();
                $('kronolithC' + type + 'PAdvanced').select('tr').findAll(function(tr) {
                    return tr.retrieve('remove');
                }).invoke('remove');
                $('kronolithCalendar' + type + 'LinkUrls').up().show();
                form.down('.kronolithColorPicker').show();
                if (type == 'internal') {
                    HordeCore.doAction('listTopTags', {}, {
                        callback: this.topTagsCallback.curry('kronolithCalendarinternalTopTags', 'kronolithCalendarTag')
                    });
                }
                form.down('.kronolithCalendarSubscribe').hide();
                form.down('.kronolithCalendarUnsubscribe').hide();
                if ($('kronolithCalendar' + type + 'LinkPerms')) {
                    $('kronolithCalendar' + type + 'LinkPerms').up('span').show();
                }
                if (!Object.isUndefined(info) && info.owner) {
                    this.setPermsFields(type, info.perms);
                }
            }
            if (type == 'remote' || type == 'internal' || type == 'tasklists') {
                if (newCalendar ||
                    (type == 'internal' && calendar == Kronolith.conf.user) ||
                    (type == 'tasklists' && calendar == 'tasks/' + Kronolith.conf.user)) {
                    form.select('.kronolithCalendarDelete').invoke('hide');
                } else {
                    form.select('.kronolithCalendarDelete').invoke('show');
                }
            }
            form.down('.kronolithCalendarSave').show();
            form.down('.kronolithFormActions .kronolithSeparator').show();
        } else {
            form.disable();
            form.down('.kronolithColorPicker').hide();
            form.down('.kronolithCalendarDelete').hide();
            form.down('.kronolithCalendarSave').hide();
            if (type == 'internal' || type == 'tasklists') {
                $('kronolithCalendar' + type + 'UrlCaldav').enable();
                $('kronolithCalendar' + type + 'UrlAccount').enable();
                $('kronolithCalendar' + type + 'UrlWebdav').enable();
                if (type == 'internal') {
                    $('kronolithCalendar' + type + 'UrlFeed').enable();
                    $('kronolithCalendar' + type + 'EmbedUrl').enable();
                    if (info.edit) {
                        $('kronolithCalendarinternalImport').enable();
                        if (info.del) {
                            $('kronolithCalendarinternalImportOver').enable();
                        }
                        $('kronolithCalendarinternalImportButton').show().enable();
                    }
                }
                HordeImple.AutoCompleter.kronolithCalendarinternalTags.disable();
                if (Kronolith.conf.calendars[type][calendar].show) {
                    form.down('.kronolithCalendarSubscribe').hide();
                    form.down('.kronolithCalendarUnsubscribe').show().enable();
                } else {
                    form.down('.kronolithCalendarSubscribe').show().enable();
                    form.down('.kronolithCalendarUnsubscribe').hide();
                }
                form.down('.kronolithFormActions .kronolithSeparator').show();
                if ($('kronolithCalendar' + type + 'LinkPerms')) {
                    $('kronolithCalendar' + type + 'LinkPerms').up('span').hide();
                }
            } else {
                form.down('.kronolithFormActions .kronolithSeparator').hide();
            }
        }
    },

    /**
     * Updates the select list in the resourcegroup calendar dialog.
     */
    updateResourcegroupSelect: function()
    {
        if (!Kronolith.conf.calendars.resource) {
            return;
        }
        $('kronolithCalendarresourcegroupmembers').update();
        $H(Kronolith.conf.calendars.resource).each(function(r) {
            var o = new Element('option', { value: r.value.id }).update(r.value.name);
            $('kronolithCalendarresourcegroupmembers').insert(o);
        });
    },

    /**
     * Handles clicks on the radio boxes of the basic permissions screen.
     *
     * @param string type  The calendar type, 'internal' or 'taskslists'.
     * @param string perm  The permission to activate, 'None', 'All', or
     *                     'Group'.
     */
    permsClickHandler: function(type, perm)
    {
        $('kronolithC' + type + 'PAdvanced')
            .select('input[type=checkbox]')
            .invoke('setValue', 0);
        $('kronolithC' + type + 'PAdvanced').select('tr').findAll(function(tr) {
            return tr.retrieve('remove');
        }).invoke('remove');

        switch (perm) {
        case 'None':
            if ($('kronolithC' + type + 'PAllShow')) {
                $('kronolithC' + type + 'PAllShow').disable();
            }
            $('kronolithC' + type + 'PGList').disable();
            $('kronolithC' + type + 'PGPerms').disable();
            $('kronolithC' + type + 'PUList').disable();
            $('kronolithC' + type + 'PUPerms').disable();
            break;
        case 'All':
            $('kronolithC' + type + 'PAllShow').enable();
            $('kronolithC' + type + 'PGList').disable();
            $('kronolithC' + type + 'PGPerms').disable();
            $('kronolithC' + type + 'PUList').disable();
            $('kronolithC' + type + 'PUPerms').disable();
            var perms = {
                'default': Kronolith.conf.perms.read,
                'guest': Kronolith.conf.perms.read
            };
            if ($F('kronolithC' + type + 'PAllShow')) {
                perms['default'] |= Kronolith.conf.perms.show;
                perms['guest'] |= Kronolith.conf.perms.show;
            }
            this.setPermsFields(type, perms);
            break;
        case 'G':
            if ($('kronolithC' + type + 'PAllShow')) {
                $('kronolithC' + type + 'PAllShow').disable();
            }
            $('kronolithC' + type + 'PGList').enable();
            $('kronolithC' + type + 'PGPerms').enable();
            $('kronolithC' + type + 'PUList').disable();
            $('kronolithC' + type + 'PUPerms').disable();
            var group = $F('kronolithC' + type + 'PGSingle')
                ? $F('kronolithC' + type + 'PGSingle')
                : $F('kronolithC' + type + 'PGList');
            this.insertGroupOrUser(type, 'group', group, true);
            $('kronolithC' + type + 'PGshow_' + group).setValue(1);
            $('kronolithC' + type + 'PGread_' + group).setValue(1);
            if ($F('kronolithC' + type + 'PGPerms') == 'edit') {
                $('kronolithC' + type + 'PGedit_' + group).setValue(1);
            } else {
                $('kronolithC' + type + 'PGedit_' + group).setValue(0);
            }
            $('kronolithC' + type + 'PGdel_' + group).setValue(0);
            if ($('kronolithC' + type + 'PGdelegate_' + group)) {
                $('kronolithC' + type + 'PGdelegate_' + group).setValue(0);
            }
            break;
        case 'U':
            if ($('kronolithC' + type + 'PAllShow')) {
                $('kronolithC' + type + 'PAllShow').disable();
            }
            $('kronolithC' + type + 'PGList').disable();
            $('kronolithC' + type + 'PGPerms').disable();
            $('kronolithC' + type + 'PUList').enable();
            $('kronolithC' + type + 'PUPerms').enable();
            var users = $F('kronolithC' + type + 'PUList').strip();
            users = users ? users.split(/\s*(?:,|\n)\s*/) : [];
            users.each(function(user) {
                if (!this.insertGroupOrUser(type, 'user', user, true)) {
                    return;
                }
                $('kronolithC' + type + 'PUshow_' + user).setValue(1);
                $('kronolithC' + type + 'PUread_' + user).setValue(1);
                if ($F('kronolithC' + type + 'PUPerms') == 'edit') {
                    $('kronolithC' + type + 'PUedit_' + user).setValue(1);
                } else {
                    $('kronolithC' + type + 'PUedit_' + user).setValue(0);
                }
                $('kronolithC' + type + 'PUdel_' + user).setValue(0);
                if ($('kronolithC' + type + 'PUdelegate_' + user)) {
                    $('kronolithC' + type + 'PUdelegate_' + user).setValue(0);
                }
            }, this);
            break;
        }
    },

    /**
     * Populates the permissions field matrix.
     *
     * @param string type   The calendar type, 'internal' or 'taskslists'.
     * @param object perms  An object with the resource permissions.
     */
    setPermsFields: function(type, perms)
    {
        if (this.groupLoading) {
            this.setPermsFields.bind(this, type, perms).defer();
            return;
        }

        var allperms = $H(Kronolith.conf.perms),
            advanced = false, users = [],
            basic, same, groupPerms, groupId, userPerms;
        $H(perms).each(function(perm) {
            switch (perm.key) {
            case 'default':
            case 'guest':
                if (Object.isUndefined(same)) {
                    same = perm.value;
                } else if (Object.isUndefined(basic) &&
                           same == perm.value &&
                           (perm.value == Kronolith.conf.perms.read ||
                            perm.value == (Kronolith.conf.perms.read | Kronolith.conf.perms.show))) {
                    basic = perm.value == Kronolith.conf.perms.read ? 'all_read' : 'all_show';
                } else if (perm.value != 0) {
                    advanced = true;
                }
                break;
            case 'creator':
                if (perm.value != 0) {
                    advanced = true;
                }
                break;
            case 'groups':
                if (!Object.isArray(perm.value)) {
                    $H(perm.value).each(function(group) {
                        if (!this.insertGroupOrUser(type, 'group', group.key)) {
                            return;
                        }
                        if (!$('kronolithC' + type + 'PGshow_' + group.key)) {
                            // Group doesn't exist anymore.
                            delete perm.value[group.key];
                            return;
                        }
                        groupPerms = group.value;
                        groupId = group.key;
                    }, this);
                    if (Object.isUndefined(basic) &&
                        $H(perm.value).size() == 1 &&
                        (groupPerms == (Kronolith.conf.perms.show | Kronolith.conf.perms.read) ||
                         groupPerms == (Kronolith.conf.perms.show | Kronolith.conf.perms.read | Kronolith.conf.perms.edit))) {
                        basic = groupPerms == (Kronolith.conf.perms.show | Kronolith.conf.perms.read) ? 'group_read' : 'group_edit';
                    } else {
                        advanced = true;
                    }
                }
                break;
            case 'users':
                if (!Object.isArray(perm.value)) {
                    $H(perm.value).each(function(user) {
                        if (user.key != Kronolith.conf.user) {
                            if (!this.insertGroupOrUser(type, 'user', user.key)) {
                                return;
                            }
                            if (!$('kronolithC' + type + 'PUshow_' + user.key)) {
                                // User doesn't exist anymore.
                                delete perm.value[user.key];
                                return;
                            }
                            // Check if we already have other basic permissions.
                            if (Object.isUndefined(userPerms) &&
                                !Object.isUndefined(basic)) {
                                advanced = true;
                            }
                            // Check if all users have the same permissions.
                            if (!Object.isUndefined(userPerms) &&
                                userPerms != user.value) {
                                advanced = true;
                            }
                            userPerms = user.value;
                            if (!advanced &&
                                (userPerms == (Kronolith.conf.perms.show | Kronolith.conf.perms.read) ||
                                 userPerms == (Kronolith.conf.perms.show | Kronolith.conf.perms.read | Kronolith.conf.perms.edit))) {
                                basic = userPerms == (Kronolith.conf.perms.show | Kronolith.conf.perms.read) ? 'user_read' : 'user_edit';
                                users.push(user.key);
                            } else {
                                advanced = true;
                            }
                        }
                    }, this);
                }
                break;
            }

            allperms.each(function(baseperm) {
                if (baseperm.key == 'all') {
                    return;
                }
                switch (perm.key) {
                case 'default':
                case 'guest':
                case 'creator':
                    if (baseperm.value & perm.value) {
                        $('kronolithC' + type + 'P' + perm.key + baseperm.key).setValue(1);
                    }
                    break;
                case 'groups':
                    $H(perm.value).each(function(group) {
                        if (baseperm.value & group.value) {
                            $('kronolithC' + type + 'PG' + baseperm.key + '_' + group.key).setValue(1);
                        }
                    });
                    break;
                case 'users':
                    $H(perm.value).each(function(user) {
                        if (baseperm.value & user.value &&
                            user.key != Kronolith.conf.user) {
                            $('kronolithC' + type + 'PU' + baseperm.key + '_' + user.key).setValue(1);
                        }
                    });
                    break;
                }
            });
        }.bind(this));

        if (advanced) {
            this.activateAdvancedPerms(type);
        } else {
            switch (basic) {
            case 'all_read':
                $('kronolithC' + type + 'PAll').setValue(1);
                $('kronolithC' + type + 'PAllShow').setValue(0);
                $('kronolithC' + type + 'PAllShow').enable();
                break;
            case 'all_show':
                $('kronolithC' + type + 'PAll').setValue(1);
                $('kronolithC' + type + 'PAllShow').setValue(1);
                $('kronolithC' + type + 'PAllShow').enable();
                break;
            case 'group_read':
            case 'group_edit':
                var setGroup = function(group) {
                    if ($('kronolithC' + type + 'PGList').visible()) {
                        $('kronolithC' + type + 'PGList').setValue(group);
                        if ($('kronolithC' + type + 'PGList').getValue() != group) {
                            // Group no longer exists.
                            this.permsClickHandler(type, 'None');
                        }
                    } else if ($('kronolithC' + type + 'PGSingle').getValue() != group) {
                        // Group no longer exists.
                        this.permsClickHandler(type, 'None');
                    }
                }.bind(this, groupId);
                if (this.groupLoading) {
                    setGroup.defer();
                } else {
                    setGroup();
                }
                $('kronolithC' + type + 'PG').setValue(1);
                $('kronolithC' + type + 'PGPerms').setValue(basic.substring(6));
                $('kronolithC' + type + 'PAdvanced').hide();
                $('kronolithC' + type + 'PBasic').show();
                $('kronolithC' + type + 'PGPerms').enable();
                break;
            case 'user_read':
            case 'user_edit':
                $('kronolithC' + type + 'PUList').enable().setValue(users.join(', '));
                $('kronolithC' + type + 'PU').setValue(1);
                $('kronolithC' + type + 'PUPerms').setValue(basic.substring(5));
                $('kronolithC' + type + 'PAdvanced').hide();
                $('kronolithC' + type + 'PBasic').show();
                $('kronolithC' + type + 'PUPerms').enable();
                break;
            }
        }
   },

    /**
     * Propagates a SELECT drop down list with the groups.
     *
     * @param array params  A two-dimensional array with the following values
     *                      in each element:
     *                      - The id of the SELECT element.
     *                      - A callback method that is invoked with the group
     *                        list passes as an argument.
     */
    updateGroupDropDown: function(params)
    {
        this.groupLoading = true;
        params.each(function(param) {
            var elm = $(param[0]), options = elm.childElements();
            options.invoke('remove');
            elm.up('form').disable();
        });
        HordeCore.doAction('listGroups', {}, {
            callback: function(r) {
                var groups;
                if (r.groups) {
                    groups = $H(r.groups);
                    params.each(function(param) {
                        groups.each(function(group) {
                            $(param[0]).insert(new Element('option', { value: group.key }).update(group.value.escapeHTML()));
                        });
                    });
                }
                params.each(function(param) {
                    $(param[0]).up('form').enable();
                    if (param[1]) {
                        param[1](groups);
                    }
                });
                this.groupLoading = false;
            }.bind(this)
        });
    },

    /**
     * Updates the group permission interface after the group list has
     * been loaded.
     *
     * @param string type  The calendar type, 'internal' or 'taskslists'.
     * @param Hash groups  The list of groups.
     */
    updateGroupPerms: function(type, groups)
    {
        $('kronolithC' + type + 'PGSingle').clear();
        if (!groups) {
            $('kronolithC' + type + 'PGNew').up('div').hide();
            $('kronolithC' + type + 'PG').up('span').hide();
        } else {
            $('kronolithC' + type + 'PGNew').up('div').show();
            $('kronolithC' + type + 'PG').up('span').show();
            if (groups.size() == 1) {
                $('kronolithC' + type + 'PGName')
                    .update('&quot;' + groups.values()[0].escapeHTML() + '&quot;')
                    .show();
                $('kronolithC' + type + 'PGSingle').setValue(groups.keys()[0]);
                $('kronolithC' + type + 'PGList').hide();
            } else {
                $('kronolithC' + type + 'PGName').hide();
                $('kronolithC' + type + 'PGList').show();
            }
        }
    },

    /**
     * Inserts a group or user row into the advanced permissions interface.
     *
     * @param string type          The calendar type, 'internal' or
     *                             'taskslists'.
     * @param what string          Either 'group' or 'user'.
     * @param group string         The group id or user name to insert.
     *                             Defaults to the value of the drop down.
     * @param stay_basic boolean   Enforces to NOT switch to the advanced
     *                             permissions screen.
     *
     * @return boolean  Whether a row has been inserted.
     */
    insertGroupOrUser: function(type, what, id, stay_basic)
    {
        var elm = $(what == 'user' ? 'kronolithC' + type + 'PUNew' : 'kronolithC' + type + 'PGNew');
        if (id) {
            elm.setValue(id);
        }
        var value = elm.getValue();
        if (!value) {
            if (id) {
                HordeCore.notify(Kronolith.text.invalid_user + ': ' + id, 'horde.error');
            }
            return false;
        }

        var tr = elm.up('tr'),
            row = tr.clone(true).store('remove', true),
            td = row.down('td'),
            clearName = elm.tagName == 'SELECT' ? elm.options[elm.selectedIndex].text: elm.getValue();

        td.update();
        td.insert(clearName.escapeHTML())
            .insert(new Element('input', { type: 'hidden', name: (what == 'user' ? 'u' : 'g') + '_names[' + value + ']', value: value }));
        row.select('input[type=checkbox]').each(function(input) {
            input.writeAttribute('name', input.name.replace(/\[.*?$/, '[' + value + ']'))
                .writeAttribute('id', input.id.replace(/new/, value))
                .next()
                .writeAttribute('for', input.id);
        });
        tr.insert({ before: row });

        if (elm.tagName == 'SELECT') {
            elm.options[elm.selectedIndex].writeAttribute('disabled', true);
            elm.selectedIndex = 0;
        } else {
            elm.clear();
        }

        if (!stay_basic) {
            this.activateAdvancedPerms(type);
        }

        return true;
    },

    /**
     * Activates the advanced permissions.
     *
     * @param string type  The calendar type, 'internal' or 'taskslists'.
     */
    activateAdvancedPerms: function(type)
    {
        [$('kronolithC' + type + 'PNone'),
         $('kronolithC' + type + 'PU'),
         $('kronolithC' + type + 'PG')].each(function(radio) {
            radio.checked = false;
        });
        if ($('kronolithC' + type + 'PAll')) {
            $('kronolithC' + type + 'PAll').checked = false;
        }
        $('kronolithC' + type + 'PBasic').hide();
        $('kronolithC' + type + 'PAdvanced').show();
    },

    /**
     * Opens the next screen of the calendar management wizard.
     *
     * @param string type  The calendar type.
     */
    calendarNext: function(type)
    {
        var i = 1;
        while (!$('kronolithCalendar' + type + i).visible()) {
            i++;
        }
        $('kronolithCalendar' + type + i).hide();
        $('kronolithCalendar' + type + (++i)).show();
        if (this.colorPicker) {
            this.colorPicker.hide();
        }
    },

    /**
     * Submits the calendar form to save the calendar data.
     *
     * @param Element form  The form node.
     *
     * @return boolean  Whether the save request was successfully sent.
     */
    saveCalendar: function(form)
    {
        if (this.colorPicker) {
            this.colorPicker.hide();
        }
        var data = form.serialize({ hash: true });

        if (data.type == 'holiday') {
            this.insertCalendarInList('holiday', data.driver, Kronolith.conf.calendars.holiday[data.driver]);
            this.toggleCalendar('holiday', data.driver);
            form.down('.kronolithCalendarSave').enable();
            this.closeRedBox();
            this.go(this.lastLocation);
            return;
        }

        if (data.name.empty()) {
            HordeCore.notify(data.type == 'tasklists' ? Kronolith.text.no_tasklist_title : Kronolith.text.no_calendar_title, 'horde.warning');
            $('kronolithCalendar' + data.type + 'Name').focus();
            return false;
        }
        HordeCore.doAction('saveCalendar', data, {
            callback: this.saveCalendarCallback.bind(this, form, data)
        });
        return true;
    },

    calendarImport: function(form, disableForm)
    {
        if ($F('kronolithCalendarinternalImport')) {
            HordeCore.notify(Kronolith.text.import_warning, 'horde.message');
            this.loading++;
            $('kronolithLoading').show();
            var name = 'kronolithIframe' + Math.round(Math.random() * 1000),
                iframe = new Element('iframe', { src: 'about:blank', name: name, id: name }).setStyle({ display: 'none' });
            document.body.insert(iframe);
            form.enable();
            form.target = name;
            form.submit();
            if (disableForm) {
                form.disable();
            }
        }
    },

    /**
     * Callback method after saving a calendar.
     *
     * @param Element form  The form node.
     * @param object data   The serialized form data.
     * @param object r      The ajax response object.
     */
    saveCalendarCallback: function(form, data, r)
    {
        var type = form.id.replace(/kronolithCalendarForm/, '');

        // If saving the calendar changed the owner, we need to delete
        // and re-insert the calendar.
        if (r.deleted) {
            this.deleteCalendar(type, data.calendar);
            delete data.calendar;
        }
        if (r.saved) {
            this.calendarImport(form, false);
            var cal = r.calendar, id;
            if (data.calendar) {
                var color = {
                    backgroundColor: cal.bg,
                    color: cal.fg
                },
                legendSpan;
                id = data.calendar;
                this.getCalendarList(type, cal.owner).select('div').each(function(element) {
                    if (element.retrieve('calendar') == id) {
                        var link = element.down('.horde-resource-link span');
                        element.setStyle(color);
                        link.update(cal.name.escapeHTML());
                        this.addShareIcon(cal, link);
                        throw $break;
                    }
                }, this);
                this.kronolithBody.select('div').each(function(el) {
                    if (el.retrieve('calendar') == type + '|' + id) {
                        el.setStyle(color);
                    }
                });
                legendSpan = $('kronolith-legend').select('span')
                    .find(function(span) {
                        return span.retrieve('calendarclass') == type &&
                            span.retrieve('calendar') == id;
                    });
                if (legendSpan) {
                    legendSpan.setStyle(color).update(cal.name.escapeHTML());
                }
                Kronolith.conf.calendars[type][id] = cal;
            } else {
                id = r.id;
                if (!Kronolith.conf.calendars[type]) {
                    Kronolith.conf.calendars[type] = [];
                }
                Kronolith.conf.calendars[type][id] = cal;
                this.insertCalendarInList(type, id, cal);
                this.storeCache($H(), [type, id], this.viewDates(this.date, this.view), true);
                if (type == 'tasklists') {
                    this.storeTasksCache($H(), this.tasktype, id.replace(/^tasks\//, ''), true);
                }
            }
            if (type == 'remote') {
                this.loadCalendar(type, id);
            }
        }
        form.down('.kronolithCalendarSave').enable();
        this.closeRedBox();
        this.go(this.lastLocation);
    },

    /**
     * Deletes a calendar and all its events from the interface and cache.
     *
     * @param string type      The calendar type.
     * @param string calendar  The calendar id.
     */
    deleteCalendar: function(type, calendar)
    {
        var container = this.getCalendarList(type, Kronolith.conf.calendars[type][calendar].owner),
            noItems = container.previous(),
            div = container.select('div').find(function(element) {
                return element.retrieve('calendar') == calendar;
            }),
            arrow = div.down('span');
        arrow.purge();
        arrow.remove();
        div.purge();
        div.remove();
        if (noItems &&
            noItems.tagName == 'DIV' &&
            noItems.className == 'horde-info' &&
            !container.childElements().size()) {
            noItems.show();
        }
        this.deleteCalendarLegend(type, calendar);
        this.removeEvent(type + '|' + calendar);
        this.deleteCache([type, calendar]);
        if (type == 'tasklists' && this.view == 'tasks') {
            this.removeTask(calendar.replace(/^tasks\//, ''));
        }
        delete Kronolith.conf.calendars[type][calendar];
    },

    /**
     * Parses a date attribute string into a Date object.
     *
     * For other strings use Date.parse().
     *
     * @param string date  A yyyyMMdd date string.
     *
     * @return Date  A date object.
     */
    parseDate: function(date)
    {
        var d = new Date(date.substr(0, 4), date.substr(4, 2) - 1, date.substr(6, 2));
        if (date.length == 12) {
            d.setHours(date.substr(8, 2));
            d.setMinutes(date.substr(10, 2));
        }
        return d;
    },

    /**
     * Calculates first and last days being displayed.
     *
     * @var Date date    The date of the view.
     * @var string view  A view name.
     *
     * @return array  Array with first and last day of the view.
     */
    viewDates: function(date, view)
    {
        var start = date.clone(), end = date.clone();

        switch (view) {
        case 'week':
        case 'workweek':
            if (view == 'workweek') {
                start.add(1).days();
            }
            start.moveToBeginOfWeek(view == 'week' ? Kronolith.conf.week_start : 1);
            end = start.clone();
            end.moveToEndOfWeek(Kronolith.conf.week_start);
            if (view == 'workweek') {
                end.add(Kronolith.conf.week_start == 0 ? -1 : -2).days();
            }
            break;
        case 'month':
            start.setDate(1);
            start.moveToBeginOfWeek(Kronolith.conf.week_start);
            end.moveToLastDayOfMonth();
            end.moveToEndOfWeek(Kronolith.conf.week_start);
            break;
        case 'year':
            start.setDate(1);
            start.setMonth(0);
            end.setMonth(11);
            end.moveToLastDayOfMonth();
            break;
        case 'agenda':
            end.add(6).days();
            break;
        }

        return [start, end];
    },

    /**
     * Stores a set of events in the cache.
     *
     * For dates in the specified date ranges that don't contain any events,
     * empty cache entries are created so that those dates aren't re-fetched
     * each time.
     *
     * @param object events        A list of calendars and events as returned
     *                             from an ajax request.
     * @param string calendar      A calendar string or array.
     * @param string dates         A date range in the format yyyymmddyyyymmdd
     *                             as used in the ajax response signature.
     * @param boolean createCache  Whether to create a cache list entry for the
     *                             response, if none exists yet.
     */
    storeCache: function(events, calendar, dates, createCache)
    {
        if (Object.isString(calendar)) {
            calendar = calendar.split('|');
        }

        // Create cache entry for the calendar.
        if (!this.ecache.get(calendar[0])) {
            if (!createCache) {
                return;
            }
            this.ecache.set(calendar[0], $H());
        }
        if (!this.ecache.get(calendar[0]).get(calendar[1])) {
            if (!createCache) {
                return;
            }
            this.ecache.get(calendar[0]).set(calendar[1], $H());
        }
        var calHash = this.ecache.get(calendar[0]).get(calendar[1]);

        // Create empty cache entries for all dates.
        if (!!dates) {
            var day = dates[0].clone(), date;
            while (!day.isAfter(dates[1])) {
                date = day.dateString();
                if (!calHash.get(date)) {
                    if (!createCache) {
                        return;
                    }
                    if (!this.cacheStart || this.cacheStart.isAfter(day)) {
                        this.cacheStart = day.clone();
                    }
                    if (!this.cacheEnd || this.cacheEnd.isBefore(day)) {
                        this.cacheEnd = day.clone();
                    }
                    calHash.set(date, $H());
                }
                day.add(1).day();
            }
        }

        var cal = calendar.join('|');
        $H(events).each(function(date) {
            // We might not have a cache for this date if the event lasts
            // longer than the current view
            if (!calHash.get(date.key)) {
                return;
            }

            // Store calendar string and other useful information in event
            // objects.
            $H(date.value).each(function(event) {
                event.value.calendar = cal;
                event.value.start = Date.parse(event.value.s);
                event.value.end = Date.parse(event.value.e);
            });

            // Store events in cache.
            calHash.set(date.key, calHash.get(date.key).merge(date.value));
        });
    },

    /**
     * Stores a set of tasks in the cache.
     *
     * @param Hash tasks           The tasks to be stored.
     * @param string tasktypes     The task type that's being stored.
     * @param string tasklist      The task list to which the tasks belong.
     * @param boolean createCache  Whether to create a cache list entry for the
     *                             response, if none exists yet.
     */
    storeTasksCache: function(tasks, tasktypes, tasklist, createCache)
    {
        var taskHashes = {}, cacheExists = {};

        if (tasktypes == 'all' || tasktypes == 'future') {
            tasktypes = [ 'complete', 'incomplete' ];
        } else {
            tasktypes = [ tasktypes ];
        }

        tasktypes.each(function(tasktype) {
            cacheExists[tasktype] = false;
            if (!this.tcache.get(tasktype)) {
                if (!createCache) {
                    return;
                }
                this.tcache.set(tasktype, $H());
            }
            if (!tasklist) {
                return;
            }
            if (!this.tcache.get(tasktype).get(tasklist)) {
                if (!createCache) {
                    return;
                }
                this.tcache.get(tasktype).set(tasklist, $H());
                cacheExists[tasktype] = true;
            } else {
                cacheExists[tasktype] = true;
            }
            taskHashes[tasktype] = this.tcache.get(tasktype).get(tasklist);
        }, this);

        $H(tasks).each(function(task) {
            var tasktype = task.value.cp ? 'complete' : 'incomplete';
            if (!cacheExists[tasktype]) {
                return;
            }
            if (!Object.isUndefined(task.value.s)) {
                task.value.start = Date.parse(task.value.s);
            }
            if (!Object.isUndefined(task.value.du)) {
                task.value.due = Date.parse(task.value.du);
            }
            taskHashes[tasktype].set(task.key, task.value);
        });
    },

    /**
     * Deletes an event or a complete calendar from the cache.
     *
     * @param string calendar  A calendar string or array.
     * @param string event     An event ID or empty if deleting the calendar.
     * @param string day       A specific day to delete in yyyyMMdd form.
     */
    deleteCache: function(calendar, event, day)
    {
        if (Object.isString(calendar)) {
            calendar = calendar.split('|');
        }
        if (!this.ecache.get(calendar[0]) ||
            !this.ecache.get(calendar[0]).get(calendar[1])) {
            return;
        }
        if (event) {
            this.ecache.get(calendar[0]).get(calendar[1]).each(function(day) {
                day.value.unset(event);
            });
        } else if (day) {
            this.ecache.get(calendar[0]).get(calendar[1]).unset(day);
        } else {
            this.ecache.get(calendar[0]).unset(calendar[1]);
        }
    },

    /**
     * Deletes tasks from the cache.
     *
     * @param string list  A task list string.
     * @param string task  A task ID. If empty, all tasks from the list are
     *                     deleted.
     */
    deleteTasksCache: function(list, task)
    {
        this.deleteCache([ 'external', 'tasks/' + list ], task);
        $w('complete incomplete').each(function(type) {
            if (!Object.isUndefined(this.tcache.get(type)) &&
                !Object.isUndefined(this.tcache.get(type).get(list))) {
                if (task) {
                    this.tcache.get(type).get(list).unset(task);
                } else {
                    this.tcache.get(type).unset(list);
                }
            }
        }, this);
    },

    /**
     * Return all events for a single day from all displayed calendars merged
     * into a single hash.
     *
     * @param string date  A yyyymmdd date string.
     *
     * @return Hash  An event hash which event ids as keys and event objects as
     *               values.
     */
    getCacheForDate: function(date, calendar)
    {
        if (calendar) {
            var cals = calendar.split('|');
            if (!this.ecache.get(cals[0]) ||
                !this.ecache.get(cals[0]).get(cals[1])) {
                return $H();
            }
            var x = this.ecache.get(cals[0]).get(cals[1]).get(date);
            return this.ecache.get(cals[0]).get(cals[1]).get(date);
        }

        var events = $H();
        this.ecache.each(function(type) {
            type.value.each(function(cal) {
                if (!Kronolith.conf.calendars[type.key][cal.key].show) {
                    return;
                }
                events = events.merge(cal.value.get(date));
            });
        });
        return events;
    },

    /**
     * Helper method for Enumerable.sortBy to sort events first by start time,
     * second by end time reversed.
     *
     * @param Hash event  A hash entry with the event object as the value.
     *
     * @return string  A comparable string.
     */
    sortEvents: function(event)
    {
        return event.value.sort;
    },

    /**
     * Adds a new location to the history and displays it in the URL hash.
     *
     * This is not really a history, because only the current and the last
     * location are stored.
     *
     * @param string loc    The location to save.
     * @param boolean save  Whether to actually save the location. This should
     *                      be false for any location that are displayed on top
     *                      of another location, i.e. in a popup view.
     */
    addHistory: function(loc, save)
    {
        location.hash = encodeURIComponent(loc);
        this.lastLocation = this.currentLocation;
        if (Object.isUndefined(save) || save) {
            this.currentLocation = loc;
        }
        this.openLocation = loc;
    },

    /**
     * Loads an external page.
     *
     * @param string loc  The URL of the page to load.
     */
    loadPage: function(loc)
    {
        window.location.assign(loc);
    },

    searchSubmit: function(e)
    {
        this.go('search:' + this.search + ':' + $F('horde-search-input'));
    },

    searchReset: function(e)
    {
        HordeTopbar.searchGhost.reset();
    },

    /**
     * Event handler for HordeCore:showNotifications events.
     */
    showNotification: function(e)
    {
        if (!e.memo.flags ||
            !e.memo.flags.alarm ||
            !e.memo.flags.growl ||
            !e.memo.flags.alarm.params.notify.ajax) {
            return;
        }

        var growl = e.memo.flags.growl, link = growl.down('A');

        if (link) {
            link.observe('click', function(ee) {
                ee.stop();
                HordeCore.Growler.ungrowl(growl);
                this.go(e.memo.flags.alarm.params.notify.ajax);
            }.bind(this));
        }
    },

    /* Keydown event handler */
    keydownHandler: function(e)
    {
        if (e.stopped) {
            return;
        }

        var kc = e.keyCode || e.charCode,
            form = e.findElement('FORM'), trigger = e.findElement();

        switch (trigger.id) {
        case 'kronolithEventLocation':
            if (kc == Event.KEY_RETURN && $F('kronolithEventLocation')) {
                this.initializeMap(true);
                this.geocode($F('kronolithEventLocation'));
                e.stop();
                return;
            }
            break;

        case 'kronolithCalendarinternalUrlCaldav':
        case 'kronolithCalendarinternalUrlWebdav':
        case 'kronolithCalendarinternalUrlAccount':
        case 'kronolithCalendarinternalUrlFeed':
        case 'kronolithCalendartasklistsUrlCaldav':
        case 'kronolithCalendartasklistsUrlWebdav':
        case 'kronolithCalendartasklistsUrlAccount':
            if (String.fromCharCode(kc) != 'C' ||
                (this.macos && !e.metaKey) ||
                (!this.macos && !e.ctrlKey)) {
                e.stop();
                return;
            }
            break;
        }

        if (form) {
            switch (kc) {
            case Event.KEY_RETURN:
                switch (form.identify()) {
                case 'kronolithEventForm':
                    if (e.element().tagName != 'TEXTAREA') {
                        this.saveEvent();
                        e.stop();
                    }
                    break;

                case 'kronolithTaskForm':
                    if (e.element().tagName != 'TEXTAREA') {
                        this.saveTask();
                        e.stop();
                    }
                    break;

                case 'kronolithQuickinsertForm':
                    this.quickSaveEvent();
                    e.stop();
                    break;

                case 'kronolithCalendarForminternal':
                case 'kronolithCalendarFormtasklists':
                case 'kronolithCalendarFormremote':
                    // Disabled for now, we have to also catch Continue buttons.
                    //var saveButton = form.down('.kronolithCalendarSave');
                    //saveButton.disable();
                    //if (!this.saveCalendar(form)) {
                    //    saveButton.enable();
                    //}
                    //e.stop();
                    break;
                }
                break;

            case Event.KEY_ESC:
                switch (form.identify()) {
                case 'kronolithQuickinsertForm':
                case 'kronolithQuicktaskForm':
                    this.quickClose();
                    break;
                case 'kronolithEventForm':
                case 'kronolithTaskForm':
                    Horde_Calendar.hideCal();
                    this.closeRedBox();
                    this.go(this.lastLocation);
                    break;
                }
                break;
            }

            return;
        }

        switch (kc) {
        case Event.KEY_ESC:
            Horde_Calendar.hideCal();
            this.closeRedBox();
            break;
        }
    },

    keyupHandler: function(e)
    {
        switch (e.element().readAttribute('id')) {
        case 'kronolithEventLocation':
            if ($F('kronolithEventLocation') && Kronolith.conf.maps.driver) {
                $('kronolithEventMapLink').show();
            } else if (Kronolith.conf.maps.driver) {
                $('kronolithEventMapLink').hide();
                this.removeMapMarker();
            }
            return;

        case 'kronolithEventStartTime':
        case 'kronolithEventEndTime':
            var field = $(e.element().readAttribute('id')), kc = e.keyCode;

            switch(e.keyCode) {
            case Event.KEY_UP:
            case Event.KEY_DOWN:
            case Event.KEY_RIGHT:
            case Event.KEY_LEFT:
                return;
            default:
                if ($F(field) !== this.knl[field.identify()].getCurrentEntry()) {
                    this.knl[field.identify()].markSelected(null);
                }
                return;
            }
        }

    },

    clickHandler: function(e, dblclick)
    {
        if (e.isRightClick() || typeof e.element != 'function') {
            return;
        }

        var elt = e.element(),
            orig = e.element(),
            id, tmp, calendar;

        while (Object.isElement(elt)) {
            id = elt.readAttribute('id');

            switch (id) {
            case 'kronolithNewEvent':
                this.go('event');
                e.stop();
                return;

            case 'kronolithNewTask':
                this.go('task');
                e.stop();
                return;

            case 'kronolithQuickEvent':
                if (this.view == 'tasks') {
                    RedBox.showHtml($('kronolithQuicktask').show());
                } else {
                    this.updateCalendarDropDown('kronolithQuickinsertCalendars');
                    $('kronolithQuickinsertCalendars').setValue(Kronolith.conf.default_calendar);
                    RedBox.showHtml($('kronolithQuickinsert').show());
                }
                e.stop();
                return;

            case 'kronolithQuickinsertSave':
                this.quickSaveEvent();
                e.stop();
                return;

            case 'kronolithQuicktaskSave':
                this.quickSaveTask();
                e.stop();
                return;

            case 'kronolithQuickinsertCancel':
            case 'kronolithQuicktaskCancel':
                this.quickClose();
                e.stop();
                return;

            case 'kronolithGotoToday':
                var view = this.view;
                if (!$w('day workweek week month year agenda').include(view)) {
                    view = Kronolith.conf.login_view;
                }
                this.go(view + ':' + new Date().dateString());
                e.stop();
                return;

            case 'kronolithEventAllday':
                this.toggleAllDay();
                break;

            case 'kronolithEventAlarmDefaultOn':
                this.disableAlarmMethods('Event');
                break;

            case 'kronolithTaskAlarmDefaultOn':
                this.disableAlarmMethods('Task');
                break;

            case 'kronolithEventAlarmPrefs':
                HordeCore.redirect(HordeCore.addURLParam(
                    Kronolith.conf.prefs_url,
                    {
                        group: 'notification'
                    }
                ));
                e.stop();
                break;

            case 'kronolithTaskAlarmPrefs':
                if (Kronolith.conf.tasks.prefs_url) {
                    HordeCore.redirect(HordeCore.addURLParam(
                        Kronolith.conf.tasks.prefs_url,
                        {
                            group: 'notification'
                        }
                    ));
                }
                e.stop();
                break;

            case 'kronolithEventLinkNone':
            case 'kronolithEventLinkDaily':
            case 'kronolithEventLinkWeekly':
            case 'kronolithEventLinkMonthly':
            case 'kronolithEventLinkYearly':
            case 'kronolithEventLinkLength':
            case 'kronolithTaskLinkNone':
            case 'kronolithTaskLinkDaily':
            case 'kronolithTaskLinkWeekly':
            case 'kronolithTaskLinkMonthly':
            case 'kronolithTaskLinkYearly':
            case 'kronolithTaskLinkLength':
                this.toggleRecurrence(
                    id.startsWith('kronolithEvent'),
                    id.substring(id.startsWith('kronolithEvent') ? 18 : 17));
                break;

            case 'kronolithEventRepeatDaily':
            case 'kronolithEventRepeatWeekly':
            case 'kronolithEventRepeatMonthly':
            case 'kronolithEventRepeatYearly':
            case 'kronolithEventRepeatLength':
            case 'kronolithTaskRepeatDaily':
            case 'kronolithTaskRepeatWeekly':
            case 'kronolithTaskRepeatMonthly':
            case 'kronolithTaskRepeatYearly':
            case 'kronolithTaskRepeatLength':
                this.toggleRecurrence(
                    id.startsWith('kronolithEvent'),
                    id.substring(id.startsWith('kronolithEvent') ? 20 : 19));
                break;

            case 'kronolithEventSave':
                if (!elt.disabled) {
                    this._checkDate($('kronolithEventStartDate'));
                    this._checkDate($('kronolithEventEndDate'));
                    if ($F('kronolithEventAttendees') && $F('kronolithEventId')) {
                        $('kronolithEventSendUpdates').setValue(0);
                        $('kronolithEventDiv').hide();
                        $('kronolithUpdateDiv').show();
                        e.stop();
                        break;
                    }
                }
            case 'kronolithEventSendUpdateYes':
                if (this.uatts) {
                    this.uatts.u = true;
                } else {
                    $('kronolithEventSendUpdates').setValue(1);
                }
            case 'kronolithEventSendUpdateNo':
                if (this.uatts) {
                    this.doDragDropUpdate(this.uatts, this.ucb);
                    this.uatts = null;
                    this.ucb = null;
                    this.closeRedBox();
                    $('kronolithUpdateDiv').hide();
                    $('kronolithEventDiv').show();
                } else if (!elt.disabled) {
                    this.saveEvent();
                }
                e.stop();
                break;
            case 'kronolithEventConflictYes':
                this.doSaveEvent();
                e.stop();
                break;
            case 'kronolithEventConflictNo':
                $('kronolithConflictDiv').hide();
                $('kronolithEventDiv').show();
                e.stop();
                break;
            case 'kronolithEventSaveAsNew':
                if (!elt.disabled) {
                    $('kronolithEventSendUpdates').setValue(1);
                    this.saveEvent(true);
                }
                e.stop();
                break;

            case 'kronolithTaskSave':
                if (!elt.disabled) {
                    this.saveTask();
                }
                e.stop();
                break;

            case 'kronolithEventDeleteCancel':
                $('kronolithDeleteDiv').hide();
                $('kronolithEventDiv').show();
                e.stop();
                return;

            case 'kronolithEventSendCancellationYes':
                $('kronolithRecurDeleteAll').enable();
                $('kronolithRecurDeleteCurrent').enable();
                $('kronolithRecurDeleteFuture').enable();
                this.paramsCache.sendupdates = 1;
            case 'kronolithEventSendCancellationNo':
                $('kronolithRecurDeleteAll').enable();
                $('kronolithRecurDeleteCurrent').enable();
                $('kronolithRecurDeleteFuture').enable();
                $('kronolithCancellationDiv').hide();
                this.delete_verified = true;
            case 'kronolithEventDelete':
                if ((Kronolith.conf.confirm_delete || this.recurs) && !this.delete_verified) {
                    $('kronolithEventDiv').hide();
                    $('kronolithDeleteDiv').show();
                    e.stop();
                    break;
                } else {
                    $('kronolithEventDiv').hide();
                    this.delete_verified = false;
                }
                // Fallthrough
            case 'kronolithRecurDeleteAll':
            case 'kronolithRecurDeleteCurrent':
            case 'kronolithRecurDeleteFuture':
            case 'kronolithEventDeleteConfirm':
                if (elt.disabled) {
                    e.stop();
                    break;
                }
                elt.disable();
                var cal = $F('kronolithEventCalendar'),
                    eventid = $F('kronolithEventId');
                if (id != 'kronolithEventSendCancellationNo' &&
                    id != 'kronolithEventSendCancellationYes') {
                    this.paramsCache = {
                        cal: cal,
                        id: eventid,
                        rstart: $F('kronolithEventRecurOStart'),
                        cstart: this.cacheStart.toISOString(),
                        cend: this.cacheEnd.toISOString()
                    };
                    switch (id) {
                    case 'kronolithRecurDeleteAll':
                        this.paramsCache.r = 'all';
                        break;
                    case 'kronolithRecurDeleteCurrent':
                        this.paramsCache.r = 'current';
                        break;
                    case 'kronolithRecurDeleteFuture':
                        this.paramsCache.r = 'future';
                        break;
                    }
                }

                if (id != 'kronolithEventSendCancellationNo'
                    && id != 'kronolithEventSendCancellationYes'
                    && $F('kronolithEventAttendees')) {

                    $('kronolithDeleteDiv').hide();
                    $('kronolithCancellationDiv').show();
                    e.stop();
                    break;
                }

                this.kronolithBody.select('div').findAll(function(el) {
                    return el.retrieve('calendar') == cal &&
                        el.retrieve('eventid') == eventid;
                }).invoke('hide');
                var viewDates = this.viewDates(this.date, this.view),
                start = viewDates[0].toString('yyyyMMdd'),
                end = viewDates[1].toString('yyyyMMdd');
                this.paramsCache.sig = start + end + (Math.random() + '').slice(2);
                this.paramsCache.view_start = start;
                this.paramsCache.view_end = end;

                HordeCore.doAction('deleteEvent', this.paramsCache, {
                    callback: function(elt,r) {
                        if (r.deleted) {
                            var days;
                            if (this.view == 'month' ||
                                this.view == 'week' ||
                                this.view == 'workweek' ||
                                this.view == 'day') {
                                days = this.findEventDays(cal, eventid);
                                days.each(function(day) {
                                    this.refreshResources(day, cal, eventid);
                                }.bind(this));
                            }
                            this.removeEvent(cal, eventid);
                            if (r.uid) {
                                this.removeException(cal, r.uid);
                            }
                            this.loadEventsCallback(r, false);
                            if (days && days.length) {
                                this.reRender(days);
                            }
                        } else {
                            this.kronolithBody.select('div').findAll(function(el) {
                                return el.retrieve('calendar') == cal &&
                                       el.retrieve('eventid') == eventid;
                            }).invoke('show');
                        }
                        elt.enable();
                    }.curry(elt).bind(this)
                });

                $('kronolithDeleteDiv').hide();
                $('kronolithEventDiv').show();
                this.closeRedBox();
                this.go(this.lastLocation);
                e.stop();
                break;

            case 'kronolithTaskDelete':
                if (elt.disabled) {
                    e.stop();
                    break;
                }

                elt.disable();
                var tasklist = $F('kronolithTaskOldList'),
                    taskid = $F('kronolithTaskId');

                HordeCore.doAction('deleteTask', {
                    list: tasklist,
                    id: taskid
                }, {
                    callback: function(r) {
                        if (r.deleted) {
                            this.removeTask(tasklist, taskid);
                        } else {
                            elt.enable();
                            $('kronolithViewTasksBody').select('tr').find(function(el) {
                                return el.retrieve('tasklist') == tasklist &&
                                       el.retrieve('taskid') == taskid;
                            }).toggle();
                        }
                    }.bind(this)
                });

                var taskrow = $('kronolithViewTasksBody').select('tr').find(function(el) {
                    return el.retrieve('tasklist') == tasklist &&
                        el.retrieve('taskid') == taskid;
                });
                if (taskrow) {
                    taskrow.hide();
                }
                this.closeRedBox();
                this.go(this.lastLocation);
                e.stop();
                break;

            case 'kronolithCinternalPMore':
            case 'kronolithCinternalPLess':
            case 'kronolithCtasklistsPMore':
            case 'kronolithCtasklistsPLess':
                var type = id.match(/kronolithC(.*)P/)[1];
                $('kronolithC' + type + 'PBasic').toggle();
                $('kronolithC' + type + 'PAdvanced').toggle();
                e.stop();
                break;

            case 'kronolithCinternalPNone':
            case 'kronolithCinternalPAll':
            case 'kronolithCinternalPG':
            case 'kronolithCinternalPU':
            case 'kronolithCtasklistsPNone':
            case 'kronolithCtasklistsPAll':
            case 'kronolithCtasklistsPG':
            case 'kronolithCtasklistsPU':
                var info = id.match(/kronolithC(.*)P(.*)/);
                this.permsClickHandler(info[1], info[2]);
                break;

            case 'kronolithCinternalPAllShow':
            case 'kronolithCtasklistsPAllShow':
                var type = id.match(/kronolithC(.*)P/)[1];
                this.permsClickHandler(type, 'All');
                break;

            case 'kronolithCinternalPAdvanced':
            case 'kronolithCtasklistsPAdvanced':
                var type = id.match(/kronolithC(.*)P/)[1];
                if (orig.tagName != 'INPUT') {
                    break;
                }
                this.activateAdvancedPerms(type);
                if (orig.name.match(/u_.*||new/)) {
                    this.insertGroupOrUser(type, 'user');
                }
                break;

            case 'kronolithCinternalPUAdd':
            case 'kronolithCinternalPGAdd':
            case 'kronolithCtasklistsPUAdd':
            case 'kronolithCtasklistsPGAdd':
                var info = id.match(/kronolithC(.*)P(.)/);
                this.insertGroupOrUser(info[1], info[2] == 'U' ? 'user' : 'group');
                break;

            case 'kronolithNavDay':
            case 'kronolithNavWeek':
            case 'kronolithNavWorkweek':
            case 'kronolithNavMonth':
            case 'kronolithNavYear':
            case 'kronolithNavAgenda':
                this.go(id.substring(12).toLowerCase() + ':' + this.date.dateString());
                e.stop();
                return;

            case 'kronolithNavTasks':
                this.go('tasks');
                e.stop();
                return;

            case 'kronolithTasksAll':
            case 'kronolithTasksComplete':
            case 'kronolithTasksIncomplete':
            case 'kronolithTasksFuture':
                this.go('tasks:' + id.substring(14).toLowerCase());
                e.stop();
                return;

            case 'kronolithMinicalDate':
                this.go('month:' + orig.retrieve('date'));
                e.stop();
                return;

            case 'kronolith-minical':
                if (orig.id == 'kronolith-minical-prev') {
                    var date = this.parseDate($('kronolithMinicalDate').retrieve('date'));
                    date.previous().month();
                    this.updateMinical(date, date.getMonth() == this.date.getMonth() ? this.view : undefined);
                    e.stop();
                    return;
                }
                if (orig.id == 'kronolith-minical-next') {
                    var date = this.parseDate($('kronolithMinicalDate').retrieve('date'));
                    date.next().month();
                    this.updateMinical(date, date.getMonth() == this.date.getMonth() ? this.view : null);
                    e.stop();
                    return;
                }

                var tmp = orig;
                if (tmp.tagName.toLowerCase() != 'td') {
                    tmp = tmp.up('td');
                }
                if (tmp) {
                    if (tmp.retrieve('weekdate') &&
                        tmp.hasClassName('kronolith-minical-week')) {
                        this.go('week:' + tmp.retrieve('weekdate'));
                    } else if (tmp.retrieve('date') &&
                               !tmp.hasClassName('empty')) {
                        this.go('day:' + tmp.retrieve('date'));
                    }
                }
                e.stop();
                return;

            case 'kronolithEventsDay':
                var date = this.date.clone();
                date.add(Math.round((e.pointerY() - elt.cumulativeOffset().top + elt.up('.kronolithViewBody').scrollTop) / this.daySizes.height * 2) * 30).minutes();
                this.go('event:' + date.toString('yyyyMMddHHmm'));
                e.stop();
                return;

            case 'kronolithViewMonth':
                if (orig.hasClassName('kronolith-first-col')) {
                    var date = orig.retrieve('date');
                    if (date) {
                        this.go('week:' + date);
                        e.stop();
                        return;
                    }
                }
                e.stop();
                return;

            case 'kronolithViewYear':
                var tmp = orig;
                if (tmp.tagName.toLowerCase() != 'td' && tmp.tagName.toLowerCase() != 'th') {
                    tmp = tmp.up('td');
                }
                if (tmp) {
                    if (tmp.retrieve('weekdate') &&
                        tmp.hasClassName('kronolith-minical-week')) {
                        this.go('week:' + tmp.retrieve('weekdate'));
                    } else if (tmp.hasClassName('kronolithMinicalDate')) {
                        this.go('month:' + tmp.retrieve('date'));
                    } else if (tmp.retrieve('date') &&
                               !tmp.hasClassName('empty')) {
                        this.go('day:' + tmp.retrieve('date'));
                    }
                }
                e.stop();
                return;

            case 'kronolithViewAgendaBody':
                var tmp = orig;
                if (tmp.tagName != 'TR') {
                    tmp = tmp.up('tr');
                }
                if (tmp && tmp.retrieve('date')) {
                    this.go('day:' + tmp.retrieve('date'));
                }
                e.stop();
                return;

            case 'kronolithSearchButton':
                this.go('search:' + this.search + ':' + $F('horde-search-input'));
                e.stop();
                break;

            case 'kronolithSearchFuture':
                if (this.search != 'future') {
                    this.go('search:future:' + $F('horde-search-input'));
                }
                e.stop();
                break;

            case 'kronolithSearchPast':
                if (this.search != 'past') {
                    this.go('search:past:' + $F('horde-search-input'));
                }
                e.stop();
                break;

            case 'kronolithSearchAll':
                if (this.search != 'all') {
                    this.go('search:all:' + $F('horde-search-input'));
                }
                e.stop();
                break;
            case 'kronolithEventToTimeslice':
                var params = $H();
                params.set('e', $('kronolithEventId').value);
                params.set('cal', $('kronolithEventCalendar').value);
                params.set('t', $('kronolithEventTimesliceType').value);
                params.set('c', $('kronolithEventTimesliceClient').value);
                HordeCore.doAction('toTimeslice', params);
                break;
            case 'kronolithEventDialog':
            case 'kronolithTaskDialog':
                Horde_Calendar.hideCal();
                return;

            case 'kronolithCalendarDialog':
                if (this.colorPicker) {
                    this.colorPicker.hide();
                }
                return;

            case 'kronolithEditRecurCurrent':
            case 'kronolithEditRecurFuture':
                $('kronolithEventStartDate').setValue(this.orstart);
                $('kronolithEventEndDate').setValue(this.orend);
                if (id == 'kronolithEditRecurCurrent') {
                    this.toggleRecurrence('Exception');
                } else {
                    this.toggleRecurrence(this.lastRecurType);
                }
                return;
            case 'kronolithEditRecurAll':
                this.toggleRecurrence(this.lastRecurType);
                break;
            case 'kronolithEventUrlToggle':
                $('kronolithEventUrlDisplay').hide();
                $('kronolithEventUrl').show();
                e.stop();
                return;
            case 'kronolithCalendarinternalImportButton':
                // Used when user has edit perms to a shared calendar.
                this.calendarImport(elt.up('form'), true);
                break;
            }

            // Caution, this only works if the element has definitely only a
            // single CSS class.
            switch (elt.className) {
            case 'kronolithPrev':
            case 'kronolithNext':
                var newDate = this.date.clone(),
                    offset = elt.className == 'kronolithPrev' ? -1 : 1;
                switch (this.view) {
                case 'day':
                case 'agenda':
                    newDate.add(offset).day();
                    break;
                case 'week':
                case 'workweek':
                    newDate.add(offset).week();
                    break;
                case 'month':
                    newDate.add(offset).month();
                    break;
                case 'year':
                    newDate.add(offset).year();
                    break;
                }
                this.go(this.view + ':' + newDate.dateString());
                e.stop();
                return;

            case 'horde-add':
                this.go('calendar:' + id.replace(/kronolithAdd/, ''));
                e.stop();
                return;

            case 'kronolithTabLink':
                this.openTab(elt);
                e.stop();
                break;

            case 'horde-cancel':
                this.closeRedBox();
                this.resetMap();
                this.go(this.lastLocation);
                e.stop();
                break;

            case 'kronolithEventTag':
                HordeImple.AutoCompleter.kronolithEventTags.addNewItemNode(elt.getText());
                e.stop();
                break;

            case 'kronolithCalendarTag':
                HordeImple.AutoCompleter.kronolithCalendarinternalTags.addNewItemNode(elt.getText());
                e.stop();
                break;

            case 'kronolithTaskTag':
                HordeImple.AutoCompleter.kronolithTaskTags.addNewItemNode(elt.getText());
                e.stop();
                break;

            case 'kronolithEventGeo':
                this.initializeMap(true);
                this.geocode($F('kronolithEventLocation'));
                e.stop();
                break;

            case 'kronolithTaskRow':
                if (elt.retrieve('taskid')) {
                    this.go('task:' + elt.retrieve('tasklist') + ':' + elt.retrieve('taskid'));
                }
                e.stop();
                return;

            case 'horde-resource-edit-000':
            case 'horde-resource-edit-fff':
                this.go('calendar:' + elt.up().retrieve('calendarclass') + '|' + elt.up().retrieve('calendar'));
                e.stop();
                return;

            case 'kronolithMore':
                this.go('day:' + elt.retrieve('date'));
                e.stop();
                return;

            case 'kronolithDatePicker':
                id = elt.readAttribute('id');
                Horde_Calendar.open(id, Date.parseExact($F(id.replace(/Picker$/, 'Date')), Kronolith.conf.date_format));
                e.stop();
                return;

            case 'kronolithColorPicker':
                var input = elt.previous();
                this.colorPicker = new ColorPicker({
                    color: $F(input),
                    offsetParent: elt,
                    update: [[input, 'value'],
                             [input, 'background']]
                });
                e.stop();
                return;
            }

            if (elt.hasClassName('kronolith-event')) {
                if (!Object.isUndefined(elt.retrieve('ajax'))) {
                    this.go(elt.retrieve('ajax'));
                } else {
                    this.go('event:' + elt.retrieve('calendar') + ':' + elt.retrieve('eventid') + ':' + elt.up().retrieve('date'));
                }
                e.stop();
                return;
            } else if (elt.hasClassName('kronolithMonthDay')) {
                if (orig.hasClassName('kronolith-day')) {
                    var date = orig.retrieve('date');
                    if (date) {
                        this.go('day:' + date);
                        e.stop();
                        return;
                    }
                }
                this.go('event:' + elt.retrieve('date'));
                e.stop();
                return;
            } else if (elt.hasClassName('kronolithWeekDay')) {
                this.go('day:' + elt.retrieve('date'));
                e.stop();
                return;
            } else if (elt.hasClassName('kronolithEventsWeek') ||
                       elt.hasClassName('kronolithEventsWorkweek') ||
                       elt.hasClassName('kronolithAllDayContainer')) {
                var date = elt.retrieve('date');
                if (elt.hasClassName('kronolithAllDayContainer')) {
                    date += 'all';
                } else {
                    date = this.parseDate(date);
                    date.add(Math.round((e.pointerY() - elt.cumulativeOffset().top + elt.up('.kronolithViewBody').scrollTop) / (elt.hasClassName('kronolithEventsWeek') ? this.weekSizes.height : this.workweekSizes.height) * 2) * 30).minutes();
                    date = date.toString('yyyyMMddHHmm');
                }
                this.go('event:' + date);
                e.stop();
                return;
            } else if (elt.hasClassName('kronolithTaskCheckbox')) {
                var taskid = elt.up('tr.kronolithTaskRow', 0).retrieve('taskid'),
                    tasklist = elt.up('tr.kronolithTaskRow', 0).retrieve('tasklist');
                this.toggleCompletionClass(taskid);

                HordeCore.doAction('toggleCompletion', {
                    list: tasklist,
                    id: taskid
                }, {
                    callback: function(r) {
                        if (r.toggled) {
                            this.toggleCompletion(tasklist, taskid, r.toggled);
                            if (r.toggled !== true) {
                                this.toggleCompletionClass(taskid);
                            }
                        } else {
                            this.toggleCompletionClass(taskid);
                        }
                    }.bind(this)
                });

                e.stop();
                return;
            } else if (elt.hasClassName('kronolithCalendarSave')) {
                if (!elt.disabled) {
                    elt.disable();
                    if (!this.saveCalendar(elt.up('form'))) {
                        elt.enable();
                    }
                }
                e.stop();
                break;
            } else if (elt.hasClassName('kronolithCalendarContinue')) {
                if (elt.disabled) {
                    e.stop();
                    break;
                }

                elt.disable();
                var form = elt.up('form'),
                    type = form.id.replace(/kronolithCalendarForm/, ''),
                    i = 1;
                while (!$('kronolithCalendar' + type + i).visible()) {
                    i++;
                }
                if (type == 'remote') {
                    var params = { url: $F('kronolithCalendarremoteUrl') };
                    if (i == 1) {
                        if (!$F('kronolithCalendarremoteUrl')) {
                            HordeCore.notify(Kronolith.text.no_url, 'horde.warning');
                            e.stop();
                            break;
                        }

                        HordeCore.doAction('getRemoteInfo', params, {
                            asynchronous: false,
                            callback: function(r) {
                                if (r.success) {
                                    if (r.name) {
                                        $('kronolithCalendarremoteName').setValue(r.name);
                                    }
                                    if (r.desc) {
                                        $('kronolithCalendarremoteDescription').setValue(r.desc);
                                    }
                                    this.calendarNext(type);
                                    this.calendarNext(type);
                                } else if (r.auth) {
                                    this.calendarNext(type);
                                } else {
                                    elt.enable();
                                }
                            }.bind(this)
                        });

                    }
                    if (i == 2) {
                        if ($F('kronolithCalendarremoteUsername')) {
                            params.user = $F('kronolithCalendarremoteUsername');
                            params.password =  $F('kronolithCalendarremotePassword');
                        }

                        HordeCore.doAction('getRemoteInfo', params, {
                            callback: function(r) {
                                if (r.success) {
                                    if (r.name &&
                                        !$F('kronolithCalendarremoteName')) {
                                        $('kronolithCalendarremoteName').setValue(r.name);
                                    }
                                    if (r.desc &&
                                        !$F('kronolithCalendarremoteDescription')) {
                                        $('kronolithCalendarremoteDescription').setValue(r.desc);
                                    }
                                    this.calendarNext(type);
                                } else {
                                    if (r.auth) {
                                        HordeCore.notify(Kronolith.text.wrong_auth, 'horde.warning');
                                    }
                                    elt.enable();
                                }
                            }.bind(this)
                        });
                    }
                    e.stop();
                    break;
                }
                this.calendarNext(type);
                e.stop();
                break;
            } else if (elt.hasClassName('kronolithCalendarDelete')) {
                var form = elt.up('form'),
                    type = form.id.replace(/kronolithCalendarForm/, ''),
                    calendar = $F('kronolithCalendar' + type + 'Id');

                if ((type == 'tasklists' &&
                     !window.confirm(Kronolith.text.delete_tasklist)) ||
                    (type != 'tasklists' &&
                     !window.confirm(Kronolith.text.delete_calendar))) {
                    e.stop();
                    break;
                }

                if (!elt.disabled) {
                    elt.disable();

                    HordeCore.doAction('deleteCalendar', {
                        type: type,
                        calendar: calendar
                    }, {
                        callback: function(r) {
                            if (r.deleted) {
                                this.deleteCalendar(type, calendar);
                            }
                            this.closeRedBox();
                            this.go(this.lastLocation);
                        }.bind(this)
                    });
                }
                e.stop();
                break;
            } else if (elt.hasClassName('kronolithCalendarSubscribe') ||
                       elt.hasClassName('kronolithCalendarUnsubscribe')) {
                var form = elt.up('form');
                this.toggleCalendar($F(form.down('input[name=type]')),
                                    $F(form.down('input[name=calendar]')));
                this.closeRedBox();
                this.go(this.lastLocation);
                e.stop();
                break;
            } else if (elt.tagName == 'INPUT' &&
                       (elt.name == 'event_alarms[]' ||
                        elt.name == 'task[alarm_methods][]')) {
                if (elt.name == 'event_alarms[]') {
                    $('kronolithEventAlarmOn').setValue(1);
                    $('kronolithEventAlarmDefaultOff').setValue(1);
                } else {
                    $('kronolithTaskAlarmOn').setValue(1);
                    $('kronolithTaskAlarmDefaultOff').setValue(1);
                }
                if ($(elt.id + 'Params')) {
                    if (elt.getValue()) {
                        $(elt.id + 'Params').show();
                    } else {
                        $(elt.id + 'Params').hide();
                    }
                }
                break;
            }

            var calClass = elt.retrieve('calendarclass');
            if (calClass) {
                this.toggleCalendar(calClass, elt.retrieve('calendar'));
                e.stop();
                return;
            }

            elt = elt.up();
        }
        // Workaround Firebug bug.
        Prototype.emptyFunction();
    },

    /**
     * Handles date selections from a date picker.
     */
    datePickerHandler: function(e)
    {
        var field = e.element().previous();
        field.setValue(e.memo.toString(Kronolith.conf.date_format));
        this.updateTimeFields(field.identify());
    },

    /**
     * Handles moving an event to a different day in month view and all day
     * events in weekly/daily views.
     */
    onDrop: function(e)
    {
        var drop = e.element(),
            el = e.memo.element;

        if (drop == el.up()) {
            return;
        }

        var lastDate = this.parseDate(el.up().retrieve('date')),
            newDate = this.parseDate(drop.retrieve('date')),
            diff = newDate.subtract(lastDate),
            eventid = el.retrieve('eventid'),
            cal = el.retrieve('calendar'),
            viewDates = this.viewDates(this.date, this.view),
            start = viewDates[0].toString('yyyyMMdd'),
            end = viewDates[1].toString('yyyyMMdd'),
            sig = start + end + (Math.random() + '').slice(2),
            events = this.getCacheForDate(lastDate.toString('yyyyMMdd'), cal),
            attributes = $H({ offDays: diff }),
            event = events.find(function(e) { return e.key == eventid; });

        drop.insert(el);
        this.startLoading(cal, sig);
        if (event.value.r) {
            attributes.set('rday', lastDate);
            attributes.set('cstart', this.cacheStart);
            attributes.set('cend', this.cacheEnd);
        }
        var uatts = {
            cal: cal,
            id: eventid,
            view: this.view,
            sig: sig,
            view_start: start,
            view_end: end,
            att: Object.toJSON(attributes)
        },
        callback = function(r) {
          if (r.events) {
              // Check if this is the still the result of the
              // most current request.
              if (r.sig == this.eventsLoading[r.cal]) {
                  var days;
                  if ((this.view == 'month' &&
                       Kronolith.conf.max_events) ||
                      this.view == 'week' ||
                      this.view == 'workweek' ||
                      this.view == 'day') {
                      days = this.findEventDays(cal, eventid);
                  }
                  this.removeEvent(cal, eventid);
                  if (days && days.length) {
                      this.reRender(days);
                  }
              }
              $H(r.events).each(function(days) {
                  $H(days.value).each(function(event) {
                      if (event.value.c.startsWith('tasks/')) {
                          var tasklist = event.value.c.substr(6),
                              task = event.key.substr(6),
                              taskObject;
                          if (this.tcache.get('incomplete') &&
                              this.tcache.get('incomplete').get(tasklist) &&
                              this.tcache.get('incomplete').get(tasklist).get(task)) {
                              taskObject = this.tcache.get('incomplete').get(tasklist).get(task);
                              taskObject.due = Date.parse(event.value.s);
                              this.tcache.get('incomplete').get(tasklist).set(task, taskObject);
                          }
                      }
                  }, this);
              }, this);
          }
          this.loadEventsCallback(r, false);
          $H(r.events).each(function(days) {
              $H(days.value).each(function(event) {
                  if (event.key == eventid) {
                      this.refreshResources(days.key, cal, eventid, lastDate.toString('yyyyMMdd'), event);
                  }
              }.bind(this))
          }.bind(this));
      }.bind(this);

      if (event.value.mt) {
          $('kronolithEventDiv').hide();
          $('kronolithUpdateDiv').show();
          RedBox.showHtml($('kronolithEventDialog').show());
          this.uatts = uatts;
          this.ucb = callback;
      } else {
          this.doDragDropUpdate(uatts, callback);
      }
    },

    onDragStart: function(e)
    {
        if (this.view == 'month') {
            return;
        }

        var elt = e.element();

        if (elt.hasClassName('kronolithDragger')) {
            elt.up().addClassName('kronolith-selected');
            DragDrop.Drags.getDrag(elt).top = elt.cumulativeOffset().top;
        } else if (elt.hasClassName('kronolithEditable')) {
            elt.addClassName('kronolith-selected').setStyle({ left: 0, width: (this.view == 'week' || this.view == 'workweek') ? '90%' : '95%', zIndex: 1 });
        }

        this.scrollTop = $('kronolithView' + this.view.capitalize())
            .down('.kronolithViewBody')
            .scrollTop;
        this.scrollLast = this.scrollTop;
    },

    onDrag: function(e)
    {
        if (this.view == 'month') {
            return;
        }

        var elt = e.element(),
            drag = DragDrop.Drags.getDrag(elt);
            storage = this.view + 'Sizes',
            step = this[storage].height / 6;

            if (!drag.event) {
                return;
            }

        var event = drag.event.value;

        if (elt.hasClassName('kronolithDragger')) {
            // Resizing the event.
            var div = elt.up(),
                top = drag.ghost.cumulativeOffset().top,
                scrollTop = $('kronolithView' + this.view.capitalize()).down('.kronolithViewBody').scrollTop,
                offset = 0,
                height;

            // Check if view has scrolled since last call.
            if (scrollTop != this.scrollLast) {
                offset = scrollTop - this.scrollLast;
                this.scrollLast = scrollTop;
            }
            if (elt.hasClassName('kronolithDraggerTop')) {
                offset += top - drag.top;
                height = div.offsetHeight - offset;
                div.setStyle({
                    top: (div.offsetTop + offset) + 'px'
                });
                offset = drag.ghost.offsetTop;
                drag.top = top;
            } else {
                offset += top - drag.top;
                height = div.offsetHeight + offset;
                offset = div.offsetTop;
                drag.top = top;
            }
            div.setStyle({
                height: height + 'px'
            });

            this.calculateEventDates(event, storage, step, offset, height);
            drag.innerDiv.update('(' + event.start.toString(Kronolith.conf.time_format) + ' - ' + event.end.toString(Kronolith.conf.time_format) + ') ' + event.t.escapeHTML());
        } else if (elt.hasClassName('kronolithEditable')) {
            // Moving the event.
            if (Object.isUndefined(drag.innerDiv)) {
                drag.innerDiv = drag.ghost.down('.kronolith-event-info');
            }
            if ((this.view == 'week') || (this.view == 'workweek')) {
                var offsetX = Math.round(drag.ghost.offsetLeft / drag.stepX);
                event.offsetDays = offsetX;
                this.calculateEventDates(event, storage, step, drag.ghost.offsetTop, drag.divHeight, event.start.clone().addDays(offsetX), event.end.clone().addDays(offsetX));
            } else {
                event.offsetDays = 0;
                this.calculateEventDates(event, storage, step, drag.ghost.offsetTop, drag.divHeight);
            }
            event.offsetTop = drag.ghost.offsetTop - drag.startTop;
            drag.innerDiv.update('(' + event.start.toString(Kronolith.conf.time_format) + ' - ' + event.end.toString(Kronolith.conf.time_format) + ') ' + event.t.escapeHTML());
            elt.clonePosition(drag.ghost, { offsetLeft: (this.view == 'week' || this.view == 'workweek') ? -2 : 0 });
        }
    },

    onDragEnd: function(e)
    {
        if (this.view == 'month') {
            return;
        }

        if (!e.element().hasClassName('kronolithDragger') &&
            !e.element().hasClassName('kronolithEditable')) {
            return;
        }

        var div = e.element(),
            drag = DragDrop.Drags.getDrag(div),
            event = drag.event;


        if (event.value.al) {
            return;
        }
        var date = drag.midnight,
            storage = this.view + 'Sizes',
            step = this[storage].height / 6,
            dates = this.viewDates(date, this.view),
            start = dates[0].dateString(),
            end = dates[1].dateString(),
            sig = start + end + (Math.random() + '').slice(2),
            element, attributes;

        div.removeClassName('kronolith-selected');
        if (!Object.isUndefined(drag.innerDiv)) {
            this.setEventText(drag.innerDiv, event.value);
        }
        this.startLoading(event.value.calendar, sig);
        if (!Object.isUndefined(event.value.offsetTop)) {
            attributes = $H({ offDays: event.value.offsetDays,
                              offMins: Math.round(event.value.offsetTop / step) * 10 });
            element = div;
        } else if (div.hasClassName('kronolithDraggerTop')) {
            attributes = $H({ start: event.value.start });
            element = div.up();
        } else if (div.hasClassName('kronolithDraggerBottom')) {
            attributes = $H({ end: event.value.end });
            element = div.up();
        } else {
            attributes = $H({ start: event.value.start,
                              end: event.value.end });
            element = div;
        }
        if (event.value.r) {
            attributes.set('rstart', event.value.s);
            attributes.set('rend', event.value.e);
            attributes.set('cstart', this.cacheStart);
            attributes.set('cend', this.cacheEnd);
        }
        element.retrieve('drags').invoke('destroy');
        var uatts = {
            cal: event.value.calendar,
            id: event.key,
            view: this.view,
            sig: sig,
            view_start: start,
            view_end: end,
            att: Object.toJSON(attributes)
        },
        callback = function(r) {
            // Check if this is the still the result of the most current
            // request.
            if (r.events &&
                r.sig == this.eventsLoading[r.cal]) {
                if (event.value.rs) {
                    var d = new Date(event.value.s);
                    this.refreshResources(d.toString('yyyyMMdd'), event.value.calendar, event.key)
                }
                this.removeEvent(event.value.calendar, event.key);
            }
            this.loadEventsCallback(r, false);
        }.bind(this);

        if (event.value.mt) {
            $('kronolithEventDiv').hide();
            $('kronolithUpdateDiv').show();
            RedBox.showHtml($('kronolithEventDialog').show());
            this.uatts = uatts;
            this.ucb = callback;
        } else {
            this.doDragDropUpdate(uatts, callback);
        }
    },

    doDragDropUpdate: function(att, cb)
    {
        HordeCore.doAction('updateEvent', att, {
            callback: cb
        });
    },

    /**
     * Refresh any resource calendars bound to the given just-updated event.
     * Clears the old resource event from UI and cache, and clears the cache
     * for the days of the new event, in order to allow listEvents to refresh
     * the UI.
     *
     * @param  string dt       The current/new date for the event (yyyyMMdd).
     * @param  string cal      The calendar the event exists in.
     * @param  string eventid  The eventid that is changing.
     * @param  string last_dt  The previous date for the event, if known. (yyyyMMdd).
     * @param  object event    The event object (if a new event) dt is ignored.
     *
     */
    refreshResources: function(dt, cal, eventid, last_dt, event)
    {
        var events = this.getCacheForDate(dt, cal),
            update_cals = [], r_dates;

        if (!event) {
            event = events.find(function(e) { return e.key == eventid; });
        }
        if (!dt) {
            dt = new Date(event.value.s);
        } else {
            dt = this.parseDate(dt);
        }
        if (event) {
            $H(event.value.rs).each(function(r) {
                var r_cal = ['resource', r.value.calendar],
                    r_events = this.getCacheForDate(last_dt, r_cal.join('|')),
                    r_event, day, end;

                if (r_events) {
                    r_event = r_events.find(function(e) { return e.value.uid == event.value.uid });
                    if (r_event) {
                        this.removeEvent(r_cal, r_event.key);
                        day = new Date(r_event.value.s);
                        end = new Date(r_event.value.s);
                        while (!day.isAfter(end)) {
                            this.deleteCache(r_cal, null, day.toString('yyyyMMdd'));
                            day.add(1).day();
                        }
                        day = new Date(event.value.s);
                        end = new Date(event.value.e);

                        while (!day.isAfter(end)) {
                            this.deleteCache(r_cal, null, day.toString('yyyyMMdd'));
                            day.add(1).day();
                        }
                    } else {
                        // Don't know the previous date/time so just nuke the cache.
                       this.deleteCache(r_cal);
                    }
                } else {
                    this.deleteCache(r_cal);
                }
                update_cals.push(r_cal);
            }.bind(this));

            if (update_cals.length) {
                dates = this.viewDates(dt, this.view);
                // Ensure we also grab the full length of the events.
                if (dates[0].isAfter(dt)) {
                    dates[0] = dt;
                }
                var dt_end = new Date(event.value.e);
                if (dt_end.isAfter(dates[1])) {
                    dates[1] = dt_end;
                }
                this.loadEvents(dates[0], dates[1], this.view, update_cals);
            }
        }
    },

    editEvent: function(calendar, id, date, title)
    {
        if (this.redBoxLoading) {
            return;
        }
        if (Object.isUndefined(HordeImple.AutoCompleter.kronolithEventTags)) {
            this.editEvent.bind(this, calendar, id, date).defer();
            return;
        }

        this.closeRedBox();
        this.quickClose();
        this.redBoxOnDisplay = RedBox.onDisplay;
        RedBox.onDisplay = function() {
            if (this.redBoxOnDisplay) {
                this.redBoxOnDisplay();
            }
            try {
                $('kronolithEventForm').focusFirstElement();
            } catch(e) {}
            if (Kronolith.conf.maps.driver &&
                $('kronolithEventLinkMap').up().hasClassName('horde-active') &&
                !this.mapInitialized) {

                this.initializeMap();
            }
            RedBox.onDisplay = this.redBoxOnDisplay;
        }.bind(this);
        this.attendees = [];
        this.resources = [];
        this.updateCalendarDropDown('kronolithEventTarget');
        this.toggleAllDay(false);
        this.openTab($('kronolithEventForm').down('.tabset a.kronolithTabLink'));
        this.disableAlarmMethods('Event');
        this.knl.kronolithEventStartTime.markSelected();
        this.knl.kronolithEventEndTime.markSelected();
        $('kronolithEventForm').reset();
        this.resetMap();
        HordeImple.AutoCompleter.kronolithEventAttendees.reset();
        HordeImple.AutoCompleter.kronolithEventTags.reset();
        HordeImple.AutoCompleter.kronolithEventResources.reset();
        if (Kronolith.conf.maps.driver) {
            $('kronolithEventMapLink').hide();
        }
        $('kronolithEventSave').show().enable();
        $('kronolithEventSaveAsNew').show().enable();
        $('kronolithEventDelete').show().enable();
        $('kronolithEventDeleteConfirm').enable();
        $('kronolithEventTarget').show();
        $('kronolithEventTargetRO').hide();
        $('kronolithEventForm').down('.kronolithFormActions .kronolithSeparator').show();
        $('kronolithEventExceptions').clear();
        if (id) {
            // An id passed to this function indicates we are editing an event.
            RedBox.loading();
            var attributes = { cal: calendar, id: id, date: date };
            // Need the current st and et of this instance.
            var events = this.getCacheForDate(date.toString('yyyyMMdd'), calendar);
            if (events) {
                var ev = events.find(function(e) { return e.key == id; });
                if (ev[1].r) {
                    attributes.rsd = ev[1].start.dateString();
                    attributes.red = ev[1].end.dateString();
                }
            }
            HordeCore.doAction('getEvent', attributes, {
                callback: this.editEventCallback.bind(this)
            });
            $('kronolithEventTopTags').update();
        } else {
            // This is a new event.
            HordeCore.doAction('listTopTags', {}, {
                callback: this.topTagsCallback.curry('kronolithEventTopTags', 'kronolithEventTag')
            });
            var d;
            if (date) {
                if (date.endsWith('all')) {
                    date = date.substring(0, date.length - 3);
                    $('kronolithEventAllday').setValue(true);
                    this.toggleAllDay(true);
                }
                d = this.parseDate(date);
            } else {
                d = new Date();
            }
            if (title) {
                $('kronolithEventTitle').setValue(title);
            }
            $('kronolithEventId').clear();
            $('kronolithEventCalendar').clear();
            $('kronolithEventTarget').setValue(Kronolith.conf.default_calendar);
            $('kronolithEventDelete').hide();
            $('kronolithEventStartDate').setValue(d.toString(Kronolith.conf.date_format));
            $('kronolithEventStartTime').setValue(d.toString(Kronolith.conf.time_format));
            this.updateFBDate(d);
            d.add(1).hour();
            this.duration = 60;
            $('kronolithEventEndDate').setValue(d.toString(Kronolith.conf.date_format));
            $('kronolithEventEndTime').setValue(d.toString(Kronolith.conf.time_format));
            $('kronolithEventLinkExport').up('span').hide();
            $('kronolithEventSaveAsNew').hide();
            $('kronolithEventUrlDisplay').hide();
            $('kronolithEventUrl').show();
            this.toggleRecurrence(true, 'None');
            $('kronolithEventEditRecur').hide();
            this.enableAlarm('Event', Kronolith.conf.default_alarm);
            this.redBoxLoading = true;
            RedBox.showHtml($('kronolithEventDialog').show());
        }
    },

    /**
     * Generates ajax request parameters for requests to save events.
     *
     * @return object  An object with request parameters.
     */
    saveEventParams: function()
    {
        var viewDates = this.viewDates(this.date, this.view),
            params = {
                sig: viewDates[0].dateString() + viewDates[1].dateString(),
                view: this.view
            };
        if (this.cacheStart) {
            params.view_start = this.cacheStart.dateString();
            params.view_end = this.cacheEnd.dateString();
        }
        return params;
    },

    /**
     * Submits the event edit form to create or update an event.
     */
    saveEvent: function(asnew)
    {
        this.validateEvent(asnew);
    },

    /**
     * Perform any preliminary checks necessary. doSaveEvent will be called from
     * the callback if checks are successful.
     *
     */
    validateEvent: function(asnew)
    {
        if (this.wrongFormat.size()) {
            HordeCore.notify(Kronolith.text.fix_form_values, 'horde.warning');
            return;
        }

        // Check that there are no conflicts.
        if (Kronolith.conf.has_resources && $F('kronolithEventResourceIds')) {
            HordeCore.doAction(
                'checkResources',
                {
                    s: this.getDate('start').toISOString(),
                    e: this.getDate('end').toISOString(),
                    i: $F('kronolithEventId'),
                    c: $F('kronolithEventCalendar'),
                    r: $F('kronolithEventResourceIds')
                },
                {
                    callback: this.validateEventCallback.curry(asnew).bind(this)
                }
            );
        } else {
            this.validateEventCallback(asnew, {});
        }
    },

    validateEventCallback: function(asnew, r)
    {
        var conflict = false;

        $H(r).each(function(a) {
            // 3 == Kronolith::RESPONSE_DECLINED
            if (a.value == 3) {
                $('kronolithEventDiv').hide();
                $('kronolithConflictDiv').show();
                conflict = true;
                return;
            }
        });
        if (!conflict) {
            this.doSaveEvent(asnew);
        }
    },

    doSaveEvent: function(asnew)
    {
        var cal = $F('kronolithEventCalendar'),
            target = $F('kronolithEventTarget'),
            eventid = $F('kronolithEventId'),
            params;

        if (this.mapInitialized) {
            $('kronolithEventMapZoom').value = this.map.getZoom();
        }

        params = $H($('kronolithEventForm').serialize({ hash: true }))
            .merge(this.saveEventParams());
        params.set('as_new', asnew ? 1 : 0);
        if (this.cacheStart) {
            params.set('cstart', this.cacheStart.toISOString());
            params.set('cend', this.cacheEnd.toISOString());
        }
        HordeImple.AutoCompleter.kronolithEventTags.shutdown();
        $('kronolithEventSave').disable();
        $('kronolithEventSaveAsNew').disable();
        $('kronolithEventDelete').disable();
        this.startLoading(target, params.get('sig'));
        HordeCore.doAction('saveEvent', params, {
            callback: function(r) {
                if (!asnew && r.events && eventid) {
                    this.removeEvent(cal, eventid);
                }
                this.loadEventsCallback(r, false);

                // Refresh bound exceptions
                var calendar = cal.split('|'), refreshed = false;
                $H(r.events).each(function(d) {
                    $H(d.value).each(function(evt) {
                        if (evt.value.bid) {
                            var cache = this.getCacheForDate(this.findEventDays(cal, evt.key, cal));
                            cache.each(function(entry) {
                                if (entry.value.bid == evt.value.bid && evt.value.c != calendar[1]) {
                                    this.removeEvent(cal, entry.key);
                                }
                            }.bind(this));
                        }
                        if (!refreshed && ((evt.key == eventid) || !eventid) && evt.value.rs) {
                            this.refreshResources(null, cal, eventid, false, evt);
                            refreshed = true;
                        }
                    }.bind(this))
                }.bind(this));

                if (r.events) {
                    this.resetMap();
                    this.closeRedBox();
                    this.go(this.lastLocation);
                } else {
                    $('kronolithEventSave').enable();
                    $('kronolithEventSaveAsNew').enable();
                    $('kronolithEventDelete').enable();
                }
                $('kronolithUpdateDiv').hide();
                $('kronolithConflictDiv').hide();
                $('kronolithEventDiv').show();
            }.bind(this)
        });
    },

    quickSaveEvent: function()
    {
        var text = $F('kronolithQuickinsertQ'),
            cal = $F('kronolithQuickinsertCalendars'),
            params;

        params = $H($('kronolithEventForm').serialize({ hash: true }))
            .merge(this.saveEventParams());
        params.set('text', text);
        params.set('cal', cal);

        this.closeRedBox();
        this.startLoading(cal, params.get('sig'));
        HordeCore.doAction('quickSaveEvent', params, {
            callback: function(r) {
                this.loadEventsCallback(r, false);
                if (r.error) {
                    this.editEvent(null, null, null, text);
                } else {
                    $('kronolithQuickinsertQ').value = '';
                }
             }.bind(this)
         });
    },

    /**
     * Closes and resets the quick event form.
     */
    quickClose: function()
    {
        $('kronolithQuickinsertQ').value = '';
        if ($('kronolithQuicktaskQ')) {
            $('kronolithQuicktaskQ').value = '';
        }
        this.closeRedBox();
    },

    topTagsCallback: function(update, tagclass, r)
    {
        $('kronolithEventTabTags').select('label').invoke('show');
        if (!r.tags) {
            $(update).update();
            return;
        }

        var t = new Element('ul', { className: 'horde-tags' });
        r.tags.each(function(tag) {
            if (tag == null) {
                return;
            }
            t.insert(new Element('li', { className: tagclass }).update(tag.escapeHTML()));
        });
        $(update).update(t);
    },

    /**
     * Callback method for showing event forms.
     *
     * @param object r  The ajax response object.
     */
    editEventCallback: function(r)
    {
        if (!r.event) {
            RedBox.close();
            this.go(this.lastLocation);
            return;
        }

        var ev = r.event;

        if (!Object.isUndefined(ev.ln)) {
            this.loadPage(ev.ln);
            this.closeRedBox();
            return;
        }

        /* Basic information */
        $('kronolithEventId').setValue(ev.id);
        $('kronolithEventCalendar').setValue(ev.ty + '|' + ev.c);
        $('kronolithEventTarget').setValue(ev.ty + '|' + ev.c);
        $('kronolithEventTargetRO').update(Kronolith.conf.calendars[ev.ty][ev.c].name.escapeHTML());
        $('kronolithEventTitle').setValue(ev.t);
        $('kronolithEventLocation').setValue(ev.l);
        $('kronolithEventTimezone').setValue(ev.tz);
        if (ev.l && Kronolith.conf.maps.driver) {
            $('kronolithEventMapLink').show();
        }
        if (ev.uhl) {
            $('kronolithEventUrlDisplay').down().update(ev.uhl);
            $('kronolithEventUrlDisplay').show();
            $('kronolithEventUrl').hide();
        }
        else {
            $('kronolithEventUrlDisplay').hide();
            $('kronolithEventUrl').show();
        }

        if (ev.u) {
            $('kronolithEventUrl').setValue(ev.u);
        }

        $('kronolithEventAllday').setValue(ev.al);

        if (ev.r && ev.rsd && ev.red) {
            // Save the original datetime, so we can properly create the
            // exception.
            var osd = Date.parse(ev.rsd + ' ' + ev.st);
            var oed = Date.parse(ev.red + ' ' + ev.et);

            $('kronolithEventRecurOStart').setValue(osd.toString('s'));
            $('kronolithEventRecurOEnd').setValue(oed.toString('s'));

            // ...and put the same value in the form field to replace the
            // date of the initial series.
            $('kronolithEventStartDate').setValue(ev.sd);
            $('kronolithEventEndDate').setValue(ev.ed);
            // Save the current datetime in case we are not editing 'all'
            this.orstart = ev.rsd;
            this.orend = ev.red;
        } else {
            $('kronolithEventStartDate').setValue(ev.sd);
            $('kronolithEventEndDate').setValue(ev.ed);
            $('kronolithEventRecurEnd').clear();
            $('kronolithEventRecurOStart').clear();
            $('kronolithEventRecurOEnd').clear();
            this.orstart = null;
            this.orend = null;
        }

        $('kronolithEventStartTime').setValue(ev.st);
        this.knl.kronolithEventStartTime.setSelected(ev.st);
        this.updateFBDate(Date.parseExact(ev.sd, Kronolith.conf.date_format));
        $('kronolithEventEndTime').setValue(ev.et);
        this.knl.kronolithEventEndTime.setSelected(ev.et);
        this.duration = Math.abs(Date.parse(ev.e).getTime() - Date.parse(ev.s).getTime()) / 60000;
        this.toggleAllDay(ev.al);
        $('kronolithEventStatus').setValue(ev.x);
        $('kronolithEventDescription').setValue(ev.d);
        $('kronolithEventPrivate').setValue(ev.pv);
        $('kronolithEventLinkExport').up('span').show();
        $('kronolithEventExport').href = Kronolith.conf.URI_EVENT_EXPORT.interpolate({ id: ev.id, calendar: ev.c, type: ev.ty });

        /* Alarm */
        if (ev.a) {
            this.enableAlarm('Event', ev.a);
            if (ev.m) {
                $('kronolithEventAlarmDefaultOff').checked = true;
                $H(ev.m).each(function(method) {
                    $('kronolithEventAlarm' + method.key).setValue(1);
                    if ($('kronolithEventAlarm' + method.key + 'Params')) {
                        $('kronolithEventAlarm' + method.key + 'Params').show();
                        $H(method.value).each(function(param) {
                            var input = $('kronolithEventAlarmParam' + param.key);
                            if (input.type == 'radio') {
                                input.up('form').select('input[type=radio]').each(function(radio) {
                                    if (radio.name == input.name &&
                                        radio.value == param.value) {
                                        radio.setValue(1);
                                        throw $break;
                                    }
                                });
                            } else {
                                input.setValue(param.value);
                            }
                        });
                    }
                });
            }
        } else {
            $('kronolithEventAlarmOff').setValue(true);
        }

        /* Recurrence */
        if (ev.r) {
            this.setRecurrenceFields(true, ev.r);
            $('kronolithRecurDelete').show();
            $('kronolithNoRecurDelete').hide();
            $('kronolithEventEditRecur').show();
            this.recurs = true;
        } else if (ev.bid) {
            $('kronolithRecurDelete').hide();
            $('kronolithNoRecurDelete').show();
            $('kronolithEventEditRecur').hide();
            var div = $('kronolithEventRepeatException');
            div.down('span').update(ev.eod);
            this.toggleRecurrence(true, 'Exception');
            this.recurs = false;
        } else {
            $('kronolithRecurDelete').hide();
            $('kronolithNoRecurDelete').show();
            $('kronolithEventEditRecur').hide();
            this.toggleRecurrence(true, 'None');
            this.recurs = false;
        }

        /* Attendees */
        if (!Object.isUndefined(ev.at)) {
            HordeImple.AutoCompleter.kronolithEventAttendees.reset(ev.at.pluck('l'));
            ev.at.each(this.addAttendee.bind(this));
            if (this.fbLoading) {
                $('kronolithFBLoading').show();
            }
        }

        /* Resources */
        if (!Object.isUndefined(ev.rs)) {
            var rs = $H(ev.rs);
            HordeImple.AutoCompleter.kronolithEventResources.reset(rs.values().pluck('name'));
            rs.each(function(r) { this.addResource(r.value, r.key); }.bind(this));
            if (this.fbLoading) {
                $('kronolithResourceFBLoading').show();
            }
        }

        /* Tags */
        HordeImple.AutoCompleter.kronolithEventTags.reset(ev.tg);

        /* Geo */
        if (ev.gl) {
            $('kronolithEventLocationLat').value = ev.gl.lat;
            $('kronolithEventLocationLon').value = ev.gl.lon;
            $('kronolithEventMapZoom').value = Math.max(1, ev.gl.zoom);
        }

        if (!ev.pe) {
            $('kronolithEventSave').hide();
            HordeImple.AutoCompleter.kronolithEventTags.disable();
            $('kronolithEventTabTags').select('label').invoke('hide');
        } else {
            HordeCore.doAction('listTopTags', {}, {
                callback: this.topTagsCallback.curry('kronolithEventTopTags', 'kronolithEventTag')
            });
        }
        if (!ev.pd) {
            $('kronolithEventDelete').hide();
            $('kronolithEventTarget').hide();
            $('kronolithEventTargetRO').show();
        }

        this.setTitle(ev.t);
        this.redBoxLoading = true;
        RedBox.showHtml($('kronolithEventDialog').show());

        /* Hide alarm message for this event. */
        if (r.msgs) {
            r.msgs = r.msgs.reject(function(msg) {
                if (msg.type != 'horde.alarm') {
                    return false;
                }
                var alarm = msg.flags.alarm;
                if (alarm.params && alarm.params.notify &&
                    alarm.params.notify.show &&
                    alarm.params.notify.show.calendar &&
                    alarm.params.notify.show.event &&
                    alarm.params.notify.show.calendar == ev.c &&
                    alarm.params.notify.show.event == ev.id) {
                    return true;
                }
                return false;
            });
        }
    },

    /**
     * Adds an attendee row to the free/busy table.
     *
     * @param object attendee  An attendee object with the properties:
     *                         - e: email address
     *                         - l: the display name of the attendee
     */
    addAttendee: function(attendee)
    {
        if (typeof attendee == 'string') {
            if (attendee.include('@')) {
                HordeCore.doAction('parseEmailAddress', {
                    email: attendee
                }, {
                    callback: function (r) {
                        if (r.email) {
                            this.addAttendee({ e: r.email, l: attendee });
                        }
                    }.bind(this)
                });
                return;
            } else {
                attendee = { l: attendee };
            }
        }

        if (attendee.e) {
            this.attendees.push(attendee);
            this.fbLoading++;
            HordeCore.doAction('getFreeBusy', {
                email: attendee.e
            }, {
                callback: function(r) {
                    this.fbLoading--;
                    if (!this.fbLoading) {
                        $('kronolithFBLoading').hide();
                    }
                    if (!Object.isUndefined(r.fb)) {
                        this.freeBusy.get(attendee.l)[1] = r.fb;
                        this.insertFreeBusy(attendee.l, this.getFBDate());
                    }
                }.bind(this)
            });
        }

        var tr = new Element('tr'), response, i;
        this.freeBusy.set(attendee.l, [ tr ]);
        attendee.r = attendee.r || 1;
        switch (attendee.r) {
            case 1: response = 'None'; break;
            case 2: response = 'Accepted'; break;
            case 3: response = 'Declined'; break;
            case 4: response = 'Tentative'; break;
        }
        tr.insert(new Element('td')
                  .writeAttribute('title', attendee.l)
                  .addClassName('kronolithAttendee' + response)
                  .insert(attendee.e ? attendee.e.escapeHTML() : attendee.l.escapeHTML()));
        for (i = 0; i < 24; i++) {
            tr.insert(new Element('td', { className: 'kronolithFBUnknown' }));
        }
        $('kronolithEventAttendeesList').down('tbody').insert(tr);
    },

    resetFBRows: function()
    {
        this.attendees.each(function(attendee) {
            var row = this.freeBusy.get(attendee.l)[0];
            row.update();

            attendee.r = attendee.r || 1;
            switch (attendee.r) {
                case 1: response = 'None'; break;
                case 2: response = 'Accepted'; break;
                case 3: response = 'Declined'; break;
                case 4: response = 'Tentative'; break;
            }
            row.insert(new Element('td')
                      .writeAttribute('title', attendee.l)
                      .addClassName('kronolithAttendee' + response)
                      .insert(attendee.e ? attendee.e.escapeHTML() : attendee.l.escapeHTML()));
            for (i = 0; i < 24; i++) {
                row.insert(new Element('td', { className: 'kronolithFBUnknown' }));
            }
        }.bind(this));
        this.resources.each(function(resource) {
            var row = this.freeBusy.get(resource)[0],
                tdone = row.down('td');
            row.update();
            row.update(tdone);
            for (i = 0; i < 24; i++) {
                row.insert(new Element('td', { className: 'kronolithFBUnknown' }));
            }
        }.bind(this));
    },

    addResource: function(resource, id)
    {
        var v, response = 1;
        if (!id) {
            // User entered
            this.resourceACCache.choices.each(function(i) {
                if (i.name == resource) {
                    v = i.code;
                    throw $break;
                } else {
                    v = false;
                }
            }.bind(this));
        } else {
            // Populating from an edit event action
            v = id;
            response = resource.response;
            resource = resource.name;
        }

        switch (response) {
            case 1: response = 'None'; break;
            case 2: response = 'Accepted'; break;
            case 3: response = 'Declined'; break;
            case 4: response = 'Tentative'; break;
        }
        var att = {
            'resource': v
        },
        tr, i;
        if (att.resource) {
            this.fbLoading++;
            HordeCore.doAction('getFreeBusy', att, {
                callback: this.addResourceCallback.curry(resource).bind(this)
            });
            tr = new Element('tr');
            this.freeBusy.set(resource, [ tr ]);
            tr.insert(new Element('td')
                .writeAttribute('title', resource)
                .addClassName('kronolithAttendee' + response)
                .insert(resource.escapeHTML()));
            for (i = 0; i < 24; i++) {
                tr.insert(new Element('td', { className: 'kronolithFBUnknown' }));
            }
            $('kronolithEventResourcesList').down('tbody').insert(tr);
            this.resourceACCache.map.set(resource, v);
            $('kronolithEventResourceIds').value = this.resourceACCache.map.values();
        } else {
            HordeCore.notify(Kronolith.text.unknown_resource + ': ' + resource, 'horde.error');
        }
    },

    removeResource: function(resource)
    {
        var row = this.freeBusy.get(resource)[0];
        row.purge();
        row.remove();
        this.resourceACCache.map.unset(resource);
        $('kronolithEventResourceIds').value = this.resourceACCache.map.values();
    },

    addResourceCallback: function(resource, r)
    {
        this.fbLoading--;
        if (!this.fbLoading) {
            $('kronolithResourceFBLoading').hide();
        }
        if (Object.isUndefined(r.fb)) {
            return;
        }
        this.resources.push(resource);
        this.freeBusy.get(resource)[1] = r.fb;
        this.insertFreeBusy(resource);
    },

    /**
     * Removes an attendee row from the free/busy table.
     *
     * @param string attendee  The display name of the attendee.
     */
    removeAttendee: function(attendee)
    {
        var row = this.freeBusy.get(attendee)[0];
        row.purge();
        row.remove();
    },

    normalizeAttendee: function(attendee)
    {
        var pattern = /:(.*);/;
        var match = pattern.exec(attendee);
        if (match) {
           return match[1].split(',');
        }
        return [attendee];
    },

    checkOrganizerAsAttendee: function()
    {
        if (HordeImple.AutoCompleter.kronolithEventAttendees.selectedItems.length == 1 &&
            HordeImple.AutoCompleter.kronolithEventAttendees.selectedItems.first().rawValue != Kronolith.conf.email) {
            // Invite the organizer of this event to the new event.
            HordeImple.AutoCompleter.kronolithEventAttendees.addNewItemNode(Kronolith.conf.email);
            this.addAttendee(Kronolith.conf.email);
        }
    },

    getFBDate: function ()
    {
        var startDate = $('kronolithFBDate').innerHTML.split(' ');
        if (startDate.length > 1) {
            startDate = startDate[1];
        } else {
            startDate = startDate[0];
        }
        return Date.parseExact(startDate, Kronolith.conf.date_format);
    },

    /**
     * Updates rows with free/busy information in the attendees table.
     *
     * @param string attendee  An attendee display name as the free/busy
     *                         identifier.
     * @param date   start     An optinal start date for f/b info. If omitted,
     *                         $('kronolithEventStartDate') is used.
     */
    insertFreeBusy: function(attendee, start)
    {
        if (!$('kronolithEventDialog').visible() ||
            !this.freeBusy.get(attendee)) {
            return;
        }
        var fb = this.freeBusy.get(attendee)[1],
            tr = this.freeBusy.get(attendee)[0],
            td = tr.select('td')[1],
            div = td.down('div'), start;
        if (!fb) {
            return;
        }

        if (!td.getWidth()) {
            this.insertFreeBusy.bind(this, attendee, start).defer();
            return;
        }

        if (div) {
            div.purge();
            div.remove();
        }
        if (!start) {
            start = Date.parseExact($F('kronolithEventStartDate'), Kronolith.conf.date_format);
        }
        var end = start.clone().add(1).days(),
            width = td.getWidth(),
            fbs = this.parseDate(fb.s),
            fbe = this.parseDate(fb.e);


        if (start.isBefore(fbs) || end.isBefore(fbs) || start.isAfter(fbe)) {
            return;
        }

        tr.select('td').each(function(td, i) {
            if (i != 0) {
                td.className = 'kronolithFBFree';
            }
            i++;
        });
        div = new Element('div').setStyle({ position: 'relative', height: td.offsetHeight + 'px' });
        td.insert(div);
        $H(fb.b).each(function(busy) {
            var left, from = Date.parse(busy.key).addSeconds(1),
            to = Date.parse(busy.value).addSeconds(1);
            if (!end.isAfter(from) || to.isBefore(start)) {
                return;
            }
            if (from.isBefore(start)) {
                from = start.clone();
            }
            if (to.isAfter(end)) {
                to = end.clone();
            }
            if (to.getHours() === 0 && to.getMinutes() === 0) {
                to.add(-1).minutes();
            }
            left = from.getHours() + from.getMinutes() / 60;
            div.insert(new Element('div', { className: 'kronolithFBBusy' }).setStyle({ zIndex: 1, top: 0, left: (left * width) + 'px', width: (((to.getHours() + to.getMinutes() / 60) - left) * width) + 'px' }));
        });

    },

    fbStartDateOnChange: function()
    {
        if (!$F('kronolithEventStartDate')) {
          this._checkDate($('kronolithEventStartDate'));
          return;
        }
        this.fbStartDateHandler(Date.parseExact($F('kronolithEventStartDate'), Kronolith.conf.date_format));
    },

    /**
     * @param Date start  The start date.
     */
    fbStartDateHandler: function(start)
    {
        this.updateFBDate(start);
        this.resetFBRows();
        // Need to check visisbility - multiple changes will break the display
        // due to the use of .defer() in insertFreeBusy().
        if ($('kronolithEventTabAttendees').visible()) {
            this.attendeeStartDateHandler(start);
        }
        if ($('kronolithEventTabResources').visible()) {
            this.resourceStartDateHandler(start);
        }
    },

    attendeeStartDateHandler: function(start)
    {
        this.attendees.each(function(attendee) {
            this.insertFreeBusy(attendee.l, start);
        }, this);
    },

    resourceStartDateHandler: function(start)
    {
        this.resources.each(function(resource) {
            this.insertFreeBusy(resource, start);
        }, this);
    },

    nextFreebusy: function()
    {
        this.fbStartDateHandler(this.getFBDate().addDays(1));
    },

    prevFreebusy: function()
    {
        this.fbStartDateHandler(this.getFBDate().addDays(-1));
    },

    /**
     * @start Date object
     */
    updateFBDate: function(start)
    {
        $('kronolithFBDate').update(start.toString('dddd') + ' ' + start.toString(Kronolith.conf.date_format));
        $('kronolithResourceFBDate').update(start.toString('dddd') + ' ' + start.toString(Kronolith.conf.date_format));
    },

    /**
     * Toggles the start and end time fields of the event edit form on and off.
     *
     * @param boolean on  Whether the event is an all-day event, i.e. the time
     *                    fields should be turned off. If not specified, the
     *                    current state is toggled.
     */
    toggleAllDay: function(on)
    {
        var end = this.getDate('end'),
            old = $('kronolithEventStartTimeLabel').getStyle('visibility') == 'hidden';
        if (Object.isUndefined(on)) {
            on = $('kronolithEventStartTimeLabel').getStyle('visibility') == 'visible';
        }
        if (end) {
            if (on) {
                if (end.getHours() == 0 && end.getMinutes() == 0) {
                    end.add(-1).minute();
                }
            } else if (old) {
                end.setHours(23);
                end.setMinutes(59);
            }
            $('kronolithEventEndDate').setValue(end.toString(Kronolith.conf.date_format));
            $('kronolithEventEndTime').setValue(end.toString(Kronolith.conf.time_format));
        }
        $('kronolithEventStartTimeLabel').setStyle({ visibility: on ? 'hidden' : 'visible' });
        $('kronolithEventEndTimeLabel').setStyle({ visibility: on ? 'hidden' : 'visible' });
    },

    /**
     * Enables the alarm in the event or task form and sets the correct value
     * and unit.
     *
     * @param string type    The object type, either 'Event' or 'Task'.
     * @param integer alarm  The alarm time in seconds.
     */
    enableAlarm: function(type, alarm) {
        if (!alarm) {
            return;
        }
        type = 'kronolith' + type + 'Alarm';
        $(type + 'On').setValue(true);
        [10080, 1440, 60, 1].each(function(unit) {
            if (alarm % unit === 0) {
                $(type + 'Value').setValue(alarm / unit);
                $(type + 'Unit').setValue(unit);
                throw $break;
            }
        });
    },

    /**
     * Disables all custom alarm methods in the event form.
     */
    disableAlarmMethods: function(type) {
        $('kronolith' + type + 'TabReminder').select('input').each(function(input) {
            if (input.name == (type == 'Event' ? 'event_alarms[]' : 'task[alarm_methods][]')) {
                input.setValue(0);
                if ($(input.id + 'Params')) {
                    $(input.id + 'Params').hide();
                }
            }
        });
    },

    /**
     * Toggles the recurrence fields of the event and task edit forms.
     *
     * @param boolean event  Whether to use the event form.
     * @param string recur   The recurrence part of the field name, i.e. 'None',
     *                       'Daily', etc.
     */
    toggleRecurrence: function(event, recur)
    {
        var prefix = 'kronolith' + (event ? 'Event' : 'Task');
        if (recur == 'Exception') {
            if (!$(prefix + 'RepeatException').visible()) {
                $(prefix + 'TabRecur').select('div').invoke('hide');
                $(prefix + 'RepeatException').show();
            }
        } else if (recur != 'None') {
            var div = $(prefix + 'Repeat' + recur),
                length = $(prefix + 'RepeatLength');
            this.lastRecurType = recur;
            if (!div.visible()) {
                $(prefix + 'TabRecur').select('div').invoke('hide');
                div.show();
                length.show();
                $(prefix + 'RepeatType').show();
            }
            switch (recur) {
            case 'Daily':
            case 'Weekly':
            case 'Monthly':
            case 'Yearly':
                var recurLower = recur.toLowerCase();
                if (div.down('input[name=recur_' + recurLower + '][value=1]').checked) {
                    div.down('input[name=recur_' + recurLower + '_interval]').disable();
                } else {
                    div.down('input[name=recur_' + recurLower + '_interval]').enable();
                }
                break;
            }

            if (length.down('input[name=recur_end_type][value=date]').checked) {
                $(prefix + 'RecurDate').enable();
                $(prefix + 'RecurPicker').setStyle({ visibility: 'visible' });
            } else {
                $(prefix + 'RecurDate').disable();
                $(prefix + 'RecurPicker').setStyle({ visibility: 'hidden' });
            }
            if (length.down('input[name=recur_end_type][value=count]').checked) {
                $(prefix + 'RecurCount').enable();
            } else {
                $(prefix + 'RecurCount').disable();
            }
        } else {
            $(prefix + 'TabRecur').select('div').invoke('hide');
            $(prefix + 'RepeatType').show();
        }
    },

    /**
     * Fills the recurrence fields of the event and task edit forms.
     *
     * @param boolean event  Whether to use the event form.
     * @param object recur   The recurrence object from the ajax response.
     */
    setRecurrenceFields: function(event, recur)
    {
        var scheme = Kronolith.conf.recur[recur.t],
            schemeLower = scheme.toLowerCase(),
            prefix = 'kronolith' + (event ? 'Event' : 'Task'),
            div = $(prefix + 'Repeat' + scheme);
        $(prefix + 'Link' + scheme).setValue(true);
        if (scheme == 'Monthly' || scheme == 'Yearly') {
            div.down('input[name=recur_' + schemeLower + '_scheme][value=' + recur.t + ']').setValue(true);
        }
        if (scheme == 'Weekly') {
            div.select('input[type=checkbox]').each(function(input) {
                if (input.name == 'weekly[]' &&
                    input.value & recur.d) {
                    input.setValue(true);
                }
            });
        }
        if (recur.i == 1) {
            div.down('input[name=recur_' + schemeLower + '][value=1]').setValue(true);
        } else {
            div.down('input[name=recur_' + schemeLower + '][value=0]').setValue(true);
            div.down('input[name=recur_' + schemeLower + '_interval]').setValue(recur.i);
        }
        if (!Object.isUndefined(recur.e)) {
            $(prefix + 'RepeatLength').down('input[name=recur_end_type][value=date]').setValue(true);
            $(prefix + 'RecurDate').setValue(Date.parse(recur.e).toString(Kronolith.conf.date_format));
        } else if (!Object.isUndefined(recur.c)) {
            $(prefix + 'RepeatLength').down('input[name=recur_end_type][value=count]').setValue(true);
            $(prefix + 'RecurCount').setValue(recur.c);
        } else {
            $(prefix + 'RepeatLength').down('input[name=recur_end_type][value=none]').setValue(true);
        }
        $(prefix + 'Exceptions').setValue(recur.ex || '');
        if ($(prefix + 'Completions')) {
            $(prefix + 'Completions').setValue(recur.co || '');
        }
        this.toggleRecurrence(event, scheme);
    },

    /**
     * Returns the Date object representing the date and time specified in the
     * event form's start or end fields.
     *
     * @param string what  Which fields to parse, either 'start' or 'end'.
     *
     * @return Date  The date object or null if the fields can't be parsed.
     */
    getDate: function(what) {
        var dateElm, timeElm, date, time;
        if (what == 'start') {
            dateElm = 'kronolithEventStartDate';
            timeElm = 'kronolithEventStartTime';
        } else {
            dateElm = 'kronolithEventEndDate';
            timeElm = 'kronolithEventEndTime';
        }
        date = Date.parseExact($F(dateElm), Kronolith.conf.date_format)
            || Date.parse($F(dateElm));
        if (date) {
            time = Date.parseExact($F(timeElm), Kronolith.conf.time_format);
            if (!time) {
                time = Date.parse($F(timeElm));
            }
            if (time) {
                date.setHours(time.getHours());
                date.setMinutes(time.getMinutes());
            }
        }
        return date;
    },

    checkDate: function(e) {
        this._checkDate(e.element());
    },

    _checkDate: function(elm)
    {
        if ($F(elm)) {
            var date = Date.parseExact($F(elm), Kronolith.conf.date_format) || Date.parse($F(elm));
            if (date) {
                elm.setValue(date.toString(Kronolith.conf.date_format));
                this.wrongFormat.unset(elm.id);
            } else {
                HordeCore.notify(Kronolith.text.wrong_date_format.interpolate({ wrong: $F(elm), right: new Date().toString(Kronolith.conf.date_format) }), 'horde.warning');
                this.wrongFormat.set(elm.id, true);
            }
        } else {
            HordeCore.notify(Kronolith.text.wrong_date_format.interpolate({ wrong: $F(elm), right: new Date().toString(Kronolith.conf.date_format) }), 'horde.warning');
            this.wrongFormat.set(elm.id, true);
        }
    },

    /**
     * Attaches a KeyNavList drop down to one of the time fields.
     *
     * @param string|Element field  A time field (id).
     *
     * @return KeyNavList  The drop down list object.
     */
    attachTimeDropDown: function(field)
    {
        var list = [], d = new Date(), time, opts;

        d.setHours(0);
        d.setMinutes(0);
        do {
            time = d.toString(Kronolith.conf.time_format);
            list.push({ l: time, v: time });
            d.add(30).minutes();
        } while (d.getHours() !== 0 || d.getMinutes() !== 0);

        field = $(field);
        opts = {
            list: list,
            domParent: field.up('.kronolithDialog'),
            onChoose: function(value) {
                if (value) {
                    field.setValue(value);
                }
                this.updateTimeFields(field.identify());
            }.bind(this)
        };

        this.knl[field.id] = new KeyNavList(field, opts);

        return this.knl[field.id];
    },

    checkTime: function(e) {
        var elm = e.element();
        if ($F(elm)) {
            var time = Date.parseExact(new Date().toString(Kronolith.conf.date_format) + ' ' + $F(elm), Kronolith.conf.date_format + ' ' + Kronolith.conf.time_format) || Date.parse(new Date().toString('yyyy-MM-dd ') + $F(elm));
            if (time) {
                elm.setValue(time.toString(Kronolith.conf.time_format));
                this.wrongFormat.unset(elm.id);
            } else {
                HordeCore.notify(Kronolith.text.wrong_time_format.interpolate({ wrong: $F(elm), right: new Date().toString(Kronolith.conf.time_format) }), 'horde.warning');
                this.wrongFormat.set(elm.id, true);
            }
        }
    },

    /**
     * Updates the start time in the event form after changing the end time.
     */
    updateStartTime: function(date) {
        var start = this.getDate('start'), end = this.getDate('end');
        if (!start) {
            return;
        }
        if (!date) {
            date = end;
        }
        if (!date) {
            return;
        }
        if (start.isAfter(end)) {
            $('kronolithEventStartDate').setValue(date.toString(Kronolith.conf.date_format));
            $('kronolithEventStartTime').setValue($F('kronolithEventEndTime'));
        }
        this.duration = Math.abs(date.getTime() - start.getTime()) / 60000;
    },

    /**
     * Updates the end time in the event form after changing the start time.
     */
    updateEndTime: function() {
        var date = this.getDate('start');
        if (!date) {
            return;
        }
        date.add(this.duration).minutes();
        $('kronolithEventEndDate').setValue(date.toString(Kronolith.conf.date_format));
        $('kronolithEventEndTime').setValue(date.toString(Kronolith.conf.time_format));
    },

    /**
     * Event handler for scrolling the mouse over the date field.
     *
     * @param Event e       The mouse event.
     * @param string field  The field name.
     */
    scrollDateField: function(e, field) {
        var date = Date.parseExact($F(field), Kronolith.conf.date_format);
        if (!date || (!e.wheelData && !e.detail)) {
            return;
        }
        date.add(e.wheelData > 0 || e.detail < 0 ? 1 : -1).days();
        $(field).setValue(date.toString(Kronolith.conf.date_format));
        switch (field) {
        case 'kronolithEventStartDate':
            this.updateEndTime();
            break;
        case 'kronolithEventEndDate':
            this.updateStartTime(date);
            break;
        }
    },

    /**
     * Event handler for scrolling the mouse over the time field.
     *
     * @param Event e       The mouse event.
     * @param string field  The field name.
     */
    scrollTimeField: function(e, field) {
        var time = Date.parseExact($F(field), Kronolith.conf.time_format) || Date.parse($F(field)),
            newTime, minute;
        if (!time || (!e.wheelData && !e.detail)) {
            return;
        }

        newTime = time.clone();
        newTime.add(e.wheelData > 0 || e.detail < 0 ? 10 : -10).minutes();
        minute = newTime.getMinutes();
        if (minute % 10) {
            if (e.wheelData > 0 || e.detail < 0) {
                minute = minute / 10 | 0;
            } else {
                minute = (minute - 10) / 10 | 0;
            }
            minute *= 10;
            newTime.setMinutes(minute);
        }
        if (newTime.getDate() != time.getDate()) {
            if (newTime.isAfter(time)) {
                newTime = time.clone().set({ hour: 23, minute: 59 });
            } else {
                newTime = time.clone().set({ hour: 0, minute: 0 });
            }
        }

        $(field).setValue(newTime.toString(Kronolith.conf.time_format));
        this.updateTimeFields(field);

        /* Mozilla bug https://bugzilla.mozilla.org/show_bug.cgi?id=502818
         * Need to stop or else multiple scroll events may be fired. We
         * lose the ability to have the mousescroll bubble up, but that is
         * more desirable than having the wrong scrolling behavior. */
        if (Prototype.Browser.Gecko && !e.stop) {
            Event.stop(e);
        }
    },

    /**
     * Updates the time fields of the event dialog after either has been
     * changed.
     *
     * @param string field  The id of the field that has been changed.
     */
    updateTimeFields: function(field)
    {
        switch (field) {
        case 'kronolithEventStartDate':
            this.fbStartDateHandler(Date.parseExact($F(field), Kronolith.conf.date_format));
        case 'kronolithEventStartTime':
            this.updateEndTime();
            break;
        case 'kronolithEventEndDate':
        case 'kronolithEventEndTime':
            this.updateStartTime();
            this.fbStartDateHandler(Date.parseExact($F('kronolithEventStartDate'), Kronolith.conf.date_format));
            break;
        }
    },

    /**
     * Closes a RedBox overlay, after saving its content to the body.
     */
    closeRedBox: function()
    {
        if (!RedBox.getWindow()) {
            return;
        }
        var content = RedBox.getWindowContents();
        if (content) {
            document.body.insert(content.hide());
        }
        RedBox.close();
    },

    // By default, no context onShow action
    contextOnShow: Prototype.emptyFunction,

    // By default, no context onClick action
    contextOnClick: Prototype.emptyFunction,

    // Map
    initializeMap: function(ignoreLL)
    {
        if (this.mapInitialized) {
            return;
        }
        var layers = [];
        if (Kronolith.conf.maps.providers) {
            Kronolith.conf.maps.providers.each(function(l) {
                var p = new HordeMap[l]();
                $H(p.getLayers()).values().each(function(e) {layers.push(e);});
            });
        }

        this.map = new HordeMap.Map[Kronolith.conf.maps.driver]({
            elt: 'kronolithEventMap',
            delayed: true,
            layers: layers,
            markerDragEnd: this.onMarkerDragEnd.bind(this),
            mapClick: this.afterClickMap.bind(this)
        });

        if ($('kronolithEventLocationLat').value && !ignoreLL) {
            var ll = { lat:$('kronolithEventLocationLat').value, lon: $('kronolithEventLocationLon').value };
            // Note that we need to cast the value of zoom to an integer here,
            // otherwise the map display breaks.
            this.placeMapMarker(ll, true, $('kronolithEventMapZoom').value - 0);
        }
        //@TODO: check for Location field - and if present, but no lat/lon value, attempt to
        // geocode it.
        this.map.display();
        this.mapInitialized = true;
    },

    resetMap: function()
    {
        this.mapInitialized = false;
        $('kronolithEventLocationLat').value = null;
        $('kronolithEventLocationLon').value = null;
        $('kronolithEventMapZoom').value = null;
        if (this.mapMarker) {
            this.map.removeMarker(this.mapMarker, {});
            this.mapMarker = null;
        }
        if (this.map) {
            this.map.destroy();
            this.map = null;
        }
    },

    /**
     * Callback for handling marker drag end.
     *
     * @param object r  An object that implenents a getLonLat() method to obtain
     *                  the new location of the marker.
     */
    onMarkerDragEnd: function(r)
    {
        var ll = r.getLonLat();
        $('kronolithEventLocationLon').value = ll.lon;
        $('kronolithEventLocationLat').value = ll.lat;
        var gc = new HordeMap.Geocoder[Kronolith.conf.maps.geocoder](this.map.map, 'kronolithEventMap');
        gc.reverseGeocode(ll, this.onReverseGeocode.bind(this), this.onGeocodeError.bind(this) );
    },

    /**
     * Callback for handling a reverse geocode request.
     *
     * @param array r  An array of objects containing the results. Each object in
     *                 the array is {lat:, lon:, address}
     */
    onReverseGeocode: function(r)
    {
        if (!r.length) {
            return;
        }
        $('kronolithEventLocation').value = r[0].address;
    },

    onGeocodeError: function(r)
    {
        $('kronolithEventGeo_loading_img').toggle();
        HordeCore.notify(Kronolith.text.geocode_error + ' ' + r, 'horde.error');
    },

    /**
     * Callback for geocoding calls.
     */
    onGeocode: function(r)
    {
        $('kronolithEventGeo_loading_img').toggle();
        r = r.shift();
        if (r.precision) {
            zoom = r.precision * 2;
        } else {
            zoom = null;
        }
        this.ensureMap(true);
        this.placeMapMarker({ lat: r.lat, lon: r.lon }, true, zoom);
    },

    geocode: function(a) {
        if (!a) {
            return;
        }
        $('kronolithEventGeo_loading_img').toggle();
        var gc = new HordeMap.Geocoder[Kronolith.conf.maps.geocoder](this.map.map, 'kronolithEventMap');
        gc.geocode(a, this.onGeocode.bind(this), this.onGeocodeError);
    },

    /**
     * Place the event marker on the map, at point ll, ensuring it exists.
     * Optionally center the map on the marker and zoom. Zoom only honored if
     * center is set, and if center is set, but zoom is null, we zoomToFit().
     *
     */
    placeMapMarker: function(ll, center, zoom)
    {
        if (!this.mapMarker) {
            this.mapMarker = this.map.addMarker(
                    ll,
                    { draggable: true },
                    {
                        context: this,
                        dragend: this.onMarkerDragEnd
                    });
        } else {
            this.map.moveMarker(this.mapMarker, ll);
        }

        if (center) {
            this.map.setCenter(ll, zoom);
            if (!zoom) {
                this.map.zoomToFit();
            }
        }
        $('kronolithEventLocationLon').value = ll.lon;
        $('kronolithEventLocationLat').value = ll.lat;
    },

    /**
     * Remove the event marker from the map. Called after clearing the location
     * field.
     */
    removeMapMarker: function()
    {
        if (this.mapMarker) {
            this.map.removeMarker(this.mapMarker, {});
            $('kronolithEventLocationLon').value = null;
            $('kronolithEventLocationLat').value = null;
        }

        this.mapMarker = false;
    },

    /**
     * Ensures the map tab is visible and sets UI elements accordingly.
     */
    ensureMap: function(ignoreLL)
    {
        if (!this.mapInitialized) {
            this.initializeMap(ignoreLL);
        }
        var dialog = $('kronolithEventForm');
        dialog.select('.kronolithTabsOption').invoke('hide');
        dialog.select('.tabset li').invoke('removeClassName', 'horde-active');
        $('kronolithEventTabMap').show();
        $('kronolithEventLinkMap').up().addClassName('horde-active');
    },

    /**
     * Callback that gets called after a new marker has been placed on the map
     * due to a single click on the map.
     *
     * @return object o  { lonlat: }
     */
    afterClickMap: function(o)
    {
        this.placeMapMarker(o.lonlat, false);
        var gc = new HordeMap.Geocoder[Kronolith.conf.maps.geocoder](this.map.map, 'kronolithEventMap');
        gc.reverseGeocode(o.lonlat, this.onReverseGeocode.bind(this), this.onGeocodeError.bind(this) );
    },

    /* Onload function. */
    onDomLoad: function()
    {
        var dateFields, timeFields;

        /* Initialize the starting page. */
        var tmp = location.hash;
        if (!tmp.empty() && tmp.startsWith('#')) {
            tmp = (tmp.length == 1) ? '' : tmp.substring(1);
        }
        if (tmp.empty()) {
            this.updateView(this.date, Kronolith.conf.login_view);
            $('kronolithView' + Kronolith.conf.login_view.capitalize()).show();
        }
        HordeCore.doAction('listCalendars', {}, { callback: this.initialize.bind(this, tmp) });

        RedBox.onDisplay = function() {
            this.redBoxLoading = false;
        }.bind(this);
        RedBox.duration = this.effectDur;

        $('kronolithEventStartDate', 'kronolithEventEndDate', 'kronolithTaskDueDate').compact().invoke('observe', 'blur', this.checkDate.bind(this));
        var timeFields = $('kronolithEventStartTime', 'kronolithEventEndTime', 'kronolithTaskDueTime').compact();
        timeFields.invoke('observe', 'blur', this.checkTime.bind(this));
        timeFields.each(function(field) {
            var dropDown = this.attachTimeDropDown(field);
            field.observe('click', function() { dropDown.show(); });
        }, this);
        $('kronolithEventStartDate', 'kronolithEventStartTime').invoke('observe', 'change', this.updateEndTime.bind(this));
        $('kronolithEventEndDate', 'kronolithEventEndTime').invoke('observe', 'change', function() { this.updateStartTime(); }.bind(this));

        if (Kronolith.conf.has_tasks) {
            $('kronolithTaskDueDate', 'kronolithTaskDueTime').compact().invoke('observe', 'focus', this.setDefaultDue.bind(this));
            $('kronolithTaskList').observe('change', function() {
                this.updateTaskParentDropDown($F('kronolithTaskList'));
                this.updateTaskAssigneeDropDown($F('kronolithTaskList'));
            }.bind(this));
        }

        document.observe('keydown', KronolithCore.keydownHandler.bindAsEventListener(KronolithCore));
        document.observe('keyup', KronolithCore.keyupHandler.bindAsEventListener(KronolithCore));
        document.observe('click', KronolithCore.clickHandler.bindAsEventListener(KronolithCore));
        document.observe('dblclick', KronolithCore.clickHandler.bindAsEventListener(KronolithCore, true));

        // Mouse wheel handler.
        dateFields = [ 'kronolithEventStartDate', 'kronolithEventEndDate' ];
        timeFields = [ 'kronolithEventStartTime', 'kronolithEventEndTime' ];
        if (Kronolith.conf.has_tasks) {
            dateFields.push('kronolithTaskDueDate');
            timeFields.push('kronolithTaskDueTime');
        }
        dateFields.each(function(field) {
            $(field).observe(Prototype.Browser.Gecko ? 'DOMMouseScroll' : 'mousewheel', this.scrollDateField.bindAsEventListener(this, field));
        }, this);
        timeFields.each(function(field) {
            $(field).observe(Prototype.Browser.Gecko ? 'DOMMouseScroll' : 'mousewheel', this.scrollTimeField.bindAsEventListener(this, field));
        }, this);

        $('kronolithEventStartDate').observe('change', this.fbStartDateOnChange.bind(this));
        $('kronolithFBDatePrev').observe('click', this.prevFreebusy.bind(this));
        $('kronolithFBDateNext').observe('click', this.nextFreebusy.bind(this));
        $('kronolithResourceFBDatePrev').observe('click', this.prevFreebusy.bind(this));
        $('kronolithResourceFBDateNext').observe('click', this.nextFreebusy.bind(this));

        this.updateMinical(this.date);
    },

    initialize: function(location, r)
    {
        Kronolith.conf.calendars = r.calendars;
        this.updateCalendarList();
        HordeSidebar.refreshEvents();
        $('kronolithLoadingCalendars').hide();
        $('kronolithMenuCalendars').show();
        this.initialized = true;

        /* Initialize the starting page. */
        if (!location.empty()) {
            this.go(decodeURIComponent(location));
        } else {
            this.go(Kronolith.conf.login_view);
        }

        /* Start polling. */
        new PeriodicalExecuter(function()
            {
                HordeCore.doAction('poll');
                $(kronolithGotoToday).update(Date.today().toString(Kronolith.conf.date_format));
            },
            60
        );
    }

};

/* Initialize global event handlers. */
document.observe('dom:loaded', KronolithCore.onDomLoad.bind(KronolithCore));
document.observe('DragDrop2:drag', KronolithCore.onDrag.bindAsEventListener(KronolithCore));
document.observe('DragDrop2:drop', KronolithCore.onDrop.bindAsEventListener(KronolithCore));
document.observe('DragDrop2:end', KronolithCore.onDragEnd.bindAsEventListener(KronolithCore));
document.observe('DragDrop2:start', KronolithCore.onDragStart.bindAsEventListener(KronolithCore));
document.observe('Horde_Calendar:select', KronolithCore.datePickerHandler.bindAsEventListener(KronolithCore));
document.observe('FormGhost:reset', KronolithCore.searchReset.bindAsEventListener(KronolithCore));
document.observe('FormGhost:submit', KronolithCore.searchSubmit.bindAsEventListener(KronolithCore));
document.observe('HordeCore:showNotifications', KronolithCore.showNotification.bindAsEventListener(KronolithCore));
if (Prototype.Browser.IE) {
    $('kronolithBody').observe('selectstart', Event.stop);
}

/* Extend AJAX exception handling. */
HordeCore.onException = HordeCore.onException.wrap(KronolithCore.onException.bind(KronolithCore));
","/**
 * kronolith.js - Base application logic.
 *
 * TODO: loadingImg()
 *
 * Copyright 2008-2017 Horde LLC (http://www.horde.org/)
 *
 * See the enclosed file COPYING for license information (GPL). If you
 * did not receive this file, see http://www.horde.org/licenses/gpl.
 *
 * @author Jan Schneider <jan@horde.org>
 */

/* Kronolith object. */
KronolithCore = {
    // Vars used and defaulting to null/false:
    //   weekSizes, daySizes,
    //   groupLoading, colorPicker, duration, timeMarker, monthDays,
    //   allDays, eventsWeek, initialized

    view: '',
    ecache: $H(),
    cacheStart: null,
    cacheEnd: null,
    holidays: [],
    tcache: $H(),
    eventsLoading: {},
    loading: 0,
    viewLoading: [],
    fbLoading: 0,
    redBoxLoading: false,
    date: Date.today(),
    tasktype: 'incomplete',
    knl: {},
    wrongFormat: $H(),
    mapMarker: null,
    map: null,
    mapInitialized: false,
    freeBusy: $H(),
    search: 'future',
    effectDur: 0.4,
    macos: navigator.appVersion.indexOf('Mac') != -1,
    orstart: null,
    orend: null,
    lastRecurType: 'None',
    uatts: null,
    ucb: null,
    resourceACCache: { choices: [], map: $H() },
    paramsCache: null,
    attendees: [],
    resources: [],

    /**
     * Flag that indicates if the event currently displayed in the event
     * properties window is a recurring event.
     *
     * @type boolean
     */
    recurs: false,

    /**
     * The location that was open before the current location.
     *
     * @var string
     */
    lastLocation: '',

    /**
     * The currently open location.
     *
     * @var string
     */
    openLocation: '',

    /**
     * The current (main) location.
     *
     * This is different from openLocation as it isn't updated for any
     * locations that are opened in a popup view, e.g. events.
     *
     * @var string
     */
    currentLocation: '',

    kronolithBody: $('kronolithBody'),

    onException: function(parentfunc, r, e)
    {
        /* Make sure loading images are closed. */
        this.loading--;
        if (!this.loading) {
            $('kronolithLoading').hide();
        }
        this.closeRedBox();
        HordeCore.notify(HordeCore.text.ajax_error, 'horde.error');
        parentfunc(r, e);
    },

    setTitle: function(title)
    {
        document.title = Kronolith.conf.name + ' :: ' + title;
        return title;
    },

    // url = (string) URL to redirect to
    // hash = (boolean) If true, url is treated as hash information to alter
    //        on the current page
    redirect: function(url, hash)
    {
        if (hash) {
            window.location.hash = escape(url);
            window.location.reload();
        } else {
            HordeCore.redirect(url);
        }
    },

    go: function(fullloc, data)
    {
        if (!this.initialized) {
            this.go.bind(this, fullloc, data).defer();
            return;
        }

        if (this.viewLoading.size()) {
            this.viewLoading.push([ fullloc, data ]);
            return;
        }

        var locParts = fullloc.split(':');
        var loc = locParts.shift();

        if (this.openLocation == fullloc) {
            return;
        }

        this.viewLoading.push([ fullloc, data ]);

        if (loc != 'search') {
            HordeTopbar.searchGhost.reset();
        }

        this.switchTaskView(false);

        switch (loc) {
        case 'day':
        case 'week':
        case 'workweek':
        case 'month':
        case 'year':
        case 'agenda':
        case 'tasks':
            this.closeView(loc);
            var locCap = loc.capitalize();
            $('kronolithNav' + locCap).up().addClassName('horde-active');

            switch (loc) {
            case 'day':
            case 'agenda':
            case 'week':
            case 'workweek':
            case 'month':
            case 'year':
                var date = locParts.shift();
                if (date) {
                    date = this.parseDate(date);
                } else {
                    date = this.date;
                }

                if (this.view != 'agenda' &&
                    this.view == loc &&
                    date.getYear() == this.date.getYear() &&
                    ((loc == 'year') ||
                     (loc == 'month' && date.getMonth() == this.date.getMonth()) ||
                     ((loc == 'week' || loc == 'workweek') && date.getRealWeek() == this.date.getRealWeek()) ||
                     ((loc == 'day'  || loc == 'agenda') && date.dateString() == this.date.dateString()))) {
                         this.setViewTitle(date, loc);
                         this.addHistory(fullloc);
                         this.loadNextView();
                         return;
                }

                this.addHistory(fullloc);
                this.view = loc;
                this.date = date;
                this.updateView(date, loc);
                var dates = this.viewDates(date, loc);
                this.loadEvents(dates[0], dates[1], loc);
                $('kronolithView' + locCap).appear({
                        duration: this.effectDur,
                        queue: 'end',
                        afterFinish: function() {
                            if (loc == 'week' || loc == 'workweek' || loc == 'day') {
                                this.calculateRowSizes(loc + 'Sizes', 'kronolithView' + locCap);
                                if ($('kronolithTimeMarker')) {
                                    this.positionTimeMarker();
                                }
                                if ($('kronolithTimeMarker')) {
                                    $('kronolithTimeMarker').show();
                                }
                                // Scroll to the work day start time.
                                $('kronolithView' + locCap).down('.kronolithViewBody').scrollTop = 9 * this[loc + 'Sizes'].height;
                            }
                            this.loadNextView();
                        }.bind(this)
                });
                $('kronolithLoading' + loc).insert($('kronolithLoading').remove());
                this.updateMinical(date, loc);

                break;

            case 'tasks':
                var tasktype = locParts.shift() || this.tasktype;


                this.switchTaskView(true);
                $('kronolithCurrent')
                    .update(this.setTitle(Kronolith.text.tasks));
                if (this.view == loc && this.tasktype == tasktype) {
                    this.addHistory(fullloc);
                    this.loadNextView();
                    return;
                }
                if (!$w('all complete incomplete future').include(tasktype)) {
                    this.loadNextView();
                    return;
                }

                this.addHistory(fullloc);
                this.view = loc;
                this.tasktype = tasktype;
                $w('All Complete Incomplete Future').each(function(tasktype) {
                    $('kronolithTasks' + tasktype).up().removeClassName('horde-active');
                });
                $('kronolithTasks' + this.tasktype.capitalize()).up().addClassName('horde-active');
                this.loadTasks(this.tasktype);
                $('kronolithView' + locCap).appear({
                    duration: this.effectDur,
                    queue: 'end',
                    afterFinish: function() {
                        this.loadNextView();
                    }.bind(this) });
                $('kronolithLoading' + loc).insert($('kronolithLoading').remove());
                this.updateMinical(this.date);

                break;

            default:
                if (!$('kronolithView' + locCap)) {
                    break;
                }
                this.addHistory(fullloc);
                this.view = loc;
                $('kronolithView' + locCap).appear({
                    duration: this.effectDur,
                    queue: 'end',
                    afterFinish: function() {
                        this.loadNextView();
                    }.bind(this) });
                break;
            }

            break;

        case 'search':
            var cals = [], time = locParts[0], term = locParts[1],
                query = Object.toJSON({ title: term });

            if (!($w('all past future').include(time))) {
                this.loadNextView();
                return;
            }

            this.addHistory(fullloc);
            this.search = time;
            $w('All Past Future').each(function(time) {
                $('kronolithSearch' + time).up().removeClassName('horde-active');
            });
            $('kronolithSearch' + this.search.capitalize()).up().addClassName('horde-active');
            this.closeView('agenda');
            this.view = 'agenda';
            this.updateView(null, 'search', term);
            $H(Kronolith.conf.calendars).each(function(type) {
                $H(type.value).each(function(calendar) {
                    if (calendar.value.show) {
                        cals.push(type.key + '|' + calendar.key);
                    }
                });
            });
            $('kronolithAgendaNoItems').hide();
            this.startLoading('search', query);

            HordeCore.doAction('searchEvents', {
                cals: Object.toJSON(cals),
                query: query,
                time: this.search
            }, {
                callback: function(r) {
                    // Hide spinner.
                    this.loading--;
                    if (!this.loading) {
                        $('kronolithLoading').hide();
                    }
                    if (r.view != 'search' ||
                        r.query != this.eventsLoading.search) {
                        return;
                    }
                    if (Object.isUndefined(r.events)) {
                        $('kronolithAgendaNoItems').show();
                        return;
                    }
                    delete this.eventsLoading.search;
                    $H(r.events).each(function(calendars) {
                        $H(calendars.value).each(function(events) {
                            this.createAgendaDay(events.key);
                            $H(events.value).each(function(event) {
                                event.value.calendar = calendars.key;
                                event.value.start = Date.parse(event.value.s);
                                event.value.end = Date.parse(event.value.e);
                                this.insertEvent(event, events.key, 'agenda');
                            }, this);
                        }, this);
                    }, this);
                }.bind(this)
            });

            $('kronolithViewAgenda').appear({
                duration: this.effectDur,
                queue: 'end',
                afterFinish: function() {
                    this.loadNextView();
                }.bind(this) });
            $('kronolithLoadingagenda').insert($('kronolithLoading').remove());
            this.updateMinical(this.date);
            break;

        case 'event':
            // Load view first if necessary.
            if (!this.view ) {
                this.viewLoading.pop();
                this.go(Kronolith.conf.login_view);
                this.go.bind(this, fullloc, data).defer();
                return;
            }

            if (this.currentLocation == fullloc) {
                this.loadNextView();
                return;
            }

            this.addHistory(fullloc, false);
            switch (locParts.length) {
            case 0:
                // New event.
                this.editEvent();
                break;
            case 1:
                // New event on a certain date.
                this.editEvent(null, null, locParts[0]);
                break;
            default:
                // Editing event.
                var date = locParts.pop(),
                    event = locParts.pop(),
                    calendar = locParts.join(':');
                this.editEvent(calendar, event, date);
                break;
            }
            this.loadNextView();
            break;

        case 'task':
            // Load view first if necessary.
            if (!this.view ) {
                this.viewLoading.pop();
                this.go('tasks');
                this.go.bind(this, fullloc, data).defer();
                return;
            }

            this.switchTaskView(true);
            switch (locParts.length) {
            case 0:
                this.addHistory(fullloc, false);
                this.editTask();
                break;
            case 2:
                this.addHistory(fullloc, false);
                this.editTask(locParts[0], locParts[1]);
                break;
            }
            this.loadNextView();
            break;

        case 'calendar':
            if (!this.view) {
                this.viewLoading.pop();
                this.go(Kronolith.conf.login_view);
                this.go.bind(this, fullloc, data).defer();
                return;
            }
            this.addHistory(fullloc, false);
            this.editCalendar(locParts.join(':'));
            this.loadNextView();
            break;

        default:
            this.loadNextView();
            break;
        }
    },

    /**
     * Removes the last loaded view from the stack and loads the last added
     * view, if the stack is still not empty.
     *
     * We want to load views from a LIFO queue, because the queue is only
     * building up if the user switches to another view while the current view
     * still loads. In that case we can go directly to the most recently
     * clicked view and drop the remaining queue.
     */
    loadNextView: function()
    {
        var current = this.viewLoading.shift();
        if (this.viewLoading.size()) {
            var next = this.viewLoading.pop();
            this.viewLoading = [];
            if (current[0] != next[0] || current[1] || next[1]) {
                this.go(next[0], next[1]);
            }
        }
    },

    /**
     * Rebuilds one of the calendar views for a new date.
     *
     * @param Date date    The date to show in the calendar.
     * @param string view  The view that's rebuilt.
     * @param mixed data   Any additional data that might be required.
     */
    updateView: function(date, view, data)
    {
        this.holidays = [];

        switch (view) {
        case 'day':
            var today = Date.today();
            this.dayEvents = [];
            this.dayGroups = [];
            this.allDayEvents = [];
            $('kronolithCurrent')
                .update(this.setViewTitle(date, view, data));
            $('kronolithViewDay')
                .down('.kronolithAllDayContainer')
                .store('date', date.dateString());
            $('kronolithEventsDay').store('date', date.dateString());
            if (date.equals(today)) {
                this.addTimeMarker('kronolithEventsDay');
            }
            break;

        case 'week':
        case 'workweek':
            this.dayEvents = [];
            this.dayGroups = [];
            this.allDayEvents = [];
            this.allDays = {};
            this.eventsWeek = {};
            var what = view == 'week' ? 'Week' : 'Workweek',
                div = $('kronolithEvents' + what).down('div'),
                th = $('kronolithView' + what + 'Head').down('.kronolithWeekDay'),
                td = $('kronolithView' + what + 'Head').down('tbody td').next('td'),
                hourRow = $('kronolithView' + what + 'Body').down('tr'),
                dates = this.viewDates(date, view),
                today = Date.today(),
                day, dateString, i, hourCol;

            $('kronolithCurrent')
                .update(this.setViewTitle(date, view, data));

            for (i = 0; i < 24; i++) {
                day = dates[0].clone();
                hourCol = hourRow.down('td').next('td');
                while (hourCol) {
                    hourCol.removeClassName('kronolith-today');
                    if (day.equals(today)) {
                        hourCol.addClassName('kronolith-today');
                    }
                    hourCol = hourCol.next('td');
                    day.next().day();
                }
                hourRow = hourRow.next('tr');
            }
            day = dates[0].clone();

            for (i = 0; i < (view == 'week' ? 7 : 5); i++) {
                dateString = day.dateString();
                this.allDays['kronolithAllDay' + dateString] = td.down('div');
                this.eventsWeek['kronolithEvents' + what + dateString] = div;
                div.store('date', dateString)
                    .writeAttribute('id', 'kronolithEvents' + what + dateString);
                th.store('date', dateString)
                    .down('span').update(day.toString('dddd, d'));
                td.removeClassName('kronolith-today');
                this.allDays['kronolithAllDay' + dateString]
                    .writeAttribute('id', 'kronolithAllDay' + dateString)
                    .store('date', dateString);
                if (day.equals(today)) {
                    td.addClassName('kronolith-today');
                    this.addTimeMarker('kronolithEvents' + what + dateString);
                }
                new Drop(td.down('div'));
                div = div.next('div');
                th = th.next('td');
                td = td.next('td');
                day.next().day();
            }
            break;

        case 'month':
            var tbody = $('kronolith-month-body'),
                dates = this.viewDates(date, view),
                day = dates[0].clone();

            $('kronolithCurrent')
                .update(this.setViewTitle(date, view, data));

            // Remove old rows. Maybe we should only rebuild the calendars if
            // necessary.
            tbody.childElements().each(function(row) {
                if (row.identify() != 'kronolithRowTemplate') {
                    row.purge();
                    row.remove();
                }
            });

            // Build new calendar view.
            this.monthDays = {};
            while (!day.isAfter(dates[1])) {
                tbody.insert(this.createWeekRow(day, date.getMonth(), dates).show());
                day.next().week();
            }
            this.equalRowHeights(tbody);

            break;

        case 'year':
            var month;

            $('kronolithCurrent').update(this.setViewTitle(date, view, data));

            // Build new calendar view.
            for (month = 0; month < 12; month++) {
                $('kronolithYear' + month).update(this.createYearMonth(date.getFullYear(), month, 'kronolithYear').show());
            }

            break;

        case 'agenda':
        case 'search':
            // Agenda days are only created on demand, if there are any events
            // to add.
            if (view == 'agenda') {
                var dates = this.viewDates(date, view);
                $('kronolithCurrent')
                    .update(this.setViewTitle(date, view, data));
                $('kronolithSearchNavigation').up().up().hide();
            } else {
                $('kronolithCurrent')
                    .update(this.setViewTitle(date, view, data));
                $('kronolithSearchNavigation').up().up().show();
            }

            // Remove old rows. Maybe we should only rebuild the calendars if
            // necessary.
            tbody = $('kronolithViewAgendaBody').childElements().each(function(row) {
                if (row.identify() != 'kronolithAgendaTemplate' &&
                    row.identify() != 'kronolithAgendaNoItems') {
                    row.purge();
                    row.remove();
                }
            });

            break;
        }
    },

    /**
     * Sets the browser title of the calendar views.
     *
     * @param Date date    The date to show in the calendar.
     * @param string view  The view that's displayed.
     * @param mixed data   Any additional data that might be required.
     */
    setViewTitle: function(date, view, data)
    {
        switch (view) {
        case 'day':
            return this.setTitle(date.toString('D'));

        case 'week':
        case 'workweek':
            var dates = this.viewDates(date, view);
            return this.setTitle(dates[0].toString(Kronolith.conf.date_format) + ' - ' + dates[1].toString(Kronolith.conf.date_format));

        case 'month':
            return this.setTitle(date.toString('MMMM yyyy'));

        case 'year':
            return this.setTitle(date.toString('yyyy'));

        case 'agenda':
            var dates = this.viewDates(date, view);
            return this.setTitle(dates[0].toString(Kronolith.conf.date_format) + ' - ' + dates[1].toString(Kronolith.conf.date_format));

        case 'search':
            return this.setTitle(Kronolith.text.searching.interpolate({ term: data })).escapeHTML();
        }
    },

    /**
     * Closes the currently active view.
     */
    closeView: function(loc)
    {
        $w('Day Workweek Week Month Year Tasks Agenda').each(function(a) {
            a = $('kronolithNav' + a);
            if (a) {
                a.up().removeClassName('horde-active');
            }
        });
        if (this.view && this.view != loc) {
            $('kronolithView' + this.view.capitalize()).fade({
                duration: this.effectDur,
                queue: 'end'
            });
            this.view = null;
        }
    },

    /**
     * Creates a single row of day cells for usage in the month and multi-week
     * views.
     *
     * @param Date date        The first day to show in the row.
     * @param integer month    The current month. Days not from the current
     *                         month get the kronolith-other-month CSS class
     *                         assigned.
     * @param array viewDates  Array of Date objects with the start and end
     *                         dates of the view.
     *
     * @return Element  The element rendering a week row.
     */
    createWeekRow: function(date, month, viewDates)
    {
        var day = date.clone(), today = new Date().dateString(),
            row, cell, dateString;

        // Create a copy of the row template.
        row = $('kronolithRowTemplate').clone(true);
        row.removeAttribute('id');

        // Fill week number and day cells.
        cell = row.down()
            .setText(date.getRealWeek())
            .store('date', date.dateString())
            .next();
        while (cell) {
            dateString = day.dateString();
            this.monthDays['kronolithMonthDay' + dateString] = cell;
            cell.id = 'kronolithMonthDay' + dateString;
            cell.store('date', dateString);
            cell.removeClassName('kronolith-other-month').removeClassName('kronolith-today');
            if (day.getMonth() != month) {
                cell.addClassName('kronolith-other-month');
            }
            if (dateString == today) {
                cell.addClassName('kronolith-today');
            }
            new Drop(cell);
            cell.store('date', dateString)
                .down('.kronolith-day')
                .store('date', dateString)
                .update(day.getDate());

            cell = cell.next();
            day.add(1).day();
        }

        return row;
    },

    /**
     * Creates a table row for a single day in the agenda view, if it doesn't
     * exist yet.
     *
     * @param string date    The day to show in the row.
     *
     * @return Element  The element rendering a week row.
     */
    createAgendaDay: function(date)
    {
        // Exit if row exists already.
        if ($('kronolithAgendaDay' + date)) {
            return;
        }

        // Create a copy of the row template.
        var body = $('kronolithViewAgendaBody'),
            row = $('kronolithAgendaTemplate').clone(true);

        // Fill week number and day cells.
        row.store('date', date)
            .down()
            .setText(this.parseDate(date).toString('D'))
            .next()
            .writeAttribute('id', 'kronolithAgendaDay' + date);
        row.removeAttribute('id');

        // Insert row.
        var nextRow;
        body.childElements().each(function(elm) {
            if (elm.retrieve('date') > date) {
                nextRow = elm;
                throw $break;
            }
        });
        if (nextRow) {
            nextRow.insert({ before: row.show() });
        } else {
            body.insert(row.show());
        }

        return row;
    },

    /**
     * Creates a table for a single month in the year view.
     *
     * @param integer year     The year.
     * @param integer month    The month.
     * @param string idPrefix  If present, each day will get a DOM ID with this
     *                         prefix
     *
     * @return Element  The element rendering a month table.
     */
    createYearMonth: function(year, month, idPrefix)
    {
        // Create a copy of the month template.
        var table = $('kronolithYearTemplate').clone(true),
            tbody = table.down('tbody');
        table.removeAttribute('id');
        tbody.writeAttribute('id', 'kronolithYearTable' + month);

        // Set month name.
        table.down('tr.kronolith-minical-nav th')
            .store('date', year.toPaddedString(4) + (month + 1).toPaddedString(2) + '01')
            .update(Date.CultureInfo.monthNames[month]);

        // Build month table.
        this.buildMinical(tbody, new Date(year, month, 1), null, idPrefix, year);

        return table;
    },

    equalRowHeights: function(tbody)
    {
        var children = tbody.childElements();
        children.invoke('setStyle', { height: (100 / (children.size() - 1)) + '%' });
    },

    /**
     * Calculates some dimensions for the day and week view.
     *
     * @param string storage  Property name where the dimensions are stored.
     * @param string view     DOM node ID of the view.
     */
    calculateRowSizes: function(storage, view)
    {
        if (!Object.isUndefined(this[storage])) {
            return;
        }

        var td = $(view).down('.kronolithViewBody tr td').next('td'),
            layout = td.getLayout(),
            spacing = td.up('table').getStyle('borderSpacing');

        // FIXME: spacing is hardcoded for IE 7 because it doesn't know about
        // border-spacing, but still uses it. WTF?
        spacing = spacing ? parseInt($w(spacing)[1], 10) : 2;
        this[storage] = {};
        this[storage].height = layout.get('margin-box-height') + spacing;
        this[storage].spacing = this[storage].height - layout.get('padding-box-height') - layout.get('border-bottom');
    },

    /**
     * Adds a horizontal ruler representing the current time to the specified
     * container.
     *
     * @param string|Element  The container of the current day.
     */
    addTimeMarker: function(container)
    {
        if ($('kronolithTimeMarker')) {
            $('kronolithTimeMarker').remove();
            this.timeMarker.stop();
        }
        $(container).insert(new Element('div', { id: 'kronolithTimeMarker' }).setStyle({ position: 'absolute' }).hide());
        this.timeMarker = new PeriodicalExecuter(this.positionTimeMarker.bind(this), 60);
    },

    /**
     * Updates the horizontal ruler representing the current time.
     */
    positionTimeMarker: function()
    {
        var today = Date.today(), now;

        switch (this.view) {
        case 'day':
            if (!this.date.equals(today)) {
                $('kronolithTimeMarker').remove();
                this.timeMarker.stop();
                return;
            }
            break;
        case 'week':
        case 'workweek':
            if ($('kronolithTimeMarker').up().retrieve('date') != today.dateString()) {
                var newContainer = this.eventsWeek['kronolithEvents' + (this.view == 'week' ? 'Week' : 'Workweek') + today.dateString()];
                $('kronolithTimeMarker').remove();
                if (newContainer) {
                    this.addTimeMarker(newContainer);
                } else {
                    this.timeMarker.stop();
                }
                return;
            }
            break;
        default:
            $('kronolithTimeMarker').remove();
            this.timeMarker.stop();
            return;
        }

        now = new Date();
        $('kronolithTimeMarker').setStyle({ top: ((now.getHours() * 60 + now.getMinutes()) * this[this.view + 'Sizes'].height / 60 | 0) + 'px' });
    },

    /**
     * Rebuilds the mini calendar.
     *
     * @param Date date    The date to show in the calendar.
     * @param string view  The view that's displayed, determines which days in
     *                     the mini calendar are highlighted.
     */
    updateMinical: function(date, view)
    {
        // Update header.
        $('kronolithMinicalDate')
            .store('date', date.dateString())
            .update(date.toString('MMMM yyyy'));

        this.buildMinical($('kronolith-minical').down('tbody'), date, view);
    },

    /**
     * Creates a mini calendar suitable for the navigation calendar and the
     * year view.
     *
     * @param Element tbody    The table body to add the days to.
     * @param Date date        The date to show in the calendar.
     * @param string view      The view that's displayed, determines which days
     *                         in the mini calendar are highlighted.
     * @param string idPrefix  If present, each day will get a DOM ID with this
     *                         prefix
     * @param integer year     If present, generating mini calendars for the
     *                         year view of this year.
     */
    buildMinical: function(tbody, date, view, idPrefix, year)
    {
        var dates = this.viewDates(date, 'month'),
            day = dates[0].clone(),
            date7 = date.clone().add(1).week(),
            today = Date.today(),
            week = this.viewDates(this.date, 'week'),
            workweek = this.viewDates(this.date, 'workweek'),
            dateString, td, tr, i;

        // Remove old calendar rows. Maybe we should only rebuild the minical
        // if necessary.
        tbody.childElements().invoke('remove');

        for (i = 0; i < 42; i++) {
            dateString = day.dateString();
            // Create calendar row and insert week number.
            if (day.getDay() == Kronolith.conf.week_start) {
                tr = new Element('tr');
                tbody.insert(tr);
                td = new Element('td', { className: 'kronolith-minical-week' })
                    .store('weekdate', dateString);
                td.update(day.getRealWeek());
                tr.insert(td);
                weekStart = day.clone();
                weekEnd = day.clone();
                weekEnd.add(6).days();
            }

            // Insert day cell.
            td = new Element('td').store('date', dateString);
            if (day.getMonth() != date.getMonth()) {
                td.addClassName('kronolith-other-month');
            } else if (!Object.isUndefined(idPrefix)) {
                td.id = idPrefix + dateString;
            }

            // Highlight days currently being displayed.
            if (view &&
                ((view == 'month' && this.date.between(dates[0], dates[1])) ||
                 (view == 'week' && day.between(week[0], week[1])) ||
                 (view == 'workweek' && day.between(workweek[0], workweek[1])) ||
                 (view == 'day' && day.equals(this.date)) ||
                 (view == 'agenda' && !day.isBefore(date) && day.isBefore(date7)))) {
                td.addClassName('kronolith-selected');
            }

            // Highlight today.
            if (day.equals(today) &&
                (Object.isUndefined(year) ||
                 (day.getYear() + 1900 == year &&
                  date.getMonth() == day.getMonth()))) {
                td.addClassName('kronolith-today');
            }
            td.insert(new Element('a').update(day.getDate()));
            tr.insert(td);
            day.next().day();
        }
    },

    /**
     * Inserts a calendar entry in the sidebar menu.
     *
     * @param string type  The calendar type.
     * @param string id    The calendar id.
     * @param object cal   The calendar object.
     * @param Element div  Container DIV where to add the entry (optional).
     */
    insertCalendarInList: function(type, id, cal, div)
    {
        var noItems, calendar, link;
        if (!div) {
            div = this.getCalendarList(type, cal.owner);
        }
        noItems = div.previous();
        if (noItems &&
            noItems.tagName == 'DIV' &&
            noItems.className == 'horde-info') {
            noItems.hide();
        }
        link = new Element('span', { className: type != 'resourcegroup' ? (cal.show ? 'horde-resource-on' : 'horde-resource-off') : 'horde-resource-none' })
            .insert(cal.name.escapeHTML());
        calendar = new Element('div')
            .store('calendar', id)
            .store('calendarclass', type)
            .setStyle({ backgroundColor: cal.bg, color: cal.fg });
        if (type != 'holiday' && type != 'external') {
            calendar.insert(
                new Element('span', { className: 'horde-resource-edit-' + cal.fg.substring(1) })
                    .setStyle({ backgroundColor: cal.bg, color: cal.fg })
                    .insert('&#9658;'));
        }
        calendar.insert(
            new Element('div', { className: 'horde-resource-link' })
                .insert(link));
        this.addShareIcon(cal, link);
        div.insert(calendar);
        if (cal.show) {
            this.addCalendarLegend(type, id, cal);
        }
    },

    /**
     * Add the share icon after the calendar name in the calendar list.
     *
     * @param object cal       A calendar object from Kronolith.conf.calendars.
     * @param Element element  The calendar element in the list.
     */
    addShareIcon: function(cal, element)
    {
        if (cal.owner && cal.perms) {
            $H(cal.perms).each(function(perm) {
                if (perm.key != 'type' &&
                    ((Object.isArray(perm.value) && perm.value.size()) ||
                     (!Object.isArray(perm.value) && perm.value))) {
                    element.insert(' ').insert(new Element('img', { src: Kronolith.conf.images.attendees.replace(/fff/, cal.fg.substring(1)), title: Kronolith.text.shared }));
                    throw $break;
                }
            });
        }
    },

    /**
     * Rebuilds the list of calendars.
     */
    updateCalendarList: function()
    {
        var ext = $H(), extNames = $H(),
            extContainer = $('kronolithExternalCalendars');

        $H(Kronolith.conf.calendars.internal).each(function(cal) {
            this.insertCalendarInList('internal', cal.key, cal.value);
        }, this);

        if (Kronolith.conf.tasks) {
            $H(Kronolith.conf.calendars.tasklists).each(function(cal) {
                this.insertCalendarInList('tasklists', cal.key, cal.value);
            }, this);
        }

        if (Kronolith.conf.calendars.resource) {
            $H(Kronolith.conf.calendars.resource).each(function(cal) {
               this.insertCalendarInList('resource', cal.key, cal.value);
            }, this);
        }

        if (Kronolith.conf.calendars.resourcegroup) {
            $H(Kronolith.conf.calendars.resourcegroup).each(function(cal) {
                this.insertCalendarInList('resourcegroup', cal.key, cal.value);
            }, this);
        }

        $H(Kronolith.conf.calendars.external).each(function(cal) {
            var parts = cal.key.split('/'), api = parts.shift();
            if (!ext.get(api)) {
                ext.set(api, $H());
            }
            ext.get(api).set(parts.join('/'), cal.value);
            extNames.set(api, cal.value.api ? cal.value.api : Kronolith.text.external_category);
        });
        ext.each(function(api) {
            extContainer
                .insert(new Element('div', { className: 'horde-sidebar-split' }))
                .insert(new Element('div')
                        .insert(new Element('h3')
                                .insert(new Element('span', { className: 'horde-expand', title: HordeSidebar.text.expand })
                                        .insert({ bottom: extNames.get(api.key).escapeHTML() })))
                        .insert(new Element('div', { id: 'kronolithExternalCalendar' + api.key, className: 'horde-resources', style: 'display:none' })));
            api.value.each(function(cal) {
                this.insertCalendarInList('external', api.key + '/' + cal.key, cal.value, $('kronolithExternalCalendar' + api.key));
            }, this);
        }, this);

        $H(Kronolith.conf.calendars.remote).each(function(cal) {
            this.insertCalendarInList('remote', cal.key, cal.value);
        }, this);

        if (Kronolith.conf.calendars.holiday) {
            $H(Kronolith.conf.calendars.holiday).each(function(cal) {
                if (cal.value.show) {
                   this.insertCalendarInList('holiday', cal.key, cal.value);
                }
            }, this);
        } else {
            $('kronolithAddholiday').up().hide();
            $('kronolithHolidayCalendars').hide();
        }
    },

    /**
     * Returns the DIV container that holds all calendars of a certain type.
     *
     * @param string type  A calendar type
     *
     * @return Element  The container of the calendar type.
     */
    getCalendarList: function(type, personal)
    {
        switch (type) {
        case 'internal':
            return personal
                ? $('kronolithMyCalendars')
                : $('kronolithSharedCalendars');
        case 'resource':
            return $('kronolithResourceCalendars');
        case 'resourcegroup':
            return $('kronolithResourceGroups');
        case 'tasklists':
            return personal
                ? $('kronolithMyTasklists')
                : $('kronolithSharedTasklists');
        case 'external':
            return $('kronolithExternalCalendars');
        case 'remote':
            return $('kronolithRemoteCalendars');
        case 'holiday':
            return $('kronolithHolidayCalendars');
        }
    },

    /**
     * Loads a certain calendar, if the current view is still a calendar view.
     *
     * @param string type      The calendar type.
     * @param string calendar  The calendar id.
     */
    loadCalendar: function(type, calendar)
    {
        if (Kronolith.conf.calendars[type][calendar].show &&
            $w('day workweek week month year agenda').include(this.view)) {
            var dates = this.viewDates(this.date, this.view);
            this.deleteCache([type, calendar]);
            this.loadEvents(dates[0], dates[1], this.view, [[type, calendar]]);
        }
    },

    /**
     * Toggles a calendars visibility.
     *
     * @param string type      The calendar type.
     * @param string calendar  The calendar id.
     */
    toggleCalendar: function(type, calendar)
    {
        var elt = $('kronolithMenuCalendars').select('div').find(function(div) {
            return div.retrieve('calendarclass') == type &&
            div.retrieve('calendar') == calendar;
        }).down('.horde-resource-link').down('span');

        Kronolith.conf.calendars[type][calendar].show = !Kronolith.conf.calendars[type][calendar].show;
        elt.toggleClassName('horde-resource-on');
        elt.toggleClassName('horde-resource-off');

        if (Kronolith.conf.calendars[type][calendar].show) {
            this.addCalendarLegend(type, calendar, Kronolith.conf.calendars[type][calendar]);
        } else {
            this.deleteCalendarLegend(type, calendar);
        }

        switch (this.view) {
        case 'month':
        case 'agenda':
            if (Object.isUndefined(this.ecache.get(type)) ||
                Object.isUndefined(this.ecache.get(type).get(calendar))) {
                this.loadCalendar(type, calendar);
            } else {
                var allEvents = this.kronolithBody.select('div').findAll(function(el) {
                    return el.retrieve('calendar') == type + '|' + calendar;
                });
                if (this.view == 'month' && Kronolith.conf.max_events) {
                    var dates = this.viewDates(this.date, this.view);
                    if (elt.hasClassName('horde-resource-off')) {
                        var day, more, events, calendars = [];
                        $H(Kronolith.conf.calendars).each(function(type) {
                            $H(type.value).each(function(cal) {
                                if (cal.value.show) {
                                    calendars.push(type.key + '|' + cal.key);
                                }
                            });
                        });
                        allEvents.each(function(el) {
                            if (el.retrieve('calendar').startsWith('holiday|')) {
                                this.holidays = this.holidays.without(el.retrieve('eventid'));
                            }
                            el.remove();
                        }, this);
                        for (var date = dates[0]; !date.isAfter(dates[1]); date.add(1).days()) {
                            day = this.monthDays['kronolithMonthDay' + date.dateString()];
                            more = day.select('.kronolithMore');
                            events = day.select('.kronolith-event');
                            if (more.size() &&
                                events.size() < Kronolith.conf.max_events) {
                                more[0].purge();
                                more[0].remove();
                                events.invoke('remove');
                                calendars.each(function(calendar) {
                                    this.insertEvents([date, date], 'month', calendar);
                                }, this);
                            }
                        }
                    } else {
                        this.insertEvents(dates, 'month', type + '|' + calendar);
                    }
                } else {
                    allEvents.invoke('toggle');
                }
            }
            break;

        case 'year':
        case 'week':
        case 'workweek':
        case 'day':
            if (Object.isUndefined(this.ecache.get(type)) ||
                Object.isUndefined(this.ecache.get(type).get(calendar))) {
                this.loadCalendar(type, calendar);
            } else {
                this.insertEvents(this.viewDates(this.date, this.view), this.view);
            }
            break;

        case 'tasks':
            if (type != 'tasklists') {
                break;
            }
            var tasklist = calendar.substr(6);
            if (elt.hasClassName('horde-resource-off')) {
                $('kronolithViewTasksBody').select('tr').findAll(function(el) {
                    return el.retrieve('tasklist') == tasklist;
                }).invoke('remove');
            } else {
                this.loadTasks(this.tasktype, [ tasklist ]);
            }
            break;
        }

        if ($w('tasklists remote external holiday resource').include(type)) {
            calendar = type + '_' + calendar;
        }
        HordeCore.doAction('saveCalPref', { toggle_calendar: calendar });
    },

    /**
     * Propagates a SELECT drop down list with the editable calendars.
     *
     * @param string id  The id of the SELECT element.
     */
    updateCalendarDropDown: function(id)
    {
        $(id).update();
        ['internal', 'remote'].each(function(type) {
            $H(Kronolith.conf.calendars[type]).each(function(cal) {
                if (cal.value.edit) {
                    $(id).insert(new Element('option', { value: type + '|' + cal.key })
                                 .setStyle({ backgroundColor: cal.value.bg, color: cal.value.fg })
                                 .update(cal.value.name.escapeHTML()));
                }
            });
        });
    },

    /**
     * Adds a calendar entry to the print legend.
     *
     * @param string type  The calendar type.
     * @param string id    The calendar id.
     * @param object cal   The calendar object.
     */
    addCalendarLegend: function(type, id, cal)
    {
        $('kronolith-legend').insert(
            new Element('span')
                .insert(cal.name.escapeHTML())
                .store('calendar', id)
                .store('calendarclass', type)
                .setStyle({ backgroundColor: cal.bg, color: cal.fg })
        );
    },

    /**
     * Deletes a calendar entry from the print legend.
     *
     * @param string type  The calendar type.
     * @param string id    The calendar id.
     */
    deleteCalendarLegend: function(type, id)
    {
        var legend = $('kronolith-legend').select('span').find(function(span) {
            return span.retrieve('calendarclass') == type &&
                span.retrieve('calendar') == id;
        });
        if (legend) {
            legend.remove();
        }
    },

    /**
     * Opens a tab in a form.
     *
     * @param Element  The A element of a tab.
     */
    openTab: function(elt)
    {
        var dialog = elt.up('form'), tab = $(elt.id.replace(/Link/, 'Tab')),
            field;
        dialog.select('.kronolithTabsOption').invoke('hide');
        dialog.select('.tabset li').invoke('removeClassName', 'horde-active');
        tab.show();
        elt.up().addClassName('horde-active');
        if (elt.id == 'kronolithEventLinkMap') {
            if (!this.mapInitialized) {
                this.initializeMap();
            }
        }
        field = tab.down('textarea');
        if (!field) {
            field = tab.down('input');
        }
        if (field) {
            try {
                field.focus();
            } catch (e) {}
        }
        switch (tab.identify()) {
        case 'kronolithEventTabAttendees':
            this.attendeeStartDateHandler(this.getFBDate());
            break;
        case 'kronolithEventTabResources':
            this.resourceStartDateHandler(this.getFBDate());
            break;
        }
    },

    /**
     * Sets the load signature and show the loading spinner.
     *
     * @param string resource   The loading resource.
     * @param string signatrue  The signature for this request.
     */
    startLoading: function(resource, signature)
    {
        this.eventsLoading[resource] = signature;
        this.loading++;
        $('kronolithLoading').show();
    },

    /**
     */
    loadEvents: function(firstDay, lastDay, view, calendars)
    {
        var loading = false;

        if (typeof calendars == 'undefined') {
            calendars = [];
            $H(Kronolith.conf.calendars).each(function(type) {
                $H(type.value).each(function(cal) {
                    if (cal.value.show) {
                        calendars.push([type.key, cal.key]);
                    }
                });
            });
        }

        calendars.each(function(cal) {
            var startDay = firstDay.clone(), endDay = lastDay.clone(),
                cals = this.ecache.get(cal[0]);

            if (typeof cals != 'undefined' &&
                typeof cals.get(cal[1]) != 'undefined') {
                cals = cals.get(cal[1]);
                while (!Object.isUndefined(cals.get(startDay.dateString())) &&
                       startDay.isBefore(endDay)) {
                    if (view != 'year') {
                        this.insertEvents([startDay, startDay], view, cal.join('|'));
                    }
                    startDay.add(1).day();
                }
                while (!Object.isUndefined(cals.get(endDay.dateString())) &&
                       (!startDay.isAfter(endDay))) {
                    if (view != 'year') {
                        this.insertEvents([endDay, endDay], view, cal.join('|'));
                    }
                    endDay.add(-1).day();
                }
                if (startDay.compareTo(endDay) > 0) {
                    return;
                }
            }
            var start = startDay.dateString(), end = endDay.dateString(),
                calendar = cal.join('|');
            loading = true;
            this.startLoading(calendar, start + end);
            this.storeCache($H(), calendar, null, true);

            HordeCore.doAction('listEvents', {
                start: start,
                end: end,
                cal: calendar,
                sig: start + end,
                view: view
            }, {
                callback: function(r) {
                    this.loadEventsCallback(r, true);
                }.bind(this)
            });
        }, this);

        if (!loading && view == 'year') {
            this.insertEvents([firstDay, lastDay], 'year');
        }
    },

    /**
     * Callback method for inserting events in the current view.
     *
     * @param object r             The ajax response object.
     * @param boolean createCache  Whether to create a cache list entry for the
     *                             response, if none exists yet. Useful for
     *                             (not) adding individual events to the cache
     *                             if it doesn't match any cached views.
     */
    loadEventsCallback: function(r, createCache)
    {
        // Hide spinner.
        this.loading--;
        if (!this.loading) {
            $('kronolithLoading').hide();
        }

        var start = this.parseDate(r.sig.substr(0, 8)),
            end = this.parseDate(r.sig.substr(8, 8)),
            dates = [start, end],
            currentDates;

        this.storeCache(r.events || {}, r.cal, dates, createCache);

        // Check if this is the still the result of the most current request.
        if (r.sig != this.eventsLoading[r.cal]) {
            return;
        }
        delete this.eventsLoading[r.cal];

        // Check if the calendar is still visible.
        var calendar = r.cal.split('|');
        if (!Kronolith.conf.calendars[calendar[0]][calendar[1]].show) {
            return;
        }

        // Check if the result is still for the current view.
        currentDates = this.viewDates(this.date, this.view);
        if (r.view != this.view ||
            !start.between(currentDates[0], currentDates[1])) {

            return;
        }

        if (this.view == 'day' ||
            this.view == 'week' ||
            this.view == 'workweek' ||
            this.view == 'month' ||
            this.view == 'agenda' ||
            (this.view == 'year' && !$H(this.eventsLoading).size())) {
            this.insertEvents(dates, this.view, r.cal);
        }
    },

    /**
     * Reads events from the cache and inserts them into the view.
     *
     * If inserting events into day and week views, the calendar parameter is
     * ignored, and events from all visible calendars are inserted instead.
     * This is necessary because the complete view has to be re-rendered if
     * events are not in chronological order.
     * The year view is specially handled too because there are no individual
     * events, only a summary of all events per day.
     *
     * @param Array dates      Start and end of dates to process.
     * @param string view      The view to update.
     * @param string calendar  The calendar to update.
     */
    insertEvents: function(dates, view, calendar)
    {
        switch (view) {
        case 'day':
        case 'week':
        case 'workweek':
            // The day and week views require the view to be completely
            // loaded, to correctly calculate the dimensions.
            if (this.viewLoading.size() || this.view != view) {
                this.insertEvents.bind(this, [dates[0].clone(), dates[1].clone()], view, calendar).defer();
                return;
            }
            break;
        }

        var day = dates[0].clone(),
                  viewDates = this.viewDates(this.date, this.view),
                  date, more, title, titles, events, monthDay, busyHours;
        while (!day.isAfter(dates[1])) {
            // Skip if somehow events slipped in though the view is gone.
            if (!day.between(viewDates[0], viewDates[1])) {
                if (window.console) {
                    window.console.trace();
                }
                day.next().day();
                continue;
            }

            date = day.dateString();
            switch (view) {
            case 'day':
            case 'week':
            case 'workweek':
                this.dayEvents = [];
                this.dayGroups = [];
                this.allDayEvents = [];
                if (view == 'day') {
                    $$('.kronolith-event').invoke('remove');
                } else {
                    this.eventsWeek['kronolithEvents' + (view == 'week' ? 'Week' : 'Workweek') + date]
                        .select('.kronolith-event')
                        .invoke('remove');
                    this.allDays['kronolithAllDay' + date]
                        .childElements()
                        .invoke('remove');
                }
                break;

            case 'month':
                monthDay = this.monthDays['kronolithMonthDay' + date];
                monthDay.select('div')
                    .findAll(function(el) { return el.retrieve('calendar') == calendar; })
                    .invoke('remove');
                break;

            case 'year':
                titles = [];
                busyHours = 0;
            }

            if (view == 'month' || view == 'agenda') {
                events = this.getCacheForDate(date, calendar);
            } else {
                events = this.getCacheForDate(date);
            }
            events.sortBy(this.sortEvents).each(function(event) {
                var insertBefore;
                switch (view) {
                case 'month':
                case 'agenda':
                    if (calendar.startsWith('holiday|')) {
                        if (this.holidays.include(event.key)) {
                            return;
                        }
                        this.holidays.push(event.key);
                    }
                    if (view == 'month' && Kronolith.conf.max_events) {
                        more = monthDay.down('.kronolithMore');
                        if (more) {
                            more.purge();
                            more.remove();
                        }
                    }
                    if (view == 'month') {
                        if (Kronolith.conf.max_events) {
                        var events = monthDay.select('.kronolith-event');
                        if (events.size() >= Kronolith.conf.max_events) {
                            if (date == (new Date().dateString())) {
                                // This is today.
                                if (event.value.al || event.value.end.isBefore()) {
                                    // No room for all-day or finished events.
                                    this.insertMore(date);
                                    return;
                                }
                                var remove, max;
                                // Find an event that is earlier than now or
                                // later then the current event.
                                events.each(function(elm) {
                                    var calendar = elm.retrieve('calendar').split('|'),
                                        event = this.ecache.get(calendar[0]).get(calendar[1]).get(date).get(elm.retrieve('eventid'));
                                    if (event.start.isBefore()) {
                                        remove = elm;
                                        throw $break;
                                    }
                                    if (!max || event.start.isAfter(max)) {
                                        max = event.start;
                                        remove = elm;
                                    }
                                }, this);
                                if (remove) {
                                    remove.purge();
                                    remove.remove();
                                    insertBefore = this.findInsertBefore(events.without(remove), event, date);
                                } else {
                                    this.insertMore(date);
                                    return;
                                }
                            } else {
                                // Not today.
                                var allDays = events.findAll(function(elm) {
                                    var calendar = elm.retrieve('calendar').split('|');
                                    return this.ecache.get(calendar[0]).get(calendar[1]).get(date).get(elm.retrieve('eventid')).al;
                                }.bind(this));
                                if (event.value.al) {
                                    // We want one all-day event.
                                    if (allDays.size()) {
                                        // There already is an all-day event.
                                        if (event.value.x == Kronolith.conf.status.confirmed ||
                                            event.value.x == Kronolith.conf.status.tentative) {
                                            // But is there a less important
                                            // one?
                                            var status = [Kronolith.conf.status.free, Kronolith.conf.status.cancelled];
                                            if (event.value.x == Kronolith.conf.status.confirmed) {
                                                status.push(Kronolith.conf.status.tentative);
                                            }
                                            var free = allDays.detect(function(elm) {
                                                var calendar = elm.retrieve('calendar').split('|');
                                                return status.include(this.ecache.get(calendar[0]).get(calendar[1]).get(date).get(elm.retrieve('eventid')).x);
                                            }.bind(this));
                                            if (!free) {
                                                this.insertMore(date);
                                                return;
                                            }
                                            insertBefore = free.next();
                                            free.purge();
                                            free.remove();
                                        } else {
                                            // No.
                                            this.insertMore(date);
                                            return;
                                        }
                                    } else {
                                        // Remove the last event to make room
                                        // for this one.
                                        var elm = events.pop();
                                        elm.purge();
                                        elm.remove();
                                        insertBefore = events.first();
                                    }
                                } else {
                                    if (allDays.size() > 1) {
                                        // We don't want more than one all-day
                                        // event.
                                        var elm = allDays.pop();
                                        // Remove element from events as well.
                                        events = events.without(elm);
                                        elm.purge();
                                        elm.remove();
                                        insertBefore = this.findInsertBefore(events, event, date);
                                    } else {
                                        // This day is full.
                                        this.insertMore(date);
                                        return;
                                    }
                                }
                            }
                            this.insertMore(date);
                        } else {
                            insertBefore = this.findInsertBefore(events, event, date);
                        }
                        } else {
                            var events = monthDay.select('.kronolith-event');
                            insertBefore = this.findInsertBefore(events, event, date);
                        }
                    }
                    break;

                case 'year':
                    title = '';
                    if (event.value.al) {
                        title += Kronolith.text.allday;
                    } else {
                        title += event.value.start.toString('t') + '-' + event.value.end.toString('t');
                    }
                    if (event.value.t) {
                        title += ': ' + event.value.t.escapeHTML();
                    }
                    if (event.value.x == Kronolith.conf.status.tentative ||
                        event.value.x == Kronolith.conf.status.confirmed) {
                        busyHours += event.value.start.getElapsed(event.value.end) / 3600000;
                    }
                    titles.push(title);
                    return;
                }
                this.insertEvent(event, date, view, insertBefore);
            }, this);

            switch (view) {
            case 'agenda':
                if ($('kronolithViewAgendaBody').select('tr').length > 2) {
                    $('kronolithAgendaNoItems').hide();
                } else {
                    $('kronolithAgendaNoItems').show();
                }
                break;

            case 'year':
                var td = $('kronolithYear' + date);
                if (td.className == 'kronolith-minical-empty') {
                    continue;
                }
                if (td.hasClassName('kronolith-today')) {
                    td.className = 'kronolith-today';
                } else {
                    td.className = '';
                }
                if (titles.length) {
                    td.addClassName('kronolithHasEvents');
                    if (busyHours > 0) {
                        td.addClassName(this.getHeatmapClass(busyHours));
                        busyHours = 0;
                    }
                    td.down('a').writeAttribute('nicetitle', Object.toJSON(titles));
                }
            }

            day.next().day();
        }
        // Workaround Firebug bug.
        Prototype.emptyFunction();
    },

    findInsertBefore: function(events, event, date)
    {
        var insertBefore, insertSort;
        events.each(function(elm) {
            var calendar = elm.retrieve('calendar').split('|'),
                existing = this.ecache
                    .get(calendar[0])
                    .get(calendar[1])
                    .get(date)
                    .get(elm.retrieve('eventid'));
            if (event.value.sort < existing.sort &&
                (!insertSort || existing.sort < insertSort)) {
                insertBefore = elm;
                insertSort = existing.sort;
            }
        }, this);
        return insertBefore;
    },

    getHeatmapClass: function(hours)
    {
        return 'heat' + Math.min(Math.ceil(hours / 2), 6);
    },

    /**
     * Creates the DOM node for an event bubble and inserts it into the view.
     *
     * @param object event    A Hash member with the event to insert.
     * @param string date     The day to update.
     * @param string view     The view to update.
     * @param Element before  Insert the event before this element (month view).
     */
    insertEvent: function(event, date, view, before)
    {
        var calendar = event.value.calendar.split('|');
        event.value.nodeId = ('kronolithEvent' + view + event.value.calendar + date + event.key).replace(new RegExp('[^a-zA-Z0-9]', 'g'), '');

        var _createElement = function(event) {
            var className ='kronolith-event';
            switch (event.value.x) {
            case 3:
                className += ' kronolith-event-cancelled';
                break;
            case 1:
            case 4:
                className += ' kronolith-event-tentative';
                break;
            }
            var el = new Element('div', { id: event.value.nodeId, className: className })
                .store('calendar', event.value.calendar)
                .store('eventid', event.key);
            if (!Object.isUndefined(event.value.aj)) {
                el.store('ajax', event.value.aj);
            }
            return el;
        };

        switch (view) {
        case 'day':
        case 'week':
        case 'workweek':
            var storage = view + 'Sizes',
                what = view == 'week' ? 'Week' : 'Workweek',
                div = _createElement(event),
                margin = view == 'day' ? 1 : 3,
                style = { backgroundColor: Kronolith.conf.calendars[calendar[0]][calendar[1]].bg,
                          color: Kronolith.conf.calendars[calendar[0]][calendar[1]].fg };

            div.writeAttribute('title', event.value.t);

            if (event.value.al) {
                if (view == 'day') {
                    $('kronolithViewDay').down('.kronolithAllDayContainer').insert(div.setStyle(style));
                } else {
                    var allDay = this.allDays['kronolithAllDay' + date],
                        existing = allDay.childElements(),
                        weekHead = $('kronolithView' + what + 'Head');
                    if (existing.size() == 3) {
                        if (existing[2].className != 'kronolithMore') {
                            existing[2].purge();
                            existing[2].remove();
                            allDay.insert({ bottom: new Element('span', { className: 'kronolithMore' }).store('date', date).insert(Kronolith.text.more) });
                        }
                    } else {
                        allDay.insert(div.setStyle(style));
                        if (event.value.pe) {
                            div.addClassName('kronolithEditable');
                            var layout = div.getLayout(),
                                minLeft = weekHead.down('.kronolith-first-col').getWidth() + this[storage].spacing + (parseInt(div.getStyle('marginLeft'), 10) || 0),
                                minTop = weekHead.down('thead').getHeight() + this[storage].spacing + (parseInt(div.getStyle('marginTop'), 10) || 0),
                                maxLeft = weekHead.getWidth() - layout.get('margin-box-width'),
                                maxTop = weekHead.down('thead').getHeight() + weekHead.down('.kronolith-all-day').getHeight(),
                                opts = {
                                    threshold: 5,
                                    parentElement: function() {
                                        return $('kronolithView' + what).down('.kronolith-view-head');
                                    },
                                    snap: function(x, y) {
                                        return [Math.min(Math.max(x, minLeft), maxLeft),
                                                Math.min(Math.max(y, minTop), maxTop - div.getHeight())];
                                    }
                                };
                            var d = new Drag(event.value.nodeId, opts);
                            div.store('drags', []);
                            Object.extend(d, {
                                event: event,
                                innerDiv: new Element('div'),
                                midnight: this.parseDate(date)
                            });
                            div.retrieve('drags').push(d);
                        }
                    }
                }
                break;
            }

            var midnight = this.parseDate(date),
                resizable = event.value.pe && (Object.isUndefined(event.value.vl) || event.value.vl),
                innerDiv = new Element('div', { className: 'kronolith-event-info' }),
                minHeight = 0, parentElement, draggerTop, draggerBottom,
                elapsed = (event.value.start.getHours() - midnight.getHours()) * 60 + (event.value.start.getMinutes() - midnight.getMinutes());
            switch (view) {
            case 'day':
                parentElement = $('kronolithEventsDay');
                break;
            case 'week':
                parentElement = this.eventsWeek['kronolithEventsWeek' + date];
                break;
            case 'workweek':
                parentElement = this.eventsWeek['kronolithEventsWorkweek' + date];
                break;
            }
            if (event.value.fi) {
                div.addClassName('kronolithFirst');
                if (resizable) {
                    draggerTop = new Element('div', { id: event.value.nodeId + 'top', className: 'kronolithDragger kronolithDraggerTop' }).setStyle(style);
                }
            } else {
                innerDiv.setStyle({ top: 0 });
            }
            if (event.value.la) {
                div.addClassName('kronolithLast');
                if (resizable) {
                    draggerBottom = new Element('div', { id: event.value.nodeId + 'bottom', className: 'kronolithDragger kronolithDraggerBottom' }).setStyle(style);
                }
            } else {
                innerDiv.setStyle({ bottom: 0 });
            }

            div.setStyle({
                top: (elapsed * this[storage].height / 60 | 0) + 'px',
                width: 100 - margin + '%'
            })
                .insert(innerDiv.setStyle(style));
            if (draggerTop) {
                div.insert(draggerTop);
            }
            if (draggerBottom) {
                div.insert(draggerBottom);
            }
            parentElement.insert(div);
            if (draggerTop) {
                minHeight += draggerTop.getHeight();
            }
            if (draggerBottom) {
                minHeight += draggerBottom.getHeight();
            }
            if (!minHeight) {
                minHeight = parseInt(innerDiv.getStyle('lineHeight'), 10)
                    + (parseInt(innerDiv.getStyle('paddingTop'), 10) || 0)
                    + (parseInt(innerDiv.getStyle('paddingBottom'), 10) || 0);
            }
            div.setStyle({ height: Math.max(Math.round(event.value.start.getElapsed(event.value.end) / 60000) * this[storage].height / 60 - this[storage].spacing | 0, minHeight) + 'px' });

            if (event.value.pe) {
                div.addClassName('kronolithEditable');
                div.store('drags', []);
                // Number of pixels that cover 10 minutes.
                var step = this[storage].height / 6,
                    stepX, minLeft, maxLeft, maxTop,
                    minBottom, maxBottom, dragBottomHeight;
                if (draggerBottom) {
                    // Height of bottom dragger
                    dragBottomHeight = draggerBottom.getHeight();
                }
                if (draggerTop) {
                    // Bottom-most position (maximum y) of top dragger
                    maxTop = div.offsetTop
                        - draggerTop.getHeight()
                        - parseInt(innerDiv.getStyle('lineHeight'), 10);
                    if (draggerBottom) {
                        maxTop += draggerBottom.offsetTop;
                    }
                }
                if (draggerBottom) {
                    // Top-most position (minimum y) of bottom dragger (upper
                    // edge)
                    minBottom = div.offsetTop
                        + parseInt(innerDiv.getStyle('lineHeight'), 10);
                    // Bottom-most position (maximum y) of bottom dragger
                    // (upper edge)
                    maxBottom = 24 * this[storage].height
                        + dragBottomHeight;
                    if (draggerTop) {
                        minBottom += draggerTop.getHeight();
                    }
                }
                    // Height of the whole event div
                var divHeight = div.getHeight(),
                    // Maximum height of the whole event div
                    maxDiv = 24 * this[storage].height - divHeight,
                    // Whether the top dragger is dragged, vs. the bottom
                    // dragger
                    opts = {
                        threshold: 5,
                        constraint: 'vertical',
                        scroll: this.kronolithBody,
                        nodrop: true,
                        parentElement: function() {
                            return parentElement;
                        }
                    };

                if (draggerTop) {
                    opts.snap = function(x, y) {
                        y = Math.max(0, step * (Math.min(maxTop, y - this.scrollTop) / step | 0));
                        return [0, y];
                    }.bind(this);
                    var d = new Drag(event.value.nodeId + 'top', opts);
                    Object.extend(d, {
                        event: event,
                        innerDiv: innerDiv,
                        midnight: midnight
                    });
                    div.retrieve('drags').push(d);
                }

                if (draggerBottom) {
                    opts.snap = function(x, y) {
                        y = Math.min(maxBottom + dragBottomHeight + KronolithCore[storage].spacing, step * ((Math.max(minBottom, y - this.scrollTop) + dragBottomHeight + KronolithCore[storage].spacing) / step | 0)) - dragBottomHeight - KronolithCore[storage].spacing;
                        return [0, y];
                    }.bind(this);
                    var d = new Drag(event.value.nodeId + 'bottom', opts);
                    Object.extend(d, {
                        event: event,
                        innerDiv: innerDiv,
                        midnight: midnight
                    });
                    div.retrieve('drags').push(d);
                }

                if (view == 'week' || view == 'workweek') {
                    var dates = this.viewDates(midnight, view);
                    minLeft = this.eventsWeek['kronolithEvents' + what + dates[0].dateString()].offsetLeft - this.eventsWeek['kronolithEvents' + what + date].offsetLeft;
                    maxLeft = this.eventsWeek['kronolithEvents' + what + dates[1].dateString()].offsetLeft - this.eventsWeek['kronolithEvents' + what + date].offsetLeft;
                    stepX = (maxLeft - minLeft) / (view == 'week' ? 6 : 4);
                }
                var d = new Drag(div, {
                    threshold: 5,
                    nodrop: true,
                    parentElement: function() { return parentElement; },
                    snap: function(x, y) {
                        x = (view == 'week' || view == 'workweek')
                            ? Math.max(minLeft, stepX * ((Math.min(maxLeft, x - (x < 0 ? stepX : 0)) + stepX / 2) / stepX | 0))
                            : 0;
                        y = Math.max(0, step * (Math.min(maxDiv, y - this.scrollTop) / step | 0));
                        return [x, y];
                    }.bind(this)
                });
                Object.extend(d, {
                    divHeight: divHeight,
                    startTop: div.offsetTop,
                    event: event,
                    midnight: midnight,
                    stepX: stepX
                });
                div.retrieve('drags').push(d);
            }

            var
                // The current column that we're probing for available space.
                column = 1,
                // The number of columns in the current conflict group.
                columns,
                // The column width in the current conflict group.
                width,
                // The first event that conflict with the current event.
                conflict = false,
                // The conflict group where this event should go.
                pos = this.dayGroups.length,
                // The event below that the current event fits.
                placeFound = false,
                // The minimum (virtual) duration of each event, defined by the
                // minimum height of an event DIV.
                minMinutes = (minHeight + this[storage].spacing) * 60 / this[storage].height;

            // this.dayEvents contains all events of the current day.
            // this.dayGroups contains conflict groups, i.e. all events that
            // conflict with each other and share a set of columns.
            //
            // Go through all events that have been added to this day already.
            this.dayEvents.each(function(ev) {
                // Due to the minimum height of an event DIV, events might
                // visually overlap, even if they physically don't.
                var minEnd = ev.start.clone().add(minMinutes).minutes(),
                    end = ev.end.isAfter(minEnd) ? ev.end : minEnd;

                // If it doesn't conflict with the current event, go ahead.
                if (!end.isAfter(event.value.start)) {
                    return;
                }

                // Found a conflicting event, now find its conflict group.
                for (pos = 0; pos < this.dayGroups.length; pos++) {
                    if (this.dayGroups[pos].indexOf(ev) != -1) {
                        // Increase column for each conflicting event in this
                        // group.
                        this.dayGroups[pos].each(function(ce) {
                            var minEnd = ce.start.clone().add(minMinutes).minutes(),
                                end = ce.end.isAfter(minEnd) ? ce.end : minEnd;
                            if (end.isAfter(event.value.start)) {
                                column++;
                            }
                        });
                        throw $break;
                    }
                }
            }, this);
            event.value.column = event.value.columns = column;

            if (Object.isUndefined(this.dayGroups[pos])) {
                this.dayGroups[pos] = [];
            }
            this.dayGroups[pos].push(event.value);

            // See if the current event had to add yet another column.
            columns = Math.max(this.dayGroups[pos][0].columns, column);

            // Update the widths of all events in a conflict group.
            width = 100 / columns;
            this.dayGroups[pos].each(function(ev) {
                ev.columns = columns;
                $(ev.nodeId).setStyle({ width: width - margin + '%', left: (width * (ev.column - 1)) + '%' });
            });
            this.dayEvents.push(event.value);

            div = innerDiv;
            break;

        case 'month':
            var monthDay = this.monthDays['kronolithMonthDay' + date],
                div = _createElement(event)
                .setStyle({ backgroundColor: Kronolith.conf.calendars[calendar[0]][calendar[1]].bg,
                            color: Kronolith.conf.calendars[calendar[0]][calendar[1]].fg });
            div.writeAttribute('title', event.value.t);
            if (before) {
                before.insert({ before: div });
            } else {
                monthDay.insert(div);
            }
            if (event.value.pe) {
                div.setStyle({ cursor: 'move' });
                new Drag(event.value.nodeId, { threshold: 5, parentElement: function() { return $('kronolith-month-body'); }, snapToParent: true });
            }
            if (Kronolith.conf.max_events) {
                var more = monthDay.down('.kronolithMore');
                if (more) {
                    monthDay.insert({ bottom: more.remove() });
                }
            }
            break;

        case 'agenda':
            var div = _createElement(event)
                .setStyle({ backgroundColor: Kronolith.conf.calendars[calendar[0]][calendar[1]].bg,
                            color: Kronolith.conf.calendars[calendar[0]][calendar[1]].fg });
            this.createAgendaDay(date);
            $('kronolithAgendaDay' + date).insert(div);
            break;
        }

        this.setEventText(div, event.value,
                          { time: view == 'agenda' || Kronolith.conf.show_time })
            .observe('mouseover', div.addClassName.curry('kronolith-selected'))
            .observe('mouseout', div.removeClassName.curry('kronolith-selected'));
    },

    /**
     * Re-renders the necessary parts of the current view, if any event changes
     * in those parts require re-rendering.
     *
     * @param Array dates  The date strings of days to re-render.
     */
    reRender: function(dates)
    {
        switch (this.view) {
        case 'week':
        case 'workweek':
        case 'day':
            dates.each(function(date) {
                date = this.parseDate(date);
                this.insertEvents([ date, date ], this.view);
            }, this);
            break;
        case 'month':
            dates.each(function(date) {
                var day = this.monthDays['kronolithMonthDay' + date];
                day.select('.kronolith-event').each(function(event) {
                    if (event.retrieve('calendar').startsWith('holiday')) {
                        delete this.holidays[event.retrieve('eventid')];
                    }
                    event.remove();
                }, this);
                day.select('.kronolithMore').invoke('remove');
                date = this.parseDate(date);
                this.loadEvents(date, date, 'month');
            }, this);
            break;
        }
    },

    /**
     * Returns all dates of the current view that contain (recurrences) of a
     * certain event.
     *
     * @param String cal      A calendar string.
     * @param String eventid  An event id.
     *
     * @return Array  A list of date strings that contain a recurrence of the
     *                event.
     */
    findEventDays: function(cal, eventid)
    {
        cal = cal.split('|');
        var cache = this.ecache.get(cal[0]).get(cal[1]),
            dates = this.viewDates(this.date, this.view),
            day = dates[0], days = [], dateString;
        while (!day.isAfter(dates[1])) {
            dateString = day.dateString();
            if (cache.get(dateString).get(eventid)) {
                days.push(dateString);
            }
            day.add(1).days();
        }
        return days;
    },

    /**
     * Adds a ""more..."" button to the month view cell that links to the days,
     * or moves it to the buttom.
     *
     * @param string date  The date string of the day cell.
     */
    insertMore: function(date)
    {
        var monthDay = this.monthDays['kronolithMonthDay' + date],
            more = monthDay.down('.kronolithMore');
        if (more) {
            monthDay.insert({ bottom: more.remove() });
        } else {
            monthDay.insert({ bottom: new Element('span', { className: 'kronolithMore' }).store('date', date).insert(Kronolith.text.more) });
        }
    },

    setEventText: function(div, event, opts)
    {
        var calendar = event.calendar.split('|'),
            span = new Element('span'),
            time, end;
        opts = Object.extend({ time: false }, opts || {});

        div.update();
        if (event.ic) {
            div.insert(new Element('img', { src: event.ic, className: 'kronolithEventIcon' }));
        }
        if (opts.time && !event.al) {
            time = new Element('span', { className: 'kronolith-time' })
                .insert(event.start.toString(Kronolith.conf.time_format));
            if (!event.start.equals(event.end)) {
                end = event.end.clone();
                if (end.getHours() == 23 &&
                    end.getMinutes() == 59 &&
                    end.getSeconds() == 59) {
                    end.add(1).second();
                }
                time.insert('-' + end.toString(Kronolith.conf.time_format));
            }
            div.insert(time).insert(' ');
        }
        div.insert(event.t.escapeHTML());
        div.insert(span);
        if (event.a) {
            span.insert(' ')
                .insert(new Element('img', { src: Kronolith.conf.images.alarm.replace(/fff/, Kronolith.conf.calendars[calendar[0]][calendar[1]].fg.substr(1)), title: Kronolith.text.alarm + ' ' + event.a }));
        }
        if (event.r) {
            span.insert(' ')
                .insert(new Element('img', { src: Kronolith.conf.images.recur.replace(/fff/, Kronolith.conf.calendars[calendar[0]][calendar[1]].fg.substr(1)), title: Kronolith.text.recur[event.r] }));
        } else if (event.bid) {
            div.store('bid', event.bid);
            span.insert(' ')
                .insert(new Element('img', { src: Kronolith.conf.images.exception.replace(/fff/, Kronolith.conf.calendars[calendar[0]][calendar[1]].fg.substr(1)), title: Kronolith.text.recur.exception }));
        }
        return div;
    },

    /**
     * Finally removes events from the DOM and the cache.
     *
     * @param string calendar  A calendar name.
     * @param string event     An event id. If empty, all events from the
     *                         calendar are deleted.
     */
    removeEvent: function(calendar, event)
    {
        this.deleteCache(calendar, event);
        this.kronolithBody.select('div.kronolith-event').findAll(function(el) {
            return el.retrieve('calendar') == calendar &&
                (!event || el.retrieve('eventid') == event);
        }).invoke('remove');
    },

    /**
     * Removes all events that reprensent exceptions to the event series
     * represented by uid.
     *
     * @param string calendar  A calendar name.
     * @param string uid       An event uid.
     */
    removeException: function(calendar, uid)
    {
        this.kronolithBody.select('div.kronolith-event').findAll(function(el) {
            if (el.retrieve('calendar') == calendar && el.retrieve('bid') == uid) {
                this.removeEvent(calendar, el.retrieve('eventid'));
            }
        }.bind(this));
    },

    /**
     * Calculates the event's start and end dates based on some drag and drop
     * information.
     */
    calculateEventDates: function(event, storage, step, offset, height, start, end)
    {
        if (!Object.isUndefined(start)) {
            event.start = start;
            event.end = end;
        }
        event.start.set({
            hour: offset / this[storage].height | 0,
            minute: Math.round(offset % this[storage].height / step) * 10
        });
        var hour = (offset + height + this[storage].spacing) / this[storage].height | 0,
            minute = Math.round((offset + height + this[storage].spacing) % this[storage].height / step) * 10,
            second = 0;
        if (hour == 24) {
            hour = 23;
            minute = 59;
            second = 59;
        }
        event.end.set({
            hour: hour,
            minute: minute,
            second: second
        });
    },

    switchTaskView: function(on)
    {
        if (on) {
            $('kronolithNewEvent', 'kronolithNewTask').compact()[0]
                .replace(Kronolith.conf.new_task);
            $('kronolithQuickEvent').addClassName('kronolithNewTask');
            $('kronolithHeader').down('.kronolithPrev').up().addClassName('disabled');
            $('kronolithHeader').down('.kronolithNext').up().addClassName('disabled');
        } else {
            $('kronolithNewEvent', 'kronolithNewTask').compact()[0]
                .replace(Kronolith.conf.new_event);
            $('kronolithQuickEvent').removeClassName('kronolithNewTask');
            $('kronolithHeader').down('.kronolithPrev').up().removeClassName('disabled');
            $('kronolithHeader').down('.kronolithNext').up().removeClassName('disabled');
        }
    },

    /**
     * Returns the task cache storage names that hold the tasks of the
     * requested task type.
     *
     * @param string tasktype  The task type.
     *
     * @return array  The list of task cache storage names.
     */
    getTaskStorage: function(tasktype)
    {
        var tasktypes;
        if (tasktype == 'all' || tasktype == 'future') {
            tasktypes = [ 'complete', 'incomplete' ];
        } else {
            tasktypes = [ tasktype ];
        }
        return tasktypes;
    },

    /**
     * Loads tasks, either from cache or from the server.
     *
     * @param integer tasktype  The tasks type (all, incomplete, complete, or
     *                          future).
     * @param Array tasksLists  The lists from where to obtain the tasks.
     */
    loadTasks: function(tasktype, tasklists)
    {
        var tasktypes = this.getTaskStorage(tasktype), loading = false,
            spinner = $('kronolithLoading');

        if (Object.isUndefined(tasklists)) {
            tasklists = [];
            $H(Kronolith.conf.calendars.tasklists).each(function(tasklist) {
                if (tasklist.value.show)
                {
                    tasklists.push(tasklist.key.substring(6));
                }
            });
        }

        tasktypes.each(function(type) {
            tasklists.each(function(list) {
                if (Object.isUndefined(this.tcache.get(type)) ||
                    Object.isUndefined(this.tcache.get(type).get(list))) {
                    loading = true;
                    this.loading++;
                    spinner.show();
                    HordeCore.doAction('listTasks', {
                        type: type,
                        list: list
                    }, {
                        callback: function(r) {
                            this.loadTasksCallback(r, true);
                        }.bind(this)
                    });
                }
            }, this);
        }, this);

        if (!loading) {
            tasklists.each(function(list) {
                this.insertTasks(tasktype, list);
            }, this);
        }
    },

    /**
     * Callback method for inserting tasks in the current view.
     *
     * @param object r             The ajax response object.
     * @param boolean createCache  Whether to create a cache list entry for the
     *                             response, if none exists yet. Useful for
     *                             (not) adding individual tasks to the cache
     *                             without assuming to have all tasks of the
     *                             list.
     */
    loadTasksCallback: function(r, createCache)
    {
        // Hide spinner.
        this.loading--;
        if (!this.loading) {
            $('kronolithLoading').hide();
        }

        this.storeTasksCache(r.tasks || {}, r.type, r.list, createCache);

        // Check if result is still valid for the current view.
        // There could be a rare race condition where two responses for the
        // same task(s) arrive in the wrong order. Checking this too, like we
        // do for events seems not worth it.
        var tasktypes = this.getTaskStorage(this.tasktype),
            tasklist = Kronolith.conf.calendars.tasklists['tasks/' + r.list];
        if (this.view != 'tasks' ||
            !tasklist || !tasklist.show ||
            !tasktypes.include(r.type)) {
            return;
        }
        this.insertTasks(this.tasktype, r.list);
    },

    /**
     * Reads tasks from the cache and inserts them into the view.
     *
     * @param integer tasktype  The tasks type (all, incomplete, complete, or
     *                          future).
     * @param string tasksList  The task list to be drawn.
     */
    insertTasks: function(tasktype, tasklist)
    {
        var tasktypes = this.getTaskStorage(tasktype), now = new Date();

        $('kronolithViewTasksBody').select('tr').findAll(function(el) {
            return el.retrieve('tasklist') == tasklist;
        }).invoke('remove');

        tasktypes.each(function(type) {
            if (!this.tcache.get(type)) {
                return;
            }
            var tasks = this.tcache.get(type).get(tasklist);
            $H(tasks).each(function(task) {
                switch (tasktype) {
                case 'complete':
                    if (!task.value.cp) {
                        return;
                    }
                    break;
                case 'incomplete':
                    if (task.value.cp ||
                        (!Object.isUndefined(task.value.start) &&
                         task.value.start.isAfter(now))) {
                        return;
                    }
                    break;
                case 'future':
                    if (task.value.cp ||
                        Object.isUndefined(task.value.start) ||
                        !task.value.start.isAfter(now)) {
                        return;
                    }
                    break;
                }
                this.insertTask(task);
            }, this);
        }, this);

        if ($('kronolithViewTasksBody').select('tr').length > 2) {
            $('kronolithTasksNoItems').hide();
        } else {
            $('kronolithTasksNoItems').show();
        }
    },

    /**
     * Creates the DOM node for a task and inserts it into the view.
     *
     * @param object task  A Hash with the task to insert
     */
    insertTask: function(task)
    {
        var row = $('kronolithTasksTemplate').clone(true),
            col = row.down(), tagc;


        row.removeAttribute('id');
        row.store('tasklist', task.value.l);
        row.store('taskid', task.key);
        col.addClassName('kronolithTask' + (!!task.value.cp ? 'Completed' : ''));
        col.setStyle({
            backgroundColor: Kronolith.conf.calendars.tasklists['tasks/' + task.value.l].bg,
            color: Kronolith.conf.calendars.tasklists['tasks/' + task.value.l].fg,
            textIndent: task.value.i + 'em'
        });
        col.insert(task.value.n.escapeHTML());
        if (!Object.isUndefined(task.value.due)) {
            var now = new Date();
            if (!now.isBefore(task.value.due)) {
                col.addClassName('kronolithTaskDue');
            }
            col.insert(new Element('span', { className: 'kronolithSeparator' }).update(' &middot; '));
            col.insert(new Element('span', { className: 'kronolithDate' }).update(task.value.due.toString(Kronolith.conf.date_format)));
            if (task.value.r) {
                col.insert(' ')
                    .insert(new Element('img', { src: Kronolith.conf.images.recur.replace(/fff/, Kronolith.conf.calendars.tasklists['tasks/' + task.value.l].fg.substr(1)), title: Kronolith.text.recur[task.value.r] }));
            }
        }

        if (!Object.isUndefined(task.value.sd)) {
            col.insert(new Element('span', { className: 'kronolithSeparator' }).update(' &middot; '));
            col.insert(new Element('span', { className: 'kronolithInfo' }).update(task.value.sd.escapeHTML()));
        }

        if (task.value.t && task.value.t.size() > 0) {
            tagc = new Element('ul', { className: 'horde-tags' });
            task.value.t.each(function(x) {
                tagc.insert(new Element('li').update(x.escapeHTML()));
            });
            col.insert(tagc);
        }
        row.insert(col.show());
        this.insertTaskPosition(row, task);
    },

    /**
     * Inserts the task row in the correct position.
     *
     * @param Element newRow  The new row to be inserted.
     * @param object newTask  A Hash with the task being added.
     */
    insertTaskPosition: function(newRow, newTask)
    {
        var rows = $('kronolithViewTasksBody').select('tr'),
            rowTasklist, rowTaskId, rowTask, parentFound;
        // The first row is a template, ignoring.
        for (var i = 2; i < rows.length; i++) {
            rowTasklist = rows[i].retrieve('tasklist');
            rowTaskId = rows[i].retrieve('taskid');
            if (newTask.value.p) {
                if (rowTaskId == newTask.value.p) {
                    parentFound = true;
                    continue;
                }
                if (!parentFound) {
                    continue;
                }
            }
            rowTask = this.tcache.inject(null, function(acc, list) {
                if (acc) {
                    return acc;
                }
                if (!Object.isUndefined(list.value.get(rowTasklist))) {
                    return list.value.get(rowTasklist).get(rowTaskId);
                }
            });

            if (Object.isUndefined(rowTask)) {
                // TODO: Throw error
                return;
            }
            if (!this.isTaskAfter(newTask.value, rowTask)) {
                break;
            }
        }
        rows[--i].insert({ after: newRow.show() });
    },

    /**
     * Analyzes which task should be drawn first.
     *
     * TODO: Very incomplete, only a dummy version
     */
    isTaskAfter: function(taskA, taskB)
    {
        // TODO: Make all ordering system
        if ((taskA.p || taskB.p) && taskA.p != taskB.p) {
            return !taskA.p;
        }
        return (taskA.pr >= taskB.pr);
    },

    /**
     * Completes/uncompletes a task.
     *
     * @param string tasklist          The task list to which the tasks belongs.
     * @param string taskid            The id of the task.
     * @param boolean|string complete  True if the task is completed, a
     *                                 due date if there are still
     *                                 incomplete recurrences.
     */
    toggleCompletion: function(tasklist, taskid, complete)
    {
        // Update the cache.
        var task = this.tcache.inject(null, function(acc, list) {
            if (acc) {
                return acc;
            }
            if (!Object.isUndefined(list.value.get(tasklist))) {
                return list.value.get(tasklist).get(taskid);
            }
        });
        if (Object.isUndefined(task)) {
            // This shouldn't happen.
            this.toggleCompletionClass(taskid);
            return;
        }
        if (Object.isUndefined(complete) || complete === true) {
            task.cp = !task.cp;
        }

        if (this.tcache.get(task.cp ? 'complete' : 'incomplete')) {
            this.tcache.get(task.cp ? 'complete' : 'incomplete').get(tasklist).set(taskid, task);
        }
        if (this.tcache.get(task.cp ? 'incomplete' : 'complete')) {
            this.tcache.get(task.cp ? 'incomplete' : 'complete').get(tasklist).unset(taskid);
        }

        // Remove row if necessary.
        var row = this.getTaskRow(taskid);
        if (!row) {
            return;
        }
        if ((this.tasktype == 'complete' && !task.cp) ||
            ((this.tasktype == 'incomplete' || this.tasktype == 'future_incomplete') && task.cp) ||
            ((complete === true) && (this.tasktype == 'future'))) {

            row.fade({
                duration: this.effectDur,
                afterFinish: function() {
                    row.purge();
                    row.remove();

                    //Check if items remained in interface
                    if ($('kronolithViewTasksBody').select('tr').length < 3) {
                        $('kronolithTasksNoItems').show();
                    }
                }
            });
        }

        // Update due date if necessary.
        if (!Object.isUndefined(complete) && complete !== true) {
            var now = new Date(), due = Date.parse(complete);
            row.down('span.kronolithDate')
                .update(due.toString(Kronolith.conf.date_format));
            if (now.isBefore(due)) {
                row.down('td.kronolithTaskCol')
                    .removeClassName('kronolithTaskDue');
            }
        }
    },

    /**
     * Toggles the CSS class to show that a task is completed/uncompleted.
     *
     * @param string taskid  The id of the task.
     */
    toggleCompletionClass: function(taskid)
    {
        var row = this.getTaskRow(taskid);
        if (!row) {
            return;
        }
        var col = row.down('td.kronolithTaskCol');
        col.toggleClassName('kronolithTask');
        col.toggleClassName('kronolithTaskCompleted');
    },

    /**
     * Returns the table row of a task.
     *
     * @param string taskid  The id of the task.
     *
     * @return Element  The table row of the task list, if found.
     */
    getTaskRow: function(taskid)
    {
        return $('kronolithViewTasksBody').select('tr').find(function(el) {
            return el.retrieve('taskid') == taskid;
        });
    },

    editTask: function(tasklist, id, desc)
    {
        if (this.redBoxLoading) {
            return;
        }

        if (Object.isUndefined(HordeImple.AutoCompleter.kronolithTaskTags)) {
            this.editTask.bind(this, tasklist, id, desc).defer();
            return;
        }

        this.closeRedBox();
        this.quickClose();
        this.redBoxOnDisplay = RedBox.onDisplay;
        RedBox.onDisplay = function() {
            if (this.redBoxOnDisplay) {
                this.redBoxOnDisplay();
            }
            try {
                $('kronolithTaskForm').focusFirstElement();
            } catch(e) {}
            RedBox.onDisplay = this.redBoxOnDisplay;
        }.bind(this);

        this.openTab($('kronolithTaskForm').down('.tabset a.kronolithTabLink'));
        $('kronolithTaskForm').enable();
        $('kronolithTaskForm').reset();
        HordeImple.AutoCompleter.kronolithTaskTags.reset();
        $('kronolithTaskSave').show().enable();
        $('kronolithTaskDelete').show().enable();
        $('kronolithTaskForm').down('.kronolithFormActions .kronolithSeparator').show();
        this.updateTasklistDropDown();
        this.disableAlarmMethods('Task');
        this.knl.kronolithTaskDueTime.markSelected();
        if (id) {
            RedBox.loading();
            this.updateTaskParentDropDown(tasklist);
            this.updateTaskAssigneeDropDown(tasklist);
            HordeCore.doAction('getTask', {
                list: tasklist,
                id: id
            }, {
                callback: this.editTaskCallback.bind(this)
            });
            $('kronolithTaskTopTags').update();
        } else {
            $('kronolithTaskId').clear();
            $('kronolithTaskOldList').clear();
            $('kronolithTaskList').setValue(Kronolith.conf.tasks.default_tasklist);
            this.updateTaskParentDropDown(Kronolith.conf.tasks.default_tasklist);
            this.updateTaskAssigneeDropDown(Kronolith.conf.tasks.default_tasklist);
            $('kronolithTaskParent').setValue('');
            $('kronolithTaskAssignee').setValue('');
            //$('kronolithTaskLocation').setValue('http://');
            HordeCore.doAction('listTopTags', {}, {
                callback: this.topTagsCallback.curry('kronolithTaskTopTags', 'kronolithTaskTag')
            });
            $('kronolithTaskPriority').setValue(3);
            if (Kronolith.conf.tasks.default_due) {
                this.setDefaultDue();
            }
            if (desc) {
                $('kronolithTaskDescription').setValue(desc);
            }
            this.toggleRecurrence(false, 'None');
            $('kronolithTaskDelete').hide();
            this.redBoxLoading = true;
            RedBox.showHtml($('kronolithTaskDialog').show());
        }
    },

    /**
     * Callback method for showing task forms.
     *
     * @param object r  The ajax response object.
     */
    editTaskCallback: function(r)
    {
        if (!r.task) {
            RedBox.close();
            this.go(this.lastLocation);
            return;
        }

        var task = r.task;

        /* Basic information */
        $('kronolithTaskId').setValue(task.id);
        $('kronolithTaskOldList').setValue(task.l);
        $('kronolithTaskList').setValue(task.l);
        $('kronolithTaskTitle').setValue(task.n);
        $('kronolithTaskParent').setValue(task.p);
        $('kronolithTaskAssignee').setValue(task.as);
        //$('kronolithTaskLocation').setValue(task.l);
        if (task.dd) {
            $('kronolithTaskDueDate').setValue(task.dd);
        }
        if (task.dt) {
            $('kronolithTaskDueTime').setValue(task.dt);
            this.knl.kronolithTaskDueTime.setSelected(task.dt);
        }
        $('kronolithTaskDescription').setValue(task.de);
        $('kronolithTaskPriority').setValue(task.pr);
        $('kronolithTaskCompleted').setValue(task.cp);

        /* Alarm */
        if (task.a) {
            this.enableAlarm('Task', task.a);
            if (task.m) {
                $('kronolithTaskAlarmDefaultOff').checked = true;
                $H(task.m).each(function(method) {
                    if (!$('kronolithTaskAlarm' + method.key)) {
                        return;
                    }
                    $('kronolithTaskAlarm' + method.key).setValue(1);
                    if ($('kronolithTaskAlarm' + method.key + 'Params')) {
                        $('kronolithTaskAlarm' + method.key + 'Params').show();
                    }
                    $H(method.value).each(function(param) {
                        var input = $('kronolithTaskAlarmParam' + param.key);
                        if (!input) {
                            return;
                        }
                        if (input.type == 'radio') {
                            input.up('form').select('input[type=radio]').each(function(radio) {
                                if (radio.name == input.name &&
                                    radio.value == param.value) {
                                    radio.setValue(1);
                                    throw $break;
                                }
                            });
                        } else {
                            input.setValue(param.value);
                        }
                    });
                });
            }
        } else {
            $('kronolithTaskAlarmOff').setValue(true);
        }

        /* Recurrence */
        if (task.r) {
            this.setRecurrenceFields(false, task.r);
        } else {
            this.toggleRecurrence(false, 'None');
        }

        HordeImple.AutoCompleter.kronolithTaskTags.reset(task.t);

        if (!task.pe) {
            $('kronolithTaskSave').hide();
            $('kronolithTaskForm').disable();
        } else {
            HordeCore.doAction('listTopTags', {}, {
                callback: this.topTagsCallback.curry('kronolithTaskTopTags', 'kronolithTaskTag')
            });
        }

        if (!task.pd) {
            $('kronolithTaskDelete').show();
        }
        if (!task.pe && !task.pd) {
            $('kronolithTaskForm').down('.kronolithFormActions .kronolithSeparator').hide();
        }

        this.setTitle(task.n);
        this.redBoxLoading = true;
        RedBox.showHtml($('kronolithTaskDialog').show());

        /* Hide alarm message for this task. */
        if (r.msgs) {
            r.msgs = r.msgs.reject(function(msg) {
                if (msg.type != 'horde.alarm') {
                    return false;
                }
                var alarm = msg.flags.alarm;
                if (alarm.params && alarm.params.notify &&
                    alarm.params.notify.show &&
                    alarm.params.notify.show.tasklist &&
                    alarm.params.notify.show.task &&
                    alarm.params.notify.show.tasklist == task.l &&
                    alarm.params.notify.show.task == task.id) {
                    return true;
                }
                return false;
            });
        }
    },

    /**
     * Propagates a SELECT drop down list with the editable task lists.
     */
    updateTasklistDropDown: function()
    {
        var tasklist = $('kronolithTaskList');
        tasklist.update();
        $H(Kronolith.conf.calendars.tasklists).each(function(cal) {
            if (cal.value.edit) {
                tasklist.insert(new Element('option', { value: cal.key.substring(6) })
                                .setStyle({ backgroundColor: cal.value.bg, color: cal.value.fg })
                                .update(cal.value.name.escapeHTML()));
            }
        });
    },

    /**
     * Propagates a SELECT drop down list with the tasks of a task list.
     *
     * @param string list  A task list ID.
     */
    updateTaskParentDropDown: function(list)
    {
        var parents = $('kronolithTaskParent');
        parents.update(new Element('option', { value: '' })
                       .update(Kronolith.text.no_parent));
        HordeCore.doAction('listTasks', {
            type: 'future_incomplete',
            list: list
        }, {
            ajaxopts: { asynchronuous: false },
            callback: function(r) {
                $H(r.tasks).each(function(task) {
                    parents.insert(new Element('option', { value: task.key })
                                .setStyle({ textIndent: task.value.i + 'em' })
                                .update(task.value.n.escapeHTML()));
                });
            }.bind(this)
        });
    },

    /**
     * Propagates a SELECT drop down list with the users of a task list.
     *
     * @param string list  A task list ID.
     */
    updateTaskAssigneeDropDown: function(list)
    {
        var assignee = $('kronolithTaskAssignee');
        assignee.update(new Element('option', { value: '' })
                       .update(Kronolith.text.no_assignee));
        $H(Kronolith.conf.calendars.tasklists['tasks/' + list].users).each(function(user) {
            assignee.insert(new Element('option', { value: user.key })
                            .update(user.value.escapeHTML()));
        });
    },

    /**
     * Sets the default due date and time for tasks.
     */
    setDefaultDue: function()
    {
        if ($F('kronolithTaskDueDate') || $F('kronolithTaskDueTime')) {
            return;
        }
        $('kronolithTaskDueDate').setValue(new Date().add(Kronolith.conf.tasks.default_due_days).days().toString(Kronolith.conf.date_format));
        if (Kronolith.conf.tasks.default_due_time == 'now') {
            $('kronolithTaskDueTime').setValue(new Date().toString(Kronolith.conf.time_format));
        } else {
            var date = new Date();
            date.setHours(Kronolith.conf.tasks.default_due_time.replace(/:.*$/, ''));
            date.setMinutes(0);
            $('kronolithTaskDueTime').setValue(date.toString(Kronolith.conf.time_format));
        }
    },

    /**
     * Finally removes tasks from the DOM and the cache.
     *
     * @param string list  A task list name.
     * @param string task  A task id. If empty, all tasks from the list are
     *                     deleted.
     */
    removeTask: function(list, task)
    {
        this.deleteTasksCache(list, task);
        $('kronolithViewTasksBody').select('tr').findAll(function(el) {
            return el.retrieve('tasklist') == list &&
                (!task || el.retrieve('taskid') == task);
        }).invoke('remove');
        this.removeEvent('tasklists|tasks/' + list, task ? '_tasks' + task : null);
        if ($('kronolithViewTasksBody').select('tr').length > 2) {
            $('kronolithTasksNoItems').hide();
        } else {
            $('kronolithTasksNoItems').show();
        }
    },

    /**
     * Submits the task edit form to create or update a task.
     */
    saveTask: function()
    {
        if (this.wrongFormat.size() ||
            (($F('kronolithTaskAlarmOn')) && $F('kronolithTaskDueDate').length == 0)) {
            HordeCore.notify(Kronolith.text.fix_form_values, 'horde.warning');
            return;
        }

        var tasklist = $F('kronolithTaskOldList'),
            target = $F('kronolithTaskList'),
            taskid = $F('kronolithTaskId'),
            viewDates = this.viewDates(this.date, this.view),
            start = viewDates[0].dateString(),
            end = viewDates[1].dateString();

        HordeImple.AutoCompleter.kronolithTaskTags.shutdown();
        $('kronolithTaskSave').disable();
        this.startLoading('tasklists|tasks/' + target, start + end + this.tasktype);
        this.loading++;
        HordeCore.doAction(
            'saveTask',
            $H($('kronolithTaskForm').serialize({ hash: true })).merge({
                sig: start + end + this.tasktype,
                view: this.view,
                view_start: start,
                view_end: end
            }), {
                callback: function(r) {
                    if (r.tasks && taskid) {
                        this.removeTask(tasklist, taskid);
                    }
                    this.loadTasksCallback(r, false);
                    this.loadEventsCallback(r, false);
                    if (r.tasks) {
                        this.closeRedBox();
                        this.go(this.lastLocation);
                    } else {
                        $('kronolithTaskSave').enable();
                    }
                }.bind(this)
            }
        );
    },

    quickSaveTask: function()
    {
        var text = $F('kronolithQuicktaskQ'),
            viewDates = this.viewDates(this.date, 'tasks'),
            start = viewDates[0].dateString(),
            end = viewDates[1].dateString(),
            params = {
                sig: start + end + this.tasktype,
                view: 'tasks',
                view_start: start,
                view_end: end,
                tasklist: Kronolith.conf.tasks.default_tasklist,
                text: text
            };

        this.closeRedBox();
        this.startLoading('tasklists|tasks/' + Kronolith.conf.tasks.default_tasklist,
                          params.sig);
        this.loading++;
        HordeCore.doAction('quickSaveTask', params, {
            callback: function(r) {
                this.loadTasksCallback(r, false);
                this.loadEventsCallback(r, false);
                if (!r.tasks || !$H(r.tasks).size()) {
                    this.editTask(null, null, text);
                } else {
                    $('kronolithQuicktaskQ').value = '';
                }
            }.bind(this)
         });
    },

    /**
     * Opens the form for editing a calendar.
     *
     * @param string calendar  Calendar type and calendar id, separated by '|'.
     */
    editCalendar: function(calendar)
    {
        if (this.redBoxLoading) {
            return;
        }

        this.closeRedBox();
        this.quickClose();

        var type = calendar.split('|')[0], cal = calendar.split('|')[1];
        if (!$w('internal tasklists remote holiday resource resourcegroup').include(type)) {
            return;
        }

        if (cal &&
            (Object.isUndefined(Kronolith.conf.calendars[type]) ||
             Object.isUndefined(Kronolith.conf.calendars[type][cal])) &&
            (type == 'internal' || type == 'tasklists')) {
            HordeCore.doAction('getCalendar', {
                cal: cal
            }, {
                callback: function(r) {
                    if (r.calendar) {
                        Kronolith.conf.calendars[type][cal] = r.calendar;
                        this.insertCalendarInList(type, cal, r.calendar);
                        $('kronolithSharedCalendars').show();
                        this.editCalendar(type + '|' + cal);
                    } else {
                        this.go(this.lastLocation);
                    }
                }.bind(this)
            });
            return;
        }

        this.redBoxOnDisplay = RedBox.onDisplay;
        RedBox.onDisplay = function() {
            if (this.redBoxOnDisplay) {
                this.redBoxOnDisplay();
            }
            try {
                $('kronolithCalendarForm' + type).focusFirstElement();
            } catch(e) {}
            RedBox.onDisplay = this.redBoxOnDisplay;
        }.bind(this);

        if ($('kronolithCalendarDialog')) {
            this.redBoxLoading = true;
            RedBox.showHtml($('kronolithCalendarDialog').show());
            this.editCalendarCallback(calendar);
        } else {
            RedBox.loading();
            HordeCore.doAction('chunkContent', {
                chunk: 'calendar'
            }, {
                callback: function(r) {
                    if (r.chunk) {
                        this.redBoxLoading = true;
                        RedBox.showHtml(r.chunk);
                        ['internal', 'tasklists'].each(function(type) {
                            $('kronolithC' + type + 'PGList').observe('change', function() {
                                $('kronolithC' + type + 'PG').setValue(1);
                                this.permsClickHandler(type, 'G');
                            }.bind(this));
                        }, this);
                        this.editCalendarCallback(calendar);
                    } else {
                        this.closeRedBox();
                    }
                }.bind(this)
            });
        }
    },

    /**
     * Callback for editing a calendar. Fills the edit form with the correct
     * values.
     *
     * @param string calendar  Calendar type and calendar id, separated by '|'.
     */
    editCalendarCallback: function(calendar)
    {
        calendar = calendar.split('|');
        var type = calendar[0];
        calendar = calendar.length == 1 ? null : calendar[1];

        var form = $('kronolithCalendarForm' + type),
            firstTab = form.down('.tabset a.kronolithTabLink'),
            info;

        form.enable();
        form.reset();
        if (firstTab) {
            this.openTab(firstTab);
        }
        $('kronolithCalendarDialog').select('.kronolithCalendarDiv').invoke('hide');
        $('kronolithCalendar' + type + '1').show();
        form.select('.kronolithCalendarContinue').invoke('enable');
        $('kronolithC' + type + 'PUNew', 'kronolithC' + type + 'PGNew').compact().each(function(elm) {
            if (elm.tagName == 'SELECT') {
                $A(elm.options).each(function(option) {
                    option.writeAttribute('disabled', false);
                });
            }
        });

        var newCalendar = !calendar;
        if (calendar &&
            (Object.isUndefined(Kronolith.conf.calendars[type]) ||
             Object.isUndefined(Kronolith.conf.calendars[type][calendar]))) {
            if (type != 'remote') {
                this.closeRedBox();
                this.go(this.lastLocation);
                return;
            }
            newCalendar = true;
        }
        if (type == 'resourcegroup') {
            this.updateResourcegroupSelect();
        }
        if (newCalendar) {
            switch (type) {
            case 'internal':
                HordeImple.AutoCompleter.kronolithCalendarinternalTags.reset();
                // Fall through.
            case 'tasklists':
                $('kronolithCalendar' + type + 'LinkExport').up('span').hide();
                break;
            case 'remote':
                if (calendar) {
                    $('kronolithCalendarremoteUrl').setValue(calendar);
                    $('kronolithCalendarremoteId').setValue(calendar);
                }
                break;
            case 'holiday':
                $('kronolithCalendarholidayDriver').update();
                $H(Kronolith.conf.calendars.holiday).each(function(calendar) {
                    if (calendar.value.show) {
                        return;
                    }
                    $('kronolithCalendarholidayDriver').insert(
                        new Element('option', { value: calendar.key })
                            .setStyle({ color: calendar.value.fg, backgroundColor: calendar.value.bg })
                            .insert(calendar.value.name.escapeHTML())
                    );
                });
                break;
            }
            $('kronolithCalendar' + type + 'Id').clear();
            var color = '#', i;
            for (i = 0; i < 3; i++) {
                color += (Math.random() * 256 | 0).toColorPart();
            }
            $('kronolithCalendar' + type + 'Color').setValue(color).setStyle({ backgroundColor: color, color: Color.brightness(Color.hex2rgb(color)) < 125 ? '#fff' : '#000' });
            form.down('.kronolithCalendarDelete').hide();
            $('kronolithCalendarinternalImportButton').hide();
        } else {
            info = Kronolith.conf.calendars[type][calendar];

            $('kronolithCalendar' + type + 'Id').setValue(calendar);
            $('kronolithCalendar' + type + 'Name').setValue(info.name);
            $('kronolithCalendar' + type + 'Color').setValue(info.bg).setStyle({ backgroundColor: info.bg, color: info.fg });
            $('kronolithCalendarinternalImportButton').hide();

            switch (type) {
            case 'internal':
                HordeImple.AutoCompleter.kronolithCalendarinternalTags.reset(Kronolith.conf.calendars.internal[calendar].tg);
                $('kronolithCalendar' + type + 'ImportCal').setValue('internal_' + calendar);
                if ($('kronolithCalendar' + type + 'LinkImport')) {
                    if (info.edit) {
                        $('kronolithCalendar' + type + 'LinkImport').up('li').show();
                    } else {
                        $('kronolithCalendar' + type + 'LinkImport').up('li').hide();
                    }
                }
                $('kronolithCalendar' + type + 'UrlFeed').setValue(info.feed);
                $('kronolithCalendar' + type + 'EmbedUrl').setValue(info.embed);
                // Fall through.
            case 'tasklists':
                $('kronolithCalendar' + type + 'Description').setValue(info.desc);
                if ($('kronolithCalendar' + type + 'LinkExport')) {
                    $('kronolithCalendar' + type + 'LinkExport').up('span').show();
                    $('kronolithCalendar' + type + 'Export').href = type == 'internal'
                        ? Kronolith.conf.URI_CALENDAR_EXPORT.interpolate({ calendar: calendar })
                        : Kronolith.conf.tasks.URI_TASKLIST_EXPORT.interpolate({ tasklist: calendar.substring(6) });
                }
                $('kronolithCalendar' + type + 'LinkUrls').up().show();
                if (info.caldav) {
                    $('kronolithCalendar' + type + 'UrlCaldav').setValue(info.caldav);
                    $('kronolithCalendar' + type + 'Caldav').show();
                } else {
                    $('kronolithCalendar' + type + 'Caldav').hide();
                }
                $('kronolithCalendar' + type + 'UrlWebdav').setValue(info.sub);
                break;
            case 'remote':
                $('kronolithCalendarremoteUrl').setValue(calendar);
                $('kronolithCalendarremoteDescription').setValue(info.desc);
                $('kronolithCalendarremoteUsername').setValue(info.user);
                $('kronolithCalendarremotePassword').setValue(info.password);
                break;
            case 'resourcegroup':
                $('kronolithCalendarresourcegroupDescription').setValue(info.desc);
                $('kronolithCalendarresourcegroupmembers').setValue(info.members);
                break;
            case 'resource':
                $('kronolithCalendarresourceDescription').setValue(info.desc);
                $('kronolithCalendarresourceResponseType').setValue(info.response_type);
                $('kronolithCalendarresourceExport').href = Kronolith.conf.URI_RESOURCE_EXPORT.interpolate({ calendar: calendar });
            }
        }

        if (newCalendar || info.owner) {
            if (type == 'internal' || type == 'tasklists') {
                this.updateGroupDropDown([['kronolithC' + type + 'PGList', this.updateGroupPerms.bind(this, type)],
                                          ['kronolithC' + type + 'PGNew']]);
                $('kronolithC' + type + 'PBasic').show();
                $('kronolithC' + type + 'PAdvanced').hide();
                $('kronolithC' + type + 'PNone').setValue(1);
                if ($('kronolithC' + type + 'PAllShow')) {
                    $('kronolithC' + type + 'PAllShow').disable();
                }
                $('kronolithC' + type + 'PGList').disable();
                $('kronolithC' + type + 'PGPerms').disable();
                $('kronolithC' + type + 'PUList').disable();
                $('kronolithC' + type + 'PUPerms').disable();
                $('kronolithC' + type + 'PAdvanced').select('tr').findAll(function(tr) {
                    return tr.retrieve('remove');
                }).invoke('remove');
                $('kronolithCalendar' + type + 'LinkUrls').up().show();
                form.down('.kronolithColorPicker').show();
                if (type == 'internal') {
                    HordeCore.doAction('listTopTags', {}, {
                        callback: this.topTagsCallback.curry('kronolithCalendarinternalTopTags', 'kronolithCalendarTag')
                    });
                }
                form.down('.kronolithCalendarSubscribe').hide();
                form.down('.kronolithCalendarUnsubscribe').hide();
                if ($('kronolithCalendar' + type + 'LinkPerms')) {
                    $('kronolithCalendar' + type + 'LinkPerms').up('span').show();
                }
                if (!Object.isUndefined(info) && info.owner) {
                    this.setPermsFields(type, info.perms);
                }
            }
            if (type == 'remote' || type == 'internal' || type == 'tasklists') {
                if (newCalendar ||
                    (type == 'internal' && calendar == Kronolith.conf.user) ||
                    (type == 'tasklists' && calendar == 'tasks/' + Kronolith.conf.user)) {
                    form.select('.kronolithCalendarDelete').invoke('hide');
                } else {
                    form.select('.kronolithCalendarDelete').invoke('show');
                }
            }
            form.down('.kronolithCalendarSave').show();
            form.down('.kronolithFormActions .kronolithSeparator').show();
        } else {
            form.disable();
            form.down('.kronolithColorPicker').hide();
            form.down('.kronolithCalendarDelete').hide();
            form.down('.kronolithCalendarSave').hide();
            if (type == 'internal' || type == 'tasklists') {
                $('kronolithCalendar' + type + 'UrlCaldav').enable();
                $('kronolithCalendar' + type + 'UrlAccount').enable();
                $('kronolithCalendar' + type + 'UrlWebdav').enable();
                if (type == 'internal') {
                    $('kronolithCalendar' + type + 'UrlFeed').enable();
                    $('kronolithCalendar' + type + 'EmbedUrl').enable();
                    if (info.edit) {
                        $('kronolithCalendarinternalImport').enable();
                        if (info.del) {
                            $('kronolithCalendarinternalImportOver').enable();
                        }
                        $('kronolithCalendarinternalImportButton').show().enable();
                    }
                }
                HordeImple.AutoCompleter.kronolithCalendarinternalTags.disable();
                if (Kronolith.conf.calendars[type][calendar].show) {
                    form.down('.kronolithCalendarSubscribe').hide();
                    form.down('.kronolithCalendarUnsubscribe').show().enable();
                } else {
                    form.down('.kronolithCalendarSubscribe').show().enable();
                    form.down('.kronolithCalendarUnsubscribe').hide();
                }
                form.down('.kronolithFormActions .kronolithSeparator').show();
                if ($('kronolithCalendar' + type + 'LinkPerms')) {
                    $('kronolithCalendar' + type + 'LinkPerms').up('span').hide();
                }
            } else {
                form.down('.kronolithFormActions .kronolithSeparator').hide();
            }
        }
    },

    /**
     * Updates the select list in the resourcegroup calendar dialog.
     */
    updateResourcegroupSelect: function()
    {
        if (!Kronolith.conf.calendars.resource) {
            return;
        }
        $('kronolithCalendarresourcegroupmembers').update();
        $H(Kronolith.conf.calendars.resource).each(function(r) {
            var o = new Element('option', { value: r.value.id }).update(r.value.name.escapeHTML());
            $('kronolithCalendarresourcegroupmembers').insert(o);
        });
    },

    /**
     * Handles clicks on the radio boxes of the basic permissions screen.
     *
     * @param string type  The calendar type, 'internal' or 'taskslists'.
     * @param string perm  The permission to activate, 'None', 'All', or
     *                     'Group'.
     */
    permsClickHandler: function(type, perm)
    {
        $('kronolithC' + type + 'PAdvanced')
            .select('input[type=checkbox]')
            .invoke('setValue', 0);
        $('kronolithC' + type + 'PAdvanced').select('tr').findAll(function(tr) {
            return tr.retrieve('remove');
        }).invoke('remove');

        switch (perm) {
        case 'None':
            if ($('kronolithC' + type + 'PAllShow')) {
                $('kronolithC' + type + 'PAllShow').disable();
            }
            $('kronolithC' + type + 'PGList').disable();
            $('kronolithC' + type + 'PGPerms').disable();
            $('kronolithC' + type + 'PUList').disable();
            $('kronolithC' + type + 'PUPerms').disable();
            break;
        case 'All':
            $('kronolithC' + type + 'PAllShow').enable();
            $('kronolithC' + type + 'PGList').disable();
            $('kronolithC' + type + 'PGPerms').disable();
            $('kronolithC' + type + 'PUList').disable();
            $('kronolithC' + type + 'PUPerms').disable();
            var perms = {
                'default': Kronolith.conf.perms.read,
                'guest': Kronolith.conf.perms.read
            };
            if ($F('kronolithC' + type + 'PAllShow')) {
                perms['default'] |= Kronolith.conf.perms.show;
                perms['guest'] |= Kronolith.conf.perms.show;
            }
            this.setPermsFields(type, perms);
            break;
        case 'G':
            if ($('kronolithC' + type + 'PAllShow')) {
                $('kronolithC' + type + 'PAllShow').disable();
            }
            $('kronolithC' + type + 'PGList').enable();
            $('kronolithC' + type + 'PGPerms').enable();
            $('kronolithC' + type + 'PUList').disable();
            $('kronolithC' + type + 'PUPerms').disable();
            var group = $F('kronolithC' + type + 'PGSingle')
                ? $F('kronolithC' + type + 'PGSingle')
                : $F('kronolithC' + type + 'PGList');
            this.insertGroupOrUser(type, 'group', group, true);
            $('kronolithC' + type + 'PGshow_' + group).setValue(1);
            $('kronolithC' + type + 'PGread_' + group).setValue(1);
            if ($F('kronolithC' + type + 'PGPerms') == 'edit') {
                $('kronolithC' + type + 'PGedit_' + group).setValue(1);
            } else {
                $('kronolithC' + type + 'PGedit_' + group).setValue(0);
            }
            $('kronolithC' + type + 'PGdel_' + group).setValue(0);
            if ($('kronolithC' + type + 'PGdelegate_' + group)) {
                $('kronolithC' + type + 'PGdelegate_' + group).setValue(0);
            }
            break;
        case 'U':
            if ($('kronolithC' + type + 'PAllShow')) {
                $('kronolithC' + type + 'PAllShow').disable();
            }
            $('kronolithC' + type + 'PGList').disable();
            $('kronolithC' + type + 'PGPerms').disable();
            $('kronolithC' + type + 'PUList').enable();
            $('kronolithC' + type + 'PUPerms').enable();
            var users = $F('kronolithC' + type + 'PUList').strip();
            users = users ? users.split(/\s*(?:,|\n)\s*/) : [];
            users.each(function(user) {
                if (!this.insertGroupOrUser(type, 'user', user, true)) {
                    return;
                }
                $('kronolithC' + type + 'PUshow_' + user).setValue(1);
                $('kronolithC' + type + 'PUread_' + user).setValue(1);
                if ($F('kronolithC' + type + 'PUPerms') == 'edit') {
                    $('kronolithC' + type + 'PUedit_' + user).setValue(1);
                } else {
                    $('kronolithC' + type + 'PUedit_' + user).setValue(0);
                }
                $('kronolithC' + type + 'PUdel_' + user).setValue(0);
                if ($('kronolithC' + type + 'PUdelegate_' + user)) {
                    $('kronolithC' + type + 'PUdelegate_' + user).setValue(0);
                }
            }, this);
            break;
        }
    },

    /**
     * Populates the permissions field matrix.
     *
     * @param string type   The calendar type, 'internal' or 'taskslists'.
     * @param object perms  An object with the resource permissions.
     */
    setPermsFields: function(type, perms)
    {
        if (this.groupLoading) {
            this.setPermsFields.bind(this, type, perms).defer();
            return;
        }

        var allperms = $H(Kronolith.conf.perms),
            advanced = false, users = [],
            basic, same, groupPerms, groupId, userPerms;
        $H(perms).each(function(perm) {
            switch (perm.key) {
            case 'default':
            case 'guest':
                if (Object.isUndefined(same)) {
                    same = perm.value;
                } else if (Object.isUndefined(basic) &&
                           same == perm.value &&
                           (perm.value == Kronolith.conf.perms.read ||
                            perm.value == (Kronolith.conf.perms.read | Kronolith.conf.perms.show))) {
                    basic = perm.value == Kronolith.conf.perms.read ? 'all_read' : 'all_show';
                } else if (perm.value != 0) {
                    advanced = true;
                }
                break;
            case 'creator':
                if (perm.value != 0) {
                    advanced = true;
                }
                break;
            case 'groups':
                if (!Object.isArray(perm.value)) {
                    $H(perm.value).each(function(group) {
                        if (!this.insertGroupOrUser(type, 'group', group.key)) {
                            return;
                        }
                        if (!$('kronolithC' + type + 'PGshow_' + group.key)) {
                            // Group doesn't exist anymore.
                            delete perm.value[group.key];
                            return;
                        }
                        groupPerms = group.value;
                        groupId = group.key;
                    }, this);
                    if (Object.isUndefined(basic) &&
                        $H(perm.value).size() == 1 &&
                        (groupPerms == (Kronolith.conf.perms.show | Kronolith.conf.perms.read) ||
                         groupPerms == (Kronolith.conf.perms.show | Kronolith.conf.perms.read | Kronolith.conf.perms.edit))) {
                        basic = groupPerms == (Kronolith.conf.perms.show | Kronolith.conf.perms.read) ? 'group_read' : 'group_edit';
                    } else {
                        advanced = true;
                    }
                }
                break;
            case 'users':
                if (!Object.isArray(perm.value)) {
                    $H(perm.value).each(function(user) {
                        if (user.key != Kronolith.conf.user) {
                            if (!this.insertGroupOrUser(type, 'user', user.key)) {
                                return;
                            }
                            if (!$('kronolithC' + type + 'PUshow_' + user.key)) {
                                // User doesn't exist anymore.
                                delete perm.value[user.key];
                                return;
                            }
                            // Check if we already have other basic permissions.
                            if (Object.isUndefined(userPerms) &&
                                !Object.isUndefined(basic)) {
                                advanced = true;
                            }
                            // Check if all users have the same permissions.
                            if (!Object.isUndefined(userPerms) &&
                                userPerms != user.value) {
                                advanced = true;
                            }
                            userPerms = user.value;
                            if (!advanced &&
                                (userPerms == (Kronolith.conf.perms.show | Kronolith.conf.perms.read) ||
                                 userPerms == (Kronolith.conf.perms.show | Kronolith.conf.perms.read | Kronolith.conf.perms.edit))) {
                                basic = userPerms == (Kronolith.conf.perms.show | Kronolith.conf.perms.read) ? 'user_read' : 'user_edit';
                                users.push(user.key);
                            } else {
                                advanced = true;
                            }
                        }
                    }, this);
                }
                break;
            }

            allperms.each(function(baseperm) {
                if (baseperm.key == 'all') {
                    return;
                }
                switch (perm.key) {
                case 'default':
                case 'guest':
                case 'creator':
                    if (baseperm.value & perm.value) {
                        $('kronolithC' + type + 'P' + perm.key + baseperm.key).setValue(1);
                    }
                    break;
                case 'groups':
                    $H(perm.value).each(function(group) {
                        if (baseperm.value & group.value) {
                            $('kronolithC' + type + 'PG' + baseperm.key + '_' + group.key).setValue(1);
                        }
                    });
                    break;
                case 'users':
                    $H(perm.value).each(function(user) {
                        if (baseperm.value & user.value &&
                            user.key != Kronolith.conf.user) {
                            $('kronolithC' + type + 'PU' + baseperm.key + '_' + user.key).setValue(1);
                        }
                    });
                    break;
                }
            });
        }.bind(this));

        if (advanced) {
            this.activateAdvancedPerms(type);
        } else {
            switch (basic) {
            case 'all_read':
                $('kronolithC' + type + 'PAll').setValue(1);
                $('kronolithC' + type + 'PAllShow').setValue(0);
                $('kronolithC' + type + 'PAllShow').enable();
                break;
            case 'all_show':
                $('kronolithC' + type + 'PAll').setValue(1);
                $('kronolithC' + type + 'PAllShow').setValue(1);
                $('kronolithC' + type + 'PAllShow').enable();
                break;
            case 'group_read':
            case 'group_edit':
                var setGroup = function(group) {
                    if ($('kronolithC' + type + 'PGList').visible()) {
                        $('kronolithC' + type + 'PGList').setValue(group);
                        if ($('kronolithC' + type + 'PGList').getValue() != group) {
                            // Group no longer exists.
                            this.permsClickHandler(type, 'None');
                        }
                    } else if ($('kronolithC' + type + 'PGSingle').getValue() != group) {
                        // Group no longer exists.
                        this.permsClickHandler(type, 'None');
                    }
                }.bind(this, groupId);
                if (this.groupLoading) {
                    setGroup.defer();
                } else {
                    setGroup();
                }
                $('kronolithC' + type + 'PG').setValue(1);
                $('kronolithC' + type + 'PGPerms').setValue(basic.substring(6));
                $('kronolithC' + type + 'PAdvanced').hide();
                $('kronolithC' + type + 'PBasic').show();
                $('kronolithC' + type + 'PGPerms').enable();
                break;
            case 'user_read':
            case 'user_edit':
                $('kronolithC' + type + 'PUList').enable().setValue(users.join(', '));
                $('kronolithC' + type + 'PU').setValue(1);
                $('kronolithC' + type + 'PUPerms').setValue(basic.substring(5));
                $('kronolithC' + type + 'PAdvanced').hide();
                $('kronolithC' + type + 'PBasic').show();
                $('kronolithC' + type + 'PUPerms').enable();
                break;
            }
        }
   },

    /**
     * Propagates a SELECT drop down list with the groups.
     *
     * @param array params  A two-dimensional array with the following values
     *                      in each element:
     *                      - The id of the SELECT element.
     *                      - A callback method that is invoked with the group
     *                        list passes as an argument.
     */
    updateGroupDropDown: function(params)
    {
        this.groupLoading = true;
        params.each(function(param) {
            var elm = $(param[0]), options = elm.childElements();
            options.invoke('remove');
            elm.up('form').disable();
        });
        HordeCore.doAction('listGroups', {}, {
            callback: function(r) {
                var groups;
                if (r.groups) {
                    groups = $H(r.groups);
                    params.each(function(param) {
                        groups.each(function(group) {
                            $(param[0]).insert(new Element('option', { value: group.key }).update(group.value.escapeHTML()));
                        });
                    });
                }
                params.each(function(param) {
                    $(param[0]).up('form').enable();
                    if (param[1]) {
                        param[1](groups);
                    }
                });
                this.groupLoading = false;
            }.bind(this)
        });
    },

    /**
     * Updates the group permission interface after the group list has
     * been loaded.
     *
     * @param string type  The calendar type, 'internal' or 'taskslists'.
     * @param Hash groups  The list of groups.
     */
    updateGroupPerms: function(type, groups)
    {
        $('kronolithC' + type + 'PGSingle').clear();
        if (!groups) {
            $('kronolithC' + type + 'PGNew').up('div').hide();
            $('kronolithC' + type + 'PG').up('span').hide();
        } else {
            $('kronolithC' + type + 'PGNew').up('div').show();
            $('kronolithC' + type + 'PG').up('span').show();
            if (groups.size() == 1) {
                $('kronolithC' + type + 'PGName')
                    .update('&quot;' + groups.values()[0].escapeHTML() + '&quot;')
                    .show();
                $('kronolithC' + type + 'PGSingle').setValue(groups.keys()[0]);
                $('kronolithC' + type + 'PGList').hide();
            } else {
                $('kronolithC' + type + 'PGName').hide();
                $('kronolithC' + type + 'PGList').show();
            }
        }
    },

    /**
     * Inserts a group or user row into the advanced permissions interface.
     *
     * @param string type          The calendar type, 'internal' or
     *                             'taskslists'.
     * @param what string          Either 'group' or 'user'.
     * @param group string         The group id or user name to insert.
     *                             Defaults to the value of the drop down.
     * @param stay_basic boolean   Enforces to NOT switch to the advanced
     *                             permissions screen.
     *
     * @return boolean  Whether a row has been inserted.
     */
    insertGroupOrUser: function(type, what, id, stay_basic)
    {
        var elm = $(what == 'user' ? 'kronolithC' + type + 'PUNew' : 'kronolithC' + type + 'PGNew');
        if (id) {
            elm.setValue(id);
        }
        var value = elm.getValue();
        if (!value) {
            if (id) {
                HordeCore.notify(Kronolith.text.invalid_user + ': ' + id, 'horde.error');
            }
            return false;
        }

        var tr = elm.up('tr'),
            row = tr.clone(true).store('remove', true),
            td = row.down('td'),
            clearName = elm.tagName == 'SELECT' ? elm.options[elm.selectedIndex].text: elm.getValue();

        td.update();
        td.insert(clearName.escapeHTML())
            .insert(new Element('input', { type: 'hidden', name: (what == 'user' ? 'u' : 'g') + '_names[' + value + ']', value: value }));
        row.select('input[type=checkbox]').each(function(input) {
            input.writeAttribute('name', input.name.replace(/\[.*?$/, '[' + value + ']'))
                .writeAttribute('id', input.id.replace(/new/, value))
                .next()
                .writeAttribute('for', input.id);
        });
        tr.insert({ before: row });

        if (elm.tagName == 'SELECT') {
            elm.options[elm.selectedIndex].writeAttribute('disabled', true);
            elm.selectedIndex = 0;
        } else {
            elm.clear();
        }

        if (!stay_basic) {
            this.activateAdvancedPerms(type);
        }

        return true;
    },

    /**
     * Activates the advanced permissions.
     *
     * @param string type  The calendar type, 'internal' or 'taskslists'.
     */
    activateAdvancedPerms: function(type)
    {
        [$('kronolithC' + type + 'PNone'),
         $('kronolithC' + type + 'PU'),
         $('kronolithC' + type + 'PG')].each(function(radio) {
            radio.checked = false;
        });
        if ($('kronolithC' + type + 'PAll')) {
            $('kronolithC' + type + 'PAll').checked = false;
        }
        $('kronolithC' + type + 'PBasic').hide();
        $('kronolithC' + type + 'PAdvanced').show();
    },

    /**
     * Opens the next screen of the calendar management wizard.
     *
     * @param string type  The calendar type.
     */
    calendarNext: function(type)
    {
        var i = 1;
        while (!$('kronolithCalendar' + type + i).visible()) {
            i++;
        }
        $('kronolithCalendar' + type + i).hide();
        $('kronolithCalendar' + type + (++i)).show();
        if (this.colorPicker) {
            this.colorPicker.hide();
        }
    },

    /**
     * Submits the calendar form to save the calendar data.
     *
     * @param Element form  The form node.
     *
     * @return boolean  Whether the save request was successfully sent.
     */
    saveCalendar: function(form)
    {
        if (this.colorPicker) {
            this.colorPicker.hide();
        }
        var data = form.serialize({ hash: true });

        if (data.type == 'holiday') {
            this.insertCalendarInList('holiday', data.driver, Kronolith.conf.calendars.holiday[data.driver]);
            this.toggleCalendar('holiday', data.driver);
            form.down('.kronolithCalendarSave').enable();
            this.closeRedBox();
            this.go(this.lastLocation);
            return;
        }

        if (data.name.empty()) {
            HordeCore.notify(data.type == 'tasklists' ? Kronolith.text.no_tasklist_title : Kronolith.text.no_calendar_title, 'horde.warning');
            $('kronolithCalendar' + data.type + 'Name').focus();
            return false;
        }
        HordeCore.doAction('saveCalendar', data, {
            callback: this.saveCalendarCallback.bind(this, form, data)
        });
        return true;
    },

    calendarImport: function(form, disableForm)
    {
        if ($F('kronolithCalendarinternalImport')) {
            HordeCore.notify(Kronolith.text.import_warning, 'horde.message');
            this.loading++;
            $('kronolithLoading').show();
            var name = 'kronolithIframe' + Math.round(Math.random() * 1000),
                iframe = new Element('iframe', { src: 'about:blank', name: name, id: name }).setStyle({ display: 'none' });
            document.body.insert(iframe);
            form.enable();
            form.target = name;
            form.submit();
            if (disableForm) {
                form.disable();
            }
        }
    },

    /**
     * Callback method after saving a calendar.
     *
     * @param Element form  The form node.
     * @param object data   The serialized form data.
     * @param object r      The ajax response object.
     */
    saveCalendarCallback: function(form, data, r)
    {
        var type = form.id.replace(/kronolithCalendarForm/, '');

        // If saving the calendar changed the owner, we need to delete
        // and re-insert the calendar.
        if (r.deleted) {
            this.deleteCalendar(type, data.calendar);
            delete data.calendar;
        }
        if (r.saved) {
            this.calendarImport(form, false);
            var cal = r.calendar, id;
            if (data.calendar) {
                var color = {
                    backgroundColor: cal.bg,
                    color: cal.fg
                },
                legendSpan;
                id = data.calendar;
                this.getCalendarList(type, cal.owner).select('div').each(function(element) {
                    if (element.retrieve('calendar') == id) {
                        var link = element.down('.horde-resource-link span');
                        element.setStyle(color);
                        link.update(cal.name.escapeHTML());
                        this.addShareIcon(cal, link);
                        throw $break;
                    }
                }, this);
                this.kronolithBody.select('div').each(function(el) {
                    if (el.retrieve('calendar') == type + '|' + id) {
                        el.setStyle(color);
                    }
                });
                legendSpan = $('kronolith-legend').select('span')
                    .find(function(span) {
                        return span.retrieve('calendarclass') == type &&
                            span.retrieve('calendar') == id;
                    });
                if (legendSpan) {
                    legendSpan.setStyle(color).update(cal.name.escapeHTML());
                }
                Kronolith.conf.calendars[type][id] = cal;
            } else {
                id = r.id;
                if (!Kronolith.conf.calendars[type]) {
                    Kronolith.conf.calendars[type] = [];
                }
                Kronolith.conf.calendars[type][id] = cal;
                this.insertCalendarInList(type, id, cal);
                this.storeCache($H(), [type, id], this.viewDates(this.date, this.view), true);
                if (type == 'tasklists') {
                    this.storeTasksCache($H(), this.tasktype, id.replace(/^tasks\//, ''), true);
                }
            }
            if (type == 'remote') {
                this.loadCalendar(type, id);
            }
        }
        form.down('.kronolithCalendarSave').enable();
        this.closeRedBox();
        this.go(this.lastLocation);
    },

    /**
     * Deletes a calendar and all its events from the interface and cache.
     *
     * @param string type      The calendar type.
     * @param string calendar  The calendar id.
     */
    deleteCalendar: function(type, calendar)
    {
        var container = this.getCalendarList(type, Kronolith.conf.calendars[type][calendar].owner),
            noItems = container.previous(),
            div = container.select('div').find(function(element) {
                return element.retrieve('calendar') == calendar;
            }),
            arrow = div.down('span');
        arrow.purge();
        arrow.remove();
        div.purge();
        div.remove();
        if (noItems &&
            noItems.tagName == 'DIV' &&
            noItems.className == 'horde-info' &&
            !container.childElements().size()) {
            noItems.show();
        }
        this.deleteCalendarLegend(type, calendar);
        this.removeEvent(type + '|' + calendar);
        this.deleteCache([type, calendar]);
        if (type == 'tasklists' && this.view == 'tasks') {
            this.removeTask(calendar.replace(/^tasks\//, ''));
        }
        delete Kronolith.conf.calendars[type][calendar];
    },

    /**
     * Parses a date attribute string into a Date object.
     *
     * For other strings use Date.parse().
     *
     * @param string date  A yyyyMMdd date string.
     *
     * @return Date  A date object.
     */
    parseDate: function(date)
    {
        var d = new Date(date.substr(0, 4), date.substr(4, 2) - 1, date.substr(6, 2));
        if (date.length == 12) {
            d.setHours(date.substr(8, 2));
            d.setMinutes(date.substr(10, 2));
        }
        return d;
    },

    /**
     * Calculates first and last days being displayed.
     *
     * @var Date date    The date of the view.
     * @var string view  A view name.
     *
     * @return array  Array with first and last day of the view.
     */
    viewDates: function(date, view)
    {
        var start = date.clone(), end = date.clone();

        switch (view) {
        case 'week':
        case 'workweek':
            if (view == 'workweek') {
                start.add(1).days();
            }
            start.moveToBeginOfWeek(view == 'week' ? Kronolith.conf.week_start : 1);
            end = start.clone();
            end.moveToEndOfWeek(Kronolith.conf.week_start);
            if (view == 'workweek') {
                end.add(Kronolith.conf.week_start == 0 ? -1 : -2).days();
            }
            break;
        case 'month':
            start.setDate(1);
            start.moveToBeginOfWeek(Kronolith.conf.week_start);
            end.moveToLastDayOfMonth();
            end.moveToEndOfWeek(Kronolith.conf.week_start);
            break;
        case 'year':
            start.setDate(1);
            start.setMonth(0);
            end.setMonth(11);
            end.moveToLastDayOfMonth();
            break;
        case 'agenda':
            end.add(6).days();
            break;
        }

        return [start, end];
    },

    /**
     * Stores a set of events in the cache.
     *
     * For dates in the specified date ranges that don't contain any events,
     * empty cache entries are created so that those dates aren't re-fetched
     * each time.
     *
     * @param object events        A list of calendars and events as returned
     *                             from an ajax request.
     * @param string calendar      A calendar string or array.
     * @param string dates         A date range in the format yyyymmddyyyymmdd
     *                             as used in the ajax response signature.
     * @param boolean createCache  Whether to create a cache list entry for the
     *                             response, if none exists yet.
     */
    storeCache: function(events, calendar, dates, createCache)
    {
        if (Object.isString(calendar)) {
            calendar = calendar.split('|');
        }

        // Create cache entry for the calendar.
        if (!this.ecache.get(calendar[0])) {
            if (!createCache) {
                return;
            }
            this.ecache.set(calendar[0], $H());
        }
        if (!this.ecache.get(calendar[0]).get(calendar[1])) {
            if (!createCache) {
                return;
            }
            this.ecache.get(calendar[0]).set(calendar[1], $H());
        }
        var calHash = this.ecache.get(calendar[0]).get(calendar[1]);

        // Create empty cache entries for all dates.
        if (!!dates) {
            var day = dates[0].clone(), date;
            while (!day.isAfter(dates[1])) {
                date = day.dateString();
                if (!calHash.get(date)) {
                    if (!createCache) {
                        return;
                    }
                    if (!this.cacheStart || this.cacheStart.isAfter(day)) {
                        this.cacheStart = day.clone();
                    }
                    if (!this.cacheEnd || this.cacheEnd.isBefore(day)) {
                        this.cacheEnd = day.clone();
                    }
                    calHash.set(date, $H());
                }
                day.add(1).day();
            }
        }

        var cal = calendar.join('|');
        $H(events).each(function(date) {
            // We might not have a cache for this date if the event lasts
            // longer than the current view
            if (!calHash.get(date.key)) {
                return;
            }

            // Store calendar string and other useful information in event
            // objects.
            $H(date.value).each(function(event) {
                event.value.calendar = cal;
                event.value.start = Date.parse(event.value.s);
                event.value.end = Date.parse(event.value.e);
            });

            // Store events in cache.
            calHash.set(date.key, calHash.get(date.key).merge(date.value));
        });
    },

    /**
     * Stores a set of tasks in the cache.
     *
     * @param Hash tasks           The tasks to be stored.
     * @param string tasktypes     The task type that's being stored.
     * @param string tasklist      The task list to which the tasks belong.
     * @param boolean createCache  Whether to create a cache list entry for the
     *                             response, if none exists yet.
     */
    storeTasksCache: function(tasks, tasktypes, tasklist, createCache)
    {
        var taskHashes = {}, cacheExists = {};

        if (tasktypes == 'all' || tasktypes == 'future') {
            tasktypes = [ 'complete', 'incomplete' ];
        } else {
            tasktypes = [ tasktypes ];
        }

        tasktypes.each(function(tasktype) {
            cacheExists[tasktype] = false;
            if (!this.tcache.get(tasktype)) {
                if (!createCache) {
                    return;
                }
                this.tcache.set(tasktype, $H());
            }
            if (!tasklist) {
                return;
            }
            if (!this.tcache.get(tasktype).get(tasklist)) {
                if (!createCache) {
                    return;
                }
                this.tcache.get(tasktype).set(tasklist, $H());
                cacheExists[tasktype] = true;
            } else {
                cacheExists[tasktype] = true;
            }
            taskHashes[tasktype] = this.tcache.get(tasktype).get(tasklist);
        }, this);

        $H(tasks).each(function(task) {
            var tasktype = task.value.cp ? 'complete' : 'incomplete';
            if (!cacheExists[tasktype]) {
                return;
            }
            if (!Object.isUndefined(task.value.s)) {
                task.value.start = Date.parse(task.value.s);
            }
            if (!Object.isUndefined(task.value.du)) {
                task.value.due = Date.parse(task.value.du);
            }
            taskHashes[tasktype].set(task.key, task.value);
        });
    },

    /**
     * Deletes an event or a complete calendar from the cache.
     *
     * @param string calendar  A calendar string or array.
     * @param string event     An event ID or empty if deleting the calendar.
     * @param string day       A specific day to delete in yyyyMMdd form.
     */
    deleteCache: function(calendar, event, day)
    {
        if (Object.isString(calendar)) {
            calendar = calendar.split('|');
        }
        if (!this.ecache.get(calendar[0]) ||
            !this.ecache.get(calendar[0]).get(calendar[1])) {
            return;
        }
        if (event) {
            this.ecache.get(calendar[0]).get(calendar[1]).each(function(day) {
                day.value.unset(event);
            });
        } else if (day) {
            this.ecache.get(calendar[0]).get(calendar[1]).unset(day);
        } else {
            this.ecache.get(calendar[0]).unset(calendar[1]);
        }
    },

    /**
     * Deletes tasks from the cache.
     *
     * @param string list  A task list string.
     * @param string task  A task ID. If empty, all tasks from the list are
     *                     deleted.
     */
    deleteTasksCache: function(list, task)
    {
        this.deleteCache([ 'external', 'tasks/' + list ], task);
        $w('complete incomplete').each(function(type) {
            if (!Object.isUndefined(this.tcache.get(type)) &&
                !Object.isUndefined(this.tcache.get(type).get(list))) {
                if (task) {
                    this.tcache.get(type).get(list).unset(task);
                } else {
                    this.tcache.get(type).unset(list);
                }
            }
        }, this);
    },

    /**
     * Return all events for a single day from all displayed calendars merged
     * into a single hash.
     *
     * @param string date  A yyyymmdd date string.
     *
     * @return Hash  An event hash which event ids as keys and event objects as
     *               values.
     */
    getCacheForDate: function(date, calendar)
    {
        if (calendar) {
            var cals = calendar.split('|');
            if (!this.ecache.get(cals[0]) ||
                !this.ecache.get(cals[0]).get(cals[1])) {
                return $H();
            }
            var x = this.ecache.get(cals[0]).get(cals[1]).get(date);
            return this.ecache.get(cals[0]).get(cals[1]).get(date);
        }

        var events = $H();
        this.ecache.each(function(type) {
            type.value.each(function(cal) {
                if (!Kronolith.conf.calendars[type.key][cal.key].show) {
                    return;
                }
                events = events.merge(cal.value.get(date));
            });
        });
        return events;
    },

    /**
     * Helper method for Enumerable.sortBy to sort events first by start time,
     * second by end time reversed.
     *
     * @param Hash event  A hash entry with the event object as the value.
     *
     * @return string  A comparable string.
     */
    sortEvents: function(event)
    {
        return event.value.sort;
    },

    /**
     * Adds a new location to the history and displays it in the URL hash.
     *
     * This is not really a history, because only the current and the last
     * location are stored.
     *
     * @param string loc    The location to save.
     * @param boolean save  Whether to actually save the location. This should
     *                      be false for any location that are displayed on top
     *                      of another location, i.e. in a popup view.
     */
    addHistory: function(loc, save)
    {
        location.hash = encodeURIComponent(loc);
        this.lastLocation = this.currentLocation;
        if (Object.isUndefined(save) || save) {
            this.currentLocation = loc;
        }
        this.openLocation = loc;
    },

    /**
     * Loads an external page.
     *
     * @param string loc  The URL of the page to load.
     */
    loadPage: function(loc)
    {
        window.location.assign(loc);
    },

    searchSubmit: function(e)
    {
        this.go('search:' + this.search + ':' + $F('horde-search-input'));
    },

    searchReset: function(e)
    {
        HordeTopbar.searchGhost.reset();
    },

    /**
     * Event handler for HordeCore:showNotifications events.
     */
    showNotification: function(e)
    {
        if (!e.memo.flags ||
            !e.memo.flags.alarm ||
            !e.memo.flags.growl ||
            !e.memo.flags.alarm.params.notify.ajax) {
            return;
        }

        var growl = e.memo.flags.growl, link = growl.down('A');

        if (link) {
            link.observe('click', function(ee) {
                ee.stop();
                HordeCore.Growler.ungrowl(growl);
                this.go(e.memo.flags.alarm.params.notify.ajax);
            }.bind(this));
        }
    },

    /* Keydown event handler */
    keydownHandler: function(e)
    {
        if (e.stopped) {
            return;
        }

        var kc = e.keyCode || e.charCode,
            form = e.findElement('FORM'), trigger = e.findElement();

        switch (trigger.id) {
        case 'kronolithEventLocation':
            if (kc == Event.KEY_RETURN && $F('kronolithEventLocation')) {
                this.initializeMap(true);
                this.geocode($F('kronolithEventLocation'));
                e.stop();
                return;
            }
            break;

        case 'kronolithCalendarinternalUrlCaldav':
        case 'kronolithCalendarinternalUrlWebdav':
        case 'kronolithCalendarinternalUrlAccount':
        case 'kronolithCalendarinternalUrlFeed':
        case 'kronolithCalendartasklistsUrlCaldav':
        case 'kronolithCalendartasklistsUrlWebdav':
        case 'kronolithCalendartasklistsUrlAccount':
            if (String.fromCharCode(kc) != 'C' ||
                (this.macos && !e.metaKey) ||
                (!this.macos && !e.ctrlKey)) {
                e.stop();
                return;
            }
            break;
        }

        if (form) {
            switch (kc) {
            case Event.KEY_RETURN:
                switch (form.identify()) {
                case 'kronolithEventForm':
                    if (e.element().tagName != 'TEXTAREA') {
                        this.saveEvent();
                        e.stop();
                    }
                    break;

                case 'kronolithTaskForm':
                    if (e.element().tagName != 'TEXTAREA') {
                        this.saveTask();
                        e.stop();
                    }
                    break;

                case 'kronolithQuickinsertForm':
                    this.quickSaveEvent();
                    e.stop();
                    break;

                case 'kronolithCalendarForminternal':
                case 'kronolithCalendarFormtasklists':
                case 'kronolithCalendarFormremote':
                    // Disabled for now, we have to also catch Continue buttons.
                    //var saveButton = form.down('.kronolithCalendarSave');
                    //saveButton.disable();
                    //if (!this.saveCalendar(form)) {
                    //    saveButton.enable();
                    //}
                    //e.stop();
                    break;
                }
                break;

            case Event.KEY_ESC:
                switch (form.identify()) {
                case 'kronolithQuickinsertForm':
                case 'kronolithQuicktaskForm':
                    this.quickClose();
                    break;
                case 'kronolithEventForm':
                case 'kronolithTaskForm':
                    Horde_Calendar.hideCal();
                    this.closeRedBox();
                    this.go(this.lastLocation);
                    break;
                }
                break;
            }

            return;
        }

        switch (kc) {
        case Event.KEY_ESC:
            Horde_Calendar.hideCal();
            this.closeRedBox();
            break;
        }
    },

    keyupHandler: function(e)
    {
        switch (e.element().readAttribute('id')) {
        case 'kronolithEventLocation':
            if ($F('kronolithEventLocation') && Kronolith.conf.maps.driver) {
                $('kronolithEventMapLink').show();
            } else if (Kronolith.conf.maps.driver) {
                $('kronolithEventMapLink').hide();
                this.removeMapMarker();
            }
            return;

        case 'kronolithEventStartTime':
        case 'kronolithEventEndTime':
            var field = $(e.element().readAttribute('id')), kc = e.keyCode;

            switch(e.keyCode) {
            case Event.KEY_UP:
            case Event.KEY_DOWN:
            case Event.KEY_RIGHT:
            case Event.KEY_LEFT:
                return;
            default:
                if ($F(field) !== this.knl[field.identify()].getCurrentEntry()) {
                    this.knl[field.identify()].markSelected(null);
                }
                return;
            }
        }

    },

    clickHandler: function(e, dblclick)
    {
        if (e.isRightClick() || typeof e.element != 'function') {
            return;
        }

        var elt = e.element(),
            orig = e.element(),
            id, tmp, calendar;

        while (Object.isElement(elt)) {
            id = elt.readAttribute('id');

            switch (id) {
            case 'kronolithNewEvent':
                this.go('event');
                e.stop();
                return;

            case 'kronolithNewTask':
                this.go('task');
                e.stop();
                return;

            case 'kronolithQuickEvent':
                if (this.view == 'tasks') {
                    RedBox.showHtml($('kronolithQuicktask').show());
                } else {
                    this.updateCalendarDropDown('kronolithQuickinsertCalendars');
                    $('kronolithQuickinsertCalendars').setValue(Kronolith.conf.default_calendar);
                    RedBox.showHtml($('kronolithQuickinsert').show());
                }
                e.stop();
                return;

            case 'kronolithQuickinsertSave':
                this.quickSaveEvent();
                e.stop();
                return;

            case 'kronolithQuicktaskSave':
                this.quickSaveTask();
                e.stop();
                return;

            case 'kronolithQuickinsertCancel':
            case 'kronolithQuicktaskCancel':
                this.quickClose();
                e.stop();
                return;

            case 'kronolithGotoToday':
                var view = this.view;
                if (!$w('day workweek week month year agenda').include(view)) {
                    view = Kronolith.conf.login_view;
                }
                this.go(view + ':' + new Date().dateString());
                e.stop();
                return;

            case 'kronolithEventAllday':
                this.toggleAllDay();
                break;

            case 'kronolithEventAlarmDefaultOn':
                this.disableAlarmMethods('Event');
                break;

            case 'kronolithTaskAlarmDefaultOn':
                this.disableAlarmMethods('Task');
                break;

            case 'kronolithEventAlarmPrefs':
                HordeCore.redirect(HordeCore.addURLParam(
                    Kronolith.conf.prefs_url,
                    {
                        group: 'notification'
                    }
                ));
                e.stop();
                break;

            case 'kronolithTaskAlarmPrefs':
                if (Kronolith.conf.tasks.prefs_url) {
                    HordeCore.redirect(HordeCore.addURLParam(
                        Kronolith.conf.tasks.prefs_url,
                        {
                            group: 'notification'
                        }
                    ));
                }
                e.stop();
                break;

            case 'kronolithEventLinkNone':
            case 'kronolithEventLinkDaily':
            case 'kronolithEventLinkWeekly':
            case 'kronolithEventLinkMonthly':
            case 'kronolithEventLinkYearly':
            case 'kronolithEventLinkLength':
            case 'kronolithTaskLinkNone':
            case 'kronolithTaskLinkDaily':
            case 'kronolithTaskLinkWeekly':
            case 'kronolithTaskLinkMonthly':
            case 'kronolithTaskLinkYearly':
            case 'kronolithTaskLinkLength':
                this.toggleRecurrence(
                    id.startsWith('kronolithEvent'),
                    id.substring(id.startsWith('kronolithEvent') ? 18 : 17));
                break;

            case 'kronolithEventRepeatDaily':
            case 'kronolithEventRepeatWeekly':
            case 'kronolithEventRepeatMonthly':
            case 'kronolithEventRepeatYearly':
            case 'kronolithEventRepeatLength':
            case 'kronolithTaskRepeatDaily':
            case 'kronolithTaskRepeatWeekly':
            case 'kronolithTaskRepeatMonthly':
            case 'kronolithTaskRepeatYearly':
            case 'kronolithTaskRepeatLength':
                this.toggleRecurrence(
                    id.startsWith('kronolithEvent'),
                    id.substring(id.startsWith('kronolithEvent') ? 20 : 19));
                break;

            case 'kronolithEventSave':
                if (!elt.disabled) {
                    this._checkDate($('kronolithEventStartDate'));
                    this._checkDate($('kronolithEventEndDate'));
                    if ($F('kronolithEventAttendees') && $F('kronolithEventId')) {
                        $('kronolithEventSendUpdates').setValue(0);
                        $('kronolithEventDiv').hide();
                        $('kronolithUpdateDiv').show();
                        e.stop();
                        break;
                    }
                }
            case 'kronolithEventSendUpdateYes':
                if (this.uatts) {
                    this.uatts.u = true;
                } else {
                    $('kronolithEventSendUpdates').setValue(1);
                }
            case 'kronolithEventSendUpdateNo':
                if (this.uatts) {
                    this.doDragDropUpdate(this.uatts, this.ucb);
                    this.uatts = null;
                    this.ucb = null;
                    this.closeRedBox();
                    $('kronolithUpdateDiv').hide();
                    $('kronolithEventDiv').show();
                } else if (!elt.disabled) {
                    this.saveEvent();
                }
                e.stop();
                break;
            case 'kronolithEventConflictYes':
                this.doSaveEvent();
                e.stop();
                break;
            case 'kronolithEventConflictNo':
                $('kronolithConflictDiv').hide();
                $('kronolithEventDiv').show();
                e.stop();
                break;
            case 'kronolithEventSaveAsNew':
                if (!elt.disabled) {
                    $('kronolithEventSendUpdates').setValue(1);
                    this.saveEvent(true);
                }
                e.stop();
                break;

            case 'kronolithTaskSave':
                if (!elt.disabled) {
                    this.saveTask();
                }
                e.stop();
                break;

            case 'kronolithEventDeleteCancel':
                $('kronolithDeleteDiv').hide();
                $('kronolithEventDiv').show();
                e.stop();
                return;

            case 'kronolithEventSendCancellationYes':
                $('kronolithRecurDeleteAll').enable();
                $('kronolithRecurDeleteCurrent').enable();
                $('kronolithRecurDeleteFuture').enable();
                this.paramsCache.sendupdates = 1;
            case 'kronolithEventSendCancellationNo':
                $('kronolithRecurDeleteAll').enable();
                $('kronolithRecurDeleteCurrent').enable();
                $('kronolithRecurDeleteFuture').enable();
                $('kronolithCancellationDiv').hide();
                this.delete_verified = true;
            case 'kronolithEventDelete':
                if ((Kronolith.conf.confirm_delete || this.recurs) && !this.delete_verified) {
                    $('kronolithEventDiv').hide();
                    $('kronolithDeleteDiv').show();
                    e.stop();
                    break;
                } else {
                    $('kronolithEventDiv').hide();
                    this.delete_verified = false;
                }
                // Fallthrough
            case 'kronolithRecurDeleteAll':
            case 'kronolithRecurDeleteCurrent':
            case 'kronolithRecurDeleteFuture':
            case 'kronolithEventDeleteConfirm':
                if (elt.disabled) {
                    e.stop();
                    break;
                }
                elt.disable();
                var cal = $F('kronolithEventCalendar'),
                    eventid = $F('kronolithEventId');
                if (id != 'kronolithEventSendCancellationNo' &&
                    id != 'kronolithEventSendCancellationYes') {
                    this.paramsCache = {
                        cal: cal,
                        id: eventid,
                        rstart: $F('kronolithEventRecurOStart'),
                        cstart: this.cacheStart.toISOString(),
                        cend: this.cacheEnd.toISOString()
                    };
                    switch (id) {
                    case 'kronolithRecurDeleteAll':
                        this.paramsCache.r = 'all';
                        break;
                    case 'kronolithRecurDeleteCurrent':
                        this.paramsCache.r = 'current';
                        break;
                    case 'kronolithRecurDeleteFuture':
                        this.paramsCache.r = 'future';
                        break;
                    }
                }

                if (id != 'kronolithEventSendCancellationNo'
                    && id != 'kronolithEventSendCancellationYes'
                    && $F('kronolithEventAttendees')) {

                    $('kronolithDeleteDiv').hide();
                    $('kronolithCancellationDiv').show();
                    e.stop();
                    break;
                }

                this.kronolithBody.select('div').findAll(function(el) {
                    return el.retrieve('calendar') == cal &&
                        el.retrieve('eventid') == eventid;
                }).invoke('hide');
                var viewDates = this.viewDates(this.date, this.view),
                start = viewDates[0].toString('yyyyMMdd'),
                end = viewDates[1].toString('yyyyMMdd');
                this.paramsCache.sig = start + end + (Math.random() + '').slice(2);
                this.paramsCache.view_start = start;
                this.paramsCache.view_end = end;

                HordeCore.doAction('deleteEvent', this.paramsCache, {
                    callback: function(elt,r) {
                        if (r.deleted) {
                            var days;
                            if (this.view == 'month' ||
                                this.view == 'week' ||
                                this.view == 'workweek' ||
                                this.view == 'day') {
                                days = this.findEventDays(cal, eventid);
                                days.each(function(day) {
                                    this.refreshResources(day, cal, eventid);
                                }.bind(this));
                            }
                            this.removeEvent(cal, eventid);
                            if (r.uid) {
                                this.removeException(cal, r.uid);
                            }
                            this.loadEventsCallback(r, false);
                            if (days && days.length) {
                                this.reRender(days);
                            }
                        } else {
                            this.kronolithBody.select('div').findAll(function(el) {
                                return el.retrieve('calendar') == cal &&
                                       el.retrieve('eventid') == eventid;
                            }).invoke('show');
                        }
                        elt.enable();
                    }.curry(elt).bind(this)
                });

                $('kronolithDeleteDiv').hide();
                $('kronolithEventDiv').show();
                this.closeRedBox();
                this.go(this.lastLocation);
                e.stop();
                break;

            case 'kronolithTaskDelete':
                if (elt.disabled) {
                    e.stop();
                    break;
                }

                elt.disable();
                var tasklist = $F('kronolithTaskOldList'),
                    taskid = $F('kronolithTaskId');

                HordeCore.doAction('deleteTask', {
                    list: tasklist,
                    id: taskid
                }, {
                    callback: function(r) {
                        if (r.deleted) {
                            this.removeTask(tasklist, taskid);
                        } else {
                            elt.enable();
                            $('kronolithViewTasksBody').select('tr').find(function(el) {
                                return el.retrieve('tasklist') == tasklist &&
                                       el.retrieve('taskid') == taskid;
                            }).toggle();
                        }
                    }.bind(this)
                });

                var taskrow = $('kronolithViewTasksBody').select('tr').find(function(el) {
                    return el.retrieve('tasklist') == tasklist &&
                        el.retrieve('taskid') == taskid;
                });
                if (taskrow) {
                    taskrow.hide();
                }
                this.closeRedBox();
                this.go(this.lastLocation);
                e.stop();
                break;

            case 'kronolithCinternalPMore':
            case 'kronolithCinternalPLess':
            case 'kronolithCtasklistsPMore':
            case 'kronolithCtasklistsPLess':
                var type = id.match(/kronolithC(.*)P/)[1];
                $('kronolithC' + type + 'PBasic').toggle();
                $('kronolithC' + type + 'PAdvanced').toggle();
                e.stop();
                break;

            case 'kronolithCinternalPNone':
            case 'kronolithCinternalPAll':
            case 'kronolithCinternalPG':
            case 'kronolithCinternalPU':
            case 'kronolithCtasklistsPNone':
            case 'kronolithCtasklistsPAll':
            case 'kronolithCtasklistsPG':
            case 'kronolithCtasklistsPU':
                var info = id.match(/kronolithC(.*)P(.*)/);
                this.permsClickHandler(info[1], info[2]);
                break;

            case 'kronolithCinternalPAllShow':
            case 'kronolithCtasklistsPAllShow':
                var type = id.match(/kronolithC(.*)P/)[1];
                this.permsClickHandler(type, 'All');
                break;

            case 'kronolithCinternalPAdvanced':
            case 'kronolithCtasklistsPAdvanced':
                var type = id.match(/kronolithC(.*)P/)[1];
                if (orig.tagName != 'INPUT') {
                    break;
                }
                this.activateAdvancedPerms(type);
                if (orig.name.match(/u_.*||new/)) {
                    this.insertGroupOrUser(type, 'user');
                }
                break;

            case 'kronolithCinternalPUAdd':
            case 'kronolithCinternalPGAdd':
            case 'kronolithCtasklistsPUAdd':
            case 'kronolithCtasklistsPGAdd':
                var info = id.match(/kronolithC(.*)P(.)/);
                this.insertGroupOrUser(info[1], info[2] == 'U' ? 'user' : 'group');
                break;

            case 'kronolithNavDay':
            case 'kronolithNavWeek':
            case 'kronolithNavWorkweek':
            case 'kronolithNavMonth':
            case 'kronolithNavYear':
            case 'kronolithNavAgenda':
                this.go(id.substring(12).toLowerCase() + ':' + this.date.dateString());
                e.stop();
                return;

            case 'kronolithNavTasks':
                this.go('tasks');
                e.stop();
                return;

            case 'kronolithTasksAll':
            case 'kronolithTasksComplete':
            case 'kronolithTasksIncomplete':
            case 'kronolithTasksFuture':
                this.go('tasks:' + id.substring(14).toLowerCase());
                e.stop();
                return;

            case 'kronolithMinicalDate':
                this.go('month:' + orig.retrieve('date'));
                e.stop();
                return;

            case 'kronolith-minical':
                if (orig.id == 'kronolith-minical-prev') {
                    var date = this.parseDate($('kronolithMinicalDate').retrieve('date'));
                    date.previous().month();
                    this.updateMinical(date, date.getMonth() == this.date.getMonth() ? this.view : undefined);
                    e.stop();
                    return;
                }
                if (orig.id == 'kronolith-minical-next') {
                    var date = this.parseDate($('kronolithMinicalDate').retrieve('date'));
                    date.next().month();
                    this.updateMinical(date, date.getMonth() == this.date.getMonth() ? this.view : null);
                    e.stop();
                    return;
                }

                var tmp = orig;
                if (tmp.tagName.toLowerCase() != 'td') {
                    tmp = tmp.up('td');
                }
                if (tmp) {
                    if (tmp.retrieve('weekdate') &&
                        tmp.hasClassName('kronolith-minical-week')) {
                        this.go('week:' + tmp.retrieve('weekdate'));
                    } else if (tmp.retrieve('date') &&
                               !tmp.hasClassName('empty')) {
                        this.go('day:' + tmp.retrieve('date'));
                    }
                }
                e.stop();
                return;

            case 'kronolithEventsDay':
                var date = this.date.clone();
                date.add(Math.round((e.pointerY() - elt.cumulativeOffset().top + elt.up('.kronolithViewBody').scrollTop) / this.daySizes.height * 2) * 30).minutes();
                this.go('event:' + date.toString('yyyyMMddHHmm'));
                e.stop();
                return;

            case 'kronolithViewMonth':
                if (orig.hasClassName('kronolith-first-col')) {
                    var date = orig.retrieve('date');
                    if (date) {
                        this.go('week:' + date);
                        e.stop();
                        return;
                    }
                }
                e.stop();
                return;

            case 'kronolithViewYear':
                var tmp = orig;
                if (tmp.tagName.toLowerCase() != 'td' && tmp.tagName.toLowerCase() != 'th') {
                    tmp = tmp.up('td');
                }
                if (tmp) {
                    if (tmp.retrieve('weekdate') &&
                        tmp.hasClassName('kronolith-minical-week')) {
                        this.go('week:' + tmp.retrieve('weekdate'));
                    } else if (tmp.hasClassName('kronolithMinicalDate')) {
                        this.go('month:' + tmp.retrieve('date'));
                    } else if (tmp.retrieve('date') &&
                               !tmp.hasClassName('empty')) {
                        this.go('day:' + tmp.retrieve('date'));
                    }
                }
                e.stop();
                return;

            case 'kronolithViewAgendaBody':
                var tmp = orig;
                if (tmp.tagName != 'TR') {
                    tmp = tmp.up('tr');
                }
                if (tmp && tmp.retrieve('date')) {
                    this.go('day:' + tmp.retrieve('date'));
                }
                e.stop();
                return;

            case 'kronolithSearchButton':
                this.go('search:' + this.search + ':' + $F('horde-search-input'));
                e.stop();
                break;

            case 'kronolithSearchFuture':
                if (this.search != 'future') {
                    this.go('search:future:' + $F('horde-search-input'));
                }
                e.stop();
                break;

            case 'kronolithSearchPast':
                if (this.search != 'past') {
                    this.go('search:past:' + $F('horde-search-input'));
                }
                e.stop();
                break;

            case 'kronolithSearchAll':
                if (this.search != 'all') {
                    this.go('search:all:' + $F('horde-search-input'));
                }
                e.stop();
                break;
            case 'kronolithEventToTimeslice':
                var params = $H();
                params.set('e', $('kronolithEventId').value);
                params.set('cal', $('kronolithEventCalendar').value);
                params.set('t', $('kronolithEventTimesliceType').value);
                params.set('c', $('kronolithEventTimesliceClient').value);
                HordeCore.doAction('toTimeslice', params);
                break;
            case 'kronolithEventDialog':
            case 'kronolithTaskDialog':
                Horde_Calendar.hideCal();
                return;

            case 'kronolithCalendarDialog':
                if (this.colorPicker) {
                    this.colorPicker.hide();
                }
                return;

            case 'kronolithEditRecurCurrent':
            case 'kronolithEditRecurFuture':
                $('kronolithEventStartDate').setValue(this.orstart);
                $('kronolithEventEndDate').setValue(this.orend);
                if (id == 'kronolithEditRecurCurrent') {
                    this.toggleRecurrence('Exception');
                } else {
                    this.toggleRecurrence(this.lastRecurType);
                }
                return;
            case 'kronolithEditRecurAll':
                this.toggleRecurrence(this.lastRecurType);
                break;
            case 'kronolithEventUrlToggle':
                $('kronolithEventUrlDisplay').hide();
                $('kronolithEventUrl').show();
                e.stop();
                return;
            case 'kronolithCalendarinternalImportButton':
                // Used when user has edit perms to a shared calendar.
                this.calendarImport(elt.up('form'), true);
                break;
            }

            // Caution, this only works if the element has definitely only a
            // single CSS class.
            switch (elt.className) {
            case 'kronolithPrev':
            case 'kronolithNext':
                var newDate = this.date.clone(),
                    offset = elt.className == 'kronolithPrev' ? -1 : 1;
                switch (this.view) {
                case 'day':
                case 'agenda':
                    newDate.add(offset).day();
                    break;
                case 'week':
                case 'workweek':
                    newDate.add(offset).week();
                    break;
                case 'month':
                    newDate.add(offset).month();
                    break;
                case 'year':
                    newDate.add(offset).year();
                    break;
                }
                this.go(this.view + ':' + newDate.dateString());
                e.stop();
                return;

            case 'horde-add':
                this.go('calendar:' + id.replace(/kronolithAdd/, ''));
                e.stop();
                return;

            case 'kronolithTabLink':
                this.openTab(elt);
                e.stop();
                break;

            case 'horde-cancel':
                this.closeRedBox();
                this.resetMap();
                this.go(this.lastLocation);
                e.stop();
                break;

            case 'kronolithEventTag':
                HordeImple.AutoCompleter.kronolithEventTags.addNewItemNode(elt.getText());
                e.stop();
                break;

            case 'kronolithCalendarTag':
                HordeImple.AutoCompleter.kronolithCalendarinternalTags.addNewItemNode(elt.getText());
                e.stop();
                break;

            case 'kronolithTaskTag':
                HordeImple.AutoCompleter.kronolithTaskTags.addNewItemNode(elt.getText());
                e.stop();
                break;

            case 'kronolithEventGeo':
                this.initializeMap(true);
                this.geocode($F('kronolithEventLocation'));
                e.stop();
                break;

            case 'kronolithTaskRow':
                if (elt.retrieve('taskid')) {
                    this.go('task:' + elt.retrieve('tasklist') + ':' + elt.retrieve('taskid'));
                }
                e.stop();
                return;

            case 'horde-resource-edit-000':
            case 'horde-resource-edit-fff':
                this.go('calendar:' + elt.up().retrieve('calendarclass') + '|' + elt.up().retrieve('calendar'));
                e.stop();
                return;

            case 'kronolithMore':
                this.go('day:' + elt.retrieve('date'));
                e.stop();
                return;

            case 'kronolithDatePicker':
                id = elt.readAttribute('id');
                Horde_Calendar.open(id, Date.parseExact($F(id.replace(/Picker$/, 'Date')), Kronolith.conf.date_format));
                e.stop();
                return;

            case 'kronolithColorPicker':
                var input = elt.previous();
                this.colorPicker = new ColorPicker({
                    color: $F(input),
                    offsetParent: elt,
                    update: [[input, 'value'],
                             [input, 'background']]
                });
                e.stop();
                return;
            }

            if (elt.hasClassName('kronolith-event')) {
                if (!Object.isUndefined(elt.retrieve('ajax'))) {
                    this.go(elt.retrieve('ajax'));
                } else {
                    this.go('event:' + elt.retrieve('calendar') + ':' + elt.retrieve('eventid') + ':' + elt.up().retrieve('date'));
                }
                e.stop();
                return;
            } else if (elt.hasClassName('kronolithMonthDay')) {
                if (orig.hasClassName('kronolith-day')) {
                    var date = orig.retrieve('date');
                    if (date) {
                        this.go('day:' + date);
                        e.stop();
                        return;
                    }
                }
                this.go('event:' + elt.retrieve('date'));
                e.stop();
                return;
            } else if (elt.hasClassName('kronolithWeekDay')) {
                this.go('day:' + elt.retrieve('date'));
                e.stop();
                return;
            } else if (elt.hasClassName('kronolithEventsWeek') ||
                       elt.hasClassName('kronolithEventsWorkweek') ||
                       elt.hasClassName('kronolithAllDayContainer')) {
                var date = elt.retrieve('date');
                if (elt.hasClassName('kronolithAllDayContainer')) {
                    date += 'all';
                } else {
                    date = this.parseDate(date);
                    date.add(Math.round((e.pointerY() - elt.cumulativeOffset().top + elt.up('.kronolithViewBody').scrollTop) / (elt.hasClassName('kronolithEventsWeek') ? this.weekSizes.height : this.workweekSizes.height) * 2) * 30).minutes();
                    date = date.toString('yyyyMMddHHmm');
                }
                this.go('event:' + date);
                e.stop();
                return;
            } else if (elt.hasClassName('kronolithTaskCheckbox')) {
                var taskid = elt.up('tr.kronolithTaskRow', 0).retrieve('taskid'),
                    tasklist = elt.up('tr.kronolithTaskRow', 0).retrieve('tasklist');
                this.toggleCompletionClass(taskid);

                HordeCore.doAction('toggleCompletion', {
                    list: tasklist,
                    id: taskid
                }, {
                    callback: function(r) {
                        if (r.toggled) {
                            this.toggleCompletion(tasklist, taskid, r.toggled);
                            if (r.toggled !== true) {
                                this.toggleCompletionClass(taskid);
                            }
                        } else {
                            this.toggleCompletionClass(taskid);
                        }
                    }.bind(this)
                });

                e.stop();
                return;
            } else if (elt.hasClassName('kronolithCalendarSave')) {
                if (!elt.disabled) {
                    elt.disable();
                    if (!this.saveCalendar(elt.up('form'))) {
                        elt.enable();
                    }
                }
                e.stop();
                break;
            } else if (elt.hasClassName('kronolithCalendarContinue')) {
                if (elt.disabled) {
                    e.stop();
                    break;
                }

                elt.disable();
                var form = elt.up('form'),
                    type = form.id.replace(/kronolithCalendarForm/, ''),
                    i = 1;
                while (!$('kronolithCalendar' + type + i).visible()) {
                    i++;
                }
                if (type == 'remote') {
                    var params = { url: $F('kronolithCalendarremoteUrl') };
                    if (i == 1) {
                        if (!$F('kronolithCalendarremoteUrl')) {
                            HordeCore.notify(Kronolith.text.no_url, 'horde.warning');
                            e.stop();
                            break;
                        }

                        HordeCore.doAction('getRemoteInfo', params, {
                            asynchronous: false,
                            callback: function(r) {
                                if (r.success) {
                                    if (r.name) {
                                        $('kronolithCalendarremoteName').setValue(r.name);
                                    }
                                    if (r.desc) {
                                        $('kronolithCalendarremoteDescription').setValue(r.desc);
                                    }
                                    this.calendarNext(type);
                                    this.calendarNext(type);
                                } else if (r.auth) {
                                    this.calendarNext(type);
                                } else {
                                    elt.enable();
                                }
                            }.bind(this)
                        });

                    }
                    if (i == 2) {
                        if ($F('kronolithCalendarremoteUsername')) {
                            params.user = $F('kronolithCalendarremoteUsername');
                            params.password =  $F('kronolithCalendarremotePassword');
                        }

                        HordeCore.doAction('getRemoteInfo', params, {
                            callback: function(r) {
                                if (r.success) {
                                    if (r.name &&
                                        !$F('kronolithCalendarremoteName')) {
                                        $('kronolithCalendarremoteName').setValue(r.name);
                                    }
                                    if (r.desc &&
                                        !$F('kronolithCalendarremoteDescription')) {
                                        $('kronolithCalendarremoteDescription').setValue(r.desc);
                                    }
                                    this.calendarNext(type);
                                } else {
                                    if (r.auth) {
                                        HordeCore.notify(Kronolith.text.wrong_auth, 'horde.warning');
                                    }
                                    elt.enable();
                                }
                            }.bind(this)
                        });
                    }
                    e.stop();
                    break;
                }
                this.calendarNext(type);
                e.stop();
                break;
            } else if (elt.hasClassName('kronolithCalendarDelete')) {
                var form = elt.up('form'),
                    type = form.id.replace(/kronolithCalendarForm/, ''),
                    calendar = $F('kronolithCalendar' + type + 'Id');

                if ((type == 'tasklists' &&
                     !window.confirm(Kronolith.text.delete_tasklist)) ||
                    (type != 'tasklists' &&
                     !window.confirm(Kronolith.text.delete_calendar))) {
                    e.stop();
                    break;
                }

                if (!elt.disabled) {
                    elt.disable();

                    HordeCore.doAction('deleteCalendar', {
                        type: type,
                        calendar: calendar
                    }, {
                        callback: function(r) {
                            if (r.deleted) {
                                this.deleteCalendar(type, calendar);
                            }
                            this.closeRedBox();
                            this.go(this.lastLocation);
                        }.bind(this)
                    });
                }
                e.stop();
                break;
            } else if (elt.hasClassName('kronolithCalendarSubscribe') ||
                       elt.hasClassName('kronolithCalendarUnsubscribe')) {
                var form = elt.up('form');
                this.toggleCalendar($F(form.down('input[name=type]')),
                                    $F(form.down('input[name=calendar]')));
                this.closeRedBox();
                this.go(this.lastLocation);
                e.stop();
                break;
            } else if (elt.tagName == 'INPUT' &&
                       (elt.name == 'event_alarms[]' ||
                        elt.name == 'task[alarm_methods][]')) {
                if (elt.name == 'event_alarms[]') {
                    $('kronolithEventAlarmOn').setValue(1);
                    $('kronolithEventAlarmDefaultOff').setValue(1);
                } else {
                    $('kronolithTaskAlarmOn').setValue(1);
                    $('kronolithTaskAlarmDefaultOff').setValue(1);
                }
                if ($(elt.id + 'Params')) {
                    if (elt.getValue()) {
                        $(elt.id + 'Params').show();
                    } else {
                        $(elt.id + 'Params').hide();
                    }
                }
                break;
            }

            var calClass = elt.retrieve('calendarclass');
            if (calClass) {
                this.toggleCalendar(calClass, elt.retrieve('calendar'));
                e.stop();
                return;
            }

            elt = elt.up();
        }
        // Workaround Firebug bug.
        Prototype.emptyFunction();
    },

    /**
     * Handles date selections from a date picker.
     */
    datePickerHandler: function(e)
    {
        var field = e.element().previous();
        field.setValue(e.memo.toString(Kronolith.conf.date_format));
        this.updateTimeFields(field.identify());
    },

    /**
     * Handles moving an event to a different day in month view and all day
     * events in weekly/daily views.
     */
    onDrop: function(e)
    {
        var drop = e.element(),
            el = e.memo.element;

        if (drop == el.up()) {
            return;
        }

        var lastDate = this.parseDate(el.up().retrieve('date')),
            newDate = this.parseDate(drop.retrieve('date')),
            diff = newDate.subtract(lastDate),
            eventid = el.retrieve('eventid'),
            cal = el.retrieve('calendar'),
            viewDates = this.viewDates(this.date, this.view),
            start = viewDates[0].toString('yyyyMMdd'),
            end = viewDates[1].toString('yyyyMMdd'),
            sig = start + end + (Math.random() + '').slice(2),
            events = this.getCacheForDate(lastDate.toString('yyyyMMdd'), cal),
            attributes = $H({ offDays: diff }),
            event = events.find(function(e) { return e.key == eventid; });

        drop.insert(el);
        this.startLoading(cal, sig);
        if (event.value.r) {
            attributes.set('rday', lastDate);
            attributes.set('cstart', this.cacheStart);
            attributes.set('cend', this.cacheEnd);
        }
        var uatts = {
            cal: cal,
            id: eventid,
            view: this.view,
            sig: sig,
            view_start: start,
            view_end: end,
            att: Object.toJSON(attributes)
        },
        callback = function(r) {
          if (r.events) {
              // Check if this is the still the result of the
              // most current request.
              if (r.sig == this.eventsLoading[r.cal]) {
                  var days;
                  if ((this.view == 'month' &&
                       Kronolith.conf.max_events) ||
                      this.view == 'week' ||
                      this.view == 'workweek' ||
                      this.view == 'day') {
                      days = this.findEventDays(cal, eventid);
                  }
                  this.removeEvent(cal, eventid);
                  if (days && days.length) {
                      this.reRender(days);
                  }
              }
              $H(r.events).each(function(days) {
                  $H(days.value).each(function(event) {
                      if (event.value.c.startsWith('tasks/')) {
                          var tasklist = event.value.c.substr(6),
                              task = event.key.substr(6),
                              taskObject;
                          if (this.tcache.get('incomplete') &&
                              this.tcache.get('incomplete').get(tasklist) &&
                              this.tcache.get('incomplete').get(tasklist).get(task)) {
                              taskObject = this.tcache.get('incomplete').get(tasklist).get(task);
                              taskObject.due = Date.parse(event.value.s);
                              this.tcache.get('incomplete').get(tasklist).set(task, taskObject);
                          }
                      }
                  }, this);
              }, this);
          }
          this.loadEventsCallback(r, false);
          $H(r.events).each(function(days) {
              $H(days.value).each(function(event) {
                  if (event.key == eventid) {
                      this.refreshResources(days.key, cal, eventid, lastDate.toString('yyyyMMdd'), event);
                  }
              }.bind(this))
          }.bind(this));
      }.bind(this);

      if (event.value.mt) {
          $('kronolithEventDiv').hide();
          $('kronolithUpdateDiv').show();
          RedBox.showHtml($('kronolithEventDialog').show());
          this.uatts = uatts;
          this.ucb = callback;
      } else {
          this.doDragDropUpdate(uatts, callback);
      }
    },

    onDragStart: function(e)
    {
        if (this.view == 'month') {
            return;
        }

        var elt = e.element();

        if (elt.hasClassName('kronolithDragger')) {
            elt.up().addClassName('kronolith-selected');
            DragDrop.Drags.getDrag(elt).top = elt.cumulativeOffset().top;
        } else if (elt.hasClassName('kronolithEditable')) {
            elt.addClassName('kronolith-selected').setStyle({ left: 0, width: (this.view == 'week' || this.view == 'workweek') ? '90%' : '95%', zIndex: 1 });
        }

        this.scrollTop = $('kronolithView' + this.view.capitalize())
            .down('.kronolithViewBody')
            .scrollTop;
        this.scrollLast = this.scrollTop;
    },

    onDrag: function(e)
    {
        if (this.view == 'month') {
            return;
        }

        var elt = e.element(),
            drag = DragDrop.Drags.getDrag(elt);
            storage = this.view + 'Sizes',
            step = this[storage].height / 6;

            if (!drag.event) {
                return;
            }

        var event = drag.event.value;

        if (elt.hasClassName('kronolithDragger')) {
            // Resizing the event.
            var div = elt.up(),
                top = drag.ghost.cumulativeOffset().top,
                scrollTop = $('kronolithView' + this.view.capitalize()).down('.kronolithViewBody').scrollTop,
                offset = 0,
                height;

            // Check if view has scrolled since last call.
            if (scrollTop != this.scrollLast) {
                offset = scrollTop - this.scrollLast;
                this.scrollLast = scrollTop;
            }
            if (elt.hasClassName('kronolithDraggerTop')) {
                offset += top - drag.top;
                height = div.offsetHeight - offset;
                div.setStyle({
                    top: (div.offsetTop + offset) + 'px'
                });
                offset = drag.ghost.offsetTop;
                drag.top = top;
            } else {
                offset += top - drag.top;
                height = div.offsetHeight + offset;
                offset = div.offsetTop;
                drag.top = top;
            }
            div.setStyle({
                height: height + 'px'
            });

            this.calculateEventDates(event, storage, step, offset, height);
            drag.innerDiv.update('(' + event.start.toString(Kronolith.conf.time_format) + ' - ' + event.end.toString(Kronolith.conf.time_format) + ') ' + event.t.escapeHTML());
        } else if (elt.hasClassName('kronolithEditable')) {
            // Moving the event.
            if (Object.isUndefined(drag.innerDiv)) {
                drag.innerDiv = drag.ghost.down('.kronolith-event-info');
            }
            if ((this.view == 'week') || (this.view == 'workweek')) {
                var offsetX = Math.round(drag.ghost.offsetLeft / drag.stepX);
                event.offsetDays = offsetX;
                this.calculateEventDates(event, storage, step, drag.ghost.offsetTop, drag.divHeight, event.start.clone().addDays(offsetX), event.end.clone().addDays(offsetX));
            } else {
                event.offsetDays = 0;
                this.calculateEventDates(event, storage, step, drag.ghost.offsetTop, drag.divHeight);
            }
            event.offsetTop = drag.ghost.offsetTop - drag.startTop;
            drag.innerDiv.update('(' + event.start.toString(Kronolith.conf.time_format) + ' - ' + event.end.toString(Kronolith.conf.time_format) + ') ' + event.t.escapeHTML());
            elt.clonePosition(drag.ghost, { offsetLeft: (this.view == 'week' || this.view == 'workweek') ? -2 : 0 });
        }
    },

    onDragEnd: function(e)
    {
        if (this.view == 'month') {
            return;
        }

        if (!e.element().hasClassName('kronolithDragger') &&
            !e.element().hasClassName('kronolithEditable')) {
            return;
        }

        var div = e.element(),
            drag = DragDrop.Drags.getDrag(div),
            event = drag.event;


        if (event.value.al) {
            return;
        }
        var date = drag.midnight,
            storage = this.view + 'Sizes',
            step = this[storage].height / 6,
            dates = this.viewDates(date, this.view),
            start = dates[0].dateString(),
            end = dates[1].dateString(),
            sig = start + end + (Math.random() + '').slice(2),
            element, attributes;

        div.removeClassName('kronolith-selected');
        if (!Object.isUndefined(drag.innerDiv)) {
            this.setEventText(drag.innerDiv, event.value);
        }
        this.startLoading(event.value.calendar, sig);
        if (!Object.isUndefined(event.value.offsetTop)) {
            attributes = $H({ offDays: event.value.offsetDays,
                              offMins: Math.round(event.value.offsetTop / step) * 10 });
            element = div;
        } else if (div.hasClassName('kronolithDraggerTop')) {
            attributes = $H({ start: event.value.start });
            element = div.up();
        } else if (div.hasClassName('kronolithDraggerBottom')) {
            attributes = $H({ end: event.value.end });
            element = div.up();
        } else {
            attributes = $H({ start: event.value.start,
                              end: event.value.end });
            element = div;
        }
        if (event.value.r) {
            attributes.set('rstart', event.value.s);
            attributes.set('rend', event.value.e);
            attributes.set('cstart', this.cacheStart);
            attributes.set('cend', this.cacheEnd);
        }
        element.retrieve('drags').invoke('destroy');
        var uatts = {
            cal: event.value.calendar,
            id: event.key,
            view: this.view,
            sig: sig,
            view_start: start,
            view_end: end,
            att: Object.toJSON(attributes)
        },
        callback = function(r) {
            // Check if this is the still the result of the most current
            // request.
            if (r.events &&
                r.sig == this.eventsLoading[r.cal]) {
                if (event.value.rs) {
                    var d = new Date(event.value.s);
                    this.refreshResources(d.toString('yyyyMMdd'), event.value.calendar, event.key)
                }
                this.removeEvent(event.value.calendar, event.key);
            }
            this.loadEventsCallback(r, false);
        }.bind(this);

        if (event.value.mt) {
            $('kronolithEventDiv').hide();
            $('kronolithUpdateDiv').show();
            RedBox.showHtml($('kronolithEventDialog').show());
            this.uatts = uatts;
            this.ucb = callback;
        } else {
            this.doDragDropUpdate(uatts, callback);
        }
    },

    doDragDropUpdate: function(att, cb)
    {
        HordeCore.doAction('updateEvent', att, {
            callback: cb
        });
    },

    /**
     * Refresh any resource calendars bound to the given just-updated event.
     * Clears the old resource event from UI and cache, and clears the cache
     * for the days of the new event, in order to allow listEvents to refresh
     * the UI.
     *
     * @param  string dt       The current/new date for the event (yyyyMMdd).
     * @param  string cal      The calendar the event exists in.
     * @param  string eventid  The eventid that is changing.
     * @param  string last_dt  The previous date for the event, if known. (yyyyMMdd).
     * @param  object event    The event object (if a new event) dt is ignored.
     *
     */
    refreshResources: function(dt, cal, eventid, last_dt, event)
    {
        var events = this.getCacheForDate(dt, cal),
            update_cals = [], r_dates;

        if (!event) {
            event = events.find(function(e) { return e.key == eventid; });
        }
        if (!dt) {
            dt = new Date(event.value.s);
        } else {
            dt = this.parseDate(dt);
        }
        if (event) {
            $H(event.value.rs).each(function(r) {
                var r_cal = ['resource', r.value.calendar],
                    r_events = this.getCacheForDate(last_dt, r_cal.join('|')),
                    r_event, day, end;

                if (r_events) {
                    r_event = r_events.find(function(e) { return e.value.uid == event.value.uid });
                    if (r_event) {
                        this.removeEvent(r_cal, r_event.key);
                        day = new Date(r_event.value.s);
                        end = new Date(r_event.value.s);
                        while (!day.isAfter(end)) {
                            this.deleteCache(r_cal, null, day.toString('yyyyMMdd'));
                            day.add(1).day();
                        }
                        day = new Date(event.value.s);
                        end = new Date(event.value.e);

                        while (!day.isAfter(end)) {
                            this.deleteCache(r_cal, null, day.toString('yyyyMMdd'));
                            day.add(1).day();
                        }
                    } else {
                        // Don't know the previous date/time so just nuke the cache.
                       this.deleteCache(r_cal);
                    }
                } else {
                    this.deleteCache(r_cal);
                }
                update_cals.push(r_cal);
            }.bind(this));

            if (update_cals.length) {
                dates = this.viewDates(dt, this.view);
                // Ensure we also grab the full length of the events.
                if (dates[0].isAfter(dt)) {
                    dates[0] = dt;
                }
                var dt_end = new Date(event.value.e);
                if (dt_end.isAfter(dates[1])) {
                    dates[1] = dt_end;
                }
                this.loadEvents(dates[0], dates[1], this.view, update_cals);
            }
        }
    },

    editEvent: function(calendar, id, date, title)
    {
        if (this.redBoxLoading) {
            return;
        }
        if (Object.isUndefined(HordeImple.AutoCompleter.kronolithEventTags)) {
            this.editEvent.bind(this, calendar, id, date).defer();
            return;
        }

        this.closeRedBox();
        this.quickClose();
        this.redBoxOnDisplay = RedBox.onDisplay;
        RedBox.onDisplay = function() {
            if (this.redBoxOnDisplay) {
                this.redBoxOnDisplay();
            }
            try {
                $('kronolithEventForm').focusFirstElement();
            } catch(e) {}
            if (Kronolith.conf.maps.driver &&
                $('kronolithEventLinkMap').up().hasClassName('horde-active') &&
                !this.mapInitialized) {

                this.initializeMap();
            }
            RedBox.onDisplay = this.redBoxOnDisplay;
        }.bind(this);
        this.attendees = [];
        this.resources = [];
        this.updateCalendarDropDown('kronolithEventTarget');
        this.toggleAllDay(false);
        this.openTab($('kronolithEventForm').down('.tabset a.kronolithTabLink'));
        this.disableAlarmMethods('Event');
        this.knl.kronolithEventStartTime.markSelected();
        this.knl.kronolithEventEndTime.markSelected();
        $('kronolithEventForm').reset();
        this.resetMap();
        HordeImple.AutoCompleter.kronolithEventAttendees.reset();
        HordeImple.AutoCompleter.kronolithEventTags.reset();
        HordeImple.AutoCompleter.kronolithEventResources.reset();
        if (Kronolith.conf.maps.driver) {
            $('kronolithEventMapLink').hide();
        }
        $('kronolithEventSave').show().enable();
        $('kronolithEventSaveAsNew').show().enable();
        $('kronolithEventDelete').show().enable();
        $('kronolithEventDeleteConfirm').enable();
        $('kronolithEventTarget').show();
        $('kronolithEventTargetRO').hide();
        $('kronolithEventForm').down('.kronolithFormActions .kronolithSeparator').show();
        $('kronolithEventExceptions').clear();
        if (id) {
            // An id passed to this function indicates we are editing an event.
            RedBox.loading();
            var attributes = { cal: calendar, id: id, date: date };
            // Need the current st and et of this instance.
            var events = this.getCacheForDate(date.toString('yyyyMMdd'), calendar);
            if (events) {
                var ev = events.find(function(e) { return e.key == id; });
                if (ev[1].r) {
                    attributes.rsd = ev[1].start.dateString();
                    attributes.red = ev[1].end.dateString();
                }
            }
            HordeCore.doAction('getEvent', attributes, {
                callback: this.editEventCallback.bind(this)
            });
            $('kronolithEventTopTags').update();
        } else {
            // This is a new event.
            HordeCore.doAction('listTopTags', {}, {
                callback: this.topTagsCallback.curry('kronolithEventTopTags', 'kronolithEventTag')
            });
            var d;
            if (date) {
                if (date.endsWith('all')) {
                    date = date.substring(0, date.length - 3);
                    $('kronolithEventAllday').setValue(true);
                    this.toggleAllDay(true);
                }
                d = this.parseDate(date);
            } else {
                d = new Date();
            }
            if (title) {
                $('kronolithEventTitle').setValue(title);
            }
            $('kronolithEventId').clear();
            $('kronolithEventCalendar').clear();
            $('kronolithEventTarget').setValue(Kronolith.conf.default_calendar);
            $('kronolithEventDelete').hide();
            $('kronolithEventStartDate').setValue(d.toString(Kronolith.conf.date_format));
            $('kronolithEventStartTime').setValue(d.toString(Kronolith.conf.time_format));
            this.updateFBDate(d);
            d.add(1).hour();
            this.duration = 60;
            $('kronolithEventEndDate').setValue(d.toString(Kronolith.conf.date_format));
            $('kronolithEventEndTime').setValue(d.toString(Kronolith.conf.time_format));
            $('kronolithEventLinkExport').up('span').hide();
            $('kronolithEventSaveAsNew').hide();
            $('kronolithEventUrlDisplay').hide();
            $('kronolithEventUrl').show();
            this.toggleRecurrence(true, 'None');
            $('kronolithEventEditRecur').hide();
            this.enableAlarm('Event', Kronolith.conf.default_alarm);
            this.redBoxLoading = true;
            RedBox.showHtml($('kronolithEventDialog').show());
        }
    },

    /**
     * Generates ajax request parameters for requests to save events.
     *
     * @return object  An object with request parameters.
     */
    saveEventParams: function()
    {
        var viewDates = this.viewDates(this.date, this.view),
            params = {
                sig: viewDates[0].dateString() + viewDates[1].dateString(),
                view: this.view
            };
        if (this.cacheStart) {
            params.view_start = this.cacheStart.dateString();
            params.view_end = this.cacheEnd.dateString();
        }
        return params;
    },

    /**
     * Submits the event edit form to create or update an event.
     */
    saveEvent: function(asnew)
    {
        this.validateEvent(asnew);
    },

    /**
     * Perform any preliminary checks necessary. doSaveEvent will be called from
     * the callback if checks are successful.
     *
     */
    validateEvent: function(asnew)
    {
        if (this.wrongFormat.size()) {
            HordeCore.notify(Kronolith.text.fix_form_values, 'horde.warning');
            return;
        }

        // Check that there are no conflicts.
        if (Kronolith.conf.has_resources && $F('kronolithEventResourceIds')) {
            HordeCore.doAction(
                'checkResources',
                {
                    s: this.getDate('start').toISOString(),
                    e: this.getDate('end').toISOString(),
                    i: $F('kronolithEventId'),
                    c: $F('kronolithEventCalendar'),
                    r: $F('kronolithEventResourceIds')
                },
                {
                    callback: this.validateEventCallback.curry(asnew).bind(this)
                }
            );
        } else {
            this.validateEventCallback(asnew, {});
        }
    },

    validateEventCallback: function(asnew, r)
    {
        var conflict = false;

        $H(r).each(function(a) {
            // 3 == Kronolith::RESPONSE_DECLINED
            if (a.value == 3) {
                $('kronolithEventDiv').hide();
                $('kronolithConflictDiv').show();
                conflict = true;
                return;
            }
        });
        if (!conflict) {
            this.doSaveEvent(asnew);
        }
    },

    doSaveEvent: function(asnew)
    {
        var cal = $F('kronolithEventCalendar'),
            target = $F('kronolithEventTarget'),
            eventid = $F('kronolithEventId'),
            params;

        if (this.mapInitialized) {
            $('kronolithEventMapZoom').value = this.map.getZoom();
        }

        params = $H($('kronolithEventForm').serialize({ hash: true }))
            .merge(this.saveEventParams());
        params.set('as_new', asnew ? 1 : 0);
        if (this.cacheStart) {
            params.set('cstart', this.cacheStart.toISOString());
            params.set('cend', this.cacheEnd.toISOString());
        }
        HordeImple.AutoCompleter.kronolithEventTags.shutdown();
        $('kronolithEventSave').disable();
        $('kronolithEventSaveAsNew').disable();
        $('kronolithEventDelete').disable();
        this.startLoading(target, params.get('sig'));
        HordeCore.doAction('saveEvent', params, {
            callback: function(r) {
                if (!asnew && r.events && eventid) {
                    this.removeEvent(cal, eventid);
                }
                this.loadEventsCallback(r, false);

                // Refresh bound exceptions
                var calendar = cal.split('|'), refreshed = false;
                $H(r.events).each(function(d) {
                    $H(d.value).each(function(evt) {
                        if (evt.value.bid) {
                            var cache = this.getCacheForDate(this.findEventDays(cal, evt.key, cal));
                            cache.each(function(entry) {
                                if (entry.value.bid == evt.value.bid && evt.value.c != calendar[1]) {
                                    this.removeEvent(cal, entry.key);
                                }
                            }.bind(this));
                        }
                        if (!refreshed && ((evt.key == eventid) || !eventid) && evt.value.rs) {
                            this.refreshResources(null, cal, eventid, false, evt);
                            refreshed = true;
                        }
                    }.bind(this))
                }.bind(this));

                if (r.events) {
                    this.resetMap();
                    this.closeRedBox();
                    this.go(this.lastLocation);
                } else {
                    $('kronolithEventSave').enable();
                    $('kronolithEventSaveAsNew').enable();
                    $('kronolithEventDelete').enable();
                }
                $('kronolithUpdateDiv').hide();
                $('kronolithConflictDiv').hide();
                $('kronolithEventDiv').show();
            }.bind(this)
        });
    },

    quickSaveEvent: function()
    {
        var text = $F('kronolithQuickinsertQ'),
            cal = $F('kronolithQuickinsertCalendars'),
            params;

        params = $H($('kronolithEventForm').serialize({ hash: true }))
            .merge(this.saveEventParams());
        params.set('text', text);
        params.set('cal', cal);

        this.closeRedBox();
        this.startLoading(cal, params.get('sig'));
        HordeCore.doAction('quickSaveEvent', params, {
            callback: function(r) {
                this.loadEventsCallback(r, false);
                if (r.error) {
                    this.editEvent(null, null, null, text);
                } else {
                    $('kronolithQuickinsertQ').value = '';
                }
             }.bind(this)
         });
    },

    /**
     * Closes and resets the quick event form.
     */
    quickClose: function()
    {
        $('kronolithQuickinsertQ').value = '';
        if ($('kronolithQuicktaskQ')) {
            $('kronolithQuicktaskQ').value = '';
        }
        this.closeRedBox();
    },

    topTagsCallback: function(update, tagclass, r)
    {
        $('kronolithEventTabTags').select('label').invoke('show');
        if (!r.tags) {
            $(update).update();
            return;
        }

        var t = new Element('ul', { className: 'horde-tags' });
        r.tags.each(function(tag) {
            if (tag == null) {
                return;
            }
            t.insert(new Element('li', { className: tagclass }).update(tag.escapeHTML()));
        });
        $(update).update(t);
    },

    /**
     * Callback method for showing event forms.
     *
     * @param object r  The ajax response object.
     */
    editEventCallback: function(r)
    {
        if (!r.event) {
            RedBox.close();
            this.go(this.lastLocation);
            return;
        }

        var ev = r.event;

        if (!Object.isUndefined(ev.ln)) {
            this.loadPage(ev.ln);
            this.closeRedBox();
            return;
        }

        /* Basic information */
        $('kronolithEventId').setValue(ev.id);
        $('kronolithEventCalendar').setValue(ev.ty + '|' + ev.c);
        $('kronolithEventTarget').setValue(ev.ty + '|' + ev.c);
        $('kronolithEventTargetRO').update(Kronolith.conf.calendars[ev.ty][ev.c].name.escapeHTML());
        $('kronolithEventTitle').setValue(ev.t);
        $('kronolithEventLocation').setValue(ev.l);
        $('kronolithEventTimezone').setValue(ev.tz);
        if (ev.l && Kronolith.conf.maps.driver) {
            $('kronolithEventMapLink').show();
        }
        if (ev.uhl) {
            $('kronolithEventUrlDisplay').down().update(ev.uhl);
            $('kronolithEventUrlDisplay').show();
            $('kronolithEventUrl').hide();
        }
        else {
            $('kronolithEventUrlDisplay').hide();
            $('kronolithEventUrl').show();
        }

        if (ev.u) {
            $('kronolithEventUrl').setValue(ev.u);
        }

        $('kronolithEventAllday').setValue(ev.al);

        if (ev.r && ev.rsd && ev.red) {
            // Save the original datetime, so we can properly create the
            // exception.
            var osd = Date.parse(ev.rsd + ' ' + ev.st);
            var oed = Date.parse(ev.red + ' ' + ev.et);

            $('kronolithEventRecurOStart').setValue(osd.toString('s'));
            $('kronolithEventRecurOEnd').setValue(oed.toString('s'));

            // ...and put the same value in the form field to replace the
            // date of the initial series.
            $('kronolithEventStartDate').setValue(ev.sd);
            $('kronolithEventEndDate').setValue(ev.ed);
            // Save the current datetime in case we are not editing 'all'
            this.orstart = ev.rsd;
            this.orend = ev.red;
        } else {
            $('kronolithEventStartDate').setValue(ev.sd);
            $('kronolithEventEndDate').setValue(ev.ed);
            $('kronolithEventRecurEnd').clear();
            $('kronolithEventRecurOStart').clear();
            $('kronolithEventRecurOEnd').clear();
            this.orstart = null;
            this.orend = null;
        }

        $('kronolithEventStartTime').setValue(ev.st);
        this.knl.kronolithEventStartTime.setSelected(ev.st);
        this.updateFBDate(Date.parseExact(ev.sd, Kronolith.conf.date_format));
        $('kronolithEventEndTime').setValue(ev.et);
        this.knl.kronolithEventEndTime.setSelected(ev.et);
        this.duration = Math.abs(Date.parse(ev.e).getTime() - Date.parse(ev.s).getTime()) / 60000;
        this.toggleAllDay(ev.al);
        $('kronolithEventStatus').setValue(ev.x);
        $('kronolithEventDescription').setValue(ev.d);
        $('kronolithEventPrivate').setValue(ev.pv);
        $('kronolithEventLinkExport').up('span').show();
        $('kronolithEventExport').href = Kronolith.conf.URI_EVENT_EXPORT.interpolate({ id: ev.id, calendar: ev.c, type: ev.ty });

        /* Alarm */
        if (ev.a) {
            this.enableAlarm('Event', ev.a);
            if (ev.m) {
                $('kronolithEventAlarmDefaultOff').checked = true;
                $H(ev.m).each(function(method) {
                    $('kronolithEventAlarm' + method.key).setValue(1);
                    if ($('kronolithEventAlarm' + method.key + 'Params')) {
                        $('kronolithEventAlarm' + method.key + 'Params').show();
                        $H(method.value).each(function(param) {
                            var input = $('kronolithEventAlarmParam' + param.key);
                            if (input.type == 'radio') {
                                input.up('form').select('input[type=radio]').each(function(radio) {
                                    if (radio.name == input.name &&
                                        radio.value == param.value) {
                                        radio.setValue(1);
                                        throw $break;
                                    }
                                });
                            } else {
                                input.setValue(param.value);
                            }
                        });
                    }
                });
            }
        } else {
            $('kronolithEventAlarmOff').setValue(true);
        }

        /* Recurrence */
        if (ev.r) {
            this.setRecurrenceFields(true, ev.r);
            $('kronolithRecurDelete').show();
            $('kronolithNoRecurDelete').hide();
            $('kronolithEventEditRecur').show();
            this.recurs = true;
        } else if (ev.bid) {
            $('kronolithRecurDelete').hide();
            $('kronolithNoRecurDelete').show();
            $('kronolithEventEditRecur').hide();
            var div = $('kronolithEventRepeatException');
            div.down('span').update(ev.eod);
            this.toggleRecurrence(true, 'Exception');
            this.recurs = false;
        } else {
            $('kronolithRecurDelete').hide();
            $('kronolithNoRecurDelete').show();
            $('kronolithEventEditRecur').hide();
            this.toggleRecurrence(true, 'None');
            this.recurs = false;
        }

        /* Attendees */
        if (!Object.isUndefined(ev.at)) {
            HordeImple.AutoCompleter.kronolithEventAttendees.reset(ev.at.pluck('l'));
            ev.at.each(this.addAttendee.bind(this));
            if (this.fbLoading) {
                $('kronolithFBLoading').show();
            }
        }

        /* Resources */
        if (!Object.isUndefined(ev.rs)) {
            var rs = $H(ev.rs);
            HordeImple.AutoCompleter.kronolithEventResources.reset(rs.values().pluck('name'));
            rs.each(function(r) { this.addResource(r.value, r.key); }.bind(this));
            if (this.fbLoading) {
                $('kronolithResourceFBLoading').show();
            }
        }

        /* Tags */
        HordeImple.AutoCompleter.kronolithEventTags.reset(ev.tg);

        /* Geo */
        if (ev.gl) {
            $('kronolithEventLocationLat').value = ev.gl.lat;
            $('kronolithEventLocationLon').value = ev.gl.lon;
            $('kronolithEventMapZoom').value = Math.max(1, ev.gl.zoom);
        }

        if (!ev.pe) {
            $('kronolithEventSave').hide();
            HordeImple.AutoCompleter.kronolithEventTags.disable();
            $('kronolithEventTabTags').select('label').invoke('hide');
        } else {
            HordeCore.doAction('listTopTags', {}, {
                callback: this.topTagsCallback.curry('kronolithEventTopTags', 'kronolithEventTag')
            });
        }
        if (!ev.pd) {
            $('kronolithEventDelete').hide();
            $('kronolithEventTarget').hide();
            $('kronolithEventTargetRO').show();
        }

        this.setTitle(ev.t);
        this.redBoxLoading = true;
        RedBox.showHtml($('kronolithEventDialog').show());

        /* Hide alarm message for this event. */
        if (r.msgs) {
            r.msgs = r.msgs.reject(function(msg) {
                if (msg.type != 'horde.alarm') {
                    return false;
                }
                var alarm = msg.flags.alarm;
                if (alarm.params && alarm.params.notify &&
                    alarm.params.notify.show &&
                    alarm.params.notify.show.calendar &&
                    alarm.params.notify.show.event &&
                    alarm.params.notify.show.calendar == ev.c &&
                    alarm.params.notify.show.event == ev.id) {
                    return true;
                }
                return false;
            });
        }
    },

    /**
     * Adds an attendee row to the free/busy table.
     *
     * @param object attendee  An attendee object with the properties:
     *                         - e: email address
     *                         - l: the display name of the attendee
     */
    addAttendee: function(attendee)
    {
        if (typeof attendee == 'string') {
            if (attendee.include('@')) {
                HordeCore.doAction('parseEmailAddress', {
                    email: attendee
                }, {
                    callback: function (r) {
                        if (r.email) {
                            this.addAttendee({ e: r.email, l: attendee });
                        }
                    }.bind(this)
                });
                return;
            } else {
                attendee = { l: attendee };
            }
        }

        if (attendee.e) {
            this.attendees.push(attendee);
            this.fbLoading++;
            HordeCore.doAction('getFreeBusy', {
                email: attendee.e
            }, {
                callback: function(r) {
                    this.fbLoading--;
                    if (!this.fbLoading) {
                        $('kronolithFBLoading').hide();
                    }
                    if (!Object.isUndefined(r.fb)) {
                        this.freeBusy.get(attendee.l)[1] = r.fb;
                        this.insertFreeBusy(attendee.l, this.getFBDate());
                    }
                }.bind(this)
            });
        }

        var tr = new Element('tr'), response, i;
        this.freeBusy.set(attendee.l, [ tr ]);
        attendee.r = attendee.r || 1;
        switch (attendee.r) {
            case 1: response = 'None'; break;
            case 2: response = 'Accepted'; break;
            case 3: response = 'Declined'; break;
            case 4: response = 'Tentative'; break;
        }
        tr.insert(new Element('td')
                  .writeAttribute('title', attendee.l)
                  .addClassName('kronolithAttendee' + response)
                  .insert(attendee.e ? attendee.e.escapeHTML() : attendee.l.escapeHTML()));
        for (i = 0; i < 24; i++) {
            tr.insert(new Element('td', { className: 'kronolithFBUnknown' }));
        }
        $('kronolithEventAttendeesList').down('tbody').insert(tr);
    },

    resetFBRows: function()
    {
        this.attendees.each(function(attendee) {
            var row = this.freeBusy.get(attendee.l)[0];
            row.update();

            attendee.r = attendee.r || 1;
            switch (attendee.r) {
                case 1: response = 'None'; break;
                case 2: response = 'Accepted'; break;
                case 3: response = 'Declined'; break;
                case 4: response = 'Tentative'; break;
            }
            row.insert(new Element('td')
                      .writeAttribute('title', attendee.l)
                      .addClassName('kronolithAttendee' + response)
                      .insert(attendee.e ? attendee.e.escapeHTML() : attendee.l.escapeHTML()));
            for (i = 0; i < 24; i++) {
                row.insert(new Element('td', { className: 'kronolithFBUnknown' }));
            }
        }.bind(this));
        this.resources.each(function(resource) {
            var row = this.freeBusy.get(resource)[0],
                tdone = row.down('td');
            row.update();
            row.update(tdone);
            for (i = 0; i < 24; i++) {
                row.insert(new Element('td', { className: 'kronolithFBUnknown' }));
            }
        }.bind(this));
    },

    addResource: function(resource, id)
    {
        var v, response = 1;
        if (!id) {
            // User entered
            this.resourceACCache.choices.each(function(i) {
                if (i.name == resource) {
                    v = i.code;
                    throw $break;
                } else {
                    v = false;
                }
            }.bind(this));
        } else {
            // Populating from an edit event action
            v = id;
            response = resource.response;
            resource = resource.name;
        }

        switch (response) {
            case 1: response = 'None'; break;
            case 2: response = 'Accepted'; break;
            case 3: response = 'Declined'; break;
            case 4: response = 'Tentative'; break;
        }
        var att = {
            'resource': v
        },
        tr, i;
        if (att.resource) {
            this.fbLoading++;
            HordeCore.doAction('getFreeBusy', att, {
                callback: this.addResourceCallback.curry(resource).bind(this)
            });
            tr = new Element('tr');
            this.freeBusy.set(resource, [ tr ]);
            tr.insert(new Element('td')
                .writeAttribute('title', resource)
                .addClassName('kronolithAttendee' + response)
                .insert(resource.escapeHTML()));
            for (i = 0; i < 24; i++) {
                tr.insert(new Element('td', { className: 'kronolithFBUnknown' }));
            }
            $('kronolithEventResourcesList').down('tbody').insert(tr);
            this.resourceACCache.map.set(resource, v);
            $('kronolithEventResourceIds').value = this.resourceACCache.map.values();
        } else {
            HordeCore.notify(Kronolith.text.unknown_resource + ': ' + resource, 'horde.error');
        }
    },

    removeResource: function(resource)
    {
        var row = this.freeBusy.get(resource)[0];
        row.purge();
        row.remove();
        this.resourceACCache.map.unset(resource);
        $('kronolithEventResourceIds').value = this.resourceACCache.map.values();
    },

    addResourceCallback: function(resource, r)
    {
        this.fbLoading--;
        if (!this.fbLoading) {
            $('kronolithResourceFBLoading').hide();
        }
        if (Object.isUndefined(r.fb)) {
            return;
        }
        this.resources.push(resource);
        this.freeBusy.get(resource)[1] = r.fb;
        this.insertFreeBusy(resource);
    },

    /**
     * Removes an attendee row from the free/busy table.
     *
     * @param string attendee  The display name of the attendee.
     */
    removeAttendee: function(attendee)
    {
        var row = this.freeBusy.get(attendee)[0];
        row.purge();
        row.remove();
    },

    normalizeAttendee: function(attendee)
    {
        var pattern = /:(.*);/;
        var match = pattern.exec(attendee);
        if (match) {
           return match[1].split(',');
        }
        return [attendee];
    },

    checkOrganizerAsAttendee: function()
    {
        if (HordeImple.AutoCompleter.kronolithEventAttendees.selectedItems.length == 1 &&
            HordeImple.AutoCompleter.kronolithEventAttendees.selectedItems.first().rawValue != Kronolith.conf.email) {
            // Invite the organizer of this event to the new event.
            HordeImple.AutoCompleter.kronolithEventAttendees.addNewItemNode(Kronolith.conf.email);
            this.addAttendee(Kronolith.conf.email);
        }
    },

    getFBDate: function ()
    {
        var startDate = $('kronolithFBDate').innerHTML.split(' ');
        if (startDate.length > 1) {
            startDate = startDate[1];
        } else {
            startDate = startDate[0];
        }
        return Date.parseExact(startDate, Kronolith.conf.date_format);
    },

    /**
     * Updates rows with free/busy information in the attendees table.
     *
     * @param string attendee  An attendee display name as the free/busy
     *                         identifier.
     * @param date   start     An optinal start date for f/b info. If omitted,
     *                         $('kronolithEventStartDate') is used.
     */
    insertFreeBusy: function(attendee, start)
    {
        if (!$('kronolithEventDialog').visible() ||
            !this.freeBusy.get(attendee)) {
            return;
        }
        var fb = this.freeBusy.get(attendee)[1],
            tr = this.freeBusy.get(attendee)[0],
            td = tr.select('td')[1],
            div = td.down('div'), start;
        if (!fb) {
            return;
        }

        if (!td.getWidth()) {
            this.insertFreeBusy.bind(this, attendee, start).defer();
            return;
        }

        if (div) {
            div.purge();
            div.remove();
        }
        if (!start) {
            start = Date.parseExact($F('kronolithEventStartDate'), Kronolith.conf.date_format);
        }
        var end = start.clone().add(1).days(),
            width = td.getWidth(),
            fbs = this.parseDate(fb.s),
            fbe = this.parseDate(fb.e);


        if (start.isBefore(fbs) || end.isBefore(fbs) || start.isAfter(fbe)) {
            return;
        }

        tr.select('td').each(function(td, i) {
            if (i != 0) {
                td.className = 'kronolithFBFree';
            }
            i++;
        });
        div = new Element('div').setStyle({ position: 'relative', height: td.offsetHeight + 'px' });
        td.insert(div);
        $H(fb.b).each(function(busy) {
            var left, from = Date.parse(busy.key).addSeconds(1),
            to = Date.parse(busy.value).addSeconds(1);
            if (!end.isAfter(from) || to.isBefore(start)) {
                return;
            }
            if (from.isBefore(start)) {
                from = start.clone();
            }
            if (to.isAfter(end)) {
                to = end.clone();
            }
            if (to.getHours() === 0 && to.getMinutes() === 0) {
                to.add(-1).minutes();
            }
            left = from.getHours() + from.getMinutes() / 60;
            div.insert(new Element('div', { className: 'kronolithFBBusy' }).setStyle({ zIndex: 1, top: 0, left: (left * width) + 'px', width: (((to.getHours() + to.getMinutes() / 60) - left) * width) + 'px' }));
        });

    },

    fbStartDateOnChange: function()
    {
        if (!$F('kronolithEventStartDate')) {
          this._checkDate($('kronolithEventStartDate'));
          return;
        }
        this.fbStartDateHandler(Date.parseExact($F('kronolithEventStartDate'), Kronolith.conf.date_format));
    },

    /**
     * @param Date start  The start date.
     */
    fbStartDateHandler: function(start)
    {
        this.updateFBDate(start);
        this.resetFBRows();
        // Need to check visisbility - multiple changes will break the display
        // due to the use of .defer() in insertFreeBusy().
        if ($('kronolithEventTabAttendees').visible()) {
            this.attendeeStartDateHandler(start);
        }
        if ($('kronolithEventTabResources').visible()) {
            this.resourceStartDateHandler(start);
        }
    },

    attendeeStartDateHandler: function(start)
    {
        this.attendees.each(function(attendee) {
            this.insertFreeBusy(attendee.l, start);
        }, this);
    },

    resourceStartDateHandler: function(start)
    {
        this.resources.each(function(resource) {
            this.insertFreeBusy(resource, start);
        }, this);
    },

    nextFreebusy: function()
    {
        this.fbStartDateHandler(this.getFBDate().addDays(1));
    },

    prevFreebusy: function()
    {
        this.fbStartDateHandler(this.getFBDate().addDays(-1));
    },

    /**
     * @start Date object
     */
    updateFBDate: function(start)
    {
        $('kronolithFBDate').update(start.toString('dddd') + ' ' + start.toString(Kronolith.conf.date_format));
        $('kronolithResourceFBDate').update(start.toString('dddd') + ' ' + start.toString(Kronolith.conf.date_format));
    },

    /**
     * Toggles the start and end time fields of the event edit form on and off.
     *
     * @param boolean on  Whether the event is an all-day event, i.e. the time
     *                    fields should be turned off. If not specified, the
     *                    current state is toggled.
     */
    toggleAllDay: function(on)
    {
        var end = this.getDate('end'),
            old = $('kronolithEventStartTimeLabel').getStyle('visibility') == 'hidden';
        if (Object.isUndefined(on)) {
            on = $('kronolithEventStartTimeLabel').getStyle('visibility') == 'visible';
        }
        if (end) {
            if (on) {
                if (end.getHours() == 0 && end.getMinutes() == 0) {
                    end.add(-1).minute();
                }
            } else if (old) {
                end.setHours(23);
                end.setMinutes(59);
            }
            $('kronolithEventEndDate').setValue(end.toString(Kronolith.conf.date_format));
            $('kronolithEventEndTime').setValue(end.toString(Kronolith.conf.time_format));
        }
        $('kronolithEventStartTimeLabel').setStyle({ visibility: on ? 'hidden' : 'visible' });
        $('kronolithEventEndTimeLabel').setStyle({ visibility: on ? 'hidden' : 'visible' });
    },

    /**
     * Enables the alarm in the event or task form and sets the correct value
     * and unit.
     *
     * @param string type    The object type, either 'Event' or 'Task'.
     * @param integer alarm  The alarm time in seconds.
     */
    enableAlarm: function(type, alarm) {
        if (!alarm) {
            return;
        }
        type = 'kronolith' + type + 'Alarm';
        $(type + 'On').setValue(true);
        [10080, 1440, 60, 1].each(function(unit) {
            if (alarm % unit === 0) {
                $(type + 'Value').setValue(alarm / unit);
                $(type + 'Unit').setValue(unit);
                throw $break;
            }
        });
    },

    /**
     * Disables all custom alarm methods in the event form.
     */
    disableAlarmMethods: function(type) {
        $('kronolith' + type + 'TabReminder').select('input').each(function(input) {
            if (input.name == (type == 'Event' ? 'event_alarms[]' : 'task[alarm_methods][]')) {
                input.setValue(0);
                if ($(input.id + 'Params')) {
                    $(input.id + 'Params').hide();
                }
            }
        });
    },

    /**
     * Toggles the recurrence fields of the event and task edit forms.
     *
     * @param boolean event  Whether to use the event form.
     * @param string recur   The recurrence part of the field name, i.e. 'None',
     *                       'Daily', etc.
     */
    toggleRecurrence: function(event, recur)
    {
        var prefix = 'kronolith' + (event ? 'Event' : 'Task');
        if (recur == 'Exception') {
            if (!$(prefix + 'RepeatException').visible()) {
                $(prefix + 'TabRecur').select('div').invoke('hide');
                $(prefix + 'RepeatException').show();
            }
        } else if (recur != 'None') {
            var div = $(prefix + 'Repeat' + recur),
                length = $(prefix + 'RepeatLength');
            this.lastRecurType = recur;
            if (!div.visible()) {
                $(prefix + 'TabRecur').select('div').invoke('hide');
                div.show();
                length.show();
                $(prefix + 'RepeatType').show();
            }
            switch (recur) {
            case 'Daily':
            case 'Weekly':
            case 'Monthly':
            case 'Yearly':
                var recurLower = recur.toLowerCase();
                if (div.down('input[name=recur_' + recurLower + '][value=1]').checked) {
                    div.down('input[name=recur_' + recurLower + '_interval]').disable();
                } else {
                    div.down('input[name=recur_' + recurLower + '_interval]').enable();
                }
                break;
            }

            if (length.down('input[name=recur_end_type][value=date]').checked) {
                $(prefix + 'RecurDate').enable();
                $(prefix + 'RecurPicker').setStyle({ visibility: 'visible' });
            } else {
                $(prefix + 'RecurDate').disable();
                $(prefix + 'RecurPicker').setStyle({ visibility: 'hidden' });
            }
            if (length.down('input[name=recur_end_type][value=count]').checked) {
                $(prefix + 'RecurCount').enable();
            } else {
                $(prefix + 'RecurCount').disable();
            }
        } else {
            $(prefix + 'TabRecur').select('div').invoke('hide');
            $(prefix + 'RepeatType').show();
        }
    },

    /**
     * Fills the recurrence fields of the event and task edit forms.
     *
     * @param boolean event  Whether to use the event form.
     * @param object recur   The recurrence object from the ajax response.
     */
    setRecurrenceFields: function(event, recur)
    {
        var scheme = Kronolith.conf.recur[recur.t],
            schemeLower = scheme.toLowerCase(),
            prefix = 'kronolith' + (event ? 'Event' : 'Task'),
            div = $(prefix + 'Repeat' + scheme);
        $(prefix + 'Link' + scheme).setValue(true);
        if (scheme == 'Monthly' || scheme == 'Yearly') {
            div.down('input[name=recur_' + schemeLower + '_scheme][value=' + recur.t + ']').setValue(true);
        }
        if (scheme == 'Weekly') {
            div.select('input[type=checkbox]').each(function(input) {
                if (input.name == 'weekly[]' &&
                    input.value & recur.d) {
                    input.setValue(true);
                }
            });
        }
        if (recur.i == 1) {
            div.down('input[name=recur_' + schemeLower + '][value=1]').setValue(true);
        } else {
            div.down('input[name=recur_' + schemeLower + '][value=0]').setValue(true);
            div.down('input[name=recur_' + schemeLower + '_interval]').setValue(recur.i);
        }
        if (!Object.isUndefined(recur.e)) {
            $(prefix + 'RepeatLength').down('input[name=recur_end_type][value=date]').setValue(true);
            $(prefix + 'RecurDate').setValue(Date.parse(recur.e).toString(Kronolith.conf.date_format));
        } else if (!Object.isUndefined(recur.c)) {
            $(prefix + 'RepeatLength').down('input[name=recur_end_type][value=count]').setValue(true);
            $(prefix + 'RecurCount').setValue(recur.c);
        } else {
            $(prefix + 'RepeatLength').down('input[name=recur_end_type][value=none]').setValue(true);
        }
        $(prefix + 'Exceptions').setValue(recur.ex || '');
        if ($(prefix + 'Completions')) {
            $(prefix + 'Completions').setValue(recur.co || '');
        }
        this.toggleRecurrence(event, scheme);
    },

    /**
     * Returns the Date object representing the date and time specified in the
     * event form's start or end fields.
     *
     * @param string what  Which fields to parse, either 'start' or 'end'.
     *
     * @return Date  The date object or null if the fields can't be parsed.
     */
    getDate: function(what) {
        var dateElm, timeElm, date, time;
        if (what == 'start') {
            dateElm = 'kronolithEventStartDate';
            timeElm = 'kronolithEventStartTime';
        } else {
            dateElm = 'kronolithEventEndDate';
            timeElm = 'kronolithEventEndTime';
        }
        date = Date.parseExact($F(dateElm), Kronolith.conf.date_format)
            || Date.parse($F(dateElm));
        if (date) {
            time = Date.parseExact($F(timeElm), Kronolith.conf.time_format);
            if (!time) {
                time = Date.parse($F(timeElm));
            }
            if (time) {
                date.setHours(time.getHours());
                date.setMinutes(time.getMinutes());
            }
        }
        return date;
    },

    checkDate: function(e) {
        this._checkDate(e.element());
    },

    _checkDate: function(elm)
    {
        if ($F(elm)) {
            var date = Date.parseExact($F(elm), Kronolith.conf.date_format) || Date.parse($F(elm));
            if (date) {
                elm.setValue(date.toString(Kronolith.conf.date_format));
                this.wrongFormat.unset(elm.id);
            } else {
                HordeCore.notify(Kronolith.text.wrong_date_format.interpolate({ wrong: $F(elm), right: new Date().toString(Kronolith.conf.date_format) }), 'horde.warning');
                this.wrongFormat.set(elm.id, true);
            }
        } else {
            HordeCore.notify(Kronolith.text.wrong_date_format.interpolate({ wrong: $F(elm), right: new Date().toString(Kronolith.conf.date_format) }), 'horde.warning');
            this.wrongFormat.set(elm.id, true);
        }
    },

    /**
     * Attaches a KeyNavList drop down to one of the time fields.
     *
     * @param string|Element field  A time field (id).
     *
     * @return KeyNavList  The drop down list object.
     */
    attachTimeDropDown: function(field)
    {
        var list = [], d = new Date(), time, opts;

        d.setHours(0);
        d.setMinutes(0);
        do {
            time = d.toString(Kronolith.conf.time_format);
            list.push({ l: time, v: time });
            d.add(30).minutes();
        } while (d.getHours() !== 0 || d.getMinutes() !== 0);

        field = $(field);
        opts = {
            list: list,
            domParent: field.up('.kronolithDialog'),
            onChoose: function(value) {
                if (value) {
                    field.setValue(value);
                }
                this.updateTimeFields(field.identify());
            }.bind(this)
        };

        this.knl[field.id] = new KeyNavList(field, opts);

        return this.knl[field.id];
    },

    checkTime: function(e) {
        var elm = e.element();
        if ($F(elm)) {
            var time = Date.parseExact(new Date().toString(Kronolith.conf.date_format) + ' ' + $F(elm), Kronolith.conf.date_format + ' ' + Kronolith.conf.time_format) || Date.parse(new Date().toString('yyyy-MM-dd ') + $F(elm));
            if (time) {
                elm.setValue(time.toString(Kronolith.conf.time_format));
                this.wrongFormat.unset(elm.id);
            } else {
                HordeCore.notify(Kronolith.text.wrong_time_format.interpolate({ wrong: $F(elm), right: new Date().toString(Kronolith.conf.time_format) }), 'horde.warning');
                this.wrongFormat.set(elm.id, true);
            }
        }
    },

    /**
     * Updates the start time in the event form after changing the end time.
     */
    updateStartTime: function(date) {
        var start = this.getDate('start'), end = this.getDate('end');
        if (!start) {
            return;
        }
        if (!date) {
            date = end;
        }
        if (!date) {
            return;
        }
        if (start.isAfter(end)) {
            $('kronolithEventStartDate').setValue(date.toString(Kronolith.conf.date_format));
            $('kronolithEventStartTime').setValue($F('kronolithEventEndTime'));
        }
        this.duration = Math.abs(date.getTime() - start.getTime()) / 60000;
    },

    /**
     * Updates the end time in the event form after changing the start time.
     */
    updateEndTime: function() {
        var date = this.getDate('start');
        if (!date) {
            return;
        }
        date.add(this.duration).minutes();
        $('kronolithEventEndDate').setValue(date.toString(Kronolith.conf.date_format));
        $('kronolithEventEndTime').setValue(date.toString(Kronolith.conf.time_format));
    },

    /**
     * Event handler for scrolling the mouse over the date field.
     *
     * @param Event e       The mouse event.
     * @param string field  The field name.
     */
    scrollDateField: function(e, field) {
        var date = Date.parseExact($F(field), Kronolith.conf.date_format);
        if (!date || (!e.wheelData && !e.detail)) {
            return;
        }
        date.add(e.wheelData > 0 || e.detail < 0 ? 1 : -1).days();
        $(field).setValue(date.toString(Kronolith.conf.date_format));
        switch (field) {
        case 'kronolithEventStartDate':
            this.updateEndTime();
            break;
        case 'kronolithEventEndDate':
            this.updateStartTime(date);
            break;
        }
    },

    /**
     * Event handler for scrolling the mouse over the time field.
     *
     * @param Event e       The mouse event.
     * @param string field  The field name.
     */
    scrollTimeField: function(e, field) {
        var time = Date.parseExact($F(field), Kronolith.conf.time_format) || Date.parse($F(field)),
            newTime, minute;
        if (!time || (!e.wheelData && !e.detail)) {
            return;
        }

        newTime = time.clone();
        newTime.add(e.wheelData > 0 || e.detail < 0 ? 10 : -10).minutes();
        minute = newTime.getMinutes();
        if (minute % 10) {
            if (e.wheelData > 0 || e.detail < 0) {
                minute = minute / 10 | 0;
            } else {
                minute = (minute - 10) / 10 | 0;
            }
            minute *= 10;
            newTime.setMinutes(minute);
        }
        if (newTime.getDate() != time.getDate()) {
            if (newTime.isAfter(time)) {
                newTime = time.clone().set({ hour: 23, minute: 59 });
            } else {
                newTime = time.clone().set({ hour: 0, minute: 0 });
            }
        }

        $(field).setValue(newTime.toString(Kronolith.conf.time_format));
        this.updateTimeFields(field);

        /* Mozilla bug https://bugzilla.mozilla.org/show_bug.cgi?id=502818
         * Need to stop or else multiple scroll events may be fired. We
         * lose the ability to have the mousescroll bubble up, but that is
         * more desirable than having the wrong scrolling behavior. */
        if (Prototype.Browser.Gecko && !e.stop) {
            Event.stop(e);
        }
    },

    /**
     * Updates the time fields of the event dialog after either has been
     * changed.
     *
     * @param string field  The id of the field that has been changed.
     */
    updateTimeFields: function(field)
    {
        switch (field) {
        case 'kronolithEventStartDate':
            this.fbStartDateHandler(Date.parseExact($F(field), Kronolith.conf.date_format));
        case 'kronolithEventStartTime':
            this.updateEndTime();
            break;
        case 'kronolithEventEndDate':
        case 'kronolithEventEndTime':
            this.updateStartTime();
            this.fbStartDateHandler(Date.parseExact($F('kronolithEventStartDate'), Kronolith.conf.date_format));
            break;
        }
    },

    /**
     * Closes a RedBox overlay, after saving its content to the body.
     */
    closeRedBox: function()
    {
        if (!RedBox.getWindow()) {
            return;
        }
        var content = RedBox.getWindowContents();
        if (content) {
            document.body.insert(content.hide());
        }
        RedBox.close();
    },

    // By default, no context onShow action
    contextOnShow: Prototype.emptyFunction,

    // By default, no context onClick action
    contextOnClick: Prototype.emptyFunction,

    // Map
    initializeMap: function(ignoreLL)
    {
        if (this.mapInitialized) {
            return;
        }
        var layers = [];
        if (Kronolith.conf.maps.providers) {
            Kronolith.conf.maps.providers.each(function(l) {
                var p = new HordeMap[l]();
                $H(p.getLayers()).values().each(function(e) {layers.push(e);});
            });
        }

        this.map = new HordeMap.Map[Kronolith.conf.maps.driver]({
            elt: 'kronolithEventMap',
            delayed: true,
            layers: layers,
            markerDragEnd: this.onMarkerDragEnd.bind(this),
            mapClick: this.afterClickMap.bind(this)
        });

        if ($('kronolithEventLocationLat').value && !ignoreLL) {
            var ll = { lat:$('kronolithEventLocationLat').value, lon: $('kronolithEventLocationLon').value };
            // Note that we need to cast the value of zoom to an integer here,
            // otherwise the map display breaks.
            this.placeMapMarker(ll, true, $('kronolithEventMapZoom').value - 0);
        }
        //@TODO: check for Location field - and if present, but no lat/lon value, attempt to
        // geocode it.
        this.map.display();
        this.mapInitialized = true;
    },

    resetMap: function()
    {
        this.mapInitialized = false;
        $('kronolithEventLocationLat').value = null;
        $('kronolithEventLocationLon').value = null;
        $('kronolithEventMapZoom').value = null;
        if (this.mapMarker) {
            this.map.removeMarker(this.mapMarker, {});
            this.mapMarker = null;
        }
        if (this.map) {
            this.map.destroy();
            this.map = null;
        }
    },

    /**
     * Callback for handling marker drag end.
     *
     * @param object r  An object that implenents a getLonLat() method to obtain
     *                  the new location of the marker.
     */
    onMarkerDragEnd: function(r)
    {
        var ll = r.getLonLat();
        $('kronolithEventLocationLon').value = ll.lon;
        $('kronolithEventLocationLat').value = ll.lat;
        var gc = new HordeMap.Geocoder[Kronolith.conf.maps.geocoder](this.map.map, 'kronolithEventMap');
        gc.reverseGeocode(ll, this.onReverseGeocode.bind(this), this.onGeocodeError.bind(this) );
    },

    /**
     * Callback for handling a reverse geocode request.
     *
     * @param array r  An array of objects containing the results. Each object in
     *                 the array is {lat:, lon:, address}
     */
    onReverseGeocode: function(r)
    {
        if (!r.length) {
            return;
        }
        $('kronolithEventLocation').value = r[0].address;
    },

    onGeocodeError: function(r)
    {
        $('kronolithEventGeo_loading_img').toggle();
        HordeCore.notify(Kronolith.text.geocode_error + ' ' + r, 'horde.error');
    },

    /**
     * Callback for geocoding calls.
     */
    onGeocode: function(r)
    {
        $('kronolithEventGeo_loading_img').toggle();
        r = r.shift();
        if (r.precision) {
            zoom = r.precision * 2;
        } else {
            zoom = null;
        }
        this.ensureMap(true);
        this.placeMapMarker({ lat: r.lat, lon: r.lon }, true, zoom);
    },

    geocode: function(a) {
        if (!a) {
            return;
        }
        $('kronolithEventGeo_loading_img').toggle();
        var gc = new HordeMap.Geocoder[Kronolith.conf.maps.geocoder](this.map.map, 'kronolithEventMap');
        gc.geocode(a, this.onGeocode.bind(this), this.onGeocodeError);
    },

    /**
     * Place the event marker on the map, at point ll, ensuring it exists.
     * Optionally center the map on the marker and zoom. Zoom only honored if
     * center is set, and if center is set, but zoom is null, we zoomToFit().
     *
     */
    placeMapMarker: function(ll, center, zoom)
    {
        if (!this.mapMarker) {
            this.mapMarker = this.map.addMarker(
                    ll,
                    { draggable: true },
                    {
                        context: this,
                        dragend: this.onMarkerDragEnd
                    });
        } else {
            this.map.moveMarker(this.mapMarker, ll);
        }

        if (center) {
            this.map.setCenter(ll, zoom);
            if (!zoom) {
                this.map.zoomToFit();
            }
        }
        $('kronolithEventLocationLon').value = ll.lon;
        $('kronolithEventLocationLat').value = ll.lat;
    },

    /**
     * Remove the event marker from the map. Called after clearing the location
     * field.
     */
    removeMapMarker: function()
    {
        if (this.mapMarker) {
            this.map.removeMarker(this.mapMarker, {});
            $('kronolithEventLocationLon').value = null;
            $('kronolithEventLocationLat').value = null;
        }

        this.mapMarker = false;
    },

    /**
     * Ensures the map tab is visible and sets UI elements accordingly.
     */
    ensureMap: function(ignoreLL)
    {
        if (!this.mapInitialized) {
            this.initializeMap(ignoreLL);
        }
        var dialog = $('kronolithEventForm');
        dialog.select('.kronolithTabsOption').invoke('hide');
        dialog.select('.tabset li').invoke('removeClassName', 'horde-active');
        $('kronolithEventTabMap').show();
        $('kronolithEventLinkMap').up().addClassName('horde-active');
    },

    /**
     * Callback that gets called after a new marker has been placed on the map
     * due to a single click on the map.
     *
     * @return object o  { lonlat: }
     */
    afterClickMap: function(o)
    {
        this.placeMapMarker(o.lonlat, false);
        var gc = new HordeMap.Geocoder[Kronolith.conf.maps.geocoder](this.map.map, 'kronolithEventMap');
        gc.reverseGeocode(o.lonlat, this.onReverseGeocode.bind(this), this.onGeocodeError.bind(this) );
    },

    /* Onload function. */
    onDomLoad: function()
    {
        var dateFields, timeFields;

        /* Initialize the starting page. */
        var tmp = location.hash;
        if (!tmp.empty() && tmp.startsWith('#')) {
            tmp = (tmp.length == 1) ? '' : tmp.substring(1);
        }
        if (tmp.empty()) {
            this.updateView(this.date, Kronolith.conf.login_view);
            $('kronolithView' + Kronolith.conf.login_view.capitalize()).show();
        }
        HordeCore.doAction('listCalendars', {}, { callback: this.initialize.bind(this, tmp) });

        RedBox.onDisplay = function() {
            this.redBoxLoading = false;
        }.bind(this);
        RedBox.duration = this.effectDur;

        $('kronolithEventStartDate', 'kronolithEventEndDate', 'kronolithTaskDueDate').compact().invoke('observe', 'blur', this.checkDate.bind(this));
        var timeFields = $('kronolithEventStartTime', 'kronolithEventEndTime', 'kronolithTaskDueTime').compact();
        timeFields.invoke('observe', 'blur', this.checkTime.bind(this));
        timeFields.each(function(field) {
            var dropDown = this.attachTimeDropDown(field);
            field.observe('click', function() { dropDown.show(); });
        }, this);
        $('kronolithEventStartDate', 'kronolithEventStartTime').invoke('observe', 'change', this.updateEndTime.bind(this));
        $('kronolithEventEndDate', 'kronolithEventEndTime').invoke('observe', 'change', function() { this.updateStartTime(); }.bind(this));

        if (Kronolith.conf.has_tasks) {
            $('kronolithTaskDueDate', 'kronolithTaskDueTime').compact().invoke('observe', 'focus', this.setDefaultDue.bind(this));
            $('kronolithTaskList').observe('change', function() {
                this.updateTaskParentDropDown($F('kronolithTaskList'));
                this.updateTaskAssigneeDropDown($F('kronolithTaskList'));
            }.bind(this));
        }

        document.observe('keydown', KronolithCore.keydownHandler.bindAsEventListener(KronolithCore));
        document.observe('keyup', KronolithCore.keyupHandler.bindAsEventListener(KronolithCore));
        document.observe('click', KronolithCore.clickHandler.bindAsEventListener(KronolithCore));
        document.observe('dblclick', KronolithCore.clickHandler.bindAsEventListener(KronolithCore, true));

        // Mouse wheel handler.
        dateFields = [ 'kronolithEventStartDate', 'kronolithEventEndDate' ];
        timeFields = [ 'kronolithEventStartTime', 'kronolithEventEndTime' ];
        if (Kronolith.conf.has_tasks) {
            dateFields.push('kronolithTaskDueDate');
            timeFields.push('kronolithTaskDueTime');
        }
        dateFields.each(function(field) {
            $(field).observe(Prototype.Browser.Gecko ? 'DOMMouseScroll' : 'mousewheel', this.scrollDateField.bindAsEventListener(this, field));
        }, this);
        timeFields.each(function(field) {
            $(field).observe(Prototype.Browser.Gecko ? 'DOMMouseScroll' : 'mousewheel', this.scrollTimeField.bindAsEventListener(this, field));
        }, this);

        $('kronolithEventStartDate').observe('change', this.fbStartDateOnChange.bind(this));
        $('kronolithFBDatePrev').observe('click', this.prevFreebusy.bind(this));
        $('kronolithFBDateNext').observe('click', this.nextFreebusy.bind(this));
        $('kronolithResourceFBDatePrev').observe('click', this.prevFreebusy.bind(this));
        $('kronolithResourceFBDateNext').observe('click', this.nextFreebusy.bind(this));

        this.updateMinical(this.date);
    },

    initialize: function(location, r)
    {
        Kronolith.conf.calendars = r.calendars;
        this.updateCalendarList();
        HordeSidebar.refreshEvents();
        $('kronolithLoadingCalendars').hide();
        $('kronolithMenuCalendars').show();
        this.initialized = true;

        /* Initialize the starting page. */
        if (!location.empty()) {
            this.go(decodeURIComponent(location));
        } else {
            this.go(Kronolith.conf.login_view);
        }

        /* Start polling. */
        new PeriodicalExecuter(function()
            {
                HordeCore.doAction('poll');
                $(kronolithGotoToday).update(Date.today().toString(Kronolith.conf.date_format));
            },
            60
        );
    }

};

/* Initialize global event handlers. */
document.observe('dom:loaded', KronolithCore.onDomLoad.bind(KronolithCore));
document.observe('DragDrop2:drag', KronolithCore.onDrag.bindAsEventListener(KronolithCore));
document.observe('DragDrop2:drop', KronolithCore.onDrop.bindAsEventListener(KronolithCore));
document.observe('DragDrop2:end', KronolithCore.onDragEnd.bindAsEventListener(KronolithCore));
document.observe('DragDrop2:start', KronolithCore.onDragStart.bindAsEventListener(KronolithCore));
document.observe('Horde_Calendar:select', KronolithCore.datePickerHandler.bindAsEventListener(KronolithCore));
document.observe('FormGhost:reset', KronolithCore.searchReset.bindAsEventListener(KronolithCore));
document.observe('FormGhost:submit', KronolithCore.searchSubmit.bindAsEventListener(KronolithCore));
document.observe('HordeCore:showNotifications', KronolithCore.showNotification.bindAsEventListener(KronolithCore));
if (Prototype.Browser.IE) {
    $('kronolithBody').observe('selectstart', Event.stop);
}

/* Extend AJAX exception handling. */
HordeCore.onException = HordeCore.onException.wrap(KronolithCore.onException.bind(KronolithCore));
"
"// We make use of this 'server' variable to provide the address of the
// REST Janus API. By default, in this example we assume that Janus is
// co-located with the web server hosting the HTML pages but listening
// on a different port (8088, the default for HTTP in Janus), which is
// why we make use of the 'window.location.hostname' base address. Since
// Janus can also do HTTPS, and considering we don't really want to make
// use of HTTP for Janus if your demos are served on HTTPS, we also rely
// on the 'window.location.protocol' prefix to build the variable, in
// particular to also change the port used to contact Janus (8088 for
// HTTP and 8089 for HTTPS, if enabled).
// In case you place Janus behind an Apache frontend (as we did on the
// online demos at http://janus.conf.meetecho.com) you can just use a
// relative path for the variable, e.g.:
//
// 		var server = ""/janus"";
//
// which will take care of this on its own.
//
//
// If you want to use the WebSockets frontend to Janus, instead, you'll
// have to pass a different kind of address, e.g.:
//
// 		var server = ""ws://"" + window.location.hostname + "":8188"";
//
// Of course this assumes that support for WebSockets has been built in
// when compiling the server. WebSockets support has not been tested
// as much as the REST API, so handle with care!
//
//
// If you have multiple options available, and want to let the library
// autodetect the best way to contact your server (or pool of servers),
// you can also pass an array of servers, e.g., to provide alternative
// means of access (e.g., try WebSockets first and, if that fails, fall
// back to plain HTTP) or just have failover servers:
//
//		var server = [
//			""ws://"" + window.location.hostname + "":8188"",
//			""/janus""
//		];
//
// This will tell the library to try connecting to each of the servers
// in the presented order. The first working server will be used for
// the whole session.
//
var server = null;
if(window.location.protocol === 'http:')
	server = ""http://"" + window.location.hostname + "":8088/janus"";
else
	server = ""https://"" + window.location.hostname + "":8089/janus"";

var janus = null;
var textroom = null;
var opaqueId = ""textroomtest-""+Janus.randomString(12);

var myroom = 1234;	// Demo room
if(getQueryStringValue(""room"") !== """")
	myroom = parseInt(getQueryStringValue(""room""));
var myusername = null;
var myid = null;
var participants = {}
var transactions = {}

$(document).ready(function() {
	// Initialize the library (all console debuggers enabled)
	Janus.init({debug: ""all"", callback: function() {
		// Use a button to start the demo
		$('#start').one('click', function() {
			$(this).attr('disabled', true).unbind('click');
			// Make sure the browser supports WebRTC
			if(!Janus.isWebrtcSupported()) {
				bootbox.alert(""No WebRTC support... "");
				return;
			}
			// Create session
			janus = new Janus(
				{
					server: server,
					success: function() {
						// Attach to TextRoom plugin
						janus.attach(
							{
								plugin: ""janus.plugin.textroom"",
								opaqueId: opaqueId,
								success: function(pluginHandle) {
									$('#details').remove();
									textroom = pluginHandle;
									Janus.log(""Plugin attached! ("" + textroom.getPlugin() + "", id="" + textroom.getId() + "")"");
									// Setup the DataChannel
									var body = { request: ""setup"" };
									Janus.debug(""Sending message:"", body);
									textroom.send({ message: body });
									$('#start').removeAttr('disabled').html(""Stop"")
										.click(function() {
											$(this).attr('disabled', true);
											janus.destroy();
										});
								},
								error: function(error) {
									console.error(""  -- Error attaching plugin..."", error);
									bootbox.alert(""Error attaching plugin... "" + error);
								},
								iceState: function(state) {
									Janus.log(""ICE state changed to "" + state);
								},
								mediaState: function(medium, on) {
									Janus.log(""Janus "" + (on ? ""started"" : ""stopped"") + "" receiving our "" + medium);
								},
								webrtcState: function(on) {
									Janus.log(""Janus says our WebRTC PeerConnection is "" + (on ? ""up"" : ""down"") + "" now"");
								},
								onmessage: function(msg, jsep) {
									Janus.debug("" ::: Got a message :::"", msg);
									if(msg[""error""]) {
										bootbox.alert(msg[""error""]);
									}
									if(jsep) {
										// Answer
										textroom.createAnswer(
											{
												jsep: jsep,
												media: { audio: false, video: false, data: true },	// We only use datachannels
												success: function(jsep) {
													Janus.debug(""Got SDP!"", jsep);
													var body = { request: ""ack"" };
													textroom.send({ message: body, jsep: jsep });
												},
												error: function(error) {
													Janus.error(""WebRTC error:"", error);
													bootbox.alert(""WebRTC error... "" + error.message);
												}
											});
									}
								},
								ondataopen: function(data) {
									Janus.log(""The DataChannel is available!"");
									// Prompt for a display name to join the default room
									$('#roomjoin').removeClass('hide').show();
									$('#registernow').removeClass('hide').show();
									$('#register').click(registerUsername);
									$('#username').focus();
								},
								ondata: function(data) {
									Janus.debug(""We got data from the DataChannel!"", data);
									//~ $('#datarecv').val(data);
									var json = JSON.parse(data);
									var transaction = json[""transaction""];
									if(transactions[transaction]) {
										// Someone was waiting for this
										transactions[transaction](json);
										delete transactions[transaction];
										return;
									}
									var what = json[""textroom""];
									if(what === ""message"") {
										// Incoming message: public or private?
										var msg = escapeXmlTags(json[""text""]);
										var from = json[""from""];
										var dateString = getDateString(json[""date""]);
										var whisper = json[""whisper""];
										var sender = participants[from] ? participants[from] : escapeXmlTags(json[""display""]);
										if(whisper === true) {
											// Private message
											$('#chatroom').append('<p style=""color: purple;"">[' + dateString + '] <b>[whisper from ' + sender + ']</b> ' + msg);
											$('#chatroom').get(0).scrollTop = $('#chatroom').get(0).scrollHeight;
										} else {
											// Public message
											$('#chatroom').append('<p>[' + dateString + '] <b>' + sender + ':</b> ' + msg);
											$('#chatroom').get(0).scrollTop = $('#chatroom').get(0).scrollHeight;
										}
									} else if(what === ""announcement"") {
										// Room announcement
										var msg = escapeXmlTags(json[""text""]);
										var dateString = getDateString(json[""date""]);
										$('#chatroom').append('<p style=""color: purple;"">[' + dateString + '] <i>' + msg + '</i>');
										$('#chatroom').get(0).scrollTop = $('#chatroom').get(0).scrollHeight;
									} else if(what === ""join"") {
										// Somebody joined
										var username = json[""username""];
										var display = json[""display""];
										participants[username] = escapeXmlTags(display ? display : username);
										if(username !== myid && $('#rp' + username).length === 0) {
											// Add to the participants list
											$('#list').append('<li id=""rp' + username + '"" class=""list-group-item"">' + participants[username] + '</li>');
											$('#rp' + username).css('cursor', 'pointer').click(function() {
												var username = $(this).attr('id').split(""rp"")[1];
												sendPrivateMsg(username);
											});
										}
										$('#chatroom').append('<p style=""color: green;"">[' + getDateString() + '] <i>' + participants[username] + ' joined</i></p>');
										$('#chatroom').get(0).scrollTop = $('#chatroom').get(0).scrollHeight;
									} else if(what === ""leave"") {
										// Somebody left
										var username = json[""username""];
										var when = new Date();
										$('#rp' + username).remove();
										$('#chatroom').append('<p style=""color: green;"">[' + getDateString() + '] <i>' + participants[username] + ' left</i></p>');
										$('#chatroom').get(0).scrollTop = $('#chatroom').get(0).scrollHeight;
										delete participants[username];
									} else if(what === ""kicked"") {
										// Somebody was kicked
										var username = json[""username""];
										var when = new Date();
										$('#rp' + username).remove();
										$('#chatroom').append('<p style=""color: green;"">[' + getDateString() + '] <i>' + participants[username] + ' was kicked from the room</i></p>');
										$('#chatroom').get(0).scrollTop = $('#chatroom').get(0).scrollHeight;
										delete participants[username];
										if(username === myid) {
											bootbox.alert(""You have been kicked from the room"", function() {
												window.location.reload();
											});
										}
									} else if(what === ""destroyed"") {
										if(json[""room""] !== myroom)
											return;
										// Room was destroyed, goodbye!
										Janus.warn(""The room has been destroyed!"");
										bootbox.alert(""The room has been destroyed"", function() {
											window.location.reload();
										});
									}
								},
								oncleanup: function() {
									Janus.log("" ::: Got a cleanup notification :::"");
									$('#datasend').attr('disabled', true);
								}
							});
					},
					error: function(error) {
						Janus.error(error);
						bootbox.alert(error, function() {
							window.location.reload();
						});
					},
					destroyed: function() {
						window.location.reload();
					}
				});
		});
	}});
});

function checkEnter(field, event) {
	var theCode = event.keyCode ? event.keyCode : event.which ? event.which : event.charCode;
	if(theCode == 13) {
		if(field.id == 'username')
			registerUsername();
		else if(field.id == 'datasend')
			sendData();
		return false;
	} else {
		return true;
	}
}

function registerUsername() {
	if($('#username').length === 0) {
		// Create fields to register
		$('#register').click(registerUsername);
		$('#username').focus();
	} else {
		// Try a registration
		$('#username').attr('disabled', true);
		$('#register').attr('disabled', true).unbind('click');
		var username = $('#username').val();
		if(username === """") {
			$('#you')
				.removeClass().addClass('label label-warning')
				.html(""Insert your display name (e.g., pippo)"");
			$('#username').removeAttr('disabled');
			$('#register').removeAttr('disabled').click(registerUsername);
			return;
		}
		myid = randomString(12);
		var transaction = randomString(12);
		var register = {
			textroom: ""join"",
			transaction: transaction,
			room: myroom,
			username: myid,
			display: username
		};
		myusername = escapeXmlTags(username);
		transactions[transaction] = function(response) {
			if(response[""textroom""] === ""error"") {
				// Something went wrong
				if(response[""error_code""] === 417) {
					// This is a ""no such room"" error: give a more meaningful description
					bootbox.alert(
						""<p>Apparently room <code>"" + myroom + ""</code> (the one this demo uses as a test room) "" +
						""does not exist...</p><p>Do you have an updated <code>janus.plugin.textroom.jcfg</code> "" +
						""configuration file? If not, make sure you copy the details of room <code>"" + myroom + ""</code> "" +
						""from that sample in your current configuration file, then restart Janus and try again.""
					);
				} else {
					bootbox.alert(response[""error""]);
				}
				$('#username').removeAttr('disabled').val("""");
				$('#register').removeAttr('disabled').click(registerUsername);
				return;
			}
			// We're in
			$('#roomjoin').hide();
			$('#room').removeClass('hide').show();
			$('#participant').removeClass('hide').html(myusername).show();
			$('#chatroom').css('height', ($(window).height()-420)+""px"");
			$('#datasend').removeAttr('disabled');
			// Any participants already in?
			console.log(""Participants:"", response.participants);
			if(response.participants && response.participants.length > 0) {
				for(var i in response.participants) {
					var p = response.participants[i];
					participants[p.username] = escapeXmlTags(p.display ? p.display : p.username);
					if(p.username !== myid && $('#rp' + p.username).length === 0) {
						// Add to the participants list
						$('#list').append('<li id=""rp' + p.username + '"" class=""list-group-item"">' + participants[p.username] + '</li>');
						$('#rp' + p.username).css('cursor', 'pointer').click(function() {
							var username = $(this).attr('id').split(""rp"")[1];
							sendPrivateMsg(username);
						});
					}
					$('#chatroom').append('<p style=""color: green;"">[' + getDateString() + '] <i>' + participants[p.username] + ' joined</i></p>');
					$('#chatroom').get(0).scrollTop = $('#chatroom').get(0).scrollHeight;
				}
			}
		};
		textroom.data({
			text: JSON.stringify(register),
			error: function(reason) {
				bootbox.alert(reason);
				$('#username').removeAttr('disabled').val("""");
				$('#register').removeAttr('disabled').click(registerUsername);
			}
		});
	}
}

function sendPrivateMsg(username) {
	var display = participants[username];
	if(!display)
		return;
	bootbox.prompt(""Private message to "" + display, function(result) {
		if(result && result !== """") {
			var message = {
				textroom: ""message"",
				transaction: randomString(12),
				room: myroom,
				to: username,
				text: result
			};
			textroom.data({
				text: JSON.stringify(message),
				error: function(reason) { bootbox.alert(reason); },
				success: function() {
					$('#chatroom').append('<p style=""color: purple;"">[' + getDateString() + '] <b>[whisper to ' + display + ']</b> ' + result);
					$('#chatroom').get(0).scrollTop = $('#chatroom').get(0).scrollHeight;
				}
			});
		}
	});
	return;
}

function sendData() {
	var data = $('#datasend').val();
	if(data === """") {
		bootbox.alert('Insert a message to send on the DataChannel');
		return;
	}
	var message = {
		textroom: ""message"",
		transaction: randomString(12),
		room: myroom,
 		text: data,
	};
	// Note: messages are always acknowledged by default. This means that you'll
	// always receive a confirmation back that the message has been received by the
	// server and forwarded to the recipients. If you do not want this to happen,
	// just add an ack:false property to the message above, and server won't send
	// you a response (meaning you just have to hope it succeeded).
	textroom.data({
		text: JSON.stringify(message),
		error: function(reason) { bootbox.alert(reason); },
		success: function() { $('#datasend').val(''); }
	});
}

// Helper to format times
function getDateString(jsonDate) {
	var when = new Date();
	if(jsonDate) {
		when = new Date(Date.parse(jsonDate));
	}
	var dateString =
			(""0"" + when.getUTCHours()).slice(-2) + "":"" +
			(""0"" + when.getUTCMinutes()).slice(-2) + "":"" +
			(""0"" + when.getUTCSeconds()).slice(-2);
	return dateString;
}

// Just an helper to generate random usernames
function randomString(len, charSet) {
    charSet = charSet || 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    var randomString = '';
    for (var i = 0; i < len; i++) {
    	var randomPoz = Math.floor(Math.random() * charSet.length);
    	randomString += charSet.substring(randomPoz,randomPoz+1);
    }
    return randomString;
}

// Helper to parse query string
function getQueryStringValue(name) {
	name = name.replace(/[\[]/, ""\\["").replace(/[\]]/, ""\\]"");
	var regex = new RegExp(""[\\?&]"" + name + ""=([^&#]*)""),
		results = regex.exec(location.search);
	return results === null ? """" : decodeURIComponent(results[1].replace(/\+/g, "" ""));
}

// Helper to escape XML tags
function escapeXmlTags(value) {
	if(value) {
		var escapedValue = value.replace(new RegExp('<', 'g'), '&lt');
		escapedValue = escapedValue.replace(new RegExp('>', 'g'), '&gt');
		return escapedValue;
	}
}
","// We make use of this 'server' variable to provide the address of the
// REST Janus API. By default, in this example we assume that Janus is
// co-located with the web server hosting the HTML pages but listening
// on a different port (8088, the default for HTTP in Janus), which is
// why we make use of the 'window.location.hostname' base address. Since
// Janus can also do HTTPS, and considering we don't really want to make
// use of HTTP for Janus if your demos are served on HTTPS, we also rely
// on the 'window.location.protocol' prefix to build the variable, in
// particular to also change the port used to contact Janus (8088 for
// HTTP and 8089 for HTTPS, if enabled).
// In case you place Janus behind an Apache frontend (as we did on the
// online demos at http://janus.conf.meetecho.com) you can just use a
// relative path for the variable, e.g.:
//
// 		var server = ""/janus"";
//
// which will take care of this on its own.
//
//
// If you want to use the WebSockets frontend to Janus, instead, you'll
// have to pass a different kind of address, e.g.:
//
// 		var server = ""ws://"" + window.location.hostname + "":8188"";
//
// Of course this assumes that support for WebSockets has been built in
// when compiling the server. WebSockets support has not been tested
// as much as the REST API, so handle with care!
//
//
// If you have multiple options available, and want to let the library
// autodetect the best way to contact your server (or pool of servers),
// you can also pass an array of servers, e.g., to provide alternative
// means of access (e.g., try WebSockets first and, if that fails, fall
// back to plain HTTP) or just have failover servers:
//
//		var server = [
//			""ws://"" + window.location.hostname + "":8188"",
//			""/janus""
//		];
//
// This will tell the library to try connecting to each of the servers
// in the presented order. The first working server will be used for
// the whole session.
//
var server = null;
if(window.location.protocol === 'http:')
	server = ""http://"" + window.location.hostname + "":8088/janus"";
else
	server = ""https://"" + window.location.hostname + "":8089/janus"";

var janus = null;
var textroom = null;
var opaqueId = ""textroomtest-""+Janus.randomString(12);

var myroom = 1234;	// Demo room
if(getQueryStringValue(""room"") !== """")
	myroom = parseInt(getQueryStringValue(""room""));
var myusername = null;
var myid = null;
var participants = {}
var transactions = {}

$(document).ready(function() {
	// Initialize the library (all console debuggers enabled)
	Janus.init({debug: ""all"", callback: function() {
		// Use a button to start the demo
		$('#start').one('click', function() {
			$(this).attr('disabled', true).unbind('click');
			// Make sure the browser supports WebRTC
			if(!Janus.isWebrtcSupported()) {
				bootbox.alert(""No WebRTC support... "");
				return;
			}
			// Create session
			janus = new Janus(
				{
					server: server,
					success: function() {
						// Attach to TextRoom plugin
						janus.attach(
							{
								plugin: ""janus.plugin.textroom"",
								opaqueId: opaqueId,
								success: function(pluginHandle) {
									$('#details').remove();
									textroom = pluginHandle;
									Janus.log(""Plugin attached! ("" + textroom.getPlugin() + "", id="" + textroom.getId() + "")"");
									// Setup the DataChannel
									var body = { request: ""setup"" };
									Janus.debug(""Sending message:"", body);
									textroom.send({ message: body });
									$('#start').removeAttr('disabled').html(""Stop"")
										.click(function() {
											$(this).attr('disabled', true);
											janus.destroy();
										});
								},
								error: function(error) {
									console.error(""  -- Error attaching plugin..."", error);
									bootbox.alert(""Error attaching plugin... "" + error);
								},
								iceState: function(state) {
									Janus.log(""ICE state changed to "" + state);
								},
								mediaState: function(medium, on) {
									Janus.log(""Janus "" + (on ? ""started"" : ""stopped"") + "" receiving our "" + medium);
								},
								webrtcState: function(on) {
									Janus.log(""Janus says our WebRTC PeerConnection is "" + (on ? ""up"" : ""down"") + "" now"");
								},
								onmessage: function(msg, jsep) {
									Janus.debug("" ::: Got a message :::"", msg);
									if(msg[""error""]) {
										bootbox.alert(msg[""error""]);
									}
									if(jsep) {
										// Answer
										textroom.createAnswer(
											{
												jsep: jsep,
												media: { audio: false, video: false, data: true },	// We only use datachannels
												success: function(jsep) {
													Janus.debug(""Got SDP!"", jsep);
													var body = { request: ""ack"" };
													textroom.send({ message: body, jsep: jsep });
												},
												error: function(error) {
													Janus.error(""WebRTC error:"", error);
													bootbox.alert(""WebRTC error... "" + error.message);
												}
											});
									}
								},
								ondataopen: function(data) {
									Janus.log(""The DataChannel is available!"");
									// Prompt for a display name to join the default room
									$('#roomjoin').removeClass('hide').show();
									$('#registernow').removeClass('hide').show();
									$('#register').click(registerUsername);
									$('#username').focus();
								},
								ondata: function(data) {
									Janus.debug(""We got data from the DataChannel!"", data);
									//~ $('#datarecv').val(data);
									var json = JSON.parse(data);
									var transaction = json[""transaction""];
									if(transactions[transaction]) {
										// Someone was waiting for this
										transactions[transaction](json);
										delete transactions[transaction];
										return;
									}
									var what = json[""textroom""];
									if(what === ""message"") {
										// Incoming message: public or private?
										var msg = escapeXmlTags(json[""text""]);
										var from = json[""from""];
										var dateString = getDateString(json[""date""]);
										var whisper = json[""whisper""];
										var sender = participants[from] ? participants[from] : escapeXmlTags(json[""display""]);
										if(whisper === true) {
											// Private message
											$('#chatroom').append('<p style=""color: purple;"">[' + dateString + '] <b>[whisper from ' + sender + ']</b> ' + msg);
											$('#chatroom').get(0).scrollTop = $('#chatroom').get(0).scrollHeight;
										} else {
											// Public message
											$('#chatroom').append('<p>[' + dateString + '] <b>' + sender + ':</b> ' + msg);
											$('#chatroom').get(0).scrollTop = $('#chatroom').get(0).scrollHeight;
										}
									} else if(what === ""announcement"") {
										// Room announcement
										var msg = escapeXmlTags(json[""text""]);
										var dateString = getDateString(json[""date""]);
										$('#chatroom').append('<p style=""color: purple;"">[' + dateString + '] <i>' + msg + '</i>');
										$('#chatroom').get(0).scrollTop = $('#chatroom').get(0).scrollHeight;
									} else if(what === ""join"") {
										// Somebody joined
										var username = json[""username""];
										var display = json[""display""];
										participants[username] = escapeXmlTags(display ? display : username);
										if(username !== myid && $('#rp' + username).length === 0) {
											// Add to the participants list
											$('#list').append('<li id=""rp' + username + '"" class=""list-group-item"">' + participants[username] + '</li>');
											$('#rp' + username).css('cursor', 'pointer').click(function() {
												var username = $(this).attr('id').split(""rp"")[1];
												sendPrivateMsg(username);
											});
										}
										$('#chatroom').append('<p style=""color: green;"">[' + getDateString() + '] <i>' + participants[username] + ' joined</i></p>');
										$('#chatroom').get(0).scrollTop = $('#chatroom').get(0).scrollHeight;
									} else if(what === ""leave"") {
										// Somebody left
										var username = json[""username""];
										var when = new Date();
										$('#rp' + username).remove();
										$('#chatroom').append('<p style=""color: green;"">[' + getDateString() + '] <i>' + participants[username] + ' left</i></p>');
										$('#chatroom').get(0).scrollTop = $('#chatroom').get(0).scrollHeight;
										delete participants[username];
									} else if(what === ""kicked"") {
										// Somebody was kicked
										var username = json[""username""];
										var when = new Date();
										$('#rp' + username).remove();
										$('#chatroom').append('<p style=""color: green;"">[' + getDateString() + '] <i>' + participants[username] + ' was kicked from the room</i></p>');
										$('#chatroom').get(0).scrollTop = $('#chatroom').get(0).scrollHeight;
										delete participants[username];
										if(username === myid) {
											bootbox.alert(""You have been kicked from the room"", function() {
												window.location.reload();
											});
										}
									} else if(what === ""destroyed"") {
										if(json[""room""] !== myroom)
											return;
										// Room was destroyed, goodbye!
										Janus.warn(""The room has been destroyed!"");
										bootbox.alert(""The room has been destroyed"", function() {
											window.location.reload();
										});
									}
								},
								oncleanup: function() {
									Janus.log("" ::: Got a cleanup notification :::"");
									$('#datasend').attr('disabled', true);
								}
							});
					},
					error: function(error) {
						Janus.error(error);
						bootbox.alert(error, function() {
							window.location.reload();
						});
					},
					destroyed: function() {
						window.location.reload();
					}
				});
		});
	}});
});

function checkEnter(field, event) {
	var theCode = event.keyCode ? event.keyCode : event.which ? event.which : event.charCode;
	if(theCode == 13) {
		if(field.id == 'username')
			registerUsername();
		else if(field.id == 'datasend')
			sendData();
		return false;
	} else {
		return true;
	}
}

function registerUsername() {
	if($('#username').length === 0) {
		// Create fields to register
		$('#register').click(registerUsername);
		$('#username').focus();
	} else {
		// Try a registration
		$('#username').attr('disabled', true);
		$('#register').attr('disabled', true).unbind('click');
		var username = $('#username').val();
		if(username === """") {
			$('#you')
				.removeClass().addClass('label label-warning')
				.html(""Insert your display name (e.g., pippo)"");
			$('#username').removeAttr('disabled');
			$('#register').removeAttr('disabled').click(registerUsername);
			return;
		}
		myid = randomString(12);
		var transaction = randomString(12);
		var register = {
			textroom: ""join"",
			transaction: transaction,
			room: myroom,
			username: myid,
			display: username
		};
		myusername = escapeXmlTags(username);
		transactions[transaction] = function(response) {
			if(response[""textroom""] === ""error"") {
				// Something went wrong
				if(response[""error_code""] === 417) {
					// This is a ""no such room"" error: give a more meaningful description
					bootbox.alert(
						""<p>Apparently room <code>"" + myroom + ""</code> (the one this demo uses as a test room) "" +
						""does not exist...</p><p>Do you have an updated <code>janus.plugin.textroom.jcfg</code> "" +
						""configuration file? If not, make sure you copy the details of room <code>"" + myroom + ""</code> "" +
						""from that sample in your current configuration file, then restart Janus and try again.""
					);
				} else {
					bootbox.alert(response[""error""]);
				}
				$('#username').removeAttr('disabled').val("""");
				$('#register').removeAttr('disabled').click(registerUsername);
				return;
			}
			// We're in
			$('#roomjoin').hide();
			$('#room').removeClass('hide').show();
			$('#participant').removeClass('hide').html(myusername).show();
			$('#chatroom').css('height', ($(window).height()-420)+""px"");
			$('#datasend').removeAttr('disabled');
			// Any participants already in?
			console.log(""Participants:"", response.participants);
			if(response.participants && response.participants.length > 0) {
				for(var i in response.participants) {
					var p = response.participants[i];
					participants[p.username] = escapeXmlTags(p.display ? p.display : p.username);
					if(p.username !== myid && $('#rp' + p.username).length === 0) {
						// Add to the participants list
						$('#list').append('<li id=""rp' + p.username + '"" class=""list-group-item"">' + participants[p.username] + '</li>');
						$('#rp' + p.username).css('cursor', 'pointer').click(function() {
							var username = $(this).attr('id').split(""rp"")[1];
							sendPrivateMsg(username);
						});
					}
					$('#chatroom').append('<p style=""color: green;"">[' + getDateString() + '] <i>' + participants[p.username] + ' joined</i></p>');
					$('#chatroom').get(0).scrollTop = $('#chatroom').get(0).scrollHeight;
				}
			}
		};
		textroom.data({
			text: JSON.stringify(register),
			error: function(reason) {
				bootbox.alert(reason);
				$('#username').removeAttr('disabled').val("""");
				$('#register').removeAttr('disabled').click(registerUsername);
			}
		});
	}
}

function sendPrivateMsg(username) {
	var display = participants[username];
	if(!display)
		return;
	bootbox.prompt(""Private message to "" + display, function(result) {
		if(result && result !== """") {
			var message = {
				textroom: ""message"",
				transaction: randomString(12),
				room: myroom,
				to: username,
				text: result
			};
			textroom.data({
				text: JSON.stringify(message),
				error: function(reason) { bootbox.alert(reason); },
				success: function() {
					$('#chatroom').append('<p style=""color: purple;"">[' + getDateString() + '] <b>[whisper to ' + display + ']</b> ' + escapeXmlTags(result));
					$('#chatroom').get(0).scrollTop = $('#chatroom').get(0).scrollHeight;
				}
			});
		}
	});
	return;
}

function sendData() {
	var data = $('#datasend').val();
	if(data === """") {
		bootbox.alert('Insert a message to send on the DataChannel');
		return;
	}
	var message = {
		textroom: ""message"",
		transaction: randomString(12),
		room: myroom,
 		text: data,
	};
	// Note: messages are always acknowledged by default. This means that you'll
	// always receive a confirmation back that the message has been received by the
	// server and forwarded to the recipients. If you do not want this to happen,
	// just add an ack:false property to the message above, and server won't send
	// you a response (meaning you just have to hope it succeeded).
	textroom.data({
		text: JSON.stringify(message),
		error: function(reason) { bootbox.alert(reason); },
		success: function() { $('#datasend').val(''); }
	});
}

// Helper to format times
function getDateString(jsonDate) {
	var when = new Date();
	if(jsonDate) {
		when = new Date(Date.parse(jsonDate));
	}
	var dateString =
			(""0"" + when.getUTCHours()).slice(-2) + "":"" +
			(""0"" + when.getUTCMinutes()).slice(-2) + "":"" +
			(""0"" + when.getUTCSeconds()).slice(-2);
	return dateString;
}

// Just an helper to generate random usernames
function randomString(len, charSet) {
    charSet = charSet || 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    var randomString = '';
    for (var i = 0; i < len; i++) {
    	var randomPoz = Math.floor(Math.random() * charSet.length);
    	randomString += charSet.substring(randomPoz,randomPoz+1);
    }
    return randomString;
}

// Helper to parse query string
function getQueryStringValue(name) {
	name = name.replace(/[\[]/, ""\\["").replace(/[\]]/, ""\\]"");
	var regex = new RegExp(""[\\?&]"" + name + ""=([^&#]*)""),
		results = regex.exec(location.search);
	return results === null ? """" : decodeURIComponent(results[1].replace(/\+/g, "" ""));
}

// Helper to escape XML tags
function escapeXmlTags(value) {
	if(value) {
		var escapedValue = value.replace(new RegExp('<', 'g'), '&lt');
		escapedValue = escapedValue.replace(new RegExp('>', 'g'), '&gt');
		return escapedValue;
	}
}
"
"/* vim: set expandtab sw=4 ts=4 sts=4: */

var chart_data = {};
var temp_chart_title;

var currentChart = null;
var currentSettings = null;

var dateTimeCols = [];
var numericCols = [];

function extractDate(dateString) {
    var matches, match;
    var dateTimeRegExp = /[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}/;
    var dateRegExp = /[0-9]{4}-[0-9]{2}-[0-9]{2}/;

    matches = dateTimeRegExp.exec(dateString);
    if (matches !== null && matches.length > 0) {
        match = matches[0];
        return new Date(match.substr(0, 4), parseInt(match.substr(5, 2), 10) - 1, match.substr(8, 2), match.substr(11, 2), match.substr(14, 2), match.substr(17, 2));
    } else {
        matches = dateRegExp.exec(dateString);
        if (matches !== null && matches.length > 0) {
            match = matches[0];
            return new Date(match.substr(0, 4), parseInt(match.substr(5, 2), 10) - 1, match.substr(8, 2));
        }
    }
    return null;
}

function PMA_queryChart(data, columnNames, settings) {
    if ($('#querychart').length === 0) {
        return;
    }

    var plotSettings = {
        title : {
            text : settings.title,
            escapeHtml: true
        },
        grid : {
            drawBorder : false,
            shadow : false,
            background : 'rgba(0,0,0,0)'
        },
        legend : {
            show : true,
            placement : 'outsideGrid',
            location : 'e'
        },
        axes : {
            xaxis : {
                label : escapeHtml(settings.xaxisLabel)
            },
            yaxis : {
                label : settings.yaxisLabel
            }
        },
        stackSeries : settings.stackSeries
    };

    // create the chart
    var factory = new JQPlotChartFactory();
    var chart = factory.createChart(settings.type, ""querychart"");

    // create the data table and add columns
    var dataTable = new DataTable();
    if (settings.type == 'timeline') {
        dataTable.addColumn(ColumnType.DATE, columnNames[settings.mainAxis]);
    } else if (settings.type == 'scatter') {
        dataTable.addColumn(ColumnType.NUMBER, columnNames[settings.mainAxis]);
    } else {
        dataTable.addColumn(ColumnType.STRING, columnNames[settings.mainAxis]);
    }

    var i;
    if (settings.seriesColumn === null) {
        $.each(settings.selectedSeries, function (index, element) {
            dataTable.addColumn(ColumnType.NUMBER, columnNames[element]);
        });

        // set data to the data table
        var columnsToExtract = [ settings.mainAxis ];
        $.each(settings.selectedSeries, function (index, element) {
            columnsToExtract.push(element);
        });
        var values = [], newRow, row, col;
        for (i = 0; i < data.length; i++) {
            row = data[i];
            newRow = [];
            for (var j = 0; j < columnsToExtract.length; j++) {
                col = columnNames[columnsToExtract[j]];
                if (j === 0) {
                    if (settings.type == 'timeline') { // first column is date type
                        newRow.push(extractDate(row[col]));
                    } else if (settings.type == 'scatter') {
                        newRow.push(parseFloat(row[col]));
                    } else { // first column is string type
                        newRow.push(row[col]);
                    }
                } else { // subsequent columns are of type, number
                    newRow.push(parseFloat(row[col]));
                }
            }
            values.push(newRow);
        }
        dataTable.setData(values);
    } else {
        var seriesNames = {}, seriesNumber = 1;
        var seriesColumnName = columnNames[settings.seriesColumn];
        for (i = 0; i < data.length; i++) {
            if (! seriesNames[data[i][seriesColumnName]]) {
                seriesNames[data[i][seriesColumnName]] = seriesNumber;
                seriesNumber++;
            }
        }

        $.each(seriesNames, function (seriesName, seriesNumber) {
            dataTable.addColumn(ColumnType.NUMBER, seriesName);
        });

        var valueMap = {}, xValue, value;
        var mainAxisName = columnNames[settings.mainAxis];
        var valueColumnName = columnNames[settings.valueColumn];
        for (i = 0; i < data.length; i++) {
            xValue = data[i][mainAxisName];
            value = valueMap[xValue];
            if (! value) {
                value = [xValue];
                valueMap[xValue] = value;
            }
            seriesNumber = seriesNames[data[i][seriesColumnName]];
            value[seriesNumber] = parseFloat(data[i][valueColumnName]);
        }

        var values = [];
        $.each(valueMap, function(index, value) {
            values.push(value);
        });
        dataTable.setData(values);
    }

    // draw the chart and return the chart object
    chart.draw(dataTable, plotSettings);
    return chart;
}

function drawChart() {
    currentSettings.width = $('#resizer').width() - 20;
    currentSettings.height = $('#resizer').height() - 20;

    // TODO: a better way using .redraw() ?
    if (currentChart !== null) {
        currentChart.destroy();
    }

    var columnNames = [];
    $('select[name=""chartXAxis""] option').each(function () {
        columnNames.push($(this).text());
    });
    try {
        currentChart = PMA_queryChart(chart_data, columnNames, currentSettings);
        if (currentChart != null) {
            $('#saveChart').attr('href', currentChart.toImageString());
        }
    } catch (err) {
        PMA_ajaxShowMessage(err.message, false);
    }
}

function getSelectedSeries() {
    var val = $('select[name=""chartSeries""]').val() || [];
    var ret = [];
    $.each(val, function (i, v) {
        ret.push(parseInt(v, 10));
    });
    return ret;
}

function onXAxisChange() {
    var $xAxisSelect = $('select[name=""chartXAxis""]');
    currentSettings.mainAxis = parseInt($xAxisSelect.val(), 10);
    if (dateTimeCols.indexOf(currentSettings.mainAxis) != -1) {
        $('span.span_timeline').show();
    } else {
        $('span.span_timeline').hide();
        if (currentSettings.type == 'timeline') {
            $('input#radio_line').prop('checked', true);
            currentSettings.type = 'line';
        }
    }
    if (numericCols.indexOf(currentSettings.mainAxis) != -1) {
        $('span.span_scatter').show();
    } else {
        $('span.span_scatter').hide();
        if (currentSettings.type == 'scatter') {
            $('input#radio_line').prop('checked', true);
            currentSettings.type = 'line';
        }
    }
    var xaxis_title = $xAxisSelect.children('option:selected').text();
    $('input[name=""xaxis_label""]').val(xaxis_title);
    currentSettings.xaxisLabel = xaxis_title;
}

function onDataSeriesChange() {
    var $seriesSelect = $('select[name=""chartSeries""]');
    currentSettings.selectedSeries = getSelectedSeries();
    var yaxis_title;
    if (currentSettings.selectedSeries.length == 1) {
        $('span.span_pie').show();
        yaxis_title = $seriesSelect.children('option:selected').text();
    } else {
        $('span.span_pie').hide();
        if (currentSettings.type == 'pie') {
            $('input#radio_line').prop('checked', true);
            currentSettings.type = 'line';
        }
        yaxis_title = PMA_messages.strYValues;
    }
    $('input[name=""yaxis_label""]').val(yaxis_title);
    currentSettings.yaxisLabel = yaxis_title;
}

/**
 * Unbind all event handlers before tearing down a page
 */
AJAX.registerTeardown('tbl_chart.js', function () {
    $('input[name=""chartType""]').unbind('click');
    $('input[name=""barStacked""]').unbind('click');
    $('input[name=""chkAlternative""]').unbind('click');
    $('input[name=""chartTitle""]').unbind('focus').unbind('keyup').unbind('blur');
    $('select[name=""chartXAxis""]').unbind('change');
    $('select[name=""chartSeries""]').unbind('change');
    $('select[name=""chartSeriesColumn""]').unbind('change');
    $('select[name=""chartValueColumn""]').unbind('change');
    $('input[name=""xaxis_label""]').unbind('keyup');
    $('input[name=""yaxis_label""]').unbind('keyup');
    $('#resizer').unbind('resizestop');
    $('#tblchartform').unbind('submit');
});

AJAX.registerOnload('tbl_chart.js', function () {

    // handle manual resize
    $('#resizer').bind('resizestop', function (event, ui) {
        // make room so that the handle will still appear
        $('#querychart').height($('#resizer').height() * 0.96);
        $('#querychart').width($('#resizer').width() * 0.96);
        if (currentChart !== null) {
            currentChart.redraw({
                resetAxes : true
            });
        }
    });

    // handle chart type changes
    $('input[name=""chartType""]').click(function () {
        var type = currentSettings.type = $(this).val();
        if (type == 'bar' || type == 'column' || type == 'area') {
            $('span.barStacked').show();
        } else {
            $('input[name=""barStacked""]').prop('checked', false);
            $.extend(true, currentSettings, {stackSeries : false});
            $('span.barStacked').hide();
        }
        drawChart();
    });

    // handle chosing alternative data format
    $('input[name=""chkAlternative""]').click(function () {
        var $seriesColumn = $('select[name=""chartSeriesColumn""]');
        var $valueColumn  = $('select[name=""chartValueColumn""]');
        var $chartSeries  = $('select[name=""chartSeries""]');
        if ($(this).is(':checked')) {
            $seriesColumn.prop('disabled', false);
            $valueColumn.prop('disabled', false);
            $chartSeries.prop('disabled', true);
            currentSettings.seriesColumn = parseInt($seriesColumn.val(), 10);
            currentSettings.valueColumn = parseInt($valueColumn.val(), 10);
        } else {
            $seriesColumn.prop('disabled', true);
            $valueColumn.prop('disabled', true);
            $chartSeries.prop('disabled', false);
            currentSettings.seriesColumn = null;
            currentSettings.valueColumn = null;
        }
        drawChart();
    });

    // handle stacking for bar, column and area charts
    $('input[name=""barStacked""]').click(function () {
        if ($(this).is(':checked')) {
            $.extend(true, currentSettings, {stackSeries : true});
        } else {
            $.extend(true, currentSettings, {stackSeries : false});
        }
        drawChart();
    });

    // handle changes in chart title
    $('input[name=""chartTitle""]')
    .focus(function () {
        temp_chart_title = $(this).val();
    })
    .keyup(function () {
        currentSettings.title = $('input[name=""chartTitle""]').val();
        drawChart();
    })
    .blur(function () {
        if ($(this).val() != temp_chart_title) {
            drawChart();
        }
    });

    // handle changing the x-axis
    $('select[name=""chartXAxis""]').change(function () {
        onXAxisChange();
        drawChart();
    });

    // handle changing the selected data series
    $('select[name=""chartSeries""]').change(function () {
        onDataSeriesChange();
        drawChart();
    });

    // handle changing the series column
    $('select[name=""chartSeriesColumn""]').change(function () {
        currentSettings.seriesColumn = parseInt($(this).val(), 10);
        drawChart();
    });

    // handle changing the value column
    $('select[name=""chartValueColumn""]').change(function () {
        currentSettings.valueColumn = parseInt($(this).val(), 10);
        drawChart();
    });

    // handle manual changes to the chart x-axis labels
    $('input[name=""xaxis_label""]').keyup(function () {
        currentSettings.xaxisLabel = $(this).val();
        drawChart();
    });

    // handle manual changes to the chart y-axis labels
    $('input[name=""yaxis_label""]').keyup(function () {
        currentSettings.yaxisLabel = $(this).val();
        drawChart();
    });

    // handler for ajax form submission
    $('#tblchartform').submit(function (event) {

        var $form = $(this);
        if (codemirror_editor) {
            $form[0].elements.sql_query.value = codemirror_editor.getValue();
        }
        if (!checkSqlQuery($form[0])) {
            return false;
        }

        var $msgbox = PMA_ajaxShowMessage();
        PMA_prepareForAjaxRequest($form);
        $.post($form.attr('action'), $form.serialize(), function (data) {
            if (typeof data !== 'undefined' &&
                    data.success === true &&
                    typeof data.chartData !== 'undefined') {
                chart_data = jQuery.parseJSON(data.chartData);
                drawChart();
                PMA_ajaxRemoveMessage($msgbox);
            } else {
                PMA_ajaxShowMessage(data.error, false);
            }
        }, ""json""); // end $.post()

        return false;
    });

    // from jQuery UI
    $('#resizer').resizable({
        minHeight: 240,
        minWidth: 300
    })
    .width($('#div_view_options').width() - 50)
    .trigger('resizestop');

    currentSettings = {
        type : 'line',
        width : $('#resizer').width() - 20,
        height : $('#resizer').height() - 20,
        xaxisLabel : $('input[name=""xaxis_label""]').val(),
        yaxisLabel : $('input[name=""yaxis_label""]').val(),
        title : $('input[name=""chartTitle""]').val(),
        stackSeries : false,
        mainAxis : parseInt($('select[name=""chartXAxis""]').val(), 10),
        selectedSeries : getSelectedSeries(),
        seriesColumn : null
    };

    var vals = $('input[name=""dateTimeCols""]').val().split(' ');
    $.each(vals, function (i, v) {
        dateTimeCols.push(parseInt(v, 10));
    });

    vals = $('input[name=""numericCols""]').val().split(' ');
    $.each(vals, function (i, v) {
        numericCols.push(parseInt(v, 10));
    });

    onXAxisChange();
    onDataSeriesChange();

    $(""#tblchartform"").submit();
});
","/* vim: set expandtab sw=4 ts=4 sts=4: */

var chart_data = {};
var temp_chart_title;

var currentChart = null;
var currentSettings = null;

var dateTimeCols = [];
var numericCols = [];

function extractDate(dateString) {
    var matches, match;
    var dateTimeRegExp = /[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}/;
    var dateRegExp = /[0-9]{4}-[0-9]{2}-[0-9]{2}/;

    matches = dateTimeRegExp.exec(dateString);
    if (matches !== null && matches.length > 0) {
        match = matches[0];
        return new Date(match.substr(0, 4), parseInt(match.substr(5, 2), 10) - 1, match.substr(8, 2), match.substr(11, 2), match.substr(14, 2), match.substr(17, 2));
    } else {
        matches = dateRegExp.exec(dateString);
        if (matches !== null && matches.length > 0) {
            match = matches[0];
            return new Date(match.substr(0, 4), parseInt(match.substr(5, 2), 10) - 1, match.substr(8, 2));
        }
    }
    return null;
}

function PMA_queryChart(data, columnNames, settings) {
    if ($('#querychart').length === 0) {
        return;
    }

    var plotSettings = {
        title : {
            text : settings.title,
            escapeHtml: true
        },
        grid : {
            drawBorder : false,
            shadow : false,
            background : 'rgba(0,0,0,0)'
        },
        legend : {
            show : true,
            placement : 'outsideGrid',
            location : 'e'
        },
        axes : {
            xaxis : {
                label : escapeHtml(settings.xaxisLabel)
            },
            yaxis : {
                label : settings.yaxisLabel
            }
        },
        stackSeries : settings.stackSeries
    };

    // create the chart
    var factory = new JQPlotChartFactory();
    var chart = factory.createChart(settings.type, ""querychart"");

    // create the data table and add columns
    var dataTable = new DataTable();
    if (settings.type == 'timeline') {
        dataTable.addColumn(ColumnType.DATE, columnNames[settings.mainAxis]);
    } else if (settings.type == 'scatter') {
        dataTable.addColumn(ColumnType.NUMBER, columnNames[settings.mainAxis]);
    } else {
        dataTable.addColumn(ColumnType.STRING, columnNames[settings.mainAxis]);
    }

    var i;
    if (settings.seriesColumn === null) {
        $.each(settings.selectedSeries, function (index, element) {
            dataTable.addColumn(ColumnType.NUMBER, columnNames[element]);
        });

        // set data to the data table
        var columnsToExtract = [ settings.mainAxis ];
        $.each(settings.selectedSeries, function (index, element) {
            columnsToExtract.push(element);
        });
        var values = [], newRow, row, col;
        for (i = 0; i < data.length; i++) {
            row = data[i];
            newRow = [];
            for (var j = 0; j < columnsToExtract.length; j++) {
                col = columnNames[columnsToExtract[j]];
                if (j === 0) {
                    if (settings.type == 'timeline') { // first column is date type
                        newRow.push(extractDate(row[col]));
                    } else if (settings.type == 'scatter') {
                        newRow.push(parseFloat(row[col]));
                    } else { // first column is string type
                        newRow.push(row[col]);
                    }
                } else { // subsequent columns are of type, number
                    newRow.push(parseFloat(row[col]));
                }
            }
            values.push(newRow);
        }
        dataTable.setData(values);
    } else {
        var seriesNames = {}, seriesNumber = 1;
        var seriesColumnName = columnNames[settings.seriesColumn];
        for (i = 0; i < data.length; i++) {
            if (! seriesNames[data[i][seriesColumnName]]) {
                seriesNames[data[i][seriesColumnName]] = seriesNumber;
                seriesNumber++;
            }
        }

        $.each(seriesNames, function (seriesName, seriesNumber) {
            dataTable.addColumn(ColumnType.NUMBER, seriesName);
        });

        var valueMap = {}, xValue, value;
        var mainAxisName = columnNames[settings.mainAxis];
        var valueColumnName = columnNames[settings.valueColumn];
        for (i = 0; i < data.length; i++) {
            xValue = data[i][mainAxisName];
            value = valueMap[xValue];
            if (! value) {
                value = [xValue];
                valueMap[xValue] = value;
            }
            seriesNumber = seriesNames[data[i][seriesColumnName]];
            value[seriesNumber] = parseFloat(data[i][valueColumnName]);
        }

        var values = [];
        $.each(valueMap, function(index, value) {
            values.push(value);
        });
        dataTable.setData(values);
    }

    // draw the chart and return the chart object
    chart.draw(dataTable, plotSettings);
    return chart;
}

function drawChart() {
    currentSettings.width = $('#resizer').width() - 20;
    currentSettings.height = $('#resizer').height() - 20;

    // TODO: a better way using .redraw() ?
    if (currentChart !== null) {
        currentChart.destroy();
    }

    var columnNames = [];
    $('select[name=""chartXAxis""] option').each(function () {
        columnNames.push(escapeHtml($(this).text()));
    });
    try {
        currentChart = PMA_queryChart(chart_data, columnNames, currentSettings);
        if (currentChart != null) {
            $('#saveChart').attr('href', currentChart.toImageString());
        }
    } catch (err) {
        PMA_ajaxShowMessage(err.message, false);
    }
}

function getSelectedSeries() {
    var val = $('select[name=""chartSeries""]').val() || [];
    var ret = [];
    $.each(val, function (i, v) {
        ret.push(parseInt(v, 10));
    });
    return ret;
}

function onXAxisChange() {
    var $xAxisSelect = $('select[name=""chartXAxis""]');
    currentSettings.mainAxis = parseInt($xAxisSelect.val(), 10);
    if (dateTimeCols.indexOf(currentSettings.mainAxis) != -1) {
        $('span.span_timeline').show();
    } else {
        $('span.span_timeline').hide();
        if (currentSettings.type == 'timeline') {
            $('input#radio_line').prop('checked', true);
            currentSettings.type = 'line';
        }
    }
    if (numericCols.indexOf(currentSettings.mainAxis) != -1) {
        $('span.span_scatter').show();
    } else {
        $('span.span_scatter').hide();
        if (currentSettings.type == 'scatter') {
            $('input#radio_line').prop('checked', true);
            currentSettings.type = 'line';
        }
    }
    var xaxis_title = $xAxisSelect.children('option:selected').text();
    $('input[name=""xaxis_label""]').val(xaxis_title);
    currentSettings.xaxisLabel = xaxis_title;
}

function onDataSeriesChange() {
    var $seriesSelect = $('select[name=""chartSeries""]');
    currentSettings.selectedSeries = getSelectedSeries();
    var yaxis_title;
    if (currentSettings.selectedSeries.length == 1) {
        $('span.span_pie').show();
        yaxis_title = $seriesSelect.children('option:selected').text();
    } else {
        $('span.span_pie').hide();
        if (currentSettings.type == 'pie') {
            $('input#radio_line').prop('checked', true);
            currentSettings.type = 'line';
        }
        yaxis_title = PMA_messages.strYValues;
    }
    $('input[name=""yaxis_label""]').val(yaxis_title);
    currentSettings.yaxisLabel = yaxis_title;
}

/**
 * Unbind all event handlers before tearing down a page
 */
AJAX.registerTeardown('tbl_chart.js', function () {
    $('input[name=""chartType""]').unbind('click');
    $('input[name=""barStacked""]').unbind('click');
    $('input[name=""chkAlternative""]').unbind('click');
    $('input[name=""chartTitle""]').unbind('focus').unbind('keyup').unbind('blur');
    $('select[name=""chartXAxis""]').unbind('change');
    $('select[name=""chartSeries""]').unbind('change');
    $('select[name=""chartSeriesColumn""]').unbind('change');
    $('select[name=""chartValueColumn""]').unbind('change');
    $('input[name=""xaxis_label""]').unbind('keyup');
    $('input[name=""yaxis_label""]').unbind('keyup');
    $('#resizer').unbind('resizestop');
    $('#tblchartform').unbind('submit');
});

AJAX.registerOnload('tbl_chart.js', function () {

    // handle manual resize
    $('#resizer').bind('resizestop', function (event, ui) {
        // make room so that the handle will still appear
        $('#querychart').height($('#resizer').height() * 0.96);
        $('#querychart').width($('#resizer').width() * 0.96);
        if (currentChart !== null) {
            currentChart.redraw({
                resetAxes : true
            });
        }
    });

    // handle chart type changes
    $('input[name=""chartType""]').click(function () {
        var type = currentSettings.type = $(this).val();
        if (type == 'bar' || type == 'column' || type == 'area') {
            $('span.barStacked').show();
        } else {
            $('input[name=""barStacked""]').prop('checked', false);
            $.extend(true, currentSettings, {stackSeries : false});
            $('span.barStacked').hide();
        }
        drawChart();
    });

    // handle chosing alternative data format
    $('input[name=""chkAlternative""]').click(function () {
        var $seriesColumn = $('select[name=""chartSeriesColumn""]');
        var $valueColumn  = $('select[name=""chartValueColumn""]');
        var $chartSeries  = $('select[name=""chartSeries""]');
        if ($(this).is(':checked')) {
            $seriesColumn.prop('disabled', false);
            $valueColumn.prop('disabled', false);
            $chartSeries.prop('disabled', true);
            currentSettings.seriesColumn = parseInt($seriesColumn.val(), 10);
            currentSettings.valueColumn = parseInt($valueColumn.val(), 10);
        } else {
            $seriesColumn.prop('disabled', true);
            $valueColumn.prop('disabled', true);
            $chartSeries.prop('disabled', false);
            currentSettings.seriesColumn = null;
            currentSettings.valueColumn = null;
        }
        drawChart();
    });

    // handle stacking for bar, column and area charts
    $('input[name=""barStacked""]').click(function () {
        if ($(this).is(':checked')) {
            $.extend(true, currentSettings, {stackSeries : true});
        } else {
            $.extend(true, currentSettings, {stackSeries : false});
        }
        drawChart();
    });

    // handle changes in chart title
    $('input[name=""chartTitle""]')
    .focus(function () {
        temp_chart_title = $(this).val();
    })
    .keyup(function () {
        currentSettings.title = $('input[name=""chartTitle""]').val();
        drawChart();
    })
    .blur(function () {
        if ($(this).val() != temp_chart_title) {
            drawChart();
        }
    });

    // handle changing the x-axis
    $('select[name=""chartXAxis""]').change(function () {
        onXAxisChange();
        drawChart();
    });

    // handle changing the selected data series
    $('select[name=""chartSeries""]').change(function () {
        onDataSeriesChange();
        drawChart();
    });

    // handle changing the series column
    $('select[name=""chartSeriesColumn""]').change(function () {
        currentSettings.seriesColumn = parseInt($(this).val(), 10);
        drawChart();
    });

    // handle changing the value column
    $('select[name=""chartValueColumn""]').change(function () {
        currentSettings.valueColumn = parseInt($(this).val(), 10);
        drawChart();
    });

    // handle manual changes to the chart x-axis labels
    $('input[name=""xaxis_label""]').keyup(function () {
        currentSettings.xaxisLabel = $(this).val();
        drawChart();
    });

    // handle manual changes to the chart y-axis labels
    $('input[name=""yaxis_label""]').keyup(function () {
        currentSettings.yaxisLabel = $(this).val();
        drawChart();
    });

    // handler for ajax form submission
    $('#tblchartform').submit(function (event) {

        var $form = $(this);
        if (codemirror_editor) {
            $form[0].elements.sql_query.value = codemirror_editor.getValue();
        }
        if (!checkSqlQuery($form[0])) {
            return false;
        }

        var $msgbox = PMA_ajaxShowMessage();
        PMA_prepareForAjaxRequest($form);
        $.post($form.attr('action'), $form.serialize(), function (data) {
            if (typeof data !== 'undefined' &&
                    data.success === true &&
                    typeof data.chartData !== 'undefined') {
                chart_data = jQuery.parseJSON(data.chartData);
                drawChart();
                PMA_ajaxRemoveMessage($msgbox);
            } else {
                PMA_ajaxShowMessage(data.error, false);
            }
        }, ""json""); // end $.post()

        return false;
    });

    // from jQuery UI
    $('#resizer').resizable({
        minHeight: 240,
        minWidth: 300
    })
    .width($('#div_view_options').width() - 50)
    .trigger('resizestop');

    currentSettings = {
        type : 'line',
        width : $('#resizer').width() - 20,
        height : $('#resizer').height() - 20,
        xaxisLabel : $('input[name=""xaxis_label""]').val(),
        yaxisLabel : $('input[name=""yaxis_label""]').val(),
        title : $('input[name=""chartTitle""]').val(),
        stackSeries : false,
        mainAxis : parseInt($('select[name=""chartXAxis""]').val(), 10),
        selectedSeries : getSelectedSeries(),
        seriesColumn : null
    };

    var vals = $('input[name=""dateTimeCols""]').val().split(' ');
    $.each(vals, function (i, v) {
        dateTimeCols.push(parseInt(v, 10));
    });

    vals = $('input[name=""numericCols""]').val().split(' ');
    $.each(vals, function (i, v) {
        numericCols.push(parseInt(v, 10));
    });

    onXAxisChange();
    onDataSeriesChange();

    $(""#tblchartform"").submit();
});
"
"export default async function ({ addon, console }) {
  await addon.tab.loadScript(""https://cdn.jsdelivr.net/npm/linkifyjs@2.1.9/dist/linkify.min.js"");
  await addon.tab.loadScript(""https://cdn.jsdelivr.net/npm/linkifyjs@2.1.9/dist/linkify-element.min.js"");

  const pageType = document.location.pathname.substr(1).split(""/"")[0];

  switch (pageType) {
    case ""users"":
      document.querySelectorAll(""#user-details .read-only"").forEach((element) => linkifyElement(element));
      break;

    case ""projects"":
      (async () => {
        while (true) {
          let element = await addon.tab.waitForElement("".project-description"", { markAsSeen: true });
          // Need to convert #[numbers] to solve conflict between tags and external Scratch player links.
          document.querySelectorAll("".project-description a"").forEach((element) => {
            if (/\d+/.test(element.textContent)) element.outerHTML = element.textContent;
          });
          element.normalize();
          linkifyElement(element);
        }
      })();
      break;

    case ""studios"":
      linkifyElement(document.querySelector(""#description.read-only .overview""));
      break;
  }

  (async () => {
    while (true) {
      let comment = await addon.tab.waitForElement("".comment"", { markAsSeen: true });
      linkifyElement(comment);
    }
  })();
}
","export default async function ({ addon, console }) {
  await addon.tab.loadScript(""https://cdn.jsdelivr.net/npm/linkifyjs@2.1.9/dist/linkify.min.js"");
  await addon.tab.loadScript(""https://cdn.jsdelivr.net/npm/linkifyjs@2.1.9/dist/linkify-element.min.js"");

  const pageType = document.location.pathname.substr(1).split(""/"")[0];

  switch (pageType) {
    case ""users"":
      document.querySelectorAll(""#user-details .read-only"").forEach((element) => linkifyElement(element));
      break;

    case ""projects"":
      (async () => {
        while (true) {
          let element = await addon.tab.waitForElement("".project-description"", { markAsSeen: true });
          // Need to convert #[numbers] to solve conflict between tags and external Scratch player links.
          document.querySelectorAll("".project-description a"").forEach((element) => {
              if (/^#\d+$/.test(element.textContent) && element.previousSibling instanceof Text) {
                  element.previousSibling.textContent += element.textContent;
                  element.remove();
              }
          });
          element.normalize();
          linkifyElement(element);
        }
      })();
      break;

    case ""studios"":
      linkifyElement(document.querySelector(""#description.read-only .overview""));
      break;
  }

  (async () => {
    while (true) {
      let comment = await addon.tab.waitForElement("".comment"", { markAsSeen: true });
      linkifyElement(comment);
    }
  })();
}
"
"/* vim: set expandtab sw=4 ts=4 sts=4: */
/**
 * general function, usually for data manipulation pages
 *
 */

/**
 * @var sql_box_locked lock for the sqlbox textarea in the querybox
 */
var sql_box_locked = false;

/**
 * @var array holds elements which content should only selected once
 */
var only_once_elements = [];

/**
 * @var   int   ajax_message_count   Number of AJAX messages shown since page load
 */
var ajax_message_count = 0;

/**
 * @var codemirror_editor object containing CodeMirror editor of the query editor in SQL tab
 */
var codemirror_editor = false;

/**
 * @var codemirror_editor object containing CodeMirror editor of the inline query editor
 */
var codemirror_inline_editor = false;

/**
 * @var sql_autocomplete_in_progress bool shows if Table/Column name autocomplete AJAX is in progress
 */
var sql_autocomplete_in_progress = false;

/**
 * @var sql_autocomplete object containing list of columns in each table
 */
var sql_autocomplete = false;

/**
 * @var sql_autocomplete_default_table string containing default table to autocomplete columns
 */
var sql_autocomplete_default_table = '';

/**
 * @var chart_activeTimeouts object active timeouts that refresh the charts. When disabling a realtime chart, this can be used to stop the continuous ajax requests
 */
var chart_activeTimeouts = {};

/**
 * @var central_column_list array to hold the columns in central list per db.
 */
var central_column_list = [];

/**
 * @var primary_indexes array to hold 'Primary' index columns.
 */
var primary_indexes = [];

/**
 * @var unique_indexes array to hold 'Unique' index columns.
 */
var unique_indexes = [];

/**
 * @var indexes array to hold 'Index' columns.
 */
var indexes = [];

/**
 * @var fulltext_indexes array to hold 'Fulltext' columns.
 */
var fulltext_indexes = [];

/**
 * @var spatial_indexes array to hold 'Spatial' columns.
 */
var spatial_indexes = [];

/**
 * Make sure that ajax requests will not be cached
 * by appending a random variable to their parameters
 */
$.ajaxPrefilter(function (options, originalOptions, jqXHR) {
    var nocache = new Date().getTime() + """" + Math.floor(Math.random() * 1000000);
    if (typeof options.data == ""string"") {
        options.data += ""&_nocache="" + nocache;
    } else if (typeof options.data == ""object"") {
        options.data = $.extend(originalOptions.data, {'_nocache' : nocache});
    }
});

/**
 * Hanle redirect and reload flags send as part of AJAX requests
 *
 * @param data ajax response data
 */
function PMA_handleRedirectAndReload(data) {
    if (parseInt(data.redirect_flag) == 1) {
        // add one more GET param to display session expiry msg
        if (window.location.href.indexOf('?') === -1) {
            window.location.href += '?session_expired=1';
        } else {
            window.location.href += '&session_expired=1';
        }
        window.location.reload();
    } else if (parseInt(data.reload_flag) == 1) {
        // remove the token param and reload
        window.location.href = window.location.href.replace(/&?token=[^&#]*/g, """");
        window.location.reload();
    }
}

/**
 * Creates an SQL editor which supports auto completing etc.
 *
 * @param $textarea jQuery object wrapping the textarea to be made the editor
 * @param options   optional options for CodeMirror
 * @param resize    optional resizing ('vertical', 'horizontal', 'both')
 */
function PMA_getSQLEditor($textarea, options, resize) {
    if ($textarea.length > 0 && typeof CodeMirror !== 'undefined') {

        // merge options for CodeMirror
        var defaults = {
            lineNumbers: true,
            matchBrackets: true,
            extraKeys: {""Ctrl-Space"": ""autocomplete""},
            hintOptions: {""completeSingle"": false, ""completeOnSingleClick"": true},
            indentUnit: 4,
            mode: ""text/x-mysql"",
            lineWrapping: true
        };

        if (CodeMirror.sqlLint) {
            $.extend(defaults, {
                gutters: [""CodeMirror-lint-markers""],
                lint: {
                    ""getAnnotations"": CodeMirror.sqlLint,
                    ""async"": true,
                }
            });
        }

        $.extend(true, defaults, options);

        // create CodeMirror editor
        var codemirrorEditor = CodeMirror.fromTextArea($textarea[0], defaults);
        // allow resizing
        if (! resize) {
            resize = 'vertical';
        }
        var handles = '';
        if (resize == 'vertical') {
            handles = 'n, s';
        }
        if (resize == 'both') {
            handles = 'all';
        }
        if (resize == 'horizontal') {
            handles = 'e, w';
        }
        $(codemirrorEditor.getWrapperElement())
            .css('resize', resize)
            .resizable({
                handles: handles,
                resize: function() {
                    codemirrorEditor.setSize($(this).width(), $(this).height());
                }
            });
        // enable autocomplete
        codemirrorEditor.on(""inputRead"", codemirrorAutocompleteOnInputRead);

        return codemirrorEditor;
    }
    return null;
}

/**
 * Clear text selection
 */
function PMA_clearSelection() {
    if (document.selection && document.selection.empty) {
        document.selection.empty();
    } else if (window.getSelection) {
        var sel = window.getSelection();
        if (sel.empty) {
            sel.empty();
        }
        if (sel.removeAllRanges) {
            sel.removeAllRanges();
        }
    }
}

/**
 * Create a jQuery UI tooltip
 *
 * @param $elements     jQuery object representing the elements
 * @param item          the item
 *                      (see http://api.jqueryui.com/tooltip/#option-items)
 * @param myContent     content of the tooltip
 * @param additionalOptions to override the default options
 *
 */
function PMA_tooltip($elements, item, myContent, additionalOptions)
{
    if ($('#no_hint').length > 0) {
        return;
    }

    var defaultOptions = {
        content: myContent,
        items:  item,
        tooltipClass: ""tooltip"",
        track: true,
        show: false,
        hide: false
    };

    $elements.tooltip($.extend(true, defaultOptions, additionalOptions));
}

/**
 * HTML escaping
 */

function escapeHtml(unsafe) {
    if (typeof(unsafe) != 'undefined') {
        return unsafe
            .toString()
            .replace(/&/g, ""&amp;"")
            .replace(/</g, ""&lt;"")
            .replace(/>/g, ""&gt;"")
            .replace(/""/g, ""&quot;"")
            .replace(/'/g, ""&#039;"");
    } else {
        return false;
    }
}

function PMA_sprintf() {
    return sprintf.apply(this, arguments);
}

/**
 * Hides/shows the default value input field, depending on the default type
 * Ticks the NULL checkbox if NULL is chosen as default value.
 */
function PMA_hideShowDefaultValue($default_type)
{
    if ($default_type.val() == 'USER_DEFINED') {
        $default_type.siblings('.default_value').show().focus();
    } else {
        $default_type.siblings('.default_value').hide();
        if ($default_type.val() == 'NULL') {
            var $null_checkbox = $default_type.closest('tr').find('.allow_null');
            $null_checkbox.prop('checked', true);
        }
    }
}

/**
 * Hides/shows the input field for column expression based on whether
 * VIRTUAL/PERSISTENT is selected
 *
 * @param $virtuality virtuality dropdown
 */
function PMA_hideShowExpression($virtuality)
{
    if ($virtuality.val() == '') {
        $virtuality.siblings('.expression').hide();
    } else {
        $virtuality.siblings('.expression').show();
    }
}

/**
 * Show notices for ENUM columns; add/hide the default value
 *
 */
function PMA_verifyColumnsProperties()
{
    $(""select.column_type"").each(function () {
        PMA_showNoticeForEnum($(this));
    });
    $(""select.default_type"").each(function () {
        PMA_hideShowDefaultValue($(this));
    });
    $('select.virtuality').each(function () {
        PMA_hideShowExpression($(this));
    });
}

/**
 * Add a hidden field to the form to indicate that this will be an
 * Ajax request (only if this hidden field does not exist)
 *
 * @param $form object   the form
 */
function PMA_prepareForAjaxRequest($form)
{
    if (! $form.find('input:hidden').is('#ajax_request_hidden')) {
        $form.append('<input type=""hidden"" id=""ajax_request_hidden"" name=""ajax_request"" value=""true"" />');
    }
}

/**
 * Generate a new password and copy it to the password input areas
 *
 * @param passwd_form object   the form that holds the password fields
 *
 * @return boolean  always true
 */
function suggestPassword(passwd_form)
{
    // restrict the password to just letters and numbers to avoid problems:
    // ""editors and viewers regard the password as multiple words and
    // things like double click no longer work""
    var pwchars = ""abcdefhjmnpqrstuvwxyz23456789ABCDEFGHJKLMNPQRSTUVWYXZ"";
    var passwordlength = 16;    // do we want that to be dynamic?  no, keep it simple :)
    var passwd = passwd_form.generated_pw;
    var randomWords = new Int32Array(passwordlength);

    passwd.value = '';

    // First we're going to try to use a built-in CSPRNG
    if (window.crypto && window.crypto.getRandomValues) {
        window.crypto.getRandomValues(randomWords);
    }
    // Because of course IE calls it msCrypto instead of being standard
    else if (window.msCrypto && window.msCrypto.getRandomValues) {
        window.msCrypto.getRandomValues(randomWords);
    } else {
        // Fallback to Math.random
        for (var i = 0; i < passwordlength; i++) {
            randomWords[i] = Math.floor(Math.random() * pwchars.length);
        }
    }

    for (var i = 0; i < passwordlength; i++) {
        passwd.value += pwchars.charAt(Math.abs(randomWords[i]) % pwchars.length);
    }

    passwd_form.text_pma_pw.value = passwd.value;
    passwd_form.text_pma_pw2.value = passwd.value;
    return true;
}

/**
 * Version string to integer conversion.
 */
function parseVersionString(str)
{
    if (typeof(str) != 'string') { return false; }
    var add = 0;
    // Parse possible alpha/beta/rc/
    var state = str.split('-');
    if (state.length >= 2) {
        if (state[1].substr(0, 2) == 'rc') {
            add = - 20 - parseInt(state[1].substr(2), 10);
        } else if (state[1].substr(0, 4) == 'beta') {
            add =  - 40 - parseInt(state[1].substr(4), 10);
        } else if (state[1].substr(0, 5) == 'alpha') {
            add =  - 60 - parseInt(state[1].substr(5), 10);
        } else if (state[1].substr(0, 3) == 'dev') {
            /* We don't handle dev, it's git snapshot */
            add = 0;
        }
    }
    // Parse version
    var x = str.split('.');
    // Use 0 for non existing parts
    var maj = parseInt(x[0], 10) || 0;
    var min = parseInt(x[1], 10) || 0;
    var pat = parseInt(x[2], 10) || 0;
    var hotfix = parseInt(x[3], 10) || 0;
    return  maj * 100000000 + min * 1000000 + pat * 10000 + hotfix * 100 + add;
}

/**
 * Indicates current available version on main page.
 */
function PMA_current_version(data)
{
    if (data && data.version && data.date) {
        var current = parseVersionString($('span.version').text());
        var latest = parseVersionString(data.version);
        var version_information_message = '<span class=""latest"">' +
            PMA_messages.strLatestAvailable +
            ' ' + escapeHtml(data.version) +
            '</span>';
        if (latest > current) {
            var message = PMA_sprintf(
                PMA_messages.strNewerVersion,
                escapeHtml(data.version),
                escapeHtml(data.date)
            );
            var htmlClass = 'notice';
            if (Math.floor(latest / 10000) === Math.floor(current / 10000)) {
                /* Security update */
                htmlClass = 'error';
            }
            $('#newer_version_notice').remove();
            $('#maincontainer').after('<div id=""newer_version_notice"" class=""' + htmlClass + '"">' + message + '</div>');
        }
        if (latest === current) {
            version_information_message = ' (' + PMA_messages.strUpToDate + ')';
        }
        var $liPmaVersion = $('#li_pma_version');
        $liPmaVersion.find('span.latest').remove();
        $liPmaVersion.append(version_information_message);
    }
}

/**
 * Loads Git revision data from ajax for index.php
 */
function PMA_display_git_revision()
{
    $('#is_git_revision').remove();
    $('#li_pma_version_git').remove();
    $.get(
        ""index.php"",
        {
            ""server"": PMA_commonParams.get('server'),
            ""token"": PMA_commonParams.get('token'),
            ""git_revision"": true,
            ""ajax_request"": true,
            ""no_debug"": true
        },
        function (data) {
            if (typeof data !== 'undefined' && data.success === true) {
                $(data.message).insertAfter('#li_pma_version');
            }
        }
    );
}

/**
 * for libraries/display_change_password.lib.php
 *     libraries/user_password.php
 *
 */

function displayPasswordGenerateButton()
{
    $('#tr_element_before_generate_password').parent().append('<tr class=""vmiddle""><td>' + PMA_messages.strGeneratePassword + '</td><td><input type=""button"" class=""button"" id=""button_generate_password"" value=""' + PMA_messages.strGenerate + '"" onclick=""suggestPassword(this.form)"" /><input type=""text"" name=""generated_pw"" id=""generated_pw"" /></td></tr>');
    $('#div_element_before_generate_password').parent().append('<div class=""item""><label for=""button_generate_password"">' + PMA_messages.strGeneratePassword + ':</label><span class=""options""><input type=""button"" class=""button"" id=""button_generate_password"" value=""' + PMA_messages.strGenerate + '"" onclick=""suggestPassword(this.form)"" /></span><input type=""text"" name=""generated_pw"" id=""generated_pw"" /></div>');
}

/*
 * Adds a date/time picker to an element
 *
 * @param object  $this_element   a jQuery object pointing to the element
 */
function PMA_addDatepicker($this_element, type, options)
{
    var showTimepicker = true;
    if (type==""date"") {
        showTimepicker = false;
    }

    var defaultOptions = {
        showOn: 'button',
        buttonImage: themeCalendarImage, // defined in js/messages.php
        buttonImageOnly: true,
        stepMinutes: 1,
        stepHours: 1,
        showSecond: true,
        showMillisec: true,
        showMicrosec: true,
        showTimepicker: showTimepicker,
        showButtonPanel: false,
        dateFormat: 'yy-mm-dd', // yy means year with four digits
        timeFormat: 'HH:mm:ss.lc',
        constrainInput: false,
        altFieldTimeOnly: false,
        showAnim: '',
        beforeShow: function (input, inst) {
            // Remember that we came from the datepicker; this is used
            // in tbl_change.js by verificationsAfterFieldChange()
            $this_element.data('comes_from', 'datepicker');
            if ($(input).closest('.cEdit').length > 0) {
                setTimeout(function () {
                    inst.dpDiv.css({
                        top: 0,
                        left: 0,
                        position: 'relative'
                    });
                }, 0);
            }
            // Fix wrong timepicker z-index, doesn't work without timeout
            setTimeout(function () {
                $('#ui-timepicker-div').css('z-index', $('#ui-datepicker-div').css('z-index'));
            }, 0);
        },
        onSelect: function() {
            $this_element.data('datepicker').inline = true;
        },
        onClose: function (dateText, dp_inst) {
            // The value is no more from the date picker
            $this_element.data('comes_from', '');
            if (typeof $this_element.data('datepicker') !== 'undefined') {
                $this_element.data('datepicker').inline = false;
            }
        }
    };
    if (type == ""datetime"" || type == ""timestamp"") {
        $this_element.datetimepicker($.extend(defaultOptions, options));
    }
    else if (type == ""date"") {
        $this_element.datetimepicker($.extend(defaultOptions, options));
    }
    else if (type == ""time"") {
        $this_element.timepicker($.extend(defaultOptions, options));
    }
}

/**
 * selects the content of a given object, f.e. a textarea
 *
 * @param element     object  element of which the content will be selected
 * @param lock        var     variable which holds the lock for this element
 *                              or true, if no lock exists
 * @param only_once   boolean if true this is only done once
 *                              f.e. only on first focus
 */
function selectContent(element, lock, only_once)
{
    if (only_once && only_once_elements[element.name]) {
        return;
    }

    only_once_elements[element.name] = true;

    if (lock) {
        return;
    }

    element.select();
}

/**
 * Displays a confirmation box before submitting a ""DROP/DELETE/ALTER"" query.
 * This function is called while clicking links
 *
 * @param theLink     object the link
 * @param theSqlQuery object the sql query to submit
 *
 * @return boolean  whether to run the query or not
 */
function confirmLink(theLink, theSqlQuery)
{
    // Confirmation is not required in the configuration file
    // or browser is Opera (crappy js implementation)
    if (PMA_messages.strDoYouReally === '' || typeof(window.opera) != 'undefined') {
        return true;
    }

    var is_confirmed = confirm(PMA_sprintf(PMA_messages.strDoYouReally, theSqlQuery));
    if (is_confirmed) {
        if ($(theLink).hasClass('formLinkSubmit')) {
            var name = 'is_js_confirmed';
            if ($(theLink).attr('href').indexOf('usesubform') != -1) {
                name = 'subform[' + $(theLink).attr('href').substr('#').match(/usesubform\[(\d+)\]/i)[1] + '][is_js_confirmed]';
            }

            $(theLink).parents('form').append('<input type=""hidden"" name=""' + name + '"" value=""1"" />');
        } else if (typeof(theLink.href) != 'undefined') {
            theLink.href += '&is_js_confirmed=1';
        } else if (typeof(theLink.form) != 'undefined') {
            theLink.form.action += '?is_js_confirmed=1';
        }
    }

    return is_confirmed;
} // end of the 'confirmLink()' function

/**
 * Displays an error message if a ""DROP DATABASE"" statement is submitted
 * while it isn't allowed, else confirms a ""DROP/DELETE/ALTER"" query before
 * submitting it if required.
 * This function is called by the 'checkSqlQuery()' js function.
 *
 * @param theForm1 object   the form
 * @param sqlQuery1 object  the sql query textarea
 *
 * @return boolean  whether to run the query or not
 *
 * @see     checkSqlQuery()
 */
function confirmQuery(theForm1, sqlQuery1)
{
    // Confirmation is not required in the configuration file
    if (PMA_messages.strDoYouReally === '') {
        return true;
    }

    // ""DROP DATABASE"" statement isn't allowed
    if (PMA_messages.strNoDropDatabases !== '') {
        var drop_re = new RegExp('(^|;)\\s*DROP\\s+(IF EXISTS\\s+)?DATABASE\\s', 'i');
        if (drop_re.test(sqlQuery1.value)) {
            alert(PMA_messages.strNoDropDatabases);
            theForm1.reset();
            sqlQuery1.focus();
            return false;
        } // end if
    } // end if

    // Confirms a ""DROP/DELETE/ALTER/TRUNCATE"" statement
    //
    // TODO: find a way (if possible) to use the parser-analyser
    // for this kind of verification
    // For now, I just added a ^ to check for the statement at
    // beginning of expression

    var do_confirm_re_0 = new RegExp('^\\s*DROP\\s+(IF EXISTS\\s+)?(TABLE|DATABASE|PROCEDURE)\\s', 'i');
    var do_confirm_re_1 = new RegExp('^\\s*ALTER\\s+TABLE\\s+((`[^`]+`)|([A-Za-z0-9_$]+))\\s+DROP\\s', 'i');
    var do_confirm_re_2 = new RegExp('^\\s*DELETE\\s+FROM\\s', 'i');
    var do_confirm_re_3 = new RegExp('^\\s*TRUNCATE\\s', 'i');

    if (do_confirm_re_0.test(sqlQuery1.value) ||
        do_confirm_re_1.test(sqlQuery1.value) ||
        do_confirm_re_2.test(sqlQuery1.value) ||
        do_confirm_re_3.test(sqlQuery1.value)) {
        var message;
        if (sqlQuery1.value.length > 100) {
            message = sqlQuery1.value.substr(0, 100) + '\n    ...';
        } else {
            message = sqlQuery1.value;
        }
        var is_confirmed = confirm(PMA_sprintf(PMA_messages.strDoYouReally, message));
        // statement is confirmed -> update the
        // ""is_js_confirmed"" form field so the confirm test won't be
        // run on the server side and allows to submit the form
        if (is_confirmed) {
            theForm1.elements.is_js_confirmed.value = 1;
            return true;
        }
        // statement is rejected -> do not submit the form
        else {
            window.focus();
            sqlQuery1.focus();
            return false;
        } // end if (handle confirm box result)
    } // end if (display confirm box)

    return true;
} // end of the 'confirmQuery()' function

/**
 * Displays an error message if the user submitted the sql query form with no
 * sql query, else checks for ""DROP/DELETE/ALTER"" statements
 *
 * @param theForm object the form
 *
 * @return boolean  always false
 *
 * @see     confirmQuery()
 */
function checkSqlQuery(theForm)
{
    // get the textarea element containing the query
    var sqlQuery;
    if (codemirror_editor) {
        codemirror_editor.save();
        sqlQuery = codemirror_editor.getValue();
    } else {
        sqlQuery = theForm.elements.sql_query.value;
    }
    var isEmpty  = 1;
    var space_re = new RegExp('\\s+');
    if (typeof(theForm.elements.sql_file) != 'undefined' &&
            theForm.elements.sql_file.value.replace(space_re, '') !== '') {
        return true;
    }
    if (isEmpty && typeof(theForm.elements.id_bookmark) != 'undefined' &&
            (theForm.elements.id_bookmark.value !== null || theForm.elements.id_bookmark.value !== '') &&
            theForm.elements.id_bookmark.selectedIndex !== 0) {
        return true;
    }
    // Checks for ""DROP/DELETE/ALTER"" statements
    if (sqlQuery.replace(space_re, '') !== '') {
        return confirmQuery(theForm, sqlQuery);
    }
    theForm.reset();
    isEmpty = 1;

    if (isEmpty) {
        alert(PMA_messages.strFormEmpty);
        codemirror_editor.focus();
        return false;
    }

    return true;
} // end of the 'checkSqlQuery()' function

/**
 * Check if a form's element is empty.
 * An element containing only spaces is also considered empty
 *
 * @param object   the form
 * @param string   the name of the form field to put the focus on
 *
 * @return boolean  whether the form field is empty or not
 */
function emptyCheckTheField(theForm, theFieldName)
{
    var theField = theForm.elements[theFieldName];
    var space_re = new RegExp('\\s+');
    return theField.value.replace(space_re, '') === '';
} // end of the 'emptyCheckTheField()' function

/**
 * Ensures a value submitted in a form is numeric and is in a range
 *
 * @param object   the form
 * @param string   the name of the form field to check
 * @param integer  the minimum authorized value
 * @param integer  the maximum authorized value
 *
 * @return boolean  whether a valid number has been submitted or not
 */
function checkFormElementInRange(theForm, theFieldName, message, min, max)
{
    var theField         = theForm.elements[theFieldName];
    var val              = parseInt(theField.value, 10);

    if (typeof(min) == 'undefined') {
        min = 0;
    }
    if (typeof(max) == 'undefined') {
        max = Number.MAX_VALUE;
    }

    // It's not a number
    if (isNaN(val)) {
        theField.select();
        alert(PMA_messages.strEnterValidNumber);
        theField.focus();
        return false;
    }
    // It's a number but it is not between min and max
    else if (val < min || val > max) {
        theField.select();
        alert(PMA_sprintf(message, val));
        theField.focus();
        return false;
    }
    // It's a valid number
    else {
        theField.value = val;
    }
    return true;

} // end of the 'checkFormElementInRange()' function


function checkTableEditForm(theForm, fieldsCnt)
{
    // TODO: avoid sending a message if user just wants to add a line
    // on the form but has not completed at least one field name

    var atLeastOneField = 0;
    var i, elm, elm2, elm3, val, id;

    for (i = 0; i < fieldsCnt; i++) {
        id = ""#field_"" + i + ""_2"";
        elm = $(id);
        val = elm.val();
        if (val == 'VARCHAR' || val == 'CHAR' || val == 'BIT' || val == 'VARBINARY' || val == 'BINARY') {
            elm2 = $(""#field_"" + i + ""_3"");
            val = parseInt(elm2.val(), 10);
            elm3 = $(""#field_"" + i + ""_1"");
            if (isNaN(val) && elm3.val() !== """") {
                elm2.select();
                alert(PMA_messages.strEnterValidLength);
                elm2.focus();
                return false;
            }
        }

        if (atLeastOneField === 0) {
            id = ""field_"" + i + ""_1"";
            if (!emptyCheckTheField(theForm, id)) {
                atLeastOneField = 1;
            }
        }
    }
    if (atLeastOneField === 0) {
        var theField = theForm.elements.field_0_1;
        alert(PMA_messages.strFormEmpty);
        theField.focus();
        return false;
    }

    // at least this section is under jQuery
    var $input = $(""input.textfield[name='table']"");
    if ($input.val() === """") {
        alert(PMA_messages.strFormEmpty);
        $input.focus();
        return false;
    }

    return true;
} // enf of the 'checkTableEditForm()' function

/**
 * True if last click is to check a row.
 */
var last_click_checked = false;

/**
 * Zero-based index of last clicked row.
 * Used to handle the shift + click event in the code above.
 */
var last_clicked_row = -1;

/**
 * Zero-based index of last shift clicked row.
 */
var last_shift_clicked_row = -1;

var _idleSecondsCounter = 0;
var IncInterval;
var updateTimeout;
AJAX.registerTeardown('functions.js', function () {
    clearTimeout(updateTimeout);
    clearInterval(IncInterval);
    $(document).off('mousemove');
});

AJAX.registerOnload('functions.js', function () {
    document.onclick = function() {
        _idleSecondsCounter = 0;
    };
    $(document).on('mousemove',function() {
        _idleSecondsCounter = 0;
    });
    document.onkeypress = function() {
        _idleSecondsCounter = 0;
    };

    function SetIdleTime() {
        _idleSecondsCounter++;
    }
    function UpdateIdleTime() {
        var href = 'index.php';
        var params = {
                'ajax_request' : true,
                'token' : PMA_commonParams.get('token'),
                'server' : PMA_commonParams.get('server'),
                'db' : PMA_commonParams.get('db'),
                'access_time':_idleSecondsCounter
            };
        $.ajax({
                type: 'POST',
                url: href,
                data: params,
                success: function (data) {
                    if (data.success) {
                        if (PMA_commonParams.get('LoginCookieValidity')-_idleSecondsCounter > 5) {
                            var interval = (PMA_commonParams.get('LoginCookieValidity') - _idleSecondsCounter - 5) * 1000;
                            if (interval > Math.pow(2, 31) - 1) { // max value for setInterval() function
                                interval = Math.pow(2, 31) - 1;
                            }
                            updateTimeout = window.setTimeout(UpdateIdleTime, interval);
                        } else {
                            updateTimeout = window.setTimeout(UpdateIdleTime, 2000);
                        }
                    } else { //timeout occurred
                        window.location.reload(true);
                        clearInterval(IncInterval);
                    }
                }
            });
    }
    if (PMA_commonParams.get('logged_in') && PMA_commonParams.get('auth_type') == 'cookie') {
        IncInterval = window.setInterval(SetIdleTime, 1000);
        var interval = (PMA_commonParams.get('LoginCookieValidity') - 5) * 1000;
        if (interval > Math.pow(2, 31) - 1) { // max value for setInterval() function
            interval = Math.pow(2, 31) - 1;
        }
        updateTimeout = window.setTimeout(UpdateIdleTime, interval);
    }
});
/**
 * Unbind all event handlers before tearing down a page
 */
AJAX.registerTeardown('functions.js', function () {
    $(document).off('click', 'input:checkbox.checkall');
});
AJAX.registerOnload('functions.js', function () {
    /**
     * Row marking in horizontal mode (use ""on"" so that it works also for
     * next pages reached via AJAX); a tr may have the class noclick to remove
     * this behavior.
     */

    $(document).on('click', 'input:checkbox.checkall', function (e) {
        $this = $(this);
        var $tr = $this.closest('tr');
        var $table = $this.closest('table');

        if (!e.shiftKey || last_clicked_row == -1) {
            // usual click

            var $checkbox = $tr.find(':checkbox.checkall');
            var checked = $this.prop('checked');
            $checkbox.prop('checked', checked).trigger('change');
            if (checked) {
                $tr.addClass('marked');
            } else {
                $tr.removeClass('marked');
            }
            last_click_checked = checked;

            // remember the last clicked row
            last_clicked_row = last_click_checked ? $table.find('tr.odd:not(.noclick), tr.even:not(.noclick)').index($tr) : -1;
            last_shift_clicked_row = -1;
        } else {
            // handle the shift click
            PMA_clearSelection();
            var start, end;

            // clear last shift click result
            if (last_shift_clicked_row >= 0) {
                if (last_shift_clicked_row >= last_clicked_row) {
                    start = last_clicked_row;
                    end = last_shift_clicked_row;
                } else {
                    start = last_shift_clicked_row;
                    end = last_clicked_row;
                }
                $tr.parent().find('tr.odd:not(.noclick), tr.even:not(.noclick)')
                    .slice(start, end + 1)
                    .removeClass('marked')
                    .find(':checkbox')
                    .prop('checked', false)
                    .trigger('change');
            }

            // handle new shift click
            var curr_row = $table.find('tr.odd:not(.noclick), tr.even:not(.noclick)').index($tr);
            if (curr_row >= last_clicked_row) {
                start = last_clicked_row;
                end = curr_row;
            } else {
                start = curr_row;
                end = last_clicked_row;
            }
            $tr.parent().find('tr.odd:not(.noclick), tr.even:not(.noclick)')
                .slice(start, end + 1)
                .addClass('marked')
                .find(':checkbox')
                .prop('checked', true)
                .trigger('change');

            // remember the last shift clicked row
            last_shift_clicked_row = curr_row;
        }
    });

    addDateTimePicker();

    /**
     * Add attribute to text boxes for iOS devices (based on bugID: 3508912)
     */
    if (navigator.userAgent.match(/(iphone|ipod|ipad)/i)) {
        $('input[type=text]').attr('autocapitalize', 'off').attr('autocorrect', 'off');
    }
});

/**
 * Row highlighting in horizontal mode (use ""on""
 * so that it works also for pages reached via AJAX)
 */
/*AJAX.registerOnload('functions.js', function () {
    $(document).on('hover', 'tr.odd, tr.even',function (event) {
        var $tr = $(this);
        $tr.toggleClass('hover',event.type=='mouseover');
        $tr.children().toggleClass('hover',event.type=='mouseover');
    });
})*/

/**
 * This array is used to remember mark status of rows in browse mode
 */
var marked_row = [];

/**
 * marks all rows and selects its first checkbox inside the given element
 * the given element is usually a table or a div containing the table or tables
 *
 * @param container    DOM element
 */
function markAllRows(container_id)
{

    $(""#"" + container_id).find(""input:checkbox:enabled"").prop('checked', true)
    .trigger(""change"")
    .parents(""tr"").addClass(""marked"");
    return true;
}

/**
 * marks all rows and selects its first checkbox inside the given element
 * the given element is usually a table or a div containing the table or tables
 *
 * @param container    DOM element
 */
function unMarkAllRows(container_id)
{

    $(""#"" + container_id).find(""input:checkbox:enabled"").prop('checked', false)
    .trigger(""change"")
    .parents(""tr"").removeClass(""marked"");
    return true;
}

/**
 * Checks/unchecks all checkbox in given container (f.e. a form, fieldset or div)
 *
 * @param string   container_id  the container id
 * @param boolean  state         new value for checkbox (true or false)
 * @return boolean  always true
 */
function setCheckboxes(container_id, state)
{

    $(""#"" + container_id).find(""input:checkbox"").prop('checked', state);
    return true;
} // end of the 'setCheckboxes()' function

/**
  * Checks/unchecks all options of a <select> element
  *
  * @param string   the form name
  * @param string   the element name
  * @param boolean  whether to check or to uncheck options
  *
  * @return boolean  always true
  */
function setSelectOptions(the_form, the_select, do_check)
{
    $(""form[name='"" + the_form + ""'] select[name='"" + the_select + ""']"").find(""option"").prop('selected', do_check);
    return true;
} // end of the 'setSelectOptions()' function

/**
 * Sets current value for query box.
 */
function setQuery(query)
{
    if (codemirror_editor) {
        codemirror_editor.setValue(query);
        codemirror_editor.focus();
    } else {
        document.sqlform.sql_query.value = query;
        document.sqlform.sql_query.focus();
    }
}

/**
 * Handles 'Simulate query' button on SQL query box.
 *
 * @return void
 */
function PMA_handleSimulateQueryButton()
{
    var update_re = new RegExp('^\\s*UPDATE\\s+((`[^`]+`)|([A-Za-z0-9_$]+))\\s+SET\\s', 'i');
    var delete_re = new RegExp('^\\s*DELETE\\s+FROM\\s', 'i');
    var query = '';

    if (codemirror_editor) {
        query = codemirror_editor.getValue();
    } else {
        query = $('#sqlquery').val();
    }

    var $simulateDml = $('#simulate_dml');
    if (update_re.test(query) || delete_re.test(query)) {
        if (! $simulateDml.length) {
            $('#button_submit_query')
            .before('<input type=""button"" id=""simulate_dml""' +
                'tabindex=""199"" value=""' +
                PMA_messages.strSimulateDML +
                '"" />');
        }
    } else {
        if ($simulateDml.length) {
            $simulateDml.remove();
        }
    }
}

/**
  * Create quick sql statements.
  *
  */
function insertQuery(queryType)
{
    if (queryType == ""clear"") {
        setQuery('');
        return;
    } else if (queryType == ""format"") {
        if (codemirror_editor) {
            $('#querymessage').html(PMA_messages.strFormatting +
                '&nbsp;<img class=""ajaxIcon"" src=""' +
                pmaThemeImage + 'ajax_clock_small.gif"" alt="""">');
            var href = 'db_sql_format.php';
            var params = {
                'ajax_request': true,
                'token': PMA_commonParams.get('token'),
                'sql': codemirror_editor.getValue()
            };
            $.ajax({
                type: 'POST',
                url: href,
                data: params,
                success: function (data) {
                    if (data.success) {
                        codemirror_editor.setValue(data.sql);
                    }
                    $('#querymessage').html('');
                }
            });
        }
        return;
    } else if (queryType == ""saved"") {
        if ($.cookie('auto_saved_sql')) {
            setQuery($.cookie('auto_saved_sql'));
        } else {
            PMA_ajaxShowMessage(PMA_messages.strNoAutoSavedQuery);
        }
        return;
    }

    var query = """";
    var myListBox = document.sqlform.dummy;
    var table = document.sqlform.table.value;

    if (myListBox.options.length > 0) {
        sql_box_locked = true;
        var columnsList = """";
        var valDis = """";
        var editDis = """";
        var NbSelect = 0;
        for (var i = 0; i < myListBox.options.length; i++) {
            NbSelect++;
            if (NbSelect > 1) {
                columnsList += "", "";
                valDis += "","";
                editDis += "","";
            }
            columnsList += myListBox.options[i].value;
            valDis += ""[value-"" + NbSelect + ""]"";
            editDis += myListBox.options[i].value + ""=[value-"" + NbSelect + ""]"";
        }
        if (queryType == ""selectall"") {
            query = ""SELECT * FROM `"" + table + ""` WHERE 1"";
        } else if (queryType == ""select"") {
            query = ""SELECT "" + columnsList + "" FROM `"" + table + ""` WHERE 1"";
        } else if (queryType == ""insert"") {
            query = ""INSERT INTO `"" + table + ""`("" + columnsList + "") VALUES ("" + valDis + "")"";
        } else if (queryType == ""update"") {
            query = ""UPDATE `"" + table + ""` SET "" + editDis + "" WHERE 1"";
        } else if (queryType == ""delete"") {
            query = ""DELETE FROM `"" + table + ""` WHERE 1"";
        }
        setQuery(query);
        sql_box_locked = false;
    }
}


/**
  * Inserts multiple fields.
  *
  */
function insertValueQuery()
{
    var myQuery = document.sqlform.sql_query;
    var myListBox = document.sqlform.dummy;

    if (myListBox.options.length > 0) {
        sql_box_locked = true;
        var columnsList = """";
        var NbSelect = 0;
        for (var i = 0; i < myListBox.options.length; i++) {
            if (myListBox.options[i].selected) {
                NbSelect++;
                if (NbSelect > 1) {
                    columnsList += "", "";
                }
                columnsList += myListBox.options[i].value;
            }
        }

        /* CodeMirror support */
        if (codemirror_editor) {
            codemirror_editor.replaceSelection(columnsList);
        //IE support
        } else if (document.selection) {
            myQuery.focus();
            var sel = document.selection.createRange();
            sel.text = columnsList;
            document.sqlform.insert.focus();
        }
        //MOZILLA/NETSCAPE support
        else if (document.sqlform.sql_query.selectionStart || document.sqlform.sql_query.selectionStart == ""0"") {
            var startPos = document.sqlform.sql_query.selectionStart;
            var endPos = document.sqlform.sql_query.selectionEnd;
            var SqlString = document.sqlform.sql_query.value;

            myQuery.value = SqlString.substring(0, startPos) + columnsList + SqlString.substring(endPos, SqlString.length);
        } else {
            myQuery.value += columnsList;
        }
        sql_box_locked = false;
    }
}

/**
 * Updates the input fields for the parameters based on the query
 */
function updateQueryParameters() {

    if ($('#parameterized').is(':checked')) {
        var query = codemirror_editor ? codemirror_editor.getValue() : $('#sqlquery').val();

        var allParameters = query.match(/:[a-zA-Z0-9_]+/g);
         var parameters = [];
         // get unique parameters
         if (allParameters) {
             $.each(allParameters, function(i, parameter){
                 if ($.inArray(parameter, parameters) === -1) {
                     parameters.push(parameter);
                 }
             });
         }

         var $temp = $('<div />');
         $temp.append($('#parametersDiv').children());
         $('#parametersDiv').empty();

         $.each(parameters, function (i, parameter) {
             var paramName = parameter.substring(1);
             var $param = $temp.find('#paramSpan_' + paramName );
             if (! $param.length) {
                 $param = $('<span class=""parameter"" id=""paramSpan_' + paramName + '"" />');
                 $('<label for=""param_' + paramName + '"" />').text(parameter).appendTo($param);
                 $('<input type=""text"" name=""parameters[' + parameter + ']"" id=""param_' + paramName + '"" />').appendTo($param);
             }
             $('#parametersDiv').append($param);
         });
    } else {
        $('#parametersDiv').empty();
    }
}

/**
 * Add a date/time picker to each element that needs it
 * (only when jquery-ui-timepicker-addon.js is loaded)
 */
function addDateTimePicker() {
    if ($.timepicker !== undefined) {
        $('input.timefield, input.datefield, input.datetimefield').each(function () {

            var decimals = $(this).parent().attr('data-decimals');
            var type = $(this).parent().attr('data-type');

            var showMillisec = false;
            var showMicrosec = false;
            var timeFormat = 'HH:mm:ss';
            // check for decimal places of seconds
            if (decimals > 0 && type.indexOf('time') != -1){
                if (decimals > 3) {
                    showMillisec = true;
                    showMicrosec = true;
                    timeFormat = 'HH:mm:ss.lc';
                } else {
                    showMillisec = true;
                    timeFormat = 'HH:mm:ss.l';
                }
            }
            PMA_addDatepicker($(this), type, {
                showMillisec: showMillisec,
                showMicrosec: showMicrosec,
                timeFormat: timeFormat
            });
        });
    }
}

/**
  * Refresh/resize the WYSIWYG scratchboard
  */
function refreshLayout()
{
    var $elm = $('#pdflayout');
    var orientation = $('#orientation_opt').val();
    var paper = 'A4';
    var $paperOpt = $('#paper_opt');
    if ($paperOpt.length == 1) {
        paper = $paperOpt.val();
    }
    var posa = 'y';
    var posb = 'x';
    if (orientation == 'P') {
        posa = 'x';
        posb = 'y';
    }
    $elm.css('width', pdfPaperSize(paper, posa) + 'px');
    $elm.css('height', pdfPaperSize(paper, posb) + 'px');
}

/**
 * Initializes positions of elements.
 */
function TableDragInit() {
    $('.pdflayout_table').each(function () {
        var $this = $(this);
        var number = $this.data('number');
        var x = $('#c_table_' + number + '_x').val();
        var y = $('#c_table_' + number + '_y').val();
        $this.css('left', x + 'px');
        $this.css('top', y + 'px');
        /* Make elements draggable */
        $this.draggable({
            containment: ""parent"",
            drag: function (evt, ui) {
                var number = $this.data('number');
                $('#c_table_' + number + '_x').val(parseInt(ui.position.left, 10));
                $('#c_table_' + number + '_y').val(parseInt(ui.position.top, 10));
            }
        });
    });
}

/**
 * Resets drag and drop positions.
 */
function resetDrag() {
    $('.pdflayout_table').each(function () {
        var $this = $(this);
        var x = $this.data('x');
        var y = $this.data('y');
        $this.css('left', x + 'px');
        $this.css('top', y + 'px');
    });
}

/**
 * User schema handlers.
 */
$(function () {
    /* Move in scratchboard on manual change */
    $(document).on('change', '.position-change', function () {
        var $this = $(this);
        var $elm = $('#table_' + $this.data('number'));
        $elm.css($this.data('axis'), $this.val() + 'px');
    });
    /* Refresh on paper size/orientation change */
    $(document).on('change', '.paper-change', function () {
        var $elm = $('#pdflayout');
        if ($elm.css('visibility') == 'visible') {
            refreshLayout();
            TableDragInit();
        }
    });
    /* Show/hide the WYSIWYG scratchboard */
    $(document).on('click', '#toggle-dragdrop', function () {
        var $elm = $('#pdflayout');
        if ($elm.css('visibility') == 'hidden') {
            refreshLayout();
            TableDragInit();
            $elm.css('visibility', 'visible');
            $elm.css('display', 'block');
            $('#showwysiwyg').val('1');
        } else {
            $elm.css('visibility', 'hidden');
            $elm.css('display', 'none');
            $('#showwysiwyg').val('0');
        }
    });
    /* Reset scratchboard */
    $(document).on('click', '#reset-dragdrop', function () {
        resetDrag();
    });
});

/**
 * Returns paper sizes for a given format
 */
function pdfPaperSize(format, axis)
{
    switch (format.toUpperCase()) {
    case '4A0':
        if (axis == 'x') {
            return 4767.87;
        } else {
            return 6740.79;
        }
        break;
    case '2A0':
        if (axis == 'x') {
            return 3370.39;
        } else {
            return 4767.87;
        }
        break;
    case 'A0':
        if (axis == 'x') {
            return 2383.94;
        } else {
            return 3370.39;
        }
        break;
    case 'A1':
        if (axis == 'x') {
            return 1683.78;
        } else {
            return 2383.94;
        }
        break;
    case 'A2':
        if (axis == 'x') {
            return 1190.55;
        } else {
            return 1683.78;
        }
        break;
    case 'A3':
        if (axis == 'x') {
            return 841.89;
        } else {
            return 1190.55;
        }
        break;
    case 'A4':
        if (axis == 'x') {
            return 595.28;
        } else {
            return 841.89;
        }
        break;
    case 'A5':
        if (axis == 'x') {
            return 419.53;
        } else {
            return 595.28;
        }
        break;
    case 'A6':
        if (axis == 'x') {
            return 297.64;
        } else {
            return 419.53;
        }
        break;
    case 'A7':
        if (axis == 'x') {
            return 209.76;
        } else {
            return 297.64;
        }
        break;
    case 'A8':
        if (axis == 'x') {
            return 147.40;
        } else {
            return 209.76;
        }
        break;
    case 'A9':
        if (axis == 'x') {
            return 104.88;
        } else {
            return 147.40;
        }
        break;
    case 'A10':
        if (axis == 'x') {
            return 73.70;
        } else {
            return 104.88;
        }
        break;
    case 'B0':
        if (axis == 'x') {
            return 2834.65;
        } else {
            return 4008.19;
        }
        break;
    case 'B1':
        if (axis == 'x') {
            return 2004.09;
        } else {
            return 2834.65;
        }
        break;
    case 'B2':
        if (axis == 'x') {
            return 1417.32;
        } else {
            return 2004.09;
        }
        break;
    case 'B3':
        if (axis == 'x') {
            return 1000.63;
        } else {
            return 1417.32;
        }
        break;
    case 'B4':
        if (axis == 'x') {
            return 708.66;
        } else {
            return 1000.63;
        }
        break;
    case 'B5':
        if (axis == 'x') {
            return 498.90;
        } else {
            return 708.66;
        }
        break;
    case 'B6':
        if (axis == 'x') {
            return 354.33;
        } else {
            return 498.90;
        }
        break;
    case 'B7':
        if (axis == 'x') {
            return 249.45;
        } else {
            return 354.33;
        }
        break;
    case 'B8':
        if (axis == 'x') {
            return 175.75;
        } else {
            return 249.45;
        }
        break;
    case 'B9':
        if (axis == 'x') {
            return 124.72;
        } else {
            return 175.75;
        }
        break;
    case 'B10':
        if (axis == 'x') {
            return 87.87;
        } else {
            return 124.72;
        }
        break;
    case 'C0':
        if (axis == 'x') {
            return 2599.37;
        } else {
            return 3676.54;
        }
        break;
    case 'C1':
        if (axis == 'x') {
            return 1836.85;
        } else {
            return 2599.37;
        }
        break;
    case 'C2':
        if (axis == 'x') {
            return 1298.27;
        } else {
            return 1836.85;
        }
        break;
    case 'C3':
        if (axis == 'x') {
            return 918.43;
        } else {
            return 1298.27;
        }
        break;
    case 'C4':
        if (axis == 'x') {
            return 649.13;
        } else {
            return 918.43;
        }
        break;
    case 'C5':
        if (axis == 'x') {
            return 459.21;
        } else {
            return 649.13;
        }
        break;
    case 'C6':
        if (axis == 'x') {
            return 323.15;
        } else {
            return 459.21;
        }
        break;
    case 'C7':
        if (axis == 'x') {
            return 229.61;
        } else {
            return 323.15;
        }
        break;
    case 'C8':
        if (axis == 'x') {
            return 161.57;
        } else {
            return 229.61;
        }
        break;
    case 'C9':
        if (axis == 'x') {
            return 113.39;
        } else {
            return 161.57;
        }
        break;
    case 'C10':
        if (axis == 'x') {
            return 79.37;
        } else {
            return 113.39;
        }
        break;
    case 'RA0':
        if (axis == 'x') {
            return 2437.80;
        } else {
            return 3458.27;
        }
        break;
    case 'RA1':
        if (axis == 'x') {
            return 1729.13;
        } else {
            return 2437.80;
        }
        break;
    case 'RA2':
        if (axis == 'x') {
            return 1218.90;
        } else {
            return 1729.13;
        }
        break;
    case 'RA3':
        if (axis == 'x') {
            return 864.57;
        } else {
            return 1218.90;
        }
        break;
    case 'RA4':
        if (axis == 'x') {
            return 609.45;
        } else {
            return 864.57;
        }
        break;
    case 'SRA0':
        if (axis == 'x') {
            return 2551.18;
        } else {
            return 3628.35;
        }
        break;
    case 'SRA1':
        if (axis == 'x') {
            return 1814.17;
        } else {
            return 2551.18;
        }
        break;
    case 'SRA2':
        if (axis == 'x') {
            return 1275.59;
        } else {
            return 1814.17;
        }
        break;
    case 'SRA3':
        if (axis == 'x') {
            return 907.09;
        } else {
            return 1275.59;
        }
        break;
    case 'SRA4':
        if (axis == 'x') {
            return 637.80;
        } else {
            return 907.09;
        }
        break;
    case 'LETTER':
        if (axis == 'x') {
            return 612.00;
        } else {
            return 792.00;
        }
        break;
    case 'LEGAL':
        if (axis == 'x') {
            return 612.00;
        } else {
            return 1008.00;
        }
        break;
    case 'EXECUTIVE':
        if (axis == 'x') {
            return 521.86;
        } else {
            return 756.00;
        }
        break;
    case 'FOLIO':
        if (axis == 'x') {
            return 612.00;
        } else {
            return 936.00;
        }
        break;
    } // end switch

    return 0;
}

/**
 * Get checkbox for foreign key checks
 *
 * @return string
 */
function getForeignKeyCheckboxLoader() {
    var html = '';
    html    += '<div>';
    html    += '<div class=""load-default-fk-check-value"">';
    html    += PMA_getImage('ajax_clock_small.gif');
    html    += '</div>';
    html    += '</div>';
    return html;
}

function loadForeignKeyCheckbox() {
    // Load default foreign key check value
    var params = {
        'ajax_request': true,
        'token': PMA_commonParams.get('token'),
        'server': PMA_commonParams.get('server'),
        'get_default_fk_check_value': true
    };
    $.get('sql.php', params, function (data) {
        var html = '<input type=""hidden"" name=""fk_checks"" value=""0"" />' +
            '<input type=""checkbox"" name=""fk_checks"" id=""fk_checks""' +
            (data.default_fk_check_value ? ' checked=""checked""' : '') + ' />' +
            '<label for=""fk_checks"">' + PMA_messages.strForeignKeyCheck + '</label>';
        $('.load-default-fk-check-value').replaceWith(html);
    });
}

function getJSConfirmCommonParam(elem) {
    return {
        'is_js_confirmed' : 1,
        'ajax_request' : true,
        'fk_checks': $(elem).find('#fk_checks').is(':checked') ? 1 : 0
    };
}

/**
 * Unbind all event handlers before tearing down a page
 */
AJAX.registerTeardown('functions.js', function () {
    $(document).off('click', ""a.inline_edit_sql"");
    $(document).off('click', ""input#sql_query_edit_save"");
    $(document).off('click', ""input#sql_query_edit_discard"");
    $('input.sqlbutton').unbind('click');
    if (codemirror_editor) {
        codemirror_editor.off('blur');
    } else {
        $(document).off('blur', '#sqlquery');
    }
    $(document).off('change', '#parameterized');
    $('#sqlquery').unbind('keydown');
    $('#sql_query_edit').unbind('keydown');

    if (codemirror_inline_editor) {
        // Copy the sql query to the text area to preserve it.
        $('#sql_query_edit').text(codemirror_inline_editor.getValue());
        $(codemirror_inline_editor.getWrapperElement()).unbind('keydown');
        codemirror_inline_editor.toTextArea();
        codemirror_inline_editor = false;
    }
    if (codemirror_editor) {
        $(codemirror_editor.getWrapperElement()).unbind('keydown');
    }
});

/**
 * Jquery Coding for inline editing SQL_QUERY
 */
AJAX.registerOnload('functions.js', function () {
    // If we are coming back to the page by clicking forward button
    // of the browser, bind the code mirror to inline query editor.
    bindCodeMirrorToInlineEditor();
    $(document).on('click', ""a.inline_edit_sql"", function () {
        if ($('#sql_query_edit').length) {
            // An inline query editor is already open,
            // we don't want another copy of it
            return false;
        }

        var $form = $(this).prev('form');
        var sql_query  = $form.find(""input[name='sql_query']"").val().trim();
        var $inner_sql = $(this).parent().prev().find('code.sql');
        var old_text   = $inner_sql.html();

        var new_content = ""<textarea name=\""sql_query_edit\"" id=\""sql_query_edit\"">"" + sql_query + ""</textarea>\n"";
        new_content    += getForeignKeyCheckboxLoader();
        new_content    += ""<input type=\""submit\"" id=\""sql_query_edit_save\"" class=\""button btnSave\"" value=\"""" + PMA_messages.strGo + ""\""/>\n"";
        new_content    += ""<input type=\""button\"" id=\""sql_query_edit_discard\"" class=\""button btnDiscard\"" value=\"""" + PMA_messages.strCancel + ""\""/>\n"";
        var $editor_area = $('div#inline_editor');
        if ($editor_area.length === 0) {
            $editor_area = $('<div id=""inline_editor_outer""></div>');
            $editor_area.insertBefore($inner_sql);
        }
        $editor_area.html(new_content);
        loadForeignKeyCheckbox();
        $inner_sql.hide();

        bindCodeMirrorToInlineEditor();
        return false;
    });

    $(document).on('click', ""input#sql_query_edit_save"", function () {
        $("".success"").hide();
        //hide already existing success message
        var sql_query;
        if (codemirror_inline_editor) {
            codemirror_inline_editor.save();
            sql_query = codemirror_inline_editor.getValue();
        } else {
            sql_query = $(this).parent().find('#sql_query_edit').val();
        }
        var fk_check = $(this).parent().find('#fk_checks').is(':checked');

        var $form = $(""a.inline_edit_sql"").prev('form');
        var $fake_form = $('<form>', {action: 'import.php', method: 'post'})
                .append($form.find(""input[name=server], input[name=db], input[name=table], input[name=token]"").clone())
                .append($('<input/>', {type: 'hidden', name: 'show_query', value: 1}))
                .append($('<input/>', {type: 'hidden', name: 'is_js_confirmed', value: 0}))
                .append($('<input/>', {type: 'hidden', name: 'sql_query', value: sql_query}))
                .append($('<input/>', {type: 'hidden', name: 'fk_checks', value: fk_check ? 1 : 0}));
        if (! checkSqlQuery($fake_form[0])) {
            return false;
        }
        $fake_form.appendTo($('body')).submit();
    });

    $(document).on('click', ""input#sql_query_edit_discard"", function () {
        var $divEditor = $('div#inline_editor_outer');
        $divEditor.siblings('code.sql').show();
        $divEditor.remove();
    });

    $('input.sqlbutton').click(function (evt) {
        insertQuery(evt.target.id);
        PMA_handleSimulateQueryButton();
        return false;
    });

    $(document).on('change', '#parameterized', updateQueryParameters);

    var $inputUsername = $('#input_username');
    if ($inputUsername) {
        if ($inputUsername.val() === '') {
            $inputUsername.focus();
        } else {
            $('#input_password').focus();
        }
    }
});

/**
 * ""inputRead"" event handler for CodeMirror SQL query editors for autocompletion
 */
function codemirrorAutocompleteOnInputRead(instance) {
    if (!sql_autocomplete_in_progress
        && (!instance.options.hintOptions.tables || !sql_autocomplete)) {

        if (!sql_autocomplete) {
            // Reset after teardown
            instance.options.hintOptions.tables = false;
            instance.options.hintOptions.defaultTable = '';

            sql_autocomplete_in_progress = true;

            var href = 'db_sql_autocomplete.php';
            var params = {
                'ajax_request': true,
                'token': PMA_commonParams.get('token'),
                'server': PMA_commonParams.get('server'),
                'db': PMA_commonParams.get('db'),
                'no_debug': true
            };

            var columnHintRender = function(elem, self, data) {
                $('<div class=""autocomplete-column-name"">')
                    .text(data.columnName)
                    .appendTo(elem);
                $('<div class=""autocomplete-column-hint"">')
                    .text(data.columnHint)
                    .appendTo(elem);
            };

            $.ajax({
                type: 'POST',
                url: href,
                data: params,
                success: function (data) {
                    if (data.success) {
                        var tables = $.parseJSON(data.tables);
                        sql_autocomplete_default_table = PMA_commonParams.get('table');
                        sql_autocomplete = [];
                        for (var table in tables) {
                            if (tables.hasOwnProperty(table)) {
                                var columns = tables[table];
                                table = {
                                    text: table,
                                    columns: []
                                };
                                for (var column in columns) {
                                    if (columns.hasOwnProperty(column)) {
                                        var displayText = columns[column].Type;
                                        if (columns[column].Key == 'PRI') {
                                            displayText += ' | Primary';
                                        } else if (columns[column].Key == 'UNI') {
                                            displayText += ' | Unique';
                                        }
                                        table.columns.push({
                                            text: column,
                                            displayText: column + "" | "" +  displayText,
                                            columnName: column,
                                            columnHint: displayText,
                                            render: columnHintRender
                                        });
                                    }
                                }
                            }
                            sql_autocomplete.push(table);
                        }
                        instance.options.hintOptions.tables = sql_autocomplete;
                        instance.options.hintOptions.defaultTable = sql_autocomplete_default_table;
                    }
                },
                complete: function () {
                    sql_autocomplete_in_progress = false;
                }
            });
        }
        else {
            instance.options.hintOptions.tables = sql_autocomplete;
            instance.options.hintOptions.defaultTable = sql_autocomplete_default_table;
        }
    }
    if (instance.state.completionActive) {
        return;
    }
    var cur = instance.getCursor();
    var token = instance.getTokenAt(cur);
    var string = '';
    if (token.string.match(/^[.`\w@]\w*$/)) {
        string = token.string;
    }
    if (string.length > 0) {
        CodeMirror.commands.autocomplete(instance);
    }
}

/**
 * Remove autocomplete information before tearing down a page
 */
AJAX.registerTeardown('functions.js', function () {
    sql_autocomplete = false;
    sql_autocomplete_default_table = '';
});

/**
 * Binds the CodeMirror to the text area used to inline edit a query.
 */
function bindCodeMirrorToInlineEditor() {
    var $inline_editor = $('#sql_query_edit');
    if ($inline_editor.length > 0) {
        if (typeof CodeMirror !== 'undefined') {
            var height = $inline_editor.css('height');
            codemirror_inline_editor = PMA_getSQLEditor($inline_editor);
            codemirror_inline_editor.getWrapperElement().style.height = height;
            codemirror_inline_editor.refresh();
            codemirror_inline_editor.focus();
            $(codemirror_inline_editor.getWrapperElement())
                .bind('keydown', catchKeypressesFromSqlInlineEdit);
        } else {
            $inline_editor
                .focus()
                .bind('keydown', catchKeypressesFromSqlInlineEdit);
        }
    }
}

function catchKeypressesFromSqlInlineEdit(event) {
    // ctrl-enter is 10 in chrome and ie, but 13 in ff
    if (event.ctrlKey && (event.keyCode == 13 || event.keyCode == 10)) {
        $(""#sql_query_edit_save"").trigger('click');
    }
}

/**
 * Adds doc link to single highlighted SQL element
 */
function PMA_doc_add($elm, params)
{
    if (typeof mysql_doc_template == 'undefined') {
        return;
    }

    var url = PMA_sprintf(
        decodeURIComponent(mysql_doc_template),
        params[0]
    );
    if (params.length > 1) {
        url += '#' + params[1];
    }
    var content = $elm.text();
    $elm.text('');
    $elm.append('<a target=""mysql_doc"" class=""cm-sql-doc"" href=""' + url + '"">' + content + '</a>');
}

/**
 * Generates doc links for keywords inside highlighted SQL
 */
function PMA_doc_keyword(idx, elm)
{
    var $elm = $(elm);
    /* Skip already processed ones */
    if ($elm.find('a').length > 0) {
        return;
    }
    var keyword = $elm.text().toUpperCase();
    var $next = $elm.next('.cm-keyword');
    if ($next) {
        var next_keyword = $next.text().toUpperCase();
        var full = keyword + ' ' + next_keyword;

        var $next2 = $next.next('.cm-keyword');
        if ($next2) {
            var next2_keyword = $next2.text().toUpperCase();
            var full2 = full + ' ' + next2_keyword;
            if (full2 in mysql_doc_keyword) {
                PMA_doc_add($elm, mysql_doc_keyword[full2]);
                PMA_doc_add($next, mysql_doc_keyword[full2]);
                PMA_doc_add($next2, mysql_doc_keyword[full2]);
                return;
            }
        }
        if (full in mysql_doc_keyword) {
            PMA_doc_add($elm, mysql_doc_keyword[full]);
            PMA_doc_add($next, mysql_doc_keyword[full]);
            return;
        }
    }
    if (keyword in mysql_doc_keyword) {
        PMA_doc_add($elm, mysql_doc_keyword[keyword]);
    }
}

/**
 * Generates doc links for builtins inside highlighted SQL
 */
function PMA_doc_builtin(idx, elm)
{
    var $elm = $(elm);
    var builtin = $elm.text().toUpperCase();
    if (builtin in mysql_doc_builtin) {
        PMA_doc_add($elm, mysql_doc_builtin[builtin]);
    }
}

/**
 * Higlights SQL using CodeMirror.
 */
function PMA_highlightSQL($base)
{
    var $elm = $base.find('code.sql');
    $elm.each(function () {
        var $sql = $(this);
        var $pre = $sql.find('pre');
        /* We only care about visible elements to avoid double processing */
        if ($pre.is("":visible"")) {
            var $highlight = $('<div class=""sql-highlight cm-s-default""></div>');
            $sql.append($highlight);
            if (typeof CodeMirror != 'undefined') {
                CodeMirror.runMode($sql.text(), 'text/x-mysql', $highlight[0]);
                $pre.hide();
                $highlight.find('.cm-keyword').each(PMA_doc_keyword);
                $highlight.find('.cm-builtin').each(PMA_doc_builtin);
            }
        }
    });
}

/**
 * Updates an element containing code.
 *
 * @param jQuery Object $base base element which contains the raw and the
 *                            highlighted code.
 *
 * @param string htmlValue    code in HTML format, displayed if code cannot be
 *                            highlighted
 *
 * @param string rawValue     raw code, used as a parameter for highlighter
 *
 * @return bool               whether content was updated or not
 */
function PMA_updateCode($base, htmlValue, rawValue)
{
    var $code = $base.find('code');
    if ($code.length == 0) {
        return false;
    }

    // Determines the type of the content and appropriate CodeMirror mode.
    var type = '', mode = '';
    if  ($code.hasClass('json')) {
        type = 'json';
        mode = 'application/json';
    } else if ($code.hasClass('sql')) {
        type = 'sql';
        mode = 'text/x-mysql';
    } else if ($code.hasClass('xml')) {
        type = 'xml';
        mode = 'application/xml';
    } else {
        return false;
    }

    // Element used to display unhighlighted code.
    var $notHighlighted = $('<pre>' + htmlValue + '</pre>');

    // Tries to highlight code using CodeMirror.
    if (typeof CodeMirror != 'undefined') {
        var $highlighted = $('<div class=""' + type + '-highlight cm-s-default""></div>');
        CodeMirror.runMode(rawValue, mode, $highlighted[0]);
        $notHighlighted.hide();
        $code.html('').append($notHighlighted, $highlighted[0]);
    } else {
        $code.html('').append($notHighlighted);
    }

    return true;
}

/**
 * Show a message on the top of the page for an Ajax request
 *
 * Sample usage:
 *
 * 1) var $msg = PMA_ajaxShowMessage();
 * This will show a message that reads ""Loading..."". Such a message will not
 * disappear automatically and cannot be dismissed by the user. To remove this
 * message either the PMA_ajaxRemoveMessage($msg) function must be called or
 * another message must be show with PMA_ajaxShowMessage() function.
 *
 * 2) var $msg = PMA_ajaxShowMessage(PMA_messages.strProcessingRequest);
 * This is a special case. The behaviour is same as above,
 * just with a different message
 *
 * 3) var $msg = PMA_ajaxShowMessage('The operation was successful');
 * This will show a message that will disappear automatically and it can also
 * be dismissed by the user.
 *
 * 4) var $msg = PMA_ajaxShowMessage('Some error', false);
 * This will show a message that will not disappear automatically, but it
 * can be dismissed by the user after he has finished reading it.
 *
 * @param string  message     string containing the message to be shown.
 *                              optional, defaults to 'Loading...'
 * @param mixed   timeout     number of milliseconds for the message to be visible
 *                              optional, defaults to 5000. If set to 'false', the
 *                              notification will never disappear
 * @return jQuery object       jQuery Element that holds the message div
 *                              this object can be passed to PMA_ajaxRemoveMessage()
 *                              to remove the notification
 */
function PMA_ajaxShowMessage(message, timeout)
{
    /**
     * @var self_closing Whether the notification will automatically disappear
     */
    var self_closing = true;
    /**
     * @var dismissable Whether the user will be able to remove
     *                  the notification by clicking on it
     */
    var dismissable = true;
    // Handle the case when a empty data.message is passed.
    // We don't want the empty message
    if (message === '') {
        return true;
    } else if (! message) {
        // If the message is undefined, show the default
        message = PMA_messages.strLoading;
        dismissable = false;
        self_closing = false;
    } else if (message == PMA_messages.strProcessingRequest) {
        // This is another case where the message should not disappear
        dismissable = false;
        self_closing = false;
    }
    // Figure out whether (or after how long) to remove the notification
    if (timeout === undefined) {
        timeout = 5000;
    } else if (timeout === false) {
        self_closing = false;
    }
    // Create a parent element for the AJAX messages, if necessary
    if ($('#loading_parent').length === 0) {
        $('<div id=""loading_parent""></div>')
        .prependTo(""#page_content"");
    }
    // Update message count to create distinct message elements every time
    ajax_message_count++;
    // Remove all old messages, if any
    $(""span.ajax_notification[id^=ajax_message_num]"").remove();
    /**
     * @var    $retval    a jQuery object containing the reference
     *                    to the created AJAX message
     */
    var $retval = $(
            '<span class=""ajax_notification"" id=""ajax_message_num_' +
            ajax_message_count +
            '""></span>'
    )
    .hide()
    .appendTo(""#loading_parent"")
    .html(message)
    .show();
    // If the notification is self-closing we should create a callback to remove it
    if (self_closing) {
        $retval
        .delay(timeout)
        .fadeOut('medium', function () {
            if ($(this).is(':data(tooltip)')) {
                $(this).tooltip('destroy');
            }
            // Remove the notification
            $(this).remove();
        });
    }
    // If the notification is dismissable we need to add the relevant class to it
    // and add a tooltip so that the users know that it can be removed
    if (dismissable) {
        $retval.addClass('dismissable').css('cursor', 'pointer');
        /**
         * Add a tooltip to the notification to let the user know that (s)he
         * can dismiss the ajax notification by clicking on it.
         */
        PMA_tooltip(
            $retval,
            'span',
            PMA_messages.strDismiss
        );
    }
    PMA_highlightSQL($retval);

    return $retval;
}

/**
 * Removes the message shown for an Ajax operation when it's completed
 *
 * @param jQuery object   jQuery Element that holds the notification
 *
 * @return nothing
 */
function PMA_ajaxRemoveMessage($this_msgbox)
{
    if ($this_msgbox !== undefined && $this_msgbox instanceof jQuery) {
        $this_msgbox
        .stop(true, true)
        .fadeOut('medium');
        if ($this_msgbox.is(':data(tooltip)')) {
            $this_msgbox.tooltip('destroy');
        } else {
            $this_msgbox.remove();
        }
    }
}

/**
 * Requests SQL for previewing before executing.
 *
 * @param jQuery Object $form Form containing query data
 *
 * @return void
 */
function PMA_previewSQL($form)
{
    var form_url = $form.attr('action');
    var form_data = $form.serialize() +
        '&do_save_data=1' +
        '&preview_sql=1' +
        '&ajax_request=1';
    var $msgbox = PMA_ajaxShowMessage();
    $.ajax({
        type: 'POST',
        url: form_url,
        data: form_data,
        success: function (response) {
            PMA_ajaxRemoveMessage($msgbox);
            if (response.success) {
                var $dialog_content = $('<div/>')
                    .append(response.sql_data);
                var button_options = {};
                button_options[PMA_messages.strClose] = function () {
                    $(this).dialog('close');
                };
                var $response_dialog = $dialog_content.dialog({
                    minWidth: 550,
                    maxHeight: 400,
                    modal: true,
                    buttons: button_options,
                    title: PMA_messages.strPreviewSQL,
                    close: function () {
                        $(this).remove();
                    },
                    open: function () {
                        // Pretty SQL printing.
                        PMA_highlightSQL($(this));
                    }
                });
            } else {
                PMA_ajaxShowMessage(response.message);
            }
        },
        error: function () {
            PMA_ajaxShowMessage(PMA_messages.strErrorProcessingRequest);
        }
    });
}

/**
 * check for reserved keyword column name
 *
 * @param jQuery Object $form Form
 *
 * @returns true|false
 */

function PMA_checkReservedWordColumns($form) {
    var is_confirmed = true;
    $.ajax({
        type: 'POST',
        url: ""tbl_structure.php"",
        data: $form.serialize() + '&reserved_word_check=1',
        success: function (data) {
            if (typeof data.success != 'undefined' && data.success === true) {
                is_confirmed = confirm(data.message);
            }
        },
        async:false
    });
    return is_confirmed;
}

// This event only need to be fired once after the initial page load
$(function () {
    /**
     * Allows the user to dismiss a notification
     * created with PMA_ajaxShowMessage()
     */
    $(document).on('click', 'span.ajax_notification.dismissable', function () {
        PMA_ajaxRemoveMessage($(this));
    });
    /**
     * The below two functions hide the ""Dismiss notification"" tooltip when a user
     * is hovering a link or button that is inside an ajax message
     */
    $(document).on('mouseover', 'span.ajax_notification a, span.ajax_notification button, span.ajax_notification input', function () {
        if ($(this).parents('span.ajax_notification').is(':data(tooltip)')) {
            $(this).parents('span.ajax_notification').tooltip('disable');
        }
    });
    $(document).on('mouseout', 'span.ajax_notification a, span.ajax_notification button, span.ajax_notification input', function () {
        if ($(this).parents('span.ajax_notification').is(':data(tooltip)')) {
            $(this).parents('span.ajax_notification').tooltip('enable');
        }
    });
});

/**
 * Hides/shows the ""Open in ENUM/SET editor"" message, depending on the data type of the column currently selected
 */
function PMA_showNoticeForEnum(selectElement)
{
    var enum_notice_id = selectElement.attr(""id"").split(""_"")[1];
    enum_notice_id += ""_"" + (parseInt(selectElement.attr(""id"").split(""_"")[2], 10) + 1);
    var selectedType = selectElement.val();
    if (selectedType == ""ENUM"" || selectedType == ""SET"") {
        $(""p#enum_notice_"" + enum_notice_id).show();
    } else {
        $(""p#enum_notice_"" + enum_notice_id).hide();
    }
}

/*
 * Creates a Profiling Chart with jqplot. Used in sql.js
 * and in server_status_monitor.js
 */
function PMA_createProfilingChartJqplot(target, data)
{
    return $.jqplot(target, [data],
        {
            seriesDefaults: {
                renderer: $.jqplot.PieRenderer,
                rendererOptions: {
                    showDataLabels:  true
                }
            },
            highlighter: {
                show: true,
                tooltipLocation: 'se',
                sizeAdjust: 0,
                tooltipAxes: 'pieref',
                useAxesFormatters: false,
                formatString: '%s, %.9Ps'
            },
            legend: {
                show: true,
                location: 'e',
                rendererOptions: {numberColumns: 2}
            },
            // from http://tango.freedesktop.org/Tango_Icon_Theme_Guidelines#Color_Palette
            seriesColors: [
                '#fce94f',
                '#fcaf3e',
                '#e9b96e',
                '#8ae234',
                '#729fcf',
                '#ad7fa8',
                '#ef2929',
                '#eeeeec',
                '#888a85',
                '#c4a000',
                '#ce5c00',
                '#8f5902',
                '#4e9a06',
                '#204a87',
                '#5c3566',
                '#a40000',
                '#babdb6',
                '#2e3436'
            ]
        }
    );
}

/**
 * Formats a profiling duration nicely (in us and ms time).
 * Used in server_status_monitor.js
 *
 * @param  integer    Number to be formatted, should be in the range of microsecond to second
 * @param  integer    Accuracy, how many numbers right to the comma should be
 * @return string     The formatted number
 */
function PMA_prettyProfilingNum(num, acc)
{
    if (!acc) {
        acc = 2;
    }
    acc = Math.pow(10, acc);
    if (num * 1000 < 0.1) {
        num = Math.round(acc * (num * 1000 * 1000)) / acc + 'µ';
    } else if (num < 0.1) {
        num = Math.round(acc * (num * 1000)) / acc + 'm';
    } else {
        num = Math.round(acc * num) / acc;
    }

    return num + 's';
}


/**
 * Formats a SQL Query nicely with newlines and indentation. Depends on Codemirror and MySQL Mode!
 *
 * @param string      Query to be formatted
 * @return string      The formatted query
 */
function PMA_SQLPrettyPrint(string)
{
    if (typeof CodeMirror == 'undefined') {
        return string;
    }

    var mode = CodeMirror.getMode({}, ""text/x-mysql"");
    var stream = new CodeMirror.StringStream(string);
    var state = mode.startState();
    var token, tokens = [];
    var output = '';
    var tabs = function (cnt) {
        var ret = '';
        for (var i = 0; i < 4 * cnt; i++) {
            ret += "" "";
        }
        return ret;
    };

    // ""root-level"" statements
    var statements = {
        'select': ['select', 'from', 'on', 'where', 'having', 'limit', 'order by', 'group by'],
        'update': ['update', 'set', 'where'],
        'insert into': ['insert into', 'values']
    };
    // don't put spaces before these tokens
    var spaceExceptionsBefore = {';': true, ',': true, '.': true, '(': true};
    // don't put spaces after these tokens
    var spaceExceptionsAfter = {'.': true};

    // Populate tokens array
    var str = '';
    while (! stream.eol()) {
        stream.start = stream.pos;
        token = mode.token(stream, state);
        if (token !== null) {
            tokens.push([token, stream.current().toLowerCase()]);
        }
    }

    var currentStatement = tokens[0][1];

    if (! statements[currentStatement]) {
        return string;
    }
    // Holds all currently opened code blocks (statement, function or generic)
    var blockStack = [];
    // Holds the type of block from last iteration (the current is in blockStack[0])
    var previousBlock;
    // If a new code block is found, newBlock contains its type for one iteration and vice versa for endBlock
    var newBlock, endBlock;
    // How much to indent in the current line
    var indentLevel = 0;
    // Holds the ""root-level"" statements
    var statementPart, lastStatementPart = statements[currentStatement][0];

    blockStack.unshift('statement');

    // Iterate through every token and format accordingly
    for (var i = 0; i < tokens.length; i++) {
        previousBlock = blockStack[0];

        // New block => push to stack
        if (tokens[i][1] == '(') {
            if (i < tokens.length - 1 && tokens[i + 1][0] == 'statement-verb') {
                blockStack.unshift(newBlock = 'statement');
            } else if (i > 0 && tokens[i - 1][0] == 'builtin') {
                blockStack.unshift(newBlock = 'function');
            } else {
                blockStack.unshift(newBlock = 'generic');
            }
        } else {
            newBlock = null;
        }

        // Block end => pop from stack
        if (tokens[i][1] == ')') {
            endBlock = blockStack[0];
            blockStack.shift();
        } else {
            endBlock = null;
        }

        // A subquery is starting
        if (i > 0 && newBlock == 'statement') {
            indentLevel++;
            output += ""\n"" + tabs(indentLevel) + tokens[i][1] + ' ' + tokens[i + 1][1].toUpperCase() + ""\n"" + tabs(indentLevel + 1);
            currentStatement = tokens[i + 1][1];
            i++;
            continue;
        }

        // A subquery is ending
        if (endBlock == 'statement' && indentLevel > 0) {
            output += ""\n"" + tabs(indentLevel);
            indentLevel--;
        }

        // One less indentation for statement parts (from, where, order by, etc.) and a newline
        statementPart = statements[currentStatement].indexOf(tokens[i][1]);
        if (statementPart != -1) {
            if (i > 0) {
                output += ""\n"";
            }
            output += tabs(indentLevel) + tokens[i][1].toUpperCase();
            output += ""\n"" + tabs(indentLevel + 1);
            lastStatementPart = tokens[i][1];
        }
        // Normal indentation and spaces for everything else
        else {
            if (! spaceExceptionsBefore[tokens[i][1]] &&
               ! (i > 0 && spaceExceptionsAfter[tokens[i - 1][1]]) &&
               output.charAt(output.length - 1) != ' ') {
                output += "" "";
            }
            if (tokens[i][0] == 'keyword') {
                output += tokens[i][1].toUpperCase();
            } else {
                output += tokens[i][1];
            }
        }

        // split columns in select and 'update set' clauses, but only inside statements blocks
        if ((lastStatementPart == 'select' || lastStatementPart == 'where'  || lastStatementPart == 'set') &&
            tokens[i][1] == ',' && blockStack[0] == 'statement') {

            output += ""\n"" + tabs(indentLevel + 1);
        }

        // split conditions in where clauses, but only inside statements blocks
        if (lastStatementPart == 'where' &&
            (tokens[i][1] == 'and' || tokens[i][1] == 'or' || tokens[i][1] == 'xor')) {

            if (blockStack[0] == 'statement') {
                output += ""\n"" + tabs(indentLevel + 1);
            }
            // Todo: Also split and or blocks in newlines & indentation++
            //if (blockStack[0] == 'generic')
             //   output += ...
        }
    }
    return output;
}

/**
 * jQuery function that uses jQueryUI's dialogs to confirm with user. Does not
 *  return a jQuery object yet and hence cannot be chained
 *
 * @param string      question
 * @param string      url           URL to be passed to the callbackFn to make
 *                                  an Ajax call to
 * @param function    callbackFn    callback to execute after user clicks on OK
 * @param function    openCallback  optional callback to run when dialog is shown
 */

jQuery.fn.PMA_confirm = function (question, url, callbackFn, openCallback) {
    var confirmState = PMA_commonParams.get('confirm');
    if (! confirmState) {
        // user does not want to confirm
        if ($.isFunction(callbackFn)) {
            callbackFn.call(this, url);
            return true;
        }
    }
    if (PMA_messages.strDoYouReally === '') {
        return true;
    }

    /**
     * @var    button_options  Object that stores the options passed to jQueryUI
     *                          dialog
     */
    var button_options = [
        {
            text: PMA_messages.strOK,
            'class': 'submitOK',
            click: function () {
                $(this).dialog(""close"");
                if ($.isFunction(callbackFn)) {
                    callbackFn.call(this, url);
                }
            }
        },
        {
            text: PMA_messages.strCancel,
            'class': 'submitCancel',
            click: function () {
                $(this).dialog(""close"");
            }
        }
    ];

    $('<div/>', {'id': 'confirm_dialog', 'title': PMA_messages.strConfirm})
    .prepend(question)
    .dialog({
        buttons: button_options,
        close: function () {
            $(this).remove();
        },
        open: openCallback,
        modal: true
    });
};

/**
 * jQuery function to sort a table's body after a new row has been appended to it.
 * Also fixes the even/odd classes of the table rows at the end.
 *
 * @param string      text_selector   string to select the sortKey's text
 *
 * @return jQuery Object for chaining purposes
 */
jQuery.fn.PMA_sort_table = function (text_selector) {
    return this.each(function () {

        /**
         * @var table_body  Object referring to the table's <tbody> element
         */
        var table_body = $(this);
        /**
         * @var rows    Object referring to the collection of rows in {@link table_body}
         */
        var rows = $(this).find('tr').get();

        //get the text of the field that we will sort by
        $.each(rows, function (index, row) {
            row.sortKey = $.trim($(row).find(text_selector).text().toLowerCase());
        });

        //get the sorted order
        rows.sort(function (a, b) {
            if (a.sortKey < b.sortKey) {
                return -1;
            }
            if (a.sortKey > b.sortKey) {
                return 1;
            }
            return 0;
        });

        //pull out each row from the table and then append it according to it's order
        $.each(rows, function (index, row) {
            $(table_body).append(row);
            row.sortKey = null;
        });

        //Re-check the classes of each row
        $(this).find('tr:odd')
        .removeClass('even').addClass('odd')
        .end()
        .find('tr:even')
        .removeClass('odd').addClass('even');
    });
};

/**
 * Unbind all event handlers before tearing down a page
 */
AJAX.registerTeardown('functions.js', function () {
    $(document).off('submit', ""#create_table_form_minimal.ajax"");
    $(document).off('submit', ""form.create_table_form.ajax"");
    $(document).off('click', ""form.create_table_form.ajax input[name=submit_num_fields]"");
    $(document).off('keyup', ""form.create_table_form.ajax input"");
});

/**
 * jQuery coding for 'Create Table'.  Used on db_operations.php,
 * db_structure.php and db_tracking.php (i.e., wherever
 * libraries/display_create_table.lib.php is used)
 *
 * Attach Ajax Event handlers for Create Table
 */
AJAX.registerOnload('functions.js', function () {
    /**
     * Attach event handler for submission of create table form (save)
     */
    $(document).on('submit', ""form.create_table_form.ajax"", function (event) {
        event.preventDefault();

        /**
         * @var    the_form    object referring to the create table form
         */
        var $form = $(this);

        /*
         * First validate the form; if there is a problem, avoid submitting it
         *
         * checkTableEditForm() needs a pure element and not a jQuery object,
         * this is why we pass $form[0] as a parameter (the jQuery object
         * is actually an array of DOM elements)
         */

        if (checkTableEditForm($form[0], $form.find('input[name=orig_num_fields]').val())) {
            PMA_prepareForAjaxRequest($form);
            if (PMA_checkReservedWordColumns($form)) {
                PMA_ajaxShowMessage(PMA_messages.strProcessingRequest);
                //User wants to submit the form
                $.post($form.attr('action'), $form.serialize() + ""&do_save_data=1"", function (data) {
                    if (typeof data !== 'undefined' && data.success === true) {
                        $('#properties_message')
                         .removeClass('error')
                         .html('');
                        PMA_ajaxShowMessage(data.message);
                        // Only if the create table dialog (distinct panel) exists
                        var $createTableDialog = $(""#create_table_dialog"");
                        if ($createTableDialog.length > 0) {
                            $createTableDialog.dialog(""close"").remove();
                        }
                        $('#tableslistcontainer').before(data.formatted_sql);

                        /**
                         * @var tables_table    Object referring to the <tbody> element that holds the list of tables
                         */
                        var tables_table = $(""#tablesForm"").find(""tbody"").not(""#tbl_summary_row"");
                        // this is the first table created in this db
                        if (tables_table.length === 0) {
                            PMA_commonActions.refreshMain(
                                PMA_commonParams.get('opendb_url')
                            );
                        } else {
                            /**
                             * @var curr_last_row   Object referring to the last <tr> element in {@link tables_table}
                             */
                            var curr_last_row = $(tables_table).find('tr:last');
                            /**
                             * @var curr_last_row_index_string   String containing the index of {@link curr_last_row}
                             */
                            var curr_last_row_index_string = $(curr_last_row).find('input:checkbox').attr('id').match(/\d+/)[0];
                            /**
                             * @var curr_last_row_index Index of {@link curr_last_row}
                             */
                            var curr_last_row_index = parseFloat(curr_last_row_index_string);
                            /**
                             * @var new_last_row_index   Index of the new row to be appended to {@link tables_table}
                             */
                            var new_last_row_index = curr_last_row_index + 1;
                            /**
                             * @var new_last_row_id String containing the id of the row to be appended to {@link tables_table}
                             */
                            var new_last_row_id = 'checkbox_tbl_' + new_last_row_index;

                            data.new_table_string = data.new_table_string.replace(/checkbox_tbl_/, new_last_row_id);
                            //append to table
                            $(data.new_table_string)
                             .appendTo(tables_table);

                            //Sort the table
                            $(tables_table).PMA_sort_table('th');

                            // Adjust summary row
                            PMA_adjustTotals();
                        }

                        //Refresh navigation as a new table has been added
                        PMA_reloadNavigation();
                        // Redirect to table structure page on creation of new table
                        var params_12 = 'ajax_request=true&ajax_page_request=true';
                        if (! (history && history.pushState)) {
                            params_12 += PMA_MicroHistory.menus.getRequestParam();
                        }
                        tblStruct_url = 'tbl_structure.php?server=' + data._params.server +
                            '&db='+ data._params.db + '&token=' + data._params.token +
                            '&goto=db_structure.php&table=' + data._params.table + '';
                        $.get(tblStruct_url, params_12, AJAX.responseHandler);
                    } else {
                        PMA_ajaxShowMessage(
                            '<div class=""error"">' + data.error + '</div>',
                            false
                        );
                    }
                }); // end $.post()
            }
        } // end if (checkTableEditForm() )
    }); // end create table form (save)

    /**
     * Attach event handler for create table form (add fields)
     */
    $(document).on('click', ""form.create_table_form.ajax input[name=submit_num_fields]"", function (event) {
        event.preventDefault();
        /**
         * @var    the_form    object referring to the create table form
         */
        var $form = $(this).closest('form');

        if (!checkFormElementInRange(this.form, 'added_fields', PMA_messages.strLeastColumnError, 1)) {
            return;
        }

        var $msgbox = PMA_ajaxShowMessage(PMA_messages.strProcessingRequest);
        PMA_prepareForAjaxRequest($form);

        //User wants to add more fields to the table
        $.post($form.attr('action'), $form.serialize() + ""&submit_num_fields=1"", function (data) {
            if (typeof data !== 'undefined' && data.success) {
                var $pageContent = $(""#page_content"");
                $pageContent.html(data.message);
                PMA_highlightSQL($pageContent);
                PMA_verifyColumnsProperties();
                PMA_hideShowConnection($('.create_table_form select[name=tbl_storage_engine]'));
                PMA_ajaxRemoveMessage($msgbox);
            } else {
                PMA_ajaxShowMessage(data.error);
            }
        }); //end $.post()
    }); // end create table form (add fields)

    $(document).on('keydown', ""form.create_table_form.ajax input[name=added_fields]"", function (event) {
        if (event.keyCode == 13) {
            event.preventDefault();
            event.stopImmediatePropagation();
            $(this)
                .closest('form')
                .find('input[name=submit_num_fields]')
                .click();
        }
    });
    $(""input[value=AUTO_INCREMENT]"").change(function(){
        if (this.checked) {
            var col = /\d/.exec($(this).attr('name'));
            col = col[0];
            var $selectFieldKey = $('select[name=""field_key[' + col + ']""]');
            if ($selectFieldKey.val() === 'none_'+col) {
                $selectFieldKey.val('primary_'+col).change();
            }
        }
    });
    $('body')
    .off('click', 'input.preview_sql')
    .on('click', 'input.preview_sql', function () {
        var $form = $(this).closest('form');
        PMA_previewSQL($form);
    });
});


/**
 * Validates the password field in a form
 *
 * @see    PMA_messages.strPasswordEmpty
 * @see    PMA_messages.strPasswordNotSame
 * @param  object $the_form The form to be validated
 * @return bool
 */
function PMA_checkPassword($the_form)
{
    // Did the user select 'no password'?
    if ($the_form.find('#nopass_1').is(':checked')) {
        return true;
    } else {
        var $pred = $the_form.find('#select_pred_password');
        if ($pred.length && ($pred.val() == 'none' || $pred.val() == 'keep')) {
            return true;
        }
    }

    var $password = $the_form.find('input[name=pma_pw]');
    var $password_repeat = $the_form.find('input[name=pma_pw2]');
    var alert_msg = false;

    if ($password.val() === '') {
        alert_msg = PMA_messages.strPasswordEmpty;
    } else if ($password.val() != $password_repeat.val()) {
        alert_msg = PMA_messages.strPasswordNotSame;
    }

    if (alert_msg) {
        alert(alert_msg);
        $password.val('');
        $password_repeat.val('');
        $password.focus();
        return false;
    }
    return true;
}

/**
 * Unbind all event handlers before tearing down a page
 */
AJAX.registerTeardown('functions.js', function () {
    $(document).off('click', '#change_password_anchor.ajax');
});
/**
 * Attach Ajax event handlers for 'Change Password' on index.php
 */
AJAX.registerOnload('functions.js', function () {

    /**
     * Attach Ajax event handler on the change password anchor
     */
    $(document).on('click', '#change_password_anchor.ajax', function (event) {
        event.preventDefault();

        var $msgbox = PMA_ajaxShowMessage();

        /**
         * @var button_options  Object containing options to be passed to jQueryUI's dialog
         */
        var button_options = {};
        button_options[PMA_messages.strGo] = function () {

            event.preventDefault();

            /**
             * @var $the_form    Object referring to the change password form
             */
            var $the_form = $(""#change_password_form"");

            if (! PMA_checkPassword($the_form)) {
                return false;
            }

            /**
             * @var this_value  String containing the value of the submit button.
             * Need to append this for the change password form on Server Privileges
             * page to work
             */
            var this_value = $(this).val();

            var $msgbox = PMA_ajaxShowMessage(PMA_messages.strProcessingRequest);
            $the_form.append('<input type=""hidden"" name=""ajax_request"" value=""true"" />');

            $.post($the_form.attr('action'), $the_form.serialize() + '&change_pw=' + this_value, function (data) {
                if (typeof data === 'undefined' || data.success !== true) {
                    PMA_ajaxShowMessage(data.error, false);
                    return;
                }

                var $pageContent = $(""#page_content"");
                $pageContent.prepend(data.message);
                PMA_highlightSQL($pageContent);
                $(""#change_password_dialog"").hide().remove();
                $(""#edit_user_dialog"").dialog(""close"").remove();
                PMA_ajaxRemoveMessage($msgbox);
            }); // end $.post()
        };

        button_options[PMA_messages.strCancel] = function () {
            $(this).dialog('close');
        };
        $.get($(this).attr('href'), {'ajax_request': true}, function (data) {
            if (typeof data === 'undefined' || !data.success) {
                PMA_ajaxShowMessage(data.error, false);
                return;
            }

            $('<div id=""change_password_dialog""></div>')
                .dialog({
                    title: PMA_messages.strChangePassword,
                    width: 600,
                    close: function (ev, ui) {
                        $(this).remove();
                    },
                    buttons: button_options,
                    modal: true
                })
                .append(data.message);
            // for this dialog, we remove the fieldset wrapping due to double headings
            $(""fieldset#fieldset_change_password"")
                .find(""legend"").remove().end()
                .find(""table.noclick"").unwrap().addClass(""some-margin"")
                .find(""input#text_pma_pw"").focus();
            displayPasswordGenerateButton();
            $('#fieldset_change_password_footer').hide();
            PMA_ajaxRemoveMessage($msgbox);
            $('#change_password_form').bind('submit', function (e) {
                e.preventDefault();
                $(this)
                    .closest('.ui-dialog')
                    .find('.ui-dialog-buttonpane .ui-button')
                    .first()
                    .click();
            });
        }); // end $.get()
    }); // end handler for change password anchor
}); // end $() for Change Password

/**
 * Unbind all event handlers before tearing down a page
 */
AJAX.registerTeardown('functions.js', function () {
    $(document).off('change', ""select.column_type"");
    $(document).off('change', ""select.default_type"");
    $(document).off('change', ""select.virtuality"");
    $(document).off('change', 'input.allow_null');
    $(document).off('change', '.create_table_form select[name=tbl_storage_engine]');
});
/**
 * Toggle the hiding/showing of the ""Open in ENUM/SET editor"" message when
 * the page loads and when the selected data type changes
 */
AJAX.registerOnload('functions.js', function () {
    // is called here for normal page loads and also when opening
    // the Create table dialog
    PMA_verifyColumnsProperties();
    //
    // needs on() to work also in the Create Table dialog
    $(document).on('change', ""select.column_type"", function () {
        PMA_showNoticeForEnum($(this));
    });
    $(document).on('change', ""select.default_type"", function () {
        PMA_hideShowDefaultValue($(this));
    });
    $(document).on('change', ""select.virtuality"", function () {
        PMA_hideShowExpression($(this));
    });
    $(document).on('change', 'input.allow_null', function () {
        PMA_validateDefaultValue($(this));
    });
    $(document).on('change', '.create_table_form select[name=tbl_storage_engine]', function () {
        PMA_hideShowConnection($(this));
    });
});

/**
 * If the chosen storage engine is FEDERATED show connection field. Hide otherwise
 *
 * @param $engine_selector storage engine selector
 */
function PMA_hideShowConnection($engine_selector)
{
    var $connection = $('.create_table_form input[name=connection]');
    var index = $connection.parent('td').index() + 1;
    var $labelTh = $connection.parents('tr').prev('tr').children('th:nth-child(' + index + ')');
    if ($engine_selector.val() != 'FEDERATED') {
        $connection
            .prop('disabled', true)
            .parent('td').hide();
        $labelTh.hide();
    } else {
        $connection
            .prop('disabled', false)
            .parent('td').show();
        $labelTh.show();
    }
}

/**
 * If the column does not allow NULL values, makes sure that default is not NULL
 */
function PMA_validateDefaultValue($null_checkbox)
{
    if (! $null_checkbox.prop('checked')) {
        var $default = $null_checkbox.closest('tr').find('.default_type');
        if ($default.val() == 'NULL') {
            $default.val('NONE');
        }
    }
}

/**
 * function to populate the input fields on picking a column from central list
 *
 * @param string  input_id input id of the name field for the column to be populated
 * @param integer offset of the selected column in central list of columns
 */
function autoPopulate(input_id, offset)
{
    var db = PMA_commonParams.get('db');
    var table = PMA_commonParams.get('table');
    input_id = input_id.substring(0, input_id.length - 1);
    $('#' + input_id + '1').val(central_column_list[db + '_' + table][offset].col_name);
    var col_type = central_column_list[db + '_' + table][offset].col_type.toUpperCase();
    $('#' + input_id + '2').val(col_type);
    var $input3 = $('#' + input_id + '3');
    $input3.val(central_column_list[db + '_' + table][offset].col_length);
    if(col_type === 'ENUM' || col_type === 'SET') {
        $input3.next().show();
    } else {
        $input3.next().hide();
    }
    var col_default = central_column_list[db + '_' + table][offset].col_default.toUpperCase();
    var $input4 = $('#' + input_id + '4');
    if (col_default !== '' && col_default !== 'NULL' && col_default !== 'CURRENT_TIMESTAMP') {
        $input4.val(""USER_DEFINED"");
        $input4.next().next().show();
        $input4.next().next().val(central_column_list[db + '_' + table][offset].col_default);
    } else {
        $input4.val(central_column_list[db + '_' + table][offset].col_default);
        $input4.next().next().hide();
    }
    $('#' + input_id + '5').val(central_column_list[db + '_' + table][offset].col_collation);
    var $input6 = $('#' + input_id + '6');
    $input6.val(central_column_list[db + '_' + table][offset].col_attribute);
    if(central_column_list[db + '_' + table][offset].col_extra === 'on update CURRENT_TIMESTAMP') {
        $input6.val(central_column_list[db + '_' + table][offset].col_extra);
    }
    if(central_column_list[db + '_' + table][offset].col_extra.toUpperCase() === 'AUTO_INCREMENT') {
        $('#' + input_id + '9').prop(""checked"",true).change();
    } else {
        $('#' + input_id + '9').prop(""checked"",false);
    }
    if(central_column_list[db + '_' + table][offset].col_isNull !== '0') {
        $('#' + input_id + '7').prop(""checked"",true);
    } else {
        $('#' + input_id + '7').prop(""checked"",false);
    }
}

/**
 * Unbind all event handlers before tearing down a page
 */
AJAX.registerTeardown('functions.js', function () {
    $(document).off('click', ""a.open_enum_editor"");
    $(document).off('click', ""input.add_value"");
    $(document).off('click', ""#enum_editor td.drop"");
    $(document).off('click', 'a.central_columns_dialog');
});
/**
 * @var $enum_editor_dialog An object that points to the jQuery
 *                          dialog of the ENUM/SET editor
 */
var $enum_editor_dialog = null;
/**
 * Opens the ENUM/SET editor and controls its functions
 */
AJAX.registerOnload('functions.js', function () {
    $(document).on('click', ""a.open_enum_editor"", function () {
        // Get the name of the column that is being edited
        var colname = $(this).closest('tr').find('input:first').val();
        var title;
        var i;
        // And use it to make up a title for the page
        if (colname.length < 1) {
            title = PMA_messages.enum_newColumnVals;
        } else {
            title = PMA_messages.enum_columnVals.replace(
                /%s/,
                '""' + escapeHtml(decodeURIComponent(colname)) + '""'
            );
        }
        // Get the values as a string
        var inputstring = $(this)
            .closest('td')
            .find(""input"")
            .val();
        // Escape html entities
        inputstring = $('<div/>')
            .text(inputstring)
            .html();
        // Parse the values, escaping quotes and
        // slashes on the fly, into an array
        var values = [];
        var in_string = false;
        var curr, next, buffer = '';
        for (i = 0; i < inputstring.length; i++) {
            curr = inputstring.charAt(i);
            next = i == inputstring.length ? '' : inputstring.charAt(i + 1);
            if (! in_string && curr == ""'"") {
                in_string = true;
            } else if (in_string && curr == ""\\"" && next == ""\\"") {
                buffer += ""&#92;"";
                i++;
            } else if (in_string && next == ""'"" && (curr == ""'"" || curr == ""\\"")) {
                buffer += ""&#39;"";
                i++;
            } else if (in_string && curr == ""'"") {
                in_string = false;
                values.push(buffer);
                buffer = '';
            } else if (in_string) {
                buffer += curr;
            }
        }
        if (buffer.length > 0) {
            // The leftovers in the buffer are the last value (if any)
            values.push(buffer);
        }
        var fields = '';
        // If there are no values, maybe the user is about to make a
        // new list so we add a few for him/her to get started with.
        if (values.length === 0) {
            values.push('', '', '', '');
        }
        // Add the parsed values to the editor
        var drop_icon = PMA_getImage('b_drop.png');
        for (i = 0; i < values.length; i++) {
            fields += ""<tr><td>"" +
                   ""<input type='text' value='"" + values[i] + ""'/>"" +
                   ""</td><td class='drop'>"" +
                   drop_icon +
                   ""</td></tr>"";
        }
        /**
         * @var dialog HTML code for the ENUM/SET dialog
         */
        var dialog = ""<div id='enum_editor'>"" +
                   ""<fieldset>"" +
                    ""<legend>"" + title + ""</legend>"" +
                    ""<p>"" + PMA_getImage('s_notice.png') +
                    PMA_messages.enum_hint + ""</p>"" +
                    ""<table class='values'>"" + fields + ""</table>"" +
                    ""</fieldset><fieldset class='tblFooters'>"" +
                    ""<table class='add'><tr><td>"" +
                    ""<div class='slider'></div>"" +
                    ""</td><td>"" +
                    ""<form><div><input type='submit' class='add_value' value='"" +
                    PMA_sprintf(PMA_messages.enum_addValue, 1) +
                    ""'/></div></form>"" +
                    ""</td></tr></table>"" +
                    ""<input type='hidden' value='"" + // So we know which column's data is being edited
                    $(this).closest('td').find(""input"").attr(""id"") +
                    ""' />"" +
                    ""</fieldset>"" +
                    ""</div>"";
        /**
         * @var  Defines functions to be called when the buttons in
         * the buttonOptions jQuery dialog bar are pressed
         */
        var buttonOptions = {};
        buttonOptions[PMA_messages.strGo] = function () {
            // When the submit button is clicked,
            // put the data back into the original form
            var value_array = [];
            $(this).find("".values input"").each(function (index, elm) {
                var val = elm.value.replace(/\\/g, '\\\\').replace(/'/g, ""''"");
                value_array.push(""'"" + val + ""'"");
            });
            // get the Length/Values text field where this value belongs
            var values_id = $(this).find(""input[type='hidden']"").val();
            $(""input#"" + values_id).val(value_array.join("",""));
            $(this).dialog(""close"");
        };
        buttonOptions[PMA_messages.strClose] = function () {
            $(this).dialog(""close"");
        };
        // Show the dialog
        var width = parseInt(
            (parseInt($('html').css('font-size'), 10) / 13) * 340,
            10
        );
        if (! width) {
            width = 340;
        }
        $enum_editor_dialog = $(dialog).dialog({
            minWidth: width,
            maxHeight: 450,
            modal: true,
            title: PMA_messages.enum_editor,
            buttons: buttonOptions,
            open: function () {
                // Focus the ""Go"" button after opening the dialog
                $(this).closest('.ui-dialog').find('.ui-dialog-buttonpane button:first').focus();
            },
            close: function () {
                $(this).remove();
            }
        });
        // slider for choosing how many fields to add
        $enum_editor_dialog.find("".slider"").slider({
            animate: true,
            range: ""min"",
            value: 1,
            min: 1,
            max: 9,
            slide: function (event, ui) {
                $(this).closest('table').find('input[type=submit]').val(
                    PMA_sprintf(PMA_messages.enum_addValue, ui.value)
                );
            }
        });
        // Focus the slider, otherwise it looks nearly transparent
        $('a.ui-slider-handle').addClass('ui-state-focus');
        return false;
    });

    $(document).on('click', 'a.central_columns_dialog', function (e) {
        var href = ""db_central_columns.php"";
        var db = PMA_commonParams.get('db');
        var table = PMA_commonParams.get('table');
        var maxRows = $(this).data('maxrows');
        var pick = $(this).data('pick');
        if (pick !== false) {
            pick = true;
        }
        var params = {
            'ajax_request' : true,
            'token' : PMA_commonParams.get('token'),
            'server' : PMA_commonParams.get('server'),
            'db' : PMA_commonParams.get('db'),
            'cur_table' : PMA_commonParams.get('table'),
            'getColumnList':true
        };
        var colid = $(this).closest('td').find(""input"").attr(""id"");
        var fields = '';
        if (! (db + '_' + table in central_column_list)) {
            central_column_list.push(db + '_' + table);
            $.ajax({
                type: 'POST',
                url: href,
                data: params,
                success: function (data) {
                    central_column_list[db + '_' + table] = $.parseJSON(data.message);
                },
                async:false
            });
        }
        var i = 0;
        var list_size = central_column_list[db + '_' + table].length;
        var min = (list_size <= maxRows) ? list_size : maxRows;
        for (i = 0; i < min; i++) {

            fields += '<tr><td><div><span style=""font-weight:bold"">' +
                escapeHtml(central_column_list[db + '_' + table][i].col_name) +
                '</span><br><span style=""color:gray"">' + central_column_list[db + '_' + table][i].col_type;

            if (central_column_list[db + '_' + table][i].col_attribute !== '') {
                fields += '(' + escapeHtml(central_column_list[db + '_' + table][i].col_attribute) + ') ';
            }
            if (central_column_list[db + '_' + table][i].col_length !== '') {
                fields += '(' + escapeHtml(central_column_list[db + '_' + table][i].col_length) +') ';
            }
            fields += escapeHtml(central_column_list[db + '_' + table][i].col_extra) + '</span>' +
                '</div></td>';
            if (pick) {
                fields += '<td><input class=""pick"" style=""width:100%"" type=""submit"" value=""' +
                    PMA_messages.pickColumn + '"" onclick=""autoPopulate(\'' + colid + '\',' + i + ')""/></td>';
            }
            fields += '</tr>';
        }
        var result_pointer = i;
        var search_in = '<input type=""text"" class=""filter_rows"" placeholder=""' + PMA_messages.searchList + '"">';
        if (fields === '') {
            fields = PMA_sprintf(PMA_messages.strEmptyCentralList, ""'"" + db + ""'"");
            search_in = '';
        }
        var seeMore = '';
        if (list_size > maxRows) {
            seeMore = ""<fieldset class='tblFooters' style='text-align:center;font-weight:bold'>"" +
                ""<a href='#' id='seeMore'>"" + PMA_messages.seeMore + ""</a></fieldset>"";
        }
        var central_columns_dialog = ""<div style='max-height:400px'>"" +
            ""<fieldset>"" +
            search_in +
            ""<table id='col_list' style='width:100%' class='values'>"" + fields + ""</table>"" +
            ""</fieldset>"" +
            seeMore +
            ""</div>"";

        var width = parseInt(
            (parseInt($('html').css('font-size'), 10) / 13) * 500,
            10
        );
        if (! width) {
            width = 500;
        }
        var buttonOptions = {};
        var $central_columns_dialog = $(central_columns_dialog).dialog({
            minWidth: width,
            maxHeight: 450,
            modal: true,
            title: PMA_messages.pickColumnTitle,
            buttons: buttonOptions,
            open: function () {
                $('#col_list').on(""click"", "".pick"", function (){
                    $central_columns_dialog.remove();
                });
                $("".filter_rows"").on(""keyup"", function () {
                    $.uiTableFilter($(""#col_list""), $(this).val());
                });
                $(""#seeMore"").click(function() {
                    fields = '';
                    min = (list_size <= maxRows + result_pointer) ? list_size : maxRows + result_pointer;
                    for (i = result_pointer; i < min; i++) {

                        fields += '<tr><td><div><span style=""font-weight:bold"">' +
                            central_column_list[db + '_' + table][i].col_name +
                            '</span><br><span style=""color:gray"">' +
                            central_column_list[db + '_' + table][i].col_type;

                        if (central_column_list[db + '_' + table][i].col_attribute !== '') {
                            fields += '(' + central_column_list[db + '_' + table][i].col_attribute + ') ';
                        }
                        if (central_column_list[db + '_' + table][i].col_length !== '') {
                            fields += '(' + central_column_list[db + '_' + table][i].col_length + ') ';
                        }
                        fields += central_column_list[db + '_' + table][i].col_extra + '</span>' +
                            '</div></td>';
                        if (pick) {
                            fields += '<td><input class=""pick"" style=""width:100%"" type=""submit"" value=""' +
                                PMA_messages.pickColumn + '"" onclick=""autoPopulate(\'' + colid + '\',' + i + ')""/></td>';
                        }
                        fields += '</tr>';
                    }
                    $(""#col_list"").append(fields);
                    result_pointer = i;
                    if (result_pointer === list_size) {
                        $('.tblFooters').hide();
                    }
                    return false;
                });
                $(this).closest('.ui-dialog').find('.ui-dialog-buttonpane button:first').focus();
            },
            close: function () {
                $('#col_list').off(""click"", "".pick"");
                $("".filter_rows"").off(""keyup"");
                $(this).remove();
            }
        });
        return false;
    });

   // $(document).on('click', 'a.show_central_list',function(e) {

   // });
    // When ""add a new value"" is clicked, append an empty text field
    $(document).on('click', ""input.add_value"", function (e) {
        e.preventDefault();
        var num_new_rows = $enum_editor_dialog.find(""div.slider"").slider('value');
        while (num_new_rows--) {
            $enum_editor_dialog.find('.values')
                .append(
                    ""<tr style='display: none;'><td>"" +
                    ""<input type='text' />"" +
                    ""</td><td class='drop'>"" +
                    PMA_getImage('b_drop.png') +
                    ""</td></tr>""
                )
                .find('tr:last')
                .show('fast');
        }
    });

    // Removes the specified row from the enum editor
    $(document).on('click', ""#enum_editor td.drop"", function () {
        $(this).closest('tr').hide('fast', function () {
            $(this).remove();
        });
    });
});

/**
 * Ensures indexes names are valid according to their type and, for a primary
 * key, lock index name to 'PRIMARY'
 * @param string   form_id  Variable which parses the form name as
 *                            the input
 * @return boolean  false    if there is no index form, true else
 */
function checkIndexName(form_id)
{
    if ($(""#"" + form_id).length === 0) {
        return false;
    }

    // Gets the elements pointers
    var $the_idx_name = $(""#input_index_name"");
    var $the_idx_choice = $(""#select_index_choice"");

    // Index is a primary key
    if ($the_idx_choice.find(""option:selected"").val() == 'PRIMARY') {
        $the_idx_name.val('PRIMARY');
        $the_idx_name.prop(""disabled"", true);
    }

    // Other cases
    else {
        if ($the_idx_name.val() == 'PRIMARY') {
            $the_idx_name.val("""");
        }
        $the_idx_name.prop(""disabled"", false);
    }

    return true;
} // end of the 'checkIndexName()' function

AJAX.registerTeardown('functions.js', function () {
    $(document).off('click', '#index_frm input[type=submit]');
});
AJAX.registerOnload('functions.js', function () {
    /**
     * Handler for adding more columns to an index in the editor
     */
    $(document).on('click', '#index_frm input[type=submit]', function (event) {
        event.preventDefault();
        var rows_to_add = $(this)
            .closest('fieldset')
            .find('.slider')
            .slider('value');

        var tempEmptyVal = function () {
            $(this).val('');
        };

        var tempSetFocus = function () {
            if ($(this).find(""option:selected"").val() === '') {
                return true;
            }
            $(this).closest(""tr"").find(""input"").focus();
        };

        while (rows_to_add--) {
            var $indexColumns = $('#index_columns');
            var $newrow = $indexColumns
                .find('tbody > tr:first')
                .clone()
                .appendTo(
                    $indexColumns.find('tbody')
                );
            $newrow.find(':input').each(tempEmptyVal);
            // focus index size input on column picked
            $newrow.find('select').change(tempSetFocus);
        }
    });
});

function indexEditorDialog(url, title, callback_success, callback_failure)
{
    /*Remove the hidden dialogs if there are*/
    var $editIndexDialog = $('#edit_index_dialog');
    if ($editIndexDialog.length !== 0) {
        $editIndexDialog.remove();
    }
    var $div = $('<div id=""edit_index_dialog""></div>');

    /**
     * @var button_options Object that stores the options
     *                     passed to jQueryUI dialog
     */
    var button_options = {};
    button_options[PMA_messages.strGo] = function () {
        /**
         * @var    the_form    object referring to the export form
         */
        var $form = $(""#index_frm"");
        var $msgbox = PMA_ajaxShowMessage(PMA_messages.strProcessingRequest);
        PMA_prepareForAjaxRequest($form);
        //User wants to submit the form
        $.post($form.attr('action'), $form.serialize() + ""&do_save_data=1"", function (data) {
            var $sqlqueryresults = $("".sqlqueryresults"");
            if ($sqlqueryresults.length !== 0) {
                $sqlqueryresults.remove();
            }
            if (typeof data !== 'undefined' && data.success === true) {
                PMA_ajaxShowMessage(data.message);
                var $resultQuery = $('.result_query');
                if ($resultQuery.length) {
                    $resultQuery.remove();
                }
                if (data.sql_query) {
                    $('<div class=""result_query""></div>')
                        .html(data.sql_query)
                        .prependTo('#page_content');
                    PMA_highlightSQL($('#page_content'));
                }
                $("".result_query .notice"").remove();
                $resultQuery.prepend(data.message);
                /*Reload the field form*/
                $(""#table_index"").remove();
                $(""<div id='temp_div'><div>"")
                    .append(data.index_table)
                    .find(""#table_index"")
                    .insertAfter(""#index_header"");
                var $editIndexDialog = $(""#edit_index_dialog"");
                if ($editIndexDialog.length > 0) {
                    $editIndexDialog.dialog(""close"");
                }
                $('div.no_indexes_defined').hide();
                if (callback_success) {
                    callback_success();
                }
                PMA_reloadNavigation();
            } else {
                var $temp_div = $(""<div id='temp_div'><div>"").append(data.error);
                var $error;
                if ($temp_div.find("".error code"").length !== 0) {
                    $error = $temp_div.find("".error code"").addClass(""error"");
                } else {
                    $error = $temp_div;
                }
                if (callback_failure) {
                    callback_failure();
                }
                PMA_ajaxShowMessage($error, false);
            }
        }); // end $.post()
    };
    button_options[PMA_messages.strPreviewSQL] = function () {
        // Function for Previewing SQL
        var $form = $('#index_frm');
        PMA_previewSQL($form);
    };
    button_options[PMA_messages.strCancel] = function () {
        $(this).dialog('close');
    };
    var $msgbox = PMA_ajaxShowMessage();
    $.get(""tbl_indexes.php"", url, function (data) {
        if (typeof data !== 'undefined' && data.success === false) {
            //in the case of an error, show the error message returned.
            PMA_ajaxShowMessage(data.error, false);
        } else {
            PMA_ajaxRemoveMessage($msgbox);
            // Show dialog if the request was successful
            $div
            .append(data.message)
            .dialog({
                title: title,
                width: 450,
                height: 350,
                open: PMA_verifyColumnsProperties,
                modal: true,
                buttons: button_options,
                close: function () {
                    $(this).remove();
                }
            });
            $div.find('.tblFooters').remove();
            showIndexEditDialog($div);
        }
    }); // end $.get()
}

function showIndexEditDialog($outer)
{
    checkIndexType();
    checkIndexName(""index_frm"");
    var $indexColumns = $('#index_columns');
    $indexColumns.find('td').each(function () {
        $(this).css(""width"", $(this).width() + 'px');
    });
    $indexColumns.find('tbody').sortable({
        axis: 'y',
        containment: $indexColumns.find(""tbody""),
        tolerance: 'pointer'
    });
    PMA_showHints($outer);
    PMA_init_slider();
    // Add a slider for selecting how many columns to add to the index
    $outer.find('.slider').slider({
        animate: true,
        value: 1,
        min: 1,
        max: 16,
        slide: function (event, ui) {
            $(this).closest('fieldset').find('input[type=submit]').val(
                PMA_sprintf(PMA_messages.strAddToIndex, ui.value)
            );
        }
    });
    $('div.add_fields').removeClass('hide');
    // focus index size input on column picked
    $outer.find('table#index_columns select').change(function () {
        if ($(this).find(""option:selected"").val() === '') {
            return true;
        }
        $(this).closest(""tr"").find(""input"").focus();
    });
    // Focus the slider, otherwise it looks nearly transparent
    $('a.ui-slider-handle').addClass('ui-state-focus');
    // set focus on index name input, if empty
    var input = $outer.find('input#input_index_name');
    input.val() || input.focus();
}

/**
 * Function to display tooltips that were
 * generated on the PHP side by PMA_Util::showHint()
 *
 * @param object $div a div jquery object which specifies the
 *                    domain for searching for tooltips. If we
 *                    omit this parameter the function searches
 *                    in the whole body
 **/
function PMA_showHints($div)
{
    if ($div === undefined || ! $div instanceof jQuery || $div.length === 0) {
        $div = $(""body"");
    }
    $div.find('.pma_hint').each(function () {
        PMA_tooltip(
            $(this).children('img'),
            'img',
            $(this).children('span').html()
        );
    });
}

AJAX.registerOnload('functions.js', function () {
    PMA_showHints();
});

function PMA_mainMenuResizerCallback() {
    // 5 px margin for jumping menu in Chrome
    return $(document.body).width() - 5;
}
// This must be fired only once after the initial page load
$(function () {
    // Initialise the menu resize plugin
    $('#topmenu').menuResizer(PMA_mainMenuResizerCallback);
    // register resize event
    $(window).resize(function () {
        $('#topmenu').menuResizer('resize');
    });
});

/**
 * Get the row number from the classlist (for example, row_1)
 */
function PMA_getRowNumber(classlist)
{
    return parseInt(classlist.split(/\s+row_/)[1], 10);
}

/**
 * Changes status of slider
 */
function PMA_set_status_label($element)
{
    var text;
    if ($element.css('display') == 'none') {
        text = '+ ';
    } else {
        text = '- ';
    }
    $element.closest('.slide-wrapper').prev().find('span').text(text);
}

/**
 * var  toggleButton  This is a function that creates a toggle
 *                    sliding button given a jQuery reference
 *                    to the correct DOM element
 */
var toggleButton = function ($obj) {
    // In rtl mode the toggle switch is flipped horizontally
    // so we need to take that into account
    var right;
    if ($('span.text_direction', $obj).text() == 'ltr') {
        right = 'right';
    } else {
        right = 'left';
    }
    /**
     *  var  h  Height of the button, used to scale the
     *          background image and position the layers
     */
    var h = $obj.height();
    $('img', $obj).height(h);
    $('table', $obj).css('bottom', h - 1);
    /**
     *  var  on   Width of the ""ON"" part of the toggle switch
     *  var  off  Width of the ""OFF"" part of the toggle switch
     */
    var on  = $('td.toggleOn', $obj).width();
    var off = $('td.toggleOff', $obj).width();
    // Make the ""ON"" and ""OFF"" parts of the switch the same size
    // + 2 pixels to avoid overflowed
    $('td.toggleOn > div', $obj).width(Math.max(on, off) + 2);
    $('td.toggleOff > div', $obj).width(Math.max(on, off) + 2);
    /**
     *  var  w  Width of the central part of the switch
     */
    var w = parseInt(($('img', $obj).height() / 16) * 22, 10);
    // Resize the central part of the switch on the top
    // layer to match the background
    $('table td:nth-child(2) > div', $obj).width(w);
    /**
     *  var  imgw    Width of the background image
     *  var  tblw    Width of the foreground layer
     *  var  offset  By how many pixels to move the background
     *               image, so that it matches the top layer
     */
    var imgw = $('img', $obj).width();
    var tblw = $('table', $obj).width();
    var offset = parseInt(((imgw - tblw) / 2), 10);
    // Move the background to match the layout of the top layer
    $obj.find('img').css(right, offset);
    /**
     *  var  offw    Outer width of the ""ON"" part of the toggle switch
     *  var  btnw    Outer width of the central part of the switch
     */
    var offw = $('td.toggleOff', $obj).outerWidth();
    var btnw = $('table td:nth-child(2)', $obj).outerWidth();
    // Resize the main div so that exactly one side of
    // the switch plus the central part fit into it.
    $obj.width(offw + btnw + 2);
    /**
     *  var  move  How many pixels to move the
     *             switch by when toggling
     */
    var move = $('td.toggleOff', $obj).outerWidth();
    // If the switch is initialized to the
    // OFF state we need to move it now.
    if ($('div.container', $obj).hasClass('off')) {
        if (right == 'right') {
            $('div.container', $obj).animate({'left': '-=' + move + 'px'}, 0);
        } else {
            $('div.container', $obj).animate({'left': '+=' + move + 'px'}, 0);
        }
    }
    // Attach an 'onclick' event to the switch
    $('div.container', $obj).click(function () {
        if ($(this).hasClass('isActive')) {
            return false;
        } else {
            $(this).addClass('isActive');
        }
        var $msg = PMA_ajaxShowMessage();
        var $container = $(this);
        var callback = $('span.callback', this).text();
        var operator, url, removeClass, addClass;
        // Perform the actual toggle
        if ($(this).hasClass('on')) {
            if (right == 'right') {
                operator = '-=';
            } else {
                operator = '+=';
            }
            url = $(this).find('td.toggleOff > span').text();
            removeClass = 'on';
            addClass = 'off';
        } else {
            if (right == 'right') {
                operator = '+=';
            } else {
                operator = '-=';
            }
            url = $(this).find('td.toggleOn > span').text();
            removeClass = 'off';
            addClass = 'on';
        }
        $.post(url, {'ajax_request': true}, function (data) {
            if (typeof data !== 'undefined' && data.success === true) {
                PMA_ajaxRemoveMessage($msg);
                $container
                .removeClass(removeClass)
                .addClass(addClass)
                .animate({'left': operator + move + 'px'}, function () {
                    $container.removeClass('isActive');
                });
                eval(callback);
            } else {
                PMA_ajaxShowMessage(data.error, false);
                $container.removeClass('isActive');
            }
        });
    });
};

/**
 * Unbind all event handlers before tearing down a page
 */
AJAX.registerTeardown('functions.js', function () {
    $('div.container').unbind('click');
});
/**
 * Initialise all toggle buttons
 */
AJAX.registerOnload('functions.js', function () {
    $('div.toggleAjax').each(function () {
        var $button = $(this).show();
        $button.find('img').each(function () {
            if (this.complete) {
                toggleButton($button);
            } else {
                $(this).load(function () {
                    toggleButton($button);
                });
            }
        });
    });
});

/**
 * Unbind all event handlers before tearing down a page
 */
AJAX.registerTeardown('functions.js', function () {
    $(document).off('change', 'select.pageselector');
    $(document).off('click', 'a.formLinkSubmit');
    $('#update_recent_tables').unbind('ready');
    $('#sync_favorite_tables').unbind('ready');
});

AJAX.registerOnload('functions.js', function () {

    /**
     * Autosubmit page selector
     */
    $(document).on('change', 'select.pageselector', function (event) {
        event.stopPropagation();
        // Check where to load the new content
        if ($(this).closest(""#pma_navigation"").length === 0) {
            // For the main page we don't need to do anything,
            $(this).closest(""form"").submit();
        } else {
            // but for the navigation we need to manually replace the content
            PMA_navigationTreePagination($(this));
        }
    });

    /**
     * Load version information asynchronously.
     */
    if ($('li.jsversioncheck').length > 0) {
        $.getJSON('version_check.php', {'server' : PMA_commonParams.get('server')}, PMA_current_version);
    }

    if ($('#is_git_revision').length > 0) {
        setTimeout(PMA_display_git_revision, 10);
    }

    /**
     * Slider effect.
     */
    PMA_init_slider();

    /**
     * Enables the text generated by PMA_Util::linkOrButton() to be clickable
     */
    $(document).on('click', 'a.formLinkSubmit', function (e) {
        if (! $(this).hasClass('requireConfirm')) {
            submitFormLink($(this));
            return false;
        }
    });

    var $updateRecentTables = $('#update_recent_tables');
    if ($updateRecentTables.length) {
        $.get(
            $updateRecentTables.attr('href'),
            {no_debug: true},
            function (data) {
                if (typeof data !== 'undefined' && data.success === true) {
                    $('#pma_recent_list').html(data.list);
                }
            }
        );
    }

    // Sync favorite tables from localStorage to pmadb.
    if ($('#sync_favorite_tables').length) {
        $.ajax({
            url: $('#sync_favorite_tables').attr(""href""),
            cache: false,
            type: 'POST',
            data: {
                favorite_tables: (isStorageSupported('localStorage') && typeof window.localStorage.favorite_tables !== 'undefined')
                    ? window.localStorage.favorite_tables
                    : '',
                no_debug: true
            },
            success: function (data) {
                // Update localStorage.
                if (isStorageSupported('localStorage')) {
                    window.localStorage.favorite_tables = data.favorite_tables;
                }
                $('#pma_favorite_list').html(data.list);
            }
        });
    }
}); // end of $()

/**
 * Submits the form placed in place of a link due to the excessive url length
 *
 * @param $link anchor
 * @returns {Boolean}
 */
function submitFormLink($link)
{
    if ($link.attr('href').indexOf('=') != -1) {
        var data = $link.attr('href').substr($link.attr('href').indexOf('#') + 1).split('=', 2);
        $link.parents('form').append('<input type=""hidden"" name=""' + data[0] + '"" value=""' + data[1] + '""/>');
    }
    $link.parents('form').submit();
}

/**
 * Initializes slider effect.
 */
function PMA_init_slider()
{
    $('div.pma_auto_slider').each(function () {
        var $this = $(this);
        if ($this.data('slider_init_done')) {
            return;
        }
        var $wrapper = $('<div>', {'class': 'slide-wrapper'});
        $wrapper.toggle($this.is(':visible'));
        $('<a>', {href: '#' + this.id, ""class"": 'ajax'})
            .text($this.attr('title'))
            .prepend($('<span>'))
            .insertBefore($this)
            .click(function () {
                var $wrapper = $this.closest('.slide-wrapper');
                var visible = $this.is(':visible');
                if (!visible) {
                    $wrapper.show();
                }
                $this[visible ? 'hide' : 'show']('blind', function () {
                    $wrapper.toggle(!visible);
                    $wrapper.parent().toggleClass(""print_ignore"", visible);
                    PMA_set_status_label($this);
                });
                return false;
            });
        $this.wrap($wrapper);
        $this.removeAttr('title');
        PMA_set_status_label($this);
        $this.data('slider_init_done', 1);
    });
}

/**
 * Initializes slider effect.
 */
AJAX.registerOnload('functions.js', function () {
    PMA_init_slider();
});

/**
 * Restores sliders to the state they were in before initialisation.
 */
AJAX.registerTeardown('functions.js', function () {
    $('div.pma_auto_slider').each(function () {
        var $this = $(this);
        $this.removeData();
        $this.parent().replaceWith($this);
        $this.parent().children('a').remove();
    });
});

/**
 * Creates a message inside an object with a sliding effect
 *
 * @param msg    A string containing the text to display
 * @param $obj   a jQuery object containing the reference
 *                 to the element where to put the message
 *                 This is optional, if no element is
 *                 provided, one will be created below the
 *                 navigation links at the top of the page
 *
 * @return bool   True on success, false on failure
 */
function PMA_slidingMessage(msg, $obj)
{
    if (msg === undefined || msg.length === 0) {
        // Don't show an empty message
        return false;
    }
    if ($obj === undefined || ! $obj instanceof jQuery || $obj.length === 0) {
        // If the second argument was not supplied,
        // we might have to create a new DOM node.
        if ($('#PMA_slidingMessage').length === 0) {
            $('#page_content').prepend(
                '<span id=""PMA_slidingMessage"" ' +
                'style=""display: inline-block;""></span>'
            );
        }
        $obj = $('#PMA_slidingMessage');
    }
    if ($obj.has('div').length > 0) {
        // If there already is a message inside the
        // target object, we must get rid of it
        $obj
        .find('div')
        .first()
        .fadeOut(function () {
            $obj
            .children()
            .remove();
            $obj
            .append('<div>' + msg + '</div>');
            // highlight any sql before taking height;
            PMA_highlightSQL($obj);
            $obj.find('div')
                .first()
                .hide();
            $obj
            .animate({
                height: $obj.find('div').first().height()
            })
            .find('div')
            .first()
            .fadeIn();
        });
    } else {
        // Object does not already have a message
        // inside it, so we simply slide it down
        $obj.width('100%')
            .html('<div>' + msg + '</div>');
        // highlight any sql before taking height;
        PMA_highlightSQL($obj);
        var h = $obj
            .find('div')
            .first()
            .hide()
            .height();
        $obj
        .find('div')
        .first()
        .css('height', 0)
        .show()
        .animate({
                height: h
            }, function () {
            // Set the height of the parent
            // to the height of the child
                $obj
                .height(
                    $obj
                    .find('div')
                    .first()
                    .height()
                );
            });
    }
    return true;
} // end PMA_slidingMessage()

/**
 * Attach CodeMirror2 editor to SQL edit area.
 */
AJAX.registerOnload('functions.js', function () {
    var $elm = $('#sqlquery');
    if ($elm.length > 0) {
        if (typeof CodeMirror != 'undefined') {
            codemirror_editor = PMA_getSQLEditor($elm);
            codemirror_editor.focus();
            codemirror_editor.on(""blur"", updateQueryParameters);
        } else {
            // without codemirror
            $elm.focus()
                .bind('blur', updateQueryParameters);
        }
    }
    PMA_highlightSQL($('body'));
});
AJAX.registerTeardown('functions.js', function () {
    if (codemirror_editor) {
        $('#sqlquery').text(codemirror_editor.getValue());
        codemirror_editor.toTextArea();
        codemirror_editor = false;
    }
});
AJAX.registerOnload('functions.js', function () {
    // initializes all lock-page elements lock-id and
    // val-hash data property
    $('#page_content form.lock-page textarea, ' +
            '#page_content form.lock-page input[type=""text""], '+
            '#page_content form.lock-page input[type=""number""], '+
            '#page_content form.lock-page select').each(function (i) {
        $(this).data('lock-id', i);
        // val-hash is the hash of default value of the field
        // so that it can be compared with new value hash
        // to check whether field was modified or not.
        $(this).data('val-hash', AJAX.hash($(this).val()));
    });

    // initializes lock-page elements (input types checkbox and radio buttons)
    // lock-id and val-hash data property
    $('#page_content form.lock-page input[type=""checkbox""], ' +
            '#page_content form.lock-page input[type=""radio""]').each(function (i) {
        $(this).data('lock-id', i);
        $(this).data('val-hash', AJAX.hash($(this).is("":checked"")));
    });
});
/**
 * jQuery plugin to cancel selection in HTML code.
 */
(function ($) {
    $.fn.noSelect = function (p) { //no select plugin by Paulo P.Marinas
        var prevent = (p === null) ? true : p;
        var is_msie = navigator.userAgent.indexOf('MSIE') > -1 || !!window.navigator.userAgent.match(/Trident.*rv\:11\./);
        var is_firefox = navigator.userAgent.indexOf('Firefox') > -1;
        var is_safari = navigator.userAgent.indexOf(""Safari"") > -1;
        var is_opera = navigator.userAgent.indexOf(""Presto"") > -1;
        if (prevent) {
            return this.each(function () {
                if (is_msie || is_safari) {
                    $(this).bind('selectstart', function () {
                        return false;
                    });
                } else if (is_firefox) {
                    $(this).css('MozUserSelect', 'none');
                    $('body').trigger('focus');
                } else if (is_opera) {
                    $(this).bind('mousedown', function () {
                        return false;
                    });
                } else {
                    $(this).attr('unselectable', 'on');
                }
            });
        } else {
            return this.each(function () {
                if (is_msie || is_safari) {
                    $(this).unbind('selectstart');
                } else if (is_firefox) {
                    $(this).css('MozUserSelect', 'inherit');
                } else if (is_opera) {
                    $(this).unbind('mousedown');
                } else {
                    $(this).removeAttr('unselectable');
                }
            });
        }
    }; //end noSelect
})(jQuery);

/**
 * jQuery plugin to correctly filter input fields by value, needed
 * because some nasty values may break selector syntax
 */
(function ($) {
    $.fn.filterByValue = function (value) {
        return this.filter(function () {
            return $(this).val() === value;
        });
    };
})(jQuery);

/**
 * Return value of a cell in a table.
 */
function PMA_getCellValue(td) {
    var $td = $(td);
    if ($td.is('.null')) {
        return '';
    } else if ((! $td.is('.to_be_saved')
        || $td.is('.set'))
        && $td.data('original_data')
    ) {
        return $td.data('original_data');
    } else {
        return $td.text();
    }
}

/**
 * Unbind all event handlers before tearing down a page
 */
AJAX.registerTeardown('functions.js', function () {
    $(document).off('click', 'a.themeselect');
    $(document).off('change', '.autosubmit');
    $('a.take_theme').unbind('click');
});

AJAX.registerOnload('functions.js', function () {
    /**
     * Theme selector.
     */
    $(document).on('click', 'a.themeselect', function (e) {
        window.open(
            e.target,
            'themes',
            'left=10,top=20,width=510,height=350,scrollbars=yes,status=yes,resizable=yes'
            );
        return false;
    });

    /**
     * Automatic form submission on change.
     */
    $(document).on('change', '.autosubmit', function (e) {
        $(this).closest('form').submit();
    });

    /**
     * Theme changer.
     */
    $('a.take_theme').click(function (e) {
        var what = this.name;
        if (window.opener && window.opener.document.forms.setTheme.elements.set_theme) {
            window.opener.document.forms.setTheme.elements.set_theme.value = what;
            window.opener.document.forms.setTheme.submit();
            window.close();
            return false;
        }
        return true;
    });
});

/**
 * Print button
 */
function printPage()
{
    // Do print the page
    if (typeof(window.print) != 'undefined') {
        window.print();
    }
}

/**
 * Unbind all event handlers before tearing down a page
 */
AJAX.registerTeardown('functions.js', function () {
    $('input#print').unbind('click');
    $(document).off('click', 'a.create_view.ajax');
    $(document).off('keydown', '#createViewDialog input, #createViewDialog select');
    $(document).off('change', '#fkc_checkbox');
});

AJAX.registerOnload('functions.js', function () {
    $('input#print').click(printPage);
    /**
     * Ajaxification for the ""Create View"" action
     */
    $(document).on('click', 'a.create_view.ajax', function (e) {
        e.preventDefault();
        PMA_createViewDialog($(this));
    });
    /**
     * Attach Ajax event handlers for input fields in the editor
     * and used to submit the Ajax request when the ENTER key is pressed.
     */
    if ($('#createViewDialog').length !== 0) {
        $(document).on('keydown', '#createViewDialog input, #createViewDialog select', function (e) {
            if (e.which === 13) { // 13 is the ENTER key
                e.preventDefault();

                // with preventing default, selection by <select> tag
                // was also prevented in IE
                $(this).blur();

                $(this).closest('.ui-dialog').find('.ui-button:first').click();
            }
        }); // end $(document).on()
    }

    syntaxHighlighter = PMA_getSQLEditor($('textarea[name=""view[as]""]'));

});

function PMA_createViewDialog($this)
{
    var $msg = PMA_ajaxShowMessage();
    var syntaxHighlighter = null;
    $.get($this.attr('href') + '&ajax_request=1&ajax_dialog=1', function (data) {
        if (typeof data !== 'undefined' && data.success === true) {
            PMA_ajaxRemoveMessage($msg);
            var buttonOptions = {};
            buttonOptions[PMA_messages.strGo] = function () {
                if (typeof CodeMirror !== 'undefined') {
                    syntaxHighlighter.save();
                }
                $msg = PMA_ajaxShowMessage();
                $.get('view_create.php', $('#createViewDialog').find('form').serialize(), function (data) {
                    PMA_ajaxRemoveMessage($msg);
                    if (typeof data !== 'undefined' && data.success === true) {
                        $('#createViewDialog').dialog(""close"");
                        $('.result_query').html(data.message);
                        PMA_reloadNavigation();
                    } else {
                        PMA_ajaxShowMessage(data.error, false);
                    }
                });
            };
            buttonOptions[PMA_messages.strClose] = function () {
                $(this).dialog(""close"");
            };
            var $dialog = $('<div/>').attr('id', 'createViewDialog').append(data.message).dialog({
                width: 600,
                minWidth: 400,
                modal: true,
                buttons: buttonOptions,
                title: PMA_messages.strCreateView,
                close: function () {
                    $(this).remove();
                }
            });
            // Attach syntax highlighted editor
            syntaxHighlighter = PMA_getSQLEditor($dialog.find('textarea'));
            $('input:visible[type=text]', $dialog).first().focus();
        } else {
            PMA_ajaxShowMessage(data.error);
        }
    });
}

/**
 * Makes the breadcrumbs and the menu bar float at the top of the viewport
 */
$(function () {
    if ($(""#floating_menubar"").length && $('#PMA_disable_floating_menubar').length === 0) {
        var left = $('html').attr('dir') == 'ltr' ? 'left' : 'right';
        $(""#floating_menubar"")
            .css('margin-' + left, $('#pma_navigation').width() + $('#pma_navigation_resizer').width())
            .css(left, 0)
            .css({
                'position': 'fixed',
                'top': 0,
                'width': '100%',
                'z-index': 99
            })
            .append($('#serverinfo'))
            .append($('#topmenucontainer'));
        // Allow the DOM to render, then adjust the padding on the body
        setTimeout(function () {
            $('body').css(
                'padding-top',
                $('#floating_menubar').outerHeight(true)
            );
            $('#topmenu').menuResizer('resize');
        }, 4);
    }
});

/**
 * Scrolls the page to the top if clicking the serverinfo bar
 */
$(function () {
    $(document).delegate(""#serverinfo, #goto_pagetop"", ""click"", function (event) {
        event.preventDefault();
        $('html, body').animate({scrollTop: 0}, 'fast');
    });
});

var checkboxes_sel = ""input.checkall:checkbox:enabled"";
/**
 * Watches checkboxes in a form to set the checkall box accordingly
 */
var checkboxes_changed = function () {
    var $form = $(this.form);
    // total number of checkboxes in current form
    var total_boxes = $form.find(checkboxes_sel).length;
    // number of checkboxes checked in current form
    var checked_boxes = $form.find(checkboxes_sel + "":checked"").length;
    var $checkall = $form.find(""input.checkall_box"");
    if (total_boxes == checked_boxes) {
        $checkall.prop({checked: true, indeterminate: false});
    }
    else if (checked_boxes > 0) {
        $checkall.prop({checked: true, indeterminate: true});
    }
    else {
        $checkall.prop({checked: false, indeterminate: false});
    }
};
$(document).on(""change"", checkboxes_sel, checkboxes_changed);

$(document).on(""change"", ""input.checkall_box"", function () {
    var is_checked = $(this).is("":checked"");
    $(this.form).find(checkboxes_sel).prop(""checked"", is_checked)
    .parents(""tr"").toggleClass(""marked"", is_checked);
});

/**
 * Watches checkboxes in a sub form to set the sub checkall box accordingly
 */
var sub_checkboxes_changed = function () {
    var $form = $(this).parent().parent();
    // total number of checkboxes in current sub form
    var total_boxes = $form.find(checkboxes_sel).length;
    // number of checkboxes checked in current sub form
    var checked_boxes = $form.find(checkboxes_sel + "":checked"").length;
    var $checkall = $form.find(""input.sub_checkall_box"");
    if (total_boxes == checked_boxes) {
        $checkall.prop({checked: true, indeterminate: false});
    }
    else if (checked_boxes > 0) {
        $checkall.prop({checked: true, indeterminate: true});
    }
    else {
        $checkall.prop({checked: false, indeterminate: false});
    }
};
$(document).on(""change"", checkboxes_sel + "", input.checkall_box:checkbox:enabled"", sub_checkboxes_changed);

$(document).on(""change"", ""input.sub_checkall_box"", function () {
    var is_checked = $(this).is("":checked"");
    var $form = $(this).parent().parent();
    $form.find(checkboxes_sel).prop(""checked"", is_checked)
    .parents(""tr"").toggleClass(""marked"", is_checked);
});

/**
 * Toggles row colors of a set of 'tr' elements starting from a given element
 *
 * @param $start Starting element
 */
function toggleRowColors($start)
{
    for (var $curr_row = $start; $curr_row.length > 0; $curr_row = $curr_row.next()) {
        if ($curr_row.hasClass('odd')) {
            $curr_row.removeClass('odd').addClass('even');
        } else if ($curr_row.hasClass('even')) {
            $curr_row.removeClass('even').addClass('odd');
        }
    }
}

/**
 * Formats a byte number to human-readable form
 *
 * @param bytes the bytes to format
 * @param optional subdecimals the number of digits after the point
 * @param optional pointchar the char to use as decimal point
 */
function formatBytes(bytes, subdecimals, pointchar) {
    if (!subdecimals) {
        subdecimals = 0;
    }
    if (!pointchar) {
        pointchar = '.';
    }
    var units = ['B', 'KiB', 'MiB', 'GiB'];
    for (var i = 0; bytes > 1024 && i < units.length; i++) {
        bytes /= 1024;
    }
    var factor = Math.pow(10, subdecimals);
    bytes = Math.round(bytes * factor) / factor;
    bytes = bytes.toString().split('.').join(pointchar);
    return bytes + ' ' + units[i];
}

AJAX.registerOnload('functions.js', function () {
    /**
     * Opens pma more themes link in themes browser, in new window instead of popup
     * This way, we don't break HTML validity
     */
    $(""a._blank"").prop(""target"", ""_blank"");
    /**
     * Reveal the login form to users with JS enabled
     * and focus the appropriate input field
     */
    var $loginform = $('#loginform');
    if ($loginform.length) {
        $loginform.find('.js-show').show();
        if ($('#input_username').val()) {
            $('#input_password').focus();
        } else {
            $('#input_username').focus();
        }
    }
});

/**
 * Dynamically adjust the width of the boxes
 * on the table and db operations pages
 */
(function () {
    function DynamicBoxes() {
        var $boxContainer = $('#boxContainer');
        if ($boxContainer.length) {
            var minWidth = $boxContainer.data('box-width');
            var viewport = $(window).width() - $('#pma_navigation').width();
            var slots = Math.floor(viewport / minWidth);
            $boxContainer.children()
            .each(function () {
                if (viewport < minWidth) {
                    $(this).width(minWidth);
                } else {
                    $(this).css('width', ((1 /  slots) * 100) + ""%"");
                }
            })
            .removeClass('clearfloat')
            .filter(':nth-child(' + slots + 'n+1)')
            .addClass('clearfloat');
        }
    }
    AJAX.registerOnload('functions.js', function () {
        DynamicBoxes();
    });
    $(function () {
        $(window).resize(DynamicBoxes);
    });
})();

/**
 * Formats timestamp for display
 */
function PMA_formatDateTime(date, seconds) {
    var result = $.datepicker.formatDate('yy-mm-dd', date);
    var timefmt = 'HH:mm';
    if (seconds) {
        timefmt = 'HH:mm:ss';
    }
    return result + ' ' + $.datepicker.formatTime(
        timefmt, {
            hour: date.getHours(),
            minute: date.getMinutes(),
            second: date.getSeconds()
        }
    );
}

/**
 * Check than forms have less fields than max allowed by PHP.
 */
function checkNumberOfFields() {
    if (typeof maxInputVars === 'undefined') {
        return false;
    }
    if (false === maxInputVars) {
        return false;
    }
    $('form').each(function() {
        var nbInputs = $(this).find(':input').length;
        if (nbInputs > maxInputVars) {
            var warning = PMA_sprintf(PMA_messages.strTooManyInputs, maxInputVars);
            PMA_ajaxShowMessage(warning);
            return false;
        }
        return true;
    });

    return true;
}

/**
 * Ignore the displayed php errors.
 * Simply removes the displayed errors.
 *
 * @param  clearPrevErrors whether to clear errors stored
 *             in $_SESSION['prev_errors'] at server
 *
 */
function PMA_ignorePhpErrors(clearPrevErrors){
    if (typeof(clearPrevErrors) === ""undefined"" ||
        clearPrevErrors === null
    ) {
        str = false;
    }
    // send AJAX request to error_report.php with send_error_report=0, exception_type=php & token.
    // It clears the prev_errors stored in session.
    if(clearPrevErrors){
        var $pmaReportErrorsForm = $('#pma_report_errors_form');
        $pmaReportErrorsForm.find('input[name=""send_error_report""]').val(0); // change send_error_report to '0'
        $pmaReportErrorsForm.submit();
    }

    // remove displayed errors
    var $pmaErrors = $('#pma_errors');
    $pmaErrors.fadeOut( ""slow"");
    $pmaErrors.remove();
}

/**
 * checks whether browser supports web storage
 *
 * @param type the type of storage i.e. localStorage or sessionStorage
 *
 * @returns bool
 */
function isStorageSupported(type)
{
    try {
        window[type].setItem('PMATest', 'test');
        // Check whether key-value pair was set successfully
        if (window[type].getItem('PMATest') === 'test') {
            // Supported, remove test variable from storage
            window[type].removeItem('PMATest');
            return true;
        }
    } catch(error) {
        // Not supported
        PMA_ajaxShowMessage(PMA_messages.strNoLocalStorage, false);
    }
    return false;
}

/**
 * Unbind all event handlers before tearing down a page
 */
AJAX.registerTeardown('functions.js', function(){
    $(document).off('keydown', 'form input, form textarea, form select');
});

AJAX.registerOnload('functions.js', function () {
    /**
     * Handle 'Ctrl/Alt + Enter' form submits
     */
    $('form input, form textarea, form select').on('keydown', function(e){
        if((e.ctrlKey && e.which == 13) || (e.altKey && e.which == 13)) {
            $form = $(this).closest('form');
            if (! $form.find('input[type=""submit""]') ||
                ! $form.find('input[type=""submit""]').click()
            ) {
                $form.submit();
            }
        }
    });
});

/**
 * Unbind all event handlers before tearing down a page
 */
AJAX.registerTeardown('functions.js', function(){
    $(document).off('change', 'input[type=radio][name=""pw_hash""]');
});

AJAX.registerOnload('functions.js', function(){
    /*
     * Display warning regarding SSL when sha256_password
     * method is selected
     * Used in user_password.php (Change Password link on index.php)
     */
    $(document).on(""change"", 'select#select_authentication_plugin_cp', function() {
        if (this.value === 'sha256_password') {
            $('#ssl_reqd_warning_cp').show();
        } else {
            $('#ssl_reqd_warning_cp').hide();
        }
    });
});
","/* vim: set expandtab sw=4 ts=4 sts=4: */
/**
 * general function, usually for data manipulation pages
 *
 */

/**
 * @var sql_box_locked lock for the sqlbox textarea in the querybox
 */
var sql_box_locked = false;

/**
 * @var array holds elements which content should only selected once
 */
var only_once_elements = [];

/**
 * @var   int   ajax_message_count   Number of AJAX messages shown since page load
 */
var ajax_message_count = 0;

/**
 * @var codemirror_editor object containing CodeMirror editor of the query editor in SQL tab
 */
var codemirror_editor = false;

/**
 * @var codemirror_editor object containing CodeMirror editor of the inline query editor
 */
var codemirror_inline_editor = false;

/**
 * @var sql_autocomplete_in_progress bool shows if Table/Column name autocomplete AJAX is in progress
 */
var sql_autocomplete_in_progress = false;

/**
 * @var sql_autocomplete object containing list of columns in each table
 */
var sql_autocomplete = false;

/**
 * @var sql_autocomplete_default_table string containing default table to autocomplete columns
 */
var sql_autocomplete_default_table = '';

/**
 * @var chart_activeTimeouts object active timeouts that refresh the charts. When disabling a realtime chart, this can be used to stop the continuous ajax requests
 */
var chart_activeTimeouts = {};

/**
 * @var central_column_list array to hold the columns in central list per db.
 */
var central_column_list = [];

/**
 * @var primary_indexes array to hold 'Primary' index columns.
 */
var primary_indexes = [];

/**
 * @var unique_indexes array to hold 'Unique' index columns.
 */
var unique_indexes = [];

/**
 * @var indexes array to hold 'Index' columns.
 */
var indexes = [];

/**
 * @var fulltext_indexes array to hold 'Fulltext' columns.
 */
var fulltext_indexes = [];

/**
 * @var spatial_indexes array to hold 'Spatial' columns.
 */
var spatial_indexes = [];

/**
 * Make sure that ajax requests will not be cached
 * by appending a random variable to their parameters
 */
$.ajaxPrefilter(function (options, originalOptions, jqXHR) {
    var nocache = new Date().getTime() + """" + Math.floor(Math.random() * 1000000);
    if (typeof options.data == ""string"") {
        options.data += ""&_nocache="" + nocache;
    } else if (typeof options.data == ""object"") {
        options.data = $.extend(originalOptions.data, {'_nocache' : nocache});
    }
});

/**
 * Hanle redirect and reload flags send as part of AJAX requests
 *
 * @param data ajax response data
 */
function PMA_handleRedirectAndReload(data) {
    if (parseInt(data.redirect_flag) == 1) {
        // add one more GET param to display session expiry msg
        if (window.location.href.indexOf('?') === -1) {
            window.location.href += '?session_expired=1';
        } else {
            window.location.href += '&session_expired=1';
        }
        window.location.reload();
    } else if (parseInt(data.reload_flag) == 1) {
        // remove the token param and reload
        window.location.href = window.location.href.replace(/&?token=[^&#]*/g, """");
        window.location.reload();
    }
}

/**
 * Creates an SQL editor which supports auto completing etc.
 *
 * @param $textarea jQuery object wrapping the textarea to be made the editor
 * @param options   optional options for CodeMirror
 * @param resize    optional resizing ('vertical', 'horizontal', 'both')
 */
function PMA_getSQLEditor($textarea, options, resize) {
    if ($textarea.length > 0 && typeof CodeMirror !== 'undefined') {

        // merge options for CodeMirror
        var defaults = {
            lineNumbers: true,
            matchBrackets: true,
            extraKeys: {""Ctrl-Space"": ""autocomplete""},
            hintOptions: {""completeSingle"": false, ""completeOnSingleClick"": true},
            indentUnit: 4,
            mode: ""text/x-mysql"",
            lineWrapping: true
        };

        if (CodeMirror.sqlLint) {
            $.extend(defaults, {
                gutters: [""CodeMirror-lint-markers""],
                lint: {
                    ""getAnnotations"": CodeMirror.sqlLint,
                    ""async"": true,
                }
            });
        }

        $.extend(true, defaults, options);

        // create CodeMirror editor
        var codemirrorEditor = CodeMirror.fromTextArea($textarea[0], defaults);
        // allow resizing
        if (! resize) {
            resize = 'vertical';
        }
        var handles = '';
        if (resize == 'vertical') {
            handles = 'n, s';
        }
        if (resize == 'both') {
            handles = 'all';
        }
        if (resize == 'horizontal') {
            handles = 'e, w';
        }
        $(codemirrorEditor.getWrapperElement())
            .css('resize', resize)
            .resizable({
                handles: handles,
                resize: function() {
                    codemirrorEditor.setSize($(this).width(), $(this).height());
                }
            });
        // enable autocomplete
        codemirrorEditor.on(""inputRead"", codemirrorAutocompleteOnInputRead);

        return codemirrorEditor;
    }
    return null;
}

/**
 * Clear text selection
 */
function PMA_clearSelection() {
    if (document.selection && document.selection.empty) {
        document.selection.empty();
    } else if (window.getSelection) {
        var sel = window.getSelection();
        if (sel.empty) {
            sel.empty();
        }
        if (sel.removeAllRanges) {
            sel.removeAllRanges();
        }
    }
}

/**
 * Create a jQuery UI tooltip
 *
 * @param $elements     jQuery object representing the elements
 * @param item          the item
 *                      (see http://api.jqueryui.com/tooltip/#option-items)
 * @param myContent     content of the tooltip
 * @param additionalOptions to override the default options
 *
 */
function PMA_tooltip($elements, item, myContent, additionalOptions)
{
    if ($('#no_hint').length > 0) {
        return;
    }

    var defaultOptions = {
        content: myContent,
        items:  item,
        tooltipClass: ""tooltip"",
        track: true,
        show: false,
        hide: false
    };

    $elements.tooltip($.extend(true, defaultOptions, additionalOptions));
}

/**
 * HTML escaping
 */

function escapeHtml(unsafe) {
    if (typeof(unsafe) != 'undefined') {
        return unsafe
            .toString()
            .replace(/&/g, ""&amp;"")
            .replace(/</g, ""&lt;"")
            .replace(/>/g, ""&gt;"")
            .replace(/""/g, ""&quot;"")
            .replace(/'/g, ""&#039;"");
    } else {
        return false;
    }
}

function PMA_sprintf() {
    return sprintf.apply(this, arguments);
}

/**
 * Hides/shows the default value input field, depending on the default type
 * Ticks the NULL checkbox if NULL is chosen as default value.
 */
function PMA_hideShowDefaultValue($default_type)
{
    if ($default_type.val() == 'USER_DEFINED') {
        $default_type.siblings('.default_value').show().focus();
    } else {
        $default_type.siblings('.default_value').hide();
        if ($default_type.val() == 'NULL') {
            var $null_checkbox = $default_type.closest('tr').find('.allow_null');
            $null_checkbox.prop('checked', true);
        }
    }
}

/**
 * Hides/shows the input field for column expression based on whether
 * VIRTUAL/PERSISTENT is selected
 *
 * @param $virtuality virtuality dropdown
 */
function PMA_hideShowExpression($virtuality)
{
    if ($virtuality.val() == '') {
        $virtuality.siblings('.expression').hide();
    } else {
        $virtuality.siblings('.expression').show();
    }
}

/**
 * Show notices for ENUM columns; add/hide the default value
 *
 */
function PMA_verifyColumnsProperties()
{
    $(""select.column_type"").each(function () {
        PMA_showNoticeForEnum($(this));
    });
    $(""select.default_type"").each(function () {
        PMA_hideShowDefaultValue($(this));
    });
    $('select.virtuality').each(function () {
        PMA_hideShowExpression($(this));
    });
}

/**
 * Add a hidden field to the form to indicate that this will be an
 * Ajax request (only if this hidden field does not exist)
 *
 * @param $form object   the form
 */
function PMA_prepareForAjaxRequest($form)
{
    if (! $form.find('input:hidden').is('#ajax_request_hidden')) {
        $form.append('<input type=""hidden"" id=""ajax_request_hidden"" name=""ajax_request"" value=""true"" />');
    }
}

/**
 * Generate a new password and copy it to the password input areas
 *
 * @param passwd_form object   the form that holds the password fields
 *
 * @return boolean  always true
 */
function suggestPassword(passwd_form)
{
    // restrict the password to just letters and numbers to avoid problems:
    // ""editors and viewers regard the password as multiple words and
    // things like double click no longer work""
    var pwchars = ""abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWYXZ"";
    var passwordlength = 16;    // do we want that to be dynamic?  no, keep it simple :)
    var passwd = passwd_form.generated_pw;
    var randomWords = new Int32Array(passwordlength);

    passwd.value = '';

    // First we're going to try to use a built-in CSPRNG
    if (window.crypto && window.crypto.getRandomValues) {
        window.crypto.getRandomValues(randomWords);
    }
    // Because of course IE calls it msCrypto instead of being standard
    else if (window.msCrypto && window.msCrypto.getRandomValues) {
        window.msCrypto.getRandomValues(randomWords);
    } else {
        // Fallback to Math.random
        for (var i = 0; i < passwordlength; i++) {
            randomWords[i] = Math.floor(Math.random() * pwchars.length);
        }
    }

    for (var i = 0; i < passwordlength; i++) {
        passwd.value += pwchars.charAt(Math.abs(randomWords[i]) % pwchars.length);
    }

    passwd_form.text_pma_pw.value = passwd.value;
    passwd_form.text_pma_pw2.value = passwd.value;
    return true;
}

/**
 * Version string to integer conversion.
 */
function parseVersionString(str)
{
    if (typeof(str) != 'string') { return false; }
    var add = 0;
    // Parse possible alpha/beta/rc/
    var state = str.split('-');
    if (state.length >= 2) {
        if (state[1].substr(0, 2) == 'rc') {
            add = - 20 - parseInt(state[1].substr(2), 10);
        } else if (state[1].substr(0, 4) == 'beta') {
            add =  - 40 - parseInt(state[1].substr(4), 10);
        } else if (state[1].substr(0, 5) == 'alpha') {
            add =  - 60 - parseInt(state[1].substr(5), 10);
        } else if (state[1].substr(0, 3) == 'dev') {
            /* We don't handle dev, it's git snapshot */
            add = 0;
        }
    }
    // Parse version
    var x = str.split('.');
    // Use 0 for non existing parts
    var maj = parseInt(x[0], 10) || 0;
    var min = parseInt(x[1], 10) || 0;
    var pat = parseInt(x[2], 10) || 0;
    var hotfix = parseInt(x[3], 10) || 0;
    return  maj * 100000000 + min * 1000000 + pat * 10000 + hotfix * 100 + add;
}

/**
 * Indicates current available version on main page.
 */
function PMA_current_version(data)
{
    if (data && data.version && data.date) {
        var current = parseVersionString($('span.version').text());
        var latest = parseVersionString(data.version);
        var version_information_message = '<span class=""latest"">' +
            PMA_messages.strLatestAvailable +
            ' ' + escapeHtml(data.version) +
            '</span>';
        if (latest > current) {
            var message = PMA_sprintf(
                PMA_messages.strNewerVersion,
                escapeHtml(data.version),
                escapeHtml(data.date)
            );
            var htmlClass = 'notice';
            if (Math.floor(latest / 10000) === Math.floor(current / 10000)) {
                /* Security update */
                htmlClass = 'error';
            }
            $('#newer_version_notice').remove();
            $('#maincontainer').after('<div id=""newer_version_notice"" class=""' + htmlClass + '"">' + message + '</div>');
        }
        if (latest === current) {
            version_information_message = ' (' + PMA_messages.strUpToDate + ')';
        }
        var $liPmaVersion = $('#li_pma_version');
        $liPmaVersion.find('span.latest').remove();
        $liPmaVersion.append(version_information_message);
    }
}

/**
 * Loads Git revision data from ajax for index.php
 */
function PMA_display_git_revision()
{
    $('#is_git_revision').remove();
    $('#li_pma_version_git').remove();
    $.get(
        ""index.php"",
        {
            ""server"": PMA_commonParams.get('server'),
            ""token"": PMA_commonParams.get('token'),
            ""git_revision"": true,
            ""ajax_request"": true,
            ""no_debug"": true
        },
        function (data) {
            if (typeof data !== 'undefined' && data.success === true) {
                $(data.message).insertAfter('#li_pma_version');
            }
        }
    );
}

/**
 * for libraries/display_change_password.lib.php
 *     libraries/user_password.php
 *
 */

function displayPasswordGenerateButton()
{
    $('#tr_element_before_generate_password').parent().append('<tr class=""vmiddle""><td>' + PMA_messages.strGeneratePassword + '</td><td><input type=""button"" class=""button"" id=""button_generate_password"" value=""' + PMA_messages.strGenerate + '"" onclick=""suggestPassword(this.form)"" /><input type=""text"" name=""generated_pw"" id=""generated_pw"" /></td></tr>');
    $('#div_element_before_generate_password').parent().append('<div class=""item""><label for=""button_generate_password"">' + PMA_messages.strGeneratePassword + ':</label><span class=""options""><input type=""button"" class=""button"" id=""button_generate_password"" value=""' + PMA_messages.strGenerate + '"" onclick=""suggestPassword(this.form)"" /></span><input type=""text"" name=""generated_pw"" id=""generated_pw"" /></div>');
}

/*
 * Adds a date/time picker to an element
 *
 * @param object  $this_element   a jQuery object pointing to the element
 */
function PMA_addDatepicker($this_element, type, options)
{
    var showTimepicker = true;
    if (type==""date"") {
        showTimepicker = false;
    }

    var defaultOptions = {
        showOn: 'button',
        buttonImage: themeCalendarImage, // defined in js/messages.php
        buttonImageOnly: true,
        stepMinutes: 1,
        stepHours: 1,
        showSecond: true,
        showMillisec: true,
        showMicrosec: true,
        showTimepicker: showTimepicker,
        showButtonPanel: false,
        dateFormat: 'yy-mm-dd', // yy means year with four digits
        timeFormat: 'HH:mm:ss.lc',
        constrainInput: false,
        altFieldTimeOnly: false,
        showAnim: '',
        beforeShow: function (input, inst) {
            // Remember that we came from the datepicker; this is used
            // in tbl_change.js by verificationsAfterFieldChange()
            $this_element.data('comes_from', 'datepicker');
            if ($(input).closest('.cEdit').length > 0) {
                setTimeout(function () {
                    inst.dpDiv.css({
                        top: 0,
                        left: 0,
                        position: 'relative'
                    });
                }, 0);
            }
            // Fix wrong timepicker z-index, doesn't work without timeout
            setTimeout(function () {
                $('#ui-timepicker-div').css('z-index', $('#ui-datepicker-div').css('z-index'));
            }, 0);
        },
        onSelect: function() {
            $this_element.data('datepicker').inline = true;
        },
        onClose: function (dateText, dp_inst) {
            // The value is no more from the date picker
            $this_element.data('comes_from', '');
            if (typeof $this_element.data('datepicker') !== 'undefined') {
                $this_element.data('datepicker').inline = false;
            }
        }
    };
    if (type == ""datetime"" || type == ""timestamp"") {
        $this_element.datetimepicker($.extend(defaultOptions, options));
    }
    else if (type == ""date"") {
        $this_element.datetimepicker($.extend(defaultOptions, options));
    }
    else if (type == ""time"") {
        $this_element.timepicker($.extend(defaultOptions, options));
    }
}

/**
 * selects the content of a given object, f.e. a textarea
 *
 * @param element     object  element of which the content will be selected
 * @param lock        var     variable which holds the lock for this element
 *                              or true, if no lock exists
 * @param only_once   boolean if true this is only done once
 *                              f.e. only on first focus
 */
function selectContent(element, lock, only_once)
{
    if (only_once && only_once_elements[element.name]) {
        return;
    }

    only_once_elements[element.name] = true;

    if (lock) {
        return;
    }

    element.select();
}

/**
 * Displays a confirmation box before submitting a ""DROP/DELETE/ALTER"" query.
 * This function is called while clicking links
 *
 * @param theLink     object the link
 * @param theSqlQuery object the sql query to submit
 *
 * @return boolean  whether to run the query or not
 */
function confirmLink(theLink, theSqlQuery)
{
    // Confirmation is not required in the configuration file
    // or browser is Opera (crappy js implementation)
    if (PMA_messages.strDoYouReally === '' || typeof(window.opera) != 'undefined') {
        return true;
    }

    var is_confirmed = confirm(PMA_sprintf(PMA_messages.strDoYouReally, theSqlQuery));
    if (is_confirmed) {
        if ($(theLink).hasClass('formLinkSubmit')) {
            var name = 'is_js_confirmed';
            if ($(theLink).attr('href').indexOf('usesubform') != -1) {
                name = 'subform[' + $(theLink).attr('href').substr('#').match(/usesubform\[(\d+)\]/i)[1] + '][is_js_confirmed]';
            }

            $(theLink).parents('form').append('<input type=""hidden"" name=""' + name + '"" value=""1"" />');
        } else if (typeof(theLink.href) != 'undefined') {
            theLink.href += '&is_js_confirmed=1';
        } else if (typeof(theLink.form) != 'undefined') {
            theLink.form.action += '?is_js_confirmed=1';
        }
    }

    return is_confirmed;
} // end of the 'confirmLink()' function

/**
 * Displays an error message if a ""DROP DATABASE"" statement is submitted
 * while it isn't allowed, else confirms a ""DROP/DELETE/ALTER"" query before
 * submitting it if required.
 * This function is called by the 'checkSqlQuery()' js function.
 *
 * @param theForm1 object   the form
 * @param sqlQuery1 object  the sql query textarea
 *
 * @return boolean  whether to run the query or not
 *
 * @see     checkSqlQuery()
 */
function confirmQuery(theForm1, sqlQuery1)
{
    // Confirmation is not required in the configuration file
    if (PMA_messages.strDoYouReally === '') {
        return true;
    }

    // ""DROP DATABASE"" statement isn't allowed
    if (PMA_messages.strNoDropDatabases !== '') {
        var drop_re = new RegExp('(^|;)\\s*DROP\\s+(IF EXISTS\\s+)?DATABASE\\s', 'i');
        if (drop_re.test(sqlQuery1.value)) {
            alert(PMA_messages.strNoDropDatabases);
            theForm1.reset();
            sqlQuery1.focus();
            return false;
        } // end if
    } // end if

    // Confirms a ""DROP/DELETE/ALTER/TRUNCATE"" statement
    //
    // TODO: find a way (if possible) to use the parser-analyser
    // for this kind of verification
    // For now, I just added a ^ to check for the statement at
    // beginning of expression

    var do_confirm_re_0 = new RegExp('^\\s*DROP\\s+(IF EXISTS\\s+)?(TABLE|DATABASE|PROCEDURE)\\s', 'i');
    var do_confirm_re_1 = new RegExp('^\\s*ALTER\\s+TABLE\\s+((`[^`]+`)|([A-Za-z0-9_$]+))\\s+DROP\\s', 'i');
    var do_confirm_re_2 = new RegExp('^\\s*DELETE\\s+FROM\\s', 'i');
    var do_confirm_re_3 = new RegExp('^\\s*TRUNCATE\\s', 'i');

    if (do_confirm_re_0.test(sqlQuery1.value) ||
        do_confirm_re_1.test(sqlQuery1.value) ||
        do_confirm_re_2.test(sqlQuery1.value) ||
        do_confirm_re_3.test(sqlQuery1.value)) {
        var message;
        if (sqlQuery1.value.length > 100) {
            message = sqlQuery1.value.substr(0, 100) + '\n    ...';
        } else {
            message = sqlQuery1.value;
        }
        var is_confirmed = confirm(PMA_sprintf(PMA_messages.strDoYouReally, message));
        // statement is confirmed -> update the
        // ""is_js_confirmed"" form field so the confirm test won't be
        // run on the server side and allows to submit the form
        if (is_confirmed) {
            theForm1.elements.is_js_confirmed.value = 1;
            return true;
        }
        // statement is rejected -> do not submit the form
        else {
            window.focus();
            sqlQuery1.focus();
            return false;
        } // end if (handle confirm box result)
    } // end if (display confirm box)

    return true;
} // end of the 'confirmQuery()' function

/**
 * Displays an error message if the user submitted the sql query form with no
 * sql query, else checks for ""DROP/DELETE/ALTER"" statements
 *
 * @param theForm object the form
 *
 * @return boolean  always false
 *
 * @see     confirmQuery()
 */
function checkSqlQuery(theForm)
{
    // get the textarea element containing the query
    var sqlQuery;
    if (codemirror_editor) {
        codemirror_editor.save();
        sqlQuery = codemirror_editor.getValue();
    } else {
        sqlQuery = theForm.elements.sql_query.value;
    }
    var isEmpty  = 1;
    var space_re = new RegExp('\\s+');
    if (typeof(theForm.elements.sql_file) != 'undefined' &&
            theForm.elements.sql_file.value.replace(space_re, '') !== '') {
        return true;
    }
    if (isEmpty && typeof(theForm.elements.id_bookmark) != 'undefined' &&
            (theForm.elements.id_bookmark.value !== null || theForm.elements.id_bookmark.value !== '') &&
            theForm.elements.id_bookmark.selectedIndex !== 0) {
        return true;
    }
    // Checks for ""DROP/DELETE/ALTER"" statements
    if (sqlQuery.replace(space_re, '') !== '') {
        return confirmQuery(theForm, sqlQuery);
    }
    theForm.reset();
    isEmpty = 1;

    if (isEmpty) {
        alert(PMA_messages.strFormEmpty);
        codemirror_editor.focus();
        return false;
    }

    return true;
} // end of the 'checkSqlQuery()' function

/**
 * Check if a form's element is empty.
 * An element containing only spaces is also considered empty
 *
 * @param object   the form
 * @param string   the name of the form field to put the focus on
 *
 * @return boolean  whether the form field is empty or not
 */
function emptyCheckTheField(theForm, theFieldName)
{
    var theField = theForm.elements[theFieldName];
    var space_re = new RegExp('\\s+');
    return theField.value.replace(space_re, '') === '';
} // end of the 'emptyCheckTheField()' function

/**
 * Ensures a value submitted in a form is numeric and is in a range
 *
 * @param object   the form
 * @param string   the name of the form field to check
 * @param integer  the minimum authorized value
 * @param integer  the maximum authorized value
 *
 * @return boolean  whether a valid number has been submitted or not
 */
function checkFormElementInRange(theForm, theFieldName, message, min, max)
{
    var theField         = theForm.elements[theFieldName];
    var val              = parseInt(theField.value, 10);

    if (typeof(min) == 'undefined') {
        min = 0;
    }
    if (typeof(max) == 'undefined') {
        max = Number.MAX_VALUE;
    }

    // It's not a number
    if (isNaN(val)) {
        theField.select();
        alert(PMA_messages.strEnterValidNumber);
        theField.focus();
        return false;
    }
    // It's a number but it is not between min and max
    else if (val < min || val > max) {
        theField.select();
        alert(PMA_sprintf(message, val));
        theField.focus();
        return false;
    }
    // It's a valid number
    else {
        theField.value = val;
    }
    return true;

} // end of the 'checkFormElementInRange()' function


function checkTableEditForm(theForm, fieldsCnt)
{
    // TODO: avoid sending a message if user just wants to add a line
    // on the form but has not completed at least one field name

    var atLeastOneField = 0;
    var i, elm, elm2, elm3, val, id;

    for (i = 0; i < fieldsCnt; i++) {
        id = ""#field_"" + i + ""_2"";
        elm = $(id);
        val = elm.val();
        if (val == 'VARCHAR' || val == 'CHAR' || val == 'BIT' || val == 'VARBINARY' || val == 'BINARY') {
            elm2 = $(""#field_"" + i + ""_3"");
            val = parseInt(elm2.val(), 10);
            elm3 = $(""#field_"" + i + ""_1"");
            if (isNaN(val) && elm3.val() !== """") {
                elm2.select();
                alert(PMA_messages.strEnterValidLength);
                elm2.focus();
                return false;
            }
        }

        if (atLeastOneField === 0) {
            id = ""field_"" + i + ""_1"";
            if (!emptyCheckTheField(theForm, id)) {
                atLeastOneField = 1;
            }
        }
    }
    if (atLeastOneField === 0) {
        var theField = theForm.elements.field_0_1;
        alert(PMA_messages.strFormEmpty);
        theField.focus();
        return false;
    }

    // at least this section is under jQuery
    var $input = $(""input.textfield[name='table']"");
    if ($input.val() === """") {
        alert(PMA_messages.strFormEmpty);
        $input.focus();
        return false;
    }

    return true;
} // enf of the 'checkTableEditForm()' function

/**
 * True if last click is to check a row.
 */
var last_click_checked = false;

/**
 * Zero-based index of last clicked row.
 * Used to handle the shift + click event in the code above.
 */
var last_clicked_row = -1;

/**
 * Zero-based index of last shift clicked row.
 */
var last_shift_clicked_row = -1;

var _idleSecondsCounter = 0;
var IncInterval;
var updateTimeout;
AJAX.registerTeardown('functions.js', function () {
    clearTimeout(updateTimeout);
    clearInterval(IncInterval);
    $(document).off('mousemove');
});

AJAX.registerOnload('functions.js', function () {
    document.onclick = function() {
        _idleSecondsCounter = 0;
    };
    $(document).on('mousemove',function() {
        _idleSecondsCounter = 0;
    });
    document.onkeypress = function() {
        _idleSecondsCounter = 0;
    };

    function SetIdleTime() {
        _idleSecondsCounter++;
    }
    function UpdateIdleTime() {
        var href = 'index.php';
        var params = {
                'ajax_request' : true,
                'token' : PMA_commonParams.get('token'),
                'server' : PMA_commonParams.get('server'),
                'db' : PMA_commonParams.get('db'),
                'access_time':_idleSecondsCounter
            };
        $.ajax({
                type: 'POST',
                url: href,
                data: params,
                success: function (data) {
                    if (data.success) {
                        if (PMA_commonParams.get('LoginCookieValidity')-_idleSecondsCounter > 5) {
                            var interval = (PMA_commonParams.get('LoginCookieValidity') - _idleSecondsCounter - 5) * 1000;
                            if (interval > Math.pow(2, 31) - 1) { // max value for setInterval() function
                                interval = Math.pow(2, 31) - 1;
                            }
                            updateTimeout = window.setTimeout(UpdateIdleTime, interval);
                        } else {
                            updateTimeout = window.setTimeout(UpdateIdleTime, 2000);
                        }
                    } else { //timeout occurred
                        window.location.reload(true);
                        clearInterval(IncInterval);
                    }
                }
            });
    }
    if (PMA_commonParams.get('logged_in') && PMA_commonParams.get('auth_type') == 'cookie') {
        IncInterval = window.setInterval(SetIdleTime, 1000);
        var interval = (PMA_commonParams.get('LoginCookieValidity') - 5) * 1000;
        if (interval > Math.pow(2, 31) - 1) { // max value for setInterval() function
            interval = Math.pow(2, 31) - 1;
        }
        updateTimeout = window.setTimeout(UpdateIdleTime, interval);
    }
});
/**
 * Unbind all event handlers before tearing down a page
 */
AJAX.registerTeardown('functions.js', function () {
    $(document).off('click', 'input:checkbox.checkall');
});
AJAX.registerOnload('functions.js', function () {
    /**
     * Row marking in horizontal mode (use ""on"" so that it works also for
     * next pages reached via AJAX); a tr may have the class noclick to remove
     * this behavior.
     */

    $(document).on('click', 'input:checkbox.checkall', function (e) {
        $this = $(this);
        var $tr = $this.closest('tr');
        var $table = $this.closest('table');

        if (!e.shiftKey || last_clicked_row == -1) {
            // usual click

            var $checkbox = $tr.find(':checkbox.checkall');
            var checked = $this.prop('checked');
            $checkbox.prop('checked', checked).trigger('change');
            if (checked) {
                $tr.addClass('marked');
            } else {
                $tr.removeClass('marked');
            }
            last_click_checked = checked;

            // remember the last clicked row
            last_clicked_row = last_click_checked ? $table.find('tr.odd:not(.noclick), tr.even:not(.noclick)').index($tr) : -1;
            last_shift_clicked_row = -1;
        } else {
            // handle the shift click
            PMA_clearSelection();
            var start, end;

            // clear last shift click result
            if (last_shift_clicked_row >= 0) {
                if (last_shift_clicked_row >= last_clicked_row) {
                    start = last_clicked_row;
                    end = last_shift_clicked_row;
                } else {
                    start = last_shift_clicked_row;
                    end = last_clicked_row;
                }
                $tr.parent().find('tr.odd:not(.noclick), tr.even:not(.noclick)')
                    .slice(start, end + 1)
                    .removeClass('marked')
                    .find(':checkbox')
                    .prop('checked', false)
                    .trigger('change');
            }

            // handle new shift click
            var curr_row = $table.find('tr.odd:not(.noclick), tr.even:not(.noclick)').index($tr);
            if (curr_row >= last_clicked_row) {
                start = last_clicked_row;
                end = curr_row;
            } else {
                start = curr_row;
                end = last_clicked_row;
            }
            $tr.parent().find('tr.odd:not(.noclick), tr.even:not(.noclick)')
                .slice(start, end + 1)
                .addClass('marked')
                .find(':checkbox')
                .prop('checked', true)
                .trigger('change');

            // remember the last shift clicked row
            last_shift_clicked_row = curr_row;
        }
    });

    addDateTimePicker();

    /**
     * Add attribute to text boxes for iOS devices (based on bugID: 3508912)
     */
    if (navigator.userAgent.match(/(iphone|ipod|ipad)/i)) {
        $('input[type=text]').attr('autocapitalize', 'off').attr('autocorrect', 'off');
    }
});

/**
 * Row highlighting in horizontal mode (use ""on""
 * so that it works also for pages reached via AJAX)
 */
/*AJAX.registerOnload('functions.js', function () {
    $(document).on('hover', 'tr.odd, tr.even',function (event) {
        var $tr = $(this);
        $tr.toggleClass('hover',event.type=='mouseover');
        $tr.children().toggleClass('hover',event.type=='mouseover');
    });
})*/

/**
 * This array is used to remember mark status of rows in browse mode
 */
var marked_row = [];

/**
 * marks all rows and selects its first checkbox inside the given element
 * the given element is usually a table or a div containing the table or tables
 *
 * @param container    DOM element
 */
function markAllRows(container_id)
{

    $(""#"" + container_id).find(""input:checkbox:enabled"").prop('checked', true)
    .trigger(""change"")
    .parents(""tr"").addClass(""marked"");
    return true;
}

/**
 * marks all rows and selects its first checkbox inside the given element
 * the given element is usually a table or a div containing the table or tables
 *
 * @param container    DOM element
 */
function unMarkAllRows(container_id)
{

    $(""#"" + container_id).find(""input:checkbox:enabled"").prop('checked', false)
    .trigger(""change"")
    .parents(""tr"").removeClass(""marked"");
    return true;
}

/**
 * Checks/unchecks all checkbox in given container (f.e. a form, fieldset or div)
 *
 * @param string   container_id  the container id
 * @param boolean  state         new value for checkbox (true or false)
 * @return boolean  always true
 */
function setCheckboxes(container_id, state)
{

    $(""#"" + container_id).find(""input:checkbox"").prop('checked', state);
    return true;
} // end of the 'setCheckboxes()' function

/**
  * Checks/unchecks all options of a <select> element
  *
  * @param string   the form name
  * @param string   the element name
  * @param boolean  whether to check or to uncheck options
  *
  * @return boolean  always true
  */
function setSelectOptions(the_form, the_select, do_check)
{
    $(""form[name='"" + the_form + ""'] select[name='"" + the_select + ""']"").find(""option"").prop('selected', do_check);
    return true;
} // end of the 'setSelectOptions()' function

/**
 * Sets current value for query box.
 */
function setQuery(query)
{
    if (codemirror_editor) {
        codemirror_editor.setValue(query);
        codemirror_editor.focus();
    } else {
        document.sqlform.sql_query.value = query;
        document.sqlform.sql_query.focus();
    }
}

/**
 * Handles 'Simulate query' button on SQL query box.
 *
 * @return void
 */
function PMA_handleSimulateQueryButton()
{
    var update_re = new RegExp('^\\s*UPDATE\\s+((`[^`]+`)|([A-Za-z0-9_$]+))\\s+SET\\s', 'i');
    var delete_re = new RegExp('^\\s*DELETE\\s+FROM\\s', 'i');
    var query = '';

    if (codemirror_editor) {
        query = codemirror_editor.getValue();
    } else {
        query = $('#sqlquery').val();
    }

    var $simulateDml = $('#simulate_dml');
    if (update_re.test(query) || delete_re.test(query)) {
        if (! $simulateDml.length) {
            $('#button_submit_query')
            .before('<input type=""button"" id=""simulate_dml""' +
                'tabindex=""199"" value=""' +
                PMA_messages.strSimulateDML +
                '"" />');
        }
    } else {
        if ($simulateDml.length) {
            $simulateDml.remove();
        }
    }
}

/**
  * Create quick sql statements.
  *
  */
function insertQuery(queryType)
{
    if (queryType == ""clear"") {
        setQuery('');
        return;
    } else if (queryType == ""format"") {
        if (codemirror_editor) {
            $('#querymessage').html(PMA_messages.strFormatting +
                '&nbsp;<img class=""ajaxIcon"" src=""' +
                pmaThemeImage + 'ajax_clock_small.gif"" alt="""">');
            var href = 'db_sql_format.php';
            var params = {
                'ajax_request': true,
                'token': PMA_commonParams.get('token'),
                'sql': codemirror_editor.getValue()
            };
            $.ajax({
                type: 'POST',
                url: href,
                data: params,
                success: function (data) {
                    if (data.success) {
                        codemirror_editor.setValue(data.sql);
                    }
                    $('#querymessage').html('');
                }
            });
        }
        return;
    } else if (queryType == ""saved"") {
        if ($.cookie('auto_saved_sql')) {
            setQuery($.cookie('auto_saved_sql'));
        } else {
            PMA_ajaxShowMessage(PMA_messages.strNoAutoSavedQuery);
        }
        return;
    }

    var query = """";
    var myListBox = document.sqlform.dummy;
    var table = document.sqlform.table.value;

    if (myListBox.options.length > 0) {
        sql_box_locked = true;
        var columnsList = """";
        var valDis = """";
        var editDis = """";
        var NbSelect = 0;
        for (var i = 0; i < myListBox.options.length; i++) {
            NbSelect++;
            if (NbSelect > 1) {
                columnsList += "", "";
                valDis += "","";
                editDis += "","";
            }
            columnsList += myListBox.options[i].value;
            valDis += ""[value-"" + NbSelect + ""]"";
            editDis += myListBox.options[i].value + ""=[value-"" + NbSelect + ""]"";
        }
        if (queryType == ""selectall"") {
            query = ""SELECT * FROM `"" + table + ""` WHERE 1"";
        } else if (queryType == ""select"") {
            query = ""SELECT "" + columnsList + "" FROM `"" + table + ""` WHERE 1"";
        } else if (queryType == ""insert"") {
            query = ""INSERT INTO `"" + table + ""`("" + columnsList + "") VALUES ("" + valDis + "")"";
        } else if (queryType == ""update"") {
            query = ""UPDATE `"" + table + ""` SET "" + editDis + "" WHERE 1"";
        } else if (queryType == ""delete"") {
            query = ""DELETE FROM `"" + table + ""` WHERE 1"";
        }
        setQuery(query);
        sql_box_locked = false;
    }
}


/**
  * Inserts multiple fields.
  *
  */
function insertValueQuery()
{
    var myQuery = document.sqlform.sql_query;
    var myListBox = document.sqlform.dummy;

    if (myListBox.options.length > 0) {
        sql_box_locked = true;
        var columnsList = """";
        var NbSelect = 0;
        for (var i = 0; i < myListBox.options.length; i++) {
            if (myListBox.options[i].selected) {
                NbSelect++;
                if (NbSelect > 1) {
                    columnsList += "", "";
                }
                columnsList += myListBox.options[i].value;
            }
        }

        /* CodeMirror support */
        if (codemirror_editor) {
            codemirror_editor.replaceSelection(columnsList);
        //IE support
        } else if (document.selection) {
            myQuery.focus();
            var sel = document.selection.createRange();
            sel.text = columnsList;
            document.sqlform.insert.focus();
        }
        //MOZILLA/NETSCAPE support
        else if (document.sqlform.sql_query.selectionStart || document.sqlform.sql_query.selectionStart == ""0"") {
            var startPos = document.sqlform.sql_query.selectionStart;
            var endPos = document.sqlform.sql_query.selectionEnd;
            var SqlString = document.sqlform.sql_query.value;

            myQuery.value = SqlString.substring(0, startPos) + columnsList + SqlString.substring(endPos, SqlString.length);
        } else {
            myQuery.value += columnsList;
        }
        sql_box_locked = false;
    }
}

/**
 * Updates the input fields for the parameters based on the query
 */
function updateQueryParameters() {

    if ($('#parameterized').is(':checked')) {
        var query = codemirror_editor ? codemirror_editor.getValue() : $('#sqlquery').val();

        var allParameters = query.match(/:[a-zA-Z0-9_]+/g);
         var parameters = [];
         // get unique parameters
         if (allParameters) {
             $.each(allParameters, function(i, parameter){
                 if ($.inArray(parameter, parameters) === -1) {
                     parameters.push(parameter);
                 }
             });
         }

         var $temp = $('<div />');
         $temp.append($('#parametersDiv').children());
         $('#parametersDiv').empty();

         $.each(parameters, function (i, parameter) {
             var paramName = parameter.substring(1);
             var $param = $temp.find('#paramSpan_' + paramName );
             if (! $param.length) {
                 $param = $('<span class=""parameter"" id=""paramSpan_' + paramName + '"" />');
                 $('<label for=""param_' + paramName + '"" />').text(parameter).appendTo($param);
                 $('<input type=""text"" name=""parameters[' + parameter + ']"" id=""param_' + paramName + '"" />').appendTo($param);
             }
             $('#parametersDiv').append($param);
         });
    } else {
        $('#parametersDiv').empty();
    }
}

/**
 * Add a date/time picker to each element that needs it
 * (only when jquery-ui-timepicker-addon.js is loaded)
 */
function addDateTimePicker() {
    if ($.timepicker !== undefined) {
        $('input.timefield, input.datefield, input.datetimefield').each(function () {

            var decimals = $(this).parent().attr('data-decimals');
            var type = $(this).parent().attr('data-type');

            var showMillisec = false;
            var showMicrosec = false;
            var timeFormat = 'HH:mm:ss';
            // check for decimal places of seconds
            if (decimals > 0 && type.indexOf('time') != -1){
                if (decimals > 3) {
                    showMillisec = true;
                    showMicrosec = true;
                    timeFormat = 'HH:mm:ss.lc';
                } else {
                    showMillisec = true;
                    timeFormat = 'HH:mm:ss.l';
                }
            }
            PMA_addDatepicker($(this), type, {
                showMillisec: showMillisec,
                showMicrosec: showMicrosec,
                timeFormat: timeFormat
            });
        });
    }
}

/**
  * Refresh/resize the WYSIWYG scratchboard
  */
function refreshLayout()
{
    var $elm = $('#pdflayout');
    var orientation = $('#orientation_opt').val();
    var paper = 'A4';
    var $paperOpt = $('#paper_opt');
    if ($paperOpt.length == 1) {
        paper = $paperOpt.val();
    }
    var posa = 'y';
    var posb = 'x';
    if (orientation == 'P') {
        posa = 'x';
        posb = 'y';
    }
    $elm.css('width', pdfPaperSize(paper, posa) + 'px');
    $elm.css('height', pdfPaperSize(paper, posb) + 'px');
}

/**
 * Initializes positions of elements.
 */
function TableDragInit() {
    $('.pdflayout_table').each(function () {
        var $this = $(this);
        var number = $this.data('number');
        var x = $('#c_table_' + number + '_x').val();
        var y = $('#c_table_' + number + '_y').val();
        $this.css('left', x + 'px');
        $this.css('top', y + 'px');
        /* Make elements draggable */
        $this.draggable({
            containment: ""parent"",
            drag: function (evt, ui) {
                var number = $this.data('number');
                $('#c_table_' + number + '_x').val(parseInt(ui.position.left, 10));
                $('#c_table_' + number + '_y').val(parseInt(ui.position.top, 10));
            }
        });
    });
}

/**
 * Resets drag and drop positions.
 */
function resetDrag() {
    $('.pdflayout_table').each(function () {
        var $this = $(this);
        var x = $this.data('x');
        var y = $this.data('y');
        $this.css('left', x + 'px');
        $this.css('top', y + 'px');
    });
}

/**
 * User schema handlers.
 */
$(function () {
    /* Move in scratchboard on manual change */
    $(document).on('change', '.position-change', function () {
        var $this = $(this);
        var $elm = $('#table_' + $this.data('number'));
        $elm.css($this.data('axis'), $this.val() + 'px');
    });
    /* Refresh on paper size/orientation change */
    $(document).on('change', '.paper-change', function () {
        var $elm = $('#pdflayout');
        if ($elm.css('visibility') == 'visible') {
            refreshLayout();
            TableDragInit();
        }
    });
    /* Show/hide the WYSIWYG scratchboard */
    $(document).on('click', '#toggle-dragdrop', function () {
        var $elm = $('#pdflayout');
        if ($elm.css('visibility') == 'hidden') {
            refreshLayout();
            TableDragInit();
            $elm.css('visibility', 'visible');
            $elm.css('display', 'block');
            $('#showwysiwyg').val('1');
        } else {
            $elm.css('visibility', 'hidden');
            $elm.css('display', 'none');
            $('#showwysiwyg').val('0');
        }
    });
    /* Reset scratchboard */
    $(document).on('click', '#reset-dragdrop', function () {
        resetDrag();
    });
});

/**
 * Returns paper sizes for a given format
 */
function pdfPaperSize(format, axis)
{
    switch (format.toUpperCase()) {
    case '4A0':
        if (axis == 'x') {
            return 4767.87;
        } else {
            return 6740.79;
        }
        break;
    case '2A0':
        if (axis == 'x') {
            return 3370.39;
        } else {
            return 4767.87;
        }
        break;
    case 'A0':
        if (axis == 'x') {
            return 2383.94;
        } else {
            return 3370.39;
        }
        break;
    case 'A1':
        if (axis == 'x') {
            return 1683.78;
        } else {
            return 2383.94;
        }
        break;
    case 'A2':
        if (axis == 'x') {
            return 1190.55;
        } else {
            return 1683.78;
        }
        break;
    case 'A3':
        if (axis == 'x') {
            return 841.89;
        } else {
            return 1190.55;
        }
        break;
    case 'A4':
        if (axis == 'x') {
            return 595.28;
        } else {
            return 841.89;
        }
        break;
    case 'A5':
        if (axis == 'x') {
            return 419.53;
        } else {
            return 595.28;
        }
        break;
    case 'A6':
        if (axis == 'x') {
            return 297.64;
        } else {
            return 419.53;
        }
        break;
    case 'A7':
        if (axis == 'x') {
            return 209.76;
        } else {
            return 297.64;
        }
        break;
    case 'A8':
        if (axis == 'x') {
            return 147.40;
        } else {
            return 209.76;
        }
        break;
    case 'A9':
        if (axis == 'x') {
            return 104.88;
        } else {
            return 147.40;
        }
        break;
    case 'A10':
        if (axis == 'x') {
            return 73.70;
        } else {
            return 104.88;
        }
        break;
    case 'B0':
        if (axis == 'x') {
            return 2834.65;
        } else {
            return 4008.19;
        }
        break;
    case 'B1':
        if (axis == 'x') {
            return 2004.09;
        } else {
            return 2834.65;
        }
        break;
    case 'B2':
        if (axis == 'x') {
            return 1417.32;
        } else {
            return 2004.09;
        }
        break;
    case 'B3':
        if (axis == 'x') {
            return 1000.63;
        } else {
            return 1417.32;
        }
        break;
    case 'B4':
        if (axis == 'x') {
            return 708.66;
        } else {
            return 1000.63;
        }
        break;
    case 'B5':
        if (axis == 'x') {
            return 498.90;
        } else {
            return 708.66;
        }
        break;
    case 'B6':
        if (axis == 'x') {
            return 354.33;
        } else {
            return 498.90;
        }
        break;
    case 'B7':
        if (axis == 'x') {
            return 249.45;
        } else {
            return 354.33;
        }
        break;
    case 'B8':
        if (axis == 'x') {
            return 175.75;
        } else {
            return 249.45;
        }
        break;
    case 'B9':
        if (axis == 'x') {
            return 124.72;
        } else {
            return 175.75;
        }
        break;
    case 'B10':
        if (axis == 'x') {
            return 87.87;
        } else {
            return 124.72;
        }
        break;
    case 'C0':
        if (axis == 'x') {
            return 2599.37;
        } else {
            return 3676.54;
        }
        break;
    case 'C1':
        if (axis == 'x') {
            return 1836.85;
        } else {
            return 2599.37;
        }
        break;
    case 'C2':
        if (axis == 'x') {
            return 1298.27;
        } else {
            return 1836.85;
        }
        break;
    case 'C3':
        if (axis == 'x') {
            return 918.43;
        } else {
            return 1298.27;
        }
        break;
    case 'C4':
        if (axis == 'x') {
            return 649.13;
        } else {
            return 918.43;
        }
        break;
    case 'C5':
        if (axis == 'x') {
            return 459.21;
        } else {
            return 649.13;
        }
        break;
    case 'C6':
        if (axis == 'x') {
            return 323.15;
        } else {
            return 459.21;
        }
        break;
    case 'C7':
        if (axis == 'x') {
            return 229.61;
        } else {
            return 323.15;
        }
        break;
    case 'C8':
        if (axis == 'x') {
            return 161.57;
        } else {
            return 229.61;
        }
        break;
    case 'C9':
        if (axis == 'x') {
            return 113.39;
        } else {
            return 161.57;
        }
        break;
    case 'C10':
        if (axis == 'x') {
            return 79.37;
        } else {
            return 113.39;
        }
        break;
    case 'RA0':
        if (axis == 'x') {
            return 2437.80;
        } else {
            return 3458.27;
        }
        break;
    case 'RA1':
        if (axis == 'x') {
            return 1729.13;
        } else {
            return 2437.80;
        }
        break;
    case 'RA2':
        if (axis == 'x') {
            return 1218.90;
        } else {
            return 1729.13;
        }
        break;
    case 'RA3':
        if (axis == 'x') {
            return 864.57;
        } else {
            return 1218.90;
        }
        break;
    case 'RA4':
        if (axis == 'x') {
            return 609.45;
        } else {
            return 864.57;
        }
        break;
    case 'SRA0':
        if (axis == 'x') {
            return 2551.18;
        } else {
            return 3628.35;
        }
        break;
    case 'SRA1':
        if (axis == 'x') {
            return 1814.17;
        } else {
            return 2551.18;
        }
        break;
    case 'SRA2':
        if (axis == 'x') {
            return 1275.59;
        } else {
            return 1814.17;
        }
        break;
    case 'SRA3':
        if (axis == 'x') {
            return 907.09;
        } else {
            return 1275.59;
        }
        break;
    case 'SRA4':
        if (axis == 'x') {
            return 637.80;
        } else {
            return 907.09;
        }
        break;
    case 'LETTER':
        if (axis == 'x') {
            return 612.00;
        } else {
            return 792.00;
        }
        break;
    case 'LEGAL':
        if (axis == 'x') {
            return 612.00;
        } else {
            return 1008.00;
        }
        break;
    case 'EXECUTIVE':
        if (axis == 'x') {
            return 521.86;
        } else {
            return 756.00;
        }
        break;
    case 'FOLIO':
        if (axis == 'x') {
            return 612.00;
        } else {
            return 936.00;
        }
        break;
    } // end switch

    return 0;
}

/**
 * Get checkbox for foreign key checks
 *
 * @return string
 */
function getForeignKeyCheckboxLoader() {
    var html = '';
    html    += '<div>';
    html    += '<div class=""load-default-fk-check-value"">';
    html    += PMA_getImage('ajax_clock_small.gif');
    html    += '</div>';
    html    += '</div>';
    return html;
}

function loadForeignKeyCheckbox() {
    // Load default foreign key check value
    var params = {
        'ajax_request': true,
        'token': PMA_commonParams.get('token'),
        'server': PMA_commonParams.get('server'),
        'get_default_fk_check_value': true
    };
    $.get('sql.php', params, function (data) {
        var html = '<input type=""hidden"" name=""fk_checks"" value=""0"" />' +
            '<input type=""checkbox"" name=""fk_checks"" id=""fk_checks""' +
            (data.default_fk_check_value ? ' checked=""checked""' : '') + ' />' +
            '<label for=""fk_checks"">' + PMA_messages.strForeignKeyCheck + '</label>';
        $('.load-default-fk-check-value').replaceWith(html);
    });
}

function getJSConfirmCommonParam(elem) {
    return {
        'is_js_confirmed' : 1,
        'ajax_request' : true,
        'fk_checks': $(elem).find('#fk_checks').is(':checked') ? 1 : 0
    };
}

/**
 * Unbind all event handlers before tearing down a page
 */
AJAX.registerTeardown('functions.js', function () {
    $(document).off('click', ""a.inline_edit_sql"");
    $(document).off('click', ""input#sql_query_edit_save"");
    $(document).off('click', ""input#sql_query_edit_discard"");
    $('input.sqlbutton').unbind('click');
    if (codemirror_editor) {
        codemirror_editor.off('blur');
    } else {
        $(document).off('blur', '#sqlquery');
    }
    $(document).off('change', '#parameterized');
    $('#sqlquery').unbind('keydown');
    $('#sql_query_edit').unbind('keydown');

    if (codemirror_inline_editor) {
        // Copy the sql query to the text area to preserve it.
        $('#sql_query_edit').text(codemirror_inline_editor.getValue());
        $(codemirror_inline_editor.getWrapperElement()).unbind('keydown');
        codemirror_inline_editor.toTextArea();
        codemirror_inline_editor = false;
    }
    if (codemirror_editor) {
        $(codemirror_editor.getWrapperElement()).unbind('keydown');
    }
});

/**
 * Jquery Coding for inline editing SQL_QUERY
 */
AJAX.registerOnload('functions.js', function () {
    // If we are coming back to the page by clicking forward button
    // of the browser, bind the code mirror to inline query editor.
    bindCodeMirrorToInlineEditor();
    $(document).on('click', ""a.inline_edit_sql"", function () {
        if ($('#sql_query_edit').length) {
            // An inline query editor is already open,
            // we don't want another copy of it
            return false;
        }

        var $form = $(this).prev('form');
        var sql_query  = $form.find(""input[name='sql_query']"").val().trim();
        var $inner_sql = $(this).parent().prev().find('code.sql');
        var old_text   = $inner_sql.html();

        var new_content = ""<textarea name=\""sql_query_edit\"" id=\""sql_query_edit\"">"" + sql_query + ""</textarea>\n"";
        new_content    += getForeignKeyCheckboxLoader();
        new_content    += ""<input type=\""submit\"" id=\""sql_query_edit_save\"" class=\""button btnSave\"" value=\"""" + PMA_messages.strGo + ""\""/>\n"";
        new_content    += ""<input type=\""button\"" id=\""sql_query_edit_discard\"" class=\""button btnDiscard\"" value=\"""" + PMA_messages.strCancel + ""\""/>\n"";
        var $editor_area = $('div#inline_editor');
        if ($editor_area.length === 0) {
            $editor_area = $('<div id=""inline_editor_outer""></div>');
            $editor_area.insertBefore($inner_sql);
        }
        $editor_area.html(new_content);
        loadForeignKeyCheckbox();
        $inner_sql.hide();

        bindCodeMirrorToInlineEditor();
        return false;
    });

    $(document).on('click', ""input#sql_query_edit_save"", function () {
        $("".success"").hide();
        //hide already existing success message
        var sql_query;
        if (codemirror_inline_editor) {
            codemirror_inline_editor.save();
            sql_query = codemirror_inline_editor.getValue();
        } else {
            sql_query = $(this).parent().find('#sql_query_edit').val();
        }
        var fk_check = $(this).parent().find('#fk_checks').is(':checked');

        var $form = $(""a.inline_edit_sql"").prev('form');
        var $fake_form = $('<form>', {action: 'import.php', method: 'post'})
                .append($form.find(""input[name=server], input[name=db], input[name=table], input[name=token]"").clone())
                .append($('<input/>', {type: 'hidden', name: 'show_query', value: 1}))
                .append($('<input/>', {type: 'hidden', name: 'is_js_confirmed', value: 0}))
                .append($('<input/>', {type: 'hidden', name: 'sql_query', value: sql_query}))
                .append($('<input/>', {type: 'hidden', name: 'fk_checks', value: fk_check ? 1 : 0}));
        if (! checkSqlQuery($fake_form[0])) {
            return false;
        }
        $fake_form.appendTo($('body')).submit();
    });

    $(document).on('click', ""input#sql_query_edit_discard"", function () {
        var $divEditor = $('div#inline_editor_outer');
        $divEditor.siblings('code.sql').show();
        $divEditor.remove();
    });

    $('input.sqlbutton').click(function (evt) {
        insertQuery(evt.target.id);
        PMA_handleSimulateQueryButton();
        return false;
    });

    $(document).on('change', '#parameterized', updateQueryParameters);

    var $inputUsername = $('#input_username');
    if ($inputUsername) {
        if ($inputUsername.val() === '') {
            $inputUsername.focus();
        } else {
            $('#input_password').focus();
        }
    }
});

/**
 * ""inputRead"" event handler for CodeMirror SQL query editors for autocompletion
 */
function codemirrorAutocompleteOnInputRead(instance) {
    if (!sql_autocomplete_in_progress
        && (!instance.options.hintOptions.tables || !sql_autocomplete)) {

        if (!sql_autocomplete) {
            // Reset after teardown
            instance.options.hintOptions.tables = false;
            instance.options.hintOptions.defaultTable = '';

            sql_autocomplete_in_progress = true;

            var href = 'db_sql_autocomplete.php';
            var params = {
                'ajax_request': true,
                'token': PMA_commonParams.get('token'),
                'server': PMA_commonParams.get('server'),
                'db': PMA_commonParams.get('db'),
                'no_debug': true
            };

            var columnHintRender = function(elem, self, data) {
                $('<div class=""autocomplete-column-name"">')
                    .text(data.columnName)
                    .appendTo(elem);
                $('<div class=""autocomplete-column-hint"">')
                    .text(data.columnHint)
                    .appendTo(elem);
            };

            $.ajax({
                type: 'POST',
                url: href,
                data: params,
                success: function (data) {
                    if (data.success) {
                        var tables = $.parseJSON(data.tables);
                        sql_autocomplete_default_table = PMA_commonParams.get('table');
                        sql_autocomplete = [];
                        for (var table in tables) {
                            if (tables.hasOwnProperty(table)) {
                                var columns = tables[table];
                                table = {
                                    text: table,
                                    columns: []
                                };
                                for (var column in columns) {
                                    if (columns.hasOwnProperty(column)) {
                                        var displayText = columns[column].Type;
                                        if (columns[column].Key == 'PRI') {
                                            displayText += ' | Primary';
                                        } else if (columns[column].Key == 'UNI') {
                                            displayText += ' | Unique';
                                        }
                                        table.columns.push({
                                            text: column,
                                            displayText: column + "" | "" +  displayText,
                                            columnName: column,
                                            columnHint: displayText,
                                            render: columnHintRender
                                        });
                                    }
                                }
                            }
                            sql_autocomplete.push(table);
                        }
                        instance.options.hintOptions.tables = sql_autocomplete;
                        instance.options.hintOptions.defaultTable = sql_autocomplete_default_table;
                    }
                },
                complete: function () {
                    sql_autocomplete_in_progress = false;
                }
            });
        }
        else {
            instance.options.hintOptions.tables = sql_autocomplete;
            instance.options.hintOptions.defaultTable = sql_autocomplete_default_table;
        }
    }
    if (instance.state.completionActive) {
        return;
    }
    var cur = instance.getCursor();
    var token = instance.getTokenAt(cur);
    var string = '';
    if (token.string.match(/^[.`\w@]\w*$/)) {
        string = token.string;
    }
    if (string.length > 0) {
        CodeMirror.commands.autocomplete(instance);
    }
}

/**
 * Remove autocomplete information before tearing down a page
 */
AJAX.registerTeardown('functions.js', function () {
    sql_autocomplete = false;
    sql_autocomplete_default_table = '';
});

/**
 * Binds the CodeMirror to the text area used to inline edit a query.
 */
function bindCodeMirrorToInlineEditor() {
    var $inline_editor = $('#sql_query_edit');
    if ($inline_editor.length > 0) {
        if (typeof CodeMirror !== 'undefined') {
            var height = $inline_editor.css('height');
            codemirror_inline_editor = PMA_getSQLEditor($inline_editor);
            codemirror_inline_editor.getWrapperElement().style.height = height;
            codemirror_inline_editor.refresh();
            codemirror_inline_editor.focus();
            $(codemirror_inline_editor.getWrapperElement())
                .bind('keydown', catchKeypressesFromSqlInlineEdit);
        } else {
            $inline_editor
                .focus()
                .bind('keydown', catchKeypressesFromSqlInlineEdit);
        }
    }
}

function catchKeypressesFromSqlInlineEdit(event) {
    // ctrl-enter is 10 in chrome and ie, but 13 in ff
    if (event.ctrlKey && (event.keyCode == 13 || event.keyCode == 10)) {
        $(""#sql_query_edit_save"").trigger('click');
    }
}

/**
 * Adds doc link to single highlighted SQL element
 */
function PMA_doc_add($elm, params)
{
    if (typeof mysql_doc_template == 'undefined') {
        return;
    }

    var url = PMA_sprintf(
        decodeURIComponent(mysql_doc_template),
        params[0]
    );
    if (params.length > 1) {
        url += '#' + params[1];
    }
    var content = $elm.text();
    $elm.text('');
    $elm.append('<a target=""mysql_doc"" class=""cm-sql-doc"" href=""' + url + '"">' + content + '</a>');
}

/**
 * Generates doc links for keywords inside highlighted SQL
 */
function PMA_doc_keyword(idx, elm)
{
    var $elm = $(elm);
    /* Skip already processed ones */
    if ($elm.find('a').length > 0) {
        return;
    }
    var keyword = $elm.text().toUpperCase();
    var $next = $elm.next('.cm-keyword');
    if ($next) {
        var next_keyword = $next.text().toUpperCase();
        var full = keyword + ' ' + next_keyword;

        var $next2 = $next.next('.cm-keyword');
        if ($next2) {
            var next2_keyword = $next2.text().toUpperCase();
            var full2 = full + ' ' + next2_keyword;
            if (full2 in mysql_doc_keyword) {
                PMA_doc_add($elm, mysql_doc_keyword[full2]);
                PMA_doc_add($next, mysql_doc_keyword[full2]);
                PMA_doc_add($next2, mysql_doc_keyword[full2]);
                return;
            }
        }
        if (full in mysql_doc_keyword) {
            PMA_doc_add($elm, mysql_doc_keyword[full]);
            PMA_doc_add($next, mysql_doc_keyword[full]);
            return;
        }
    }
    if (keyword in mysql_doc_keyword) {
        PMA_doc_add($elm, mysql_doc_keyword[keyword]);
    }
}

/**
 * Generates doc links for builtins inside highlighted SQL
 */
function PMA_doc_builtin(idx, elm)
{
    var $elm = $(elm);
    var builtin = $elm.text().toUpperCase();
    if (builtin in mysql_doc_builtin) {
        PMA_doc_add($elm, mysql_doc_builtin[builtin]);
    }
}

/**
 * Higlights SQL using CodeMirror.
 */
function PMA_highlightSQL($base)
{
    var $elm = $base.find('code.sql');
    $elm.each(function () {
        var $sql = $(this);
        var $pre = $sql.find('pre');
        /* We only care about visible elements to avoid double processing */
        if ($pre.is("":visible"")) {
            var $highlight = $('<div class=""sql-highlight cm-s-default""></div>');
            $sql.append($highlight);
            if (typeof CodeMirror != 'undefined') {
                CodeMirror.runMode($sql.text(), 'text/x-mysql', $highlight[0]);
                $pre.hide();
                $highlight.find('.cm-keyword').each(PMA_doc_keyword);
                $highlight.find('.cm-builtin').each(PMA_doc_builtin);
            }
        }
    });
}

/**
 * Updates an element containing code.
 *
 * @param jQuery Object $base base element which contains the raw and the
 *                            highlighted code.
 *
 * @param string htmlValue    code in HTML format, displayed if code cannot be
 *                            highlighted
 *
 * @param string rawValue     raw code, used as a parameter for highlighter
 *
 * @return bool               whether content was updated or not
 */
function PMA_updateCode($base, htmlValue, rawValue)
{
    var $code = $base.find('code');
    if ($code.length == 0) {
        return false;
    }

    // Determines the type of the content and appropriate CodeMirror mode.
    var type = '', mode = '';
    if  ($code.hasClass('json')) {
        type = 'json';
        mode = 'application/json';
    } else if ($code.hasClass('sql')) {
        type = 'sql';
        mode = 'text/x-mysql';
    } else if ($code.hasClass('xml')) {
        type = 'xml';
        mode = 'application/xml';
    } else {
        return false;
    }

    // Element used to display unhighlighted code.
    var $notHighlighted = $('<pre>' + htmlValue + '</pre>');

    // Tries to highlight code using CodeMirror.
    if (typeof CodeMirror != 'undefined') {
        var $highlighted = $('<div class=""' + type + '-highlight cm-s-default""></div>');
        CodeMirror.runMode(rawValue, mode, $highlighted[0]);
        $notHighlighted.hide();
        $code.html('').append($notHighlighted, $highlighted[0]);
    } else {
        $code.html('').append($notHighlighted);
    }

    return true;
}

/**
 * Show a message on the top of the page for an Ajax request
 *
 * Sample usage:
 *
 * 1) var $msg = PMA_ajaxShowMessage();
 * This will show a message that reads ""Loading..."". Such a message will not
 * disappear automatically and cannot be dismissed by the user. To remove this
 * message either the PMA_ajaxRemoveMessage($msg) function must be called or
 * another message must be show with PMA_ajaxShowMessage() function.
 *
 * 2) var $msg = PMA_ajaxShowMessage(PMA_messages.strProcessingRequest);
 * This is a special case. The behaviour is same as above,
 * just with a different message
 *
 * 3) var $msg = PMA_ajaxShowMessage('The operation was successful');
 * This will show a message that will disappear automatically and it can also
 * be dismissed by the user.
 *
 * 4) var $msg = PMA_ajaxShowMessage('Some error', false);
 * This will show a message that will not disappear automatically, but it
 * can be dismissed by the user after he has finished reading it.
 *
 * @param string  message     string containing the message to be shown.
 *                              optional, defaults to 'Loading...'
 * @param mixed   timeout     number of milliseconds for the message to be visible
 *                              optional, defaults to 5000. If set to 'false', the
 *                              notification will never disappear
 * @return jQuery object       jQuery Element that holds the message div
 *                              this object can be passed to PMA_ajaxRemoveMessage()
 *                              to remove the notification
 */
function PMA_ajaxShowMessage(message, timeout)
{
    /**
     * @var self_closing Whether the notification will automatically disappear
     */
    var self_closing = true;
    /**
     * @var dismissable Whether the user will be able to remove
     *                  the notification by clicking on it
     */
    var dismissable = true;
    // Handle the case when a empty data.message is passed.
    // We don't want the empty message
    if (message === '') {
        return true;
    } else if (! message) {
        // If the message is undefined, show the default
        message = PMA_messages.strLoading;
        dismissable = false;
        self_closing = false;
    } else if (message == PMA_messages.strProcessingRequest) {
        // This is another case where the message should not disappear
        dismissable = false;
        self_closing = false;
    }
    // Figure out whether (or after how long) to remove the notification
    if (timeout === undefined) {
        timeout = 5000;
    } else if (timeout === false) {
        self_closing = false;
    }
    // Create a parent element for the AJAX messages, if necessary
    if ($('#loading_parent').length === 0) {
        $('<div id=""loading_parent""></div>')
        .prependTo(""#page_content"");
    }
    // Update message count to create distinct message elements every time
    ajax_message_count++;
    // Remove all old messages, if any
    $(""span.ajax_notification[id^=ajax_message_num]"").remove();
    /**
     * @var    $retval    a jQuery object containing the reference
     *                    to the created AJAX message
     */
    var $retval = $(
            '<span class=""ajax_notification"" id=""ajax_message_num_' +
            ajax_message_count +
            '""></span>'
    )
    .hide()
    .appendTo(""#loading_parent"")
    .html(message)
    .show();
    // If the notification is self-closing we should create a callback to remove it
    if (self_closing) {
        $retval
        .delay(timeout)
        .fadeOut('medium', function () {
            if ($(this).is(':data(tooltip)')) {
                $(this).tooltip('destroy');
            }
            // Remove the notification
            $(this).remove();
        });
    }
    // If the notification is dismissable we need to add the relevant class to it
    // and add a tooltip so that the users know that it can be removed
    if (dismissable) {
        $retval.addClass('dismissable').css('cursor', 'pointer');
        /**
         * Add a tooltip to the notification to let the user know that (s)he
         * can dismiss the ajax notification by clicking on it.
         */
        PMA_tooltip(
            $retval,
            'span',
            PMA_messages.strDismiss
        );
    }
    PMA_highlightSQL($retval);

    return $retval;
}

/**
 * Removes the message shown for an Ajax operation when it's completed
 *
 * @param jQuery object   jQuery Element that holds the notification
 *
 * @return nothing
 */
function PMA_ajaxRemoveMessage($this_msgbox)
{
    if ($this_msgbox !== undefined && $this_msgbox instanceof jQuery) {
        $this_msgbox
        .stop(true, true)
        .fadeOut('medium');
        if ($this_msgbox.is(':data(tooltip)')) {
            $this_msgbox.tooltip('destroy');
        } else {
            $this_msgbox.remove();
        }
    }
}

/**
 * Requests SQL for previewing before executing.
 *
 * @param jQuery Object $form Form containing query data
 *
 * @return void
 */
function PMA_previewSQL($form)
{
    var form_url = $form.attr('action');
    var form_data = $form.serialize() +
        '&do_save_data=1' +
        '&preview_sql=1' +
        '&ajax_request=1';
    var $msgbox = PMA_ajaxShowMessage();
    $.ajax({
        type: 'POST',
        url: form_url,
        data: form_data,
        success: function (response) {
            PMA_ajaxRemoveMessage($msgbox);
            if (response.success) {
                var $dialog_content = $('<div/>')
                    .append(response.sql_data);
                var button_options = {};
                button_options[PMA_messages.strClose] = function () {
                    $(this).dialog('close');
                };
                var $response_dialog = $dialog_content.dialog({
                    minWidth: 550,
                    maxHeight: 400,
                    modal: true,
                    buttons: button_options,
                    title: PMA_messages.strPreviewSQL,
                    close: function () {
                        $(this).remove();
                    },
                    open: function () {
                        // Pretty SQL printing.
                        PMA_highlightSQL($(this));
                    }
                });
            } else {
                PMA_ajaxShowMessage(response.message);
            }
        },
        error: function () {
            PMA_ajaxShowMessage(PMA_messages.strErrorProcessingRequest);
        }
    });
}

/**
 * check for reserved keyword column name
 *
 * @param jQuery Object $form Form
 *
 * @returns true|false
 */

function PMA_checkReservedWordColumns($form) {
    var is_confirmed = true;
    $.ajax({
        type: 'POST',
        url: ""tbl_structure.php"",
        data: $form.serialize() + '&reserved_word_check=1',
        success: function (data) {
            if (typeof data.success != 'undefined' && data.success === true) {
                is_confirmed = confirm(data.message);
            }
        },
        async:false
    });
    return is_confirmed;
}

// This event only need to be fired once after the initial page load
$(function () {
    /**
     * Allows the user to dismiss a notification
     * created with PMA_ajaxShowMessage()
     */
    $(document).on('click', 'span.ajax_notification.dismissable', function () {
        PMA_ajaxRemoveMessage($(this));
    });
    /**
     * The below two functions hide the ""Dismiss notification"" tooltip when a user
     * is hovering a link or button that is inside an ajax message
     */
    $(document).on('mouseover', 'span.ajax_notification a, span.ajax_notification button, span.ajax_notification input', function () {
        if ($(this).parents('span.ajax_notification').is(':data(tooltip)')) {
            $(this).parents('span.ajax_notification').tooltip('disable');
        }
    });
    $(document).on('mouseout', 'span.ajax_notification a, span.ajax_notification button, span.ajax_notification input', function () {
        if ($(this).parents('span.ajax_notification').is(':data(tooltip)')) {
            $(this).parents('span.ajax_notification').tooltip('enable');
        }
    });
});

/**
 * Hides/shows the ""Open in ENUM/SET editor"" message, depending on the data type of the column currently selected
 */
function PMA_showNoticeForEnum(selectElement)
{
    var enum_notice_id = selectElement.attr(""id"").split(""_"")[1];
    enum_notice_id += ""_"" + (parseInt(selectElement.attr(""id"").split(""_"")[2], 10) + 1);
    var selectedType = selectElement.val();
    if (selectedType == ""ENUM"" || selectedType == ""SET"") {
        $(""p#enum_notice_"" + enum_notice_id).show();
    } else {
        $(""p#enum_notice_"" + enum_notice_id).hide();
    }
}

/*
 * Creates a Profiling Chart with jqplot. Used in sql.js
 * and in server_status_monitor.js
 */
function PMA_createProfilingChartJqplot(target, data)
{
    return $.jqplot(target, [data],
        {
            seriesDefaults: {
                renderer: $.jqplot.PieRenderer,
                rendererOptions: {
                    showDataLabels:  true
                }
            },
            highlighter: {
                show: true,
                tooltipLocation: 'se',
                sizeAdjust: 0,
                tooltipAxes: 'pieref',
                useAxesFormatters: false,
                formatString: '%s, %.9Ps'
            },
            legend: {
                show: true,
                location: 'e',
                rendererOptions: {numberColumns: 2}
            },
            // from http://tango.freedesktop.org/Tango_Icon_Theme_Guidelines#Color_Palette
            seriesColors: [
                '#fce94f',
                '#fcaf3e',
                '#e9b96e',
                '#8ae234',
                '#729fcf',
                '#ad7fa8',
                '#ef2929',
                '#eeeeec',
                '#888a85',
                '#c4a000',
                '#ce5c00',
                '#8f5902',
                '#4e9a06',
                '#204a87',
                '#5c3566',
                '#a40000',
                '#babdb6',
                '#2e3436'
            ]
        }
    );
}

/**
 * Formats a profiling duration nicely (in us and ms time).
 * Used in server_status_monitor.js
 *
 * @param  integer    Number to be formatted, should be in the range of microsecond to second
 * @param  integer    Accuracy, how many numbers right to the comma should be
 * @return string     The formatted number
 */
function PMA_prettyProfilingNum(num, acc)
{
    if (!acc) {
        acc = 2;
    }
    acc = Math.pow(10, acc);
    if (num * 1000 < 0.1) {
        num = Math.round(acc * (num * 1000 * 1000)) / acc + 'µ';
    } else if (num < 0.1) {
        num = Math.round(acc * (num * 1000)) / acc + 'm';
    } else {
        num = Math.round(acc * num) / acc;
    }

    return num + 's';
}


/**
 * Formats a SQL Query nicely with newlines and indentation. Depends on Codemirror and MySQL Mode!
 *
 * @param string      Query to be formatted
 * @return string      The formatted query
 */
function PMA_SQLPrettyPrint(string)
{
    if (typeof CodeMirror == 'undefined') {
        return string;
    }

    var mode = CodeMirror.getMode({}, ""text/x-mysql"");
    var stream = new CodeMirror.StringStream(string);
    var state = mode.startState();
    var token, tokens = [];
    var output = '';
    var tabs = function (cnt) {
        var ret = '';
        for (var i = 0; i < 4 * cnt; i++) {
            ret += "" "";
        }
        return ret;
    };

    // ""root-level"" statements
    var statements = {
        'select': ['select', 'from', 'on', 'where', 'having', 'limit', 'order by', 'group by'],
        'update': ['update', 'set', 'where'],
        'insert into': ['insert into', 'values']
    };
    // don't put spaces before these tokens
    var spaceExceptionsBefore = {';': true, ',': true, '.': true, '(': true};
    // don't put spaces after these tokens
    var spaceExceptionsAfter = {'.': true};

    // Populate tokens array
    var str = '';
    while (! stream.eol()) {
        stream.start = stream.pos;
        token = mode.token(stream, state);
        if (token !== null) {
            tokens.push([token, stream.current().toLowerCase()]);
        }
    }

    var currentStatement = tokens[0][1];

    if (! statements[currentStatement]) {
        return string;
    }
    // Holds all currently opened code blocks (statement, function or generic)
    var blockStack = [];
    // Holds the type of block from last iteration (the current is in blockStack[0])
    var previousBlock;
    // If a new code block is found, newBlock contains its type for one iteration and vice versa for endBlock
    var newBlock, endBlock;
    // How much to indent in the current line
    var indentLevel = 0;
    // Holds the ""root-level"" statements
    var statementPart, lastStatementPart = statements[currentStatement][0];

    blockStack.unshift('statement');

    // Iterate through every token and format accordingly
    for (var i = 0; i < tokens.length; i++) {
        previousBlock = blockStack[0];

        // New block => push to stack
        if (tokens[i][1] == '(') {
            if (i < tokens.length - 1 && tokens[i + 1][0] == 'statement-verb') {
                blockStack.unshift(newBlock = 'statement');
            } else if (i > 0 && tokens[i - 1][0] == 'builtin') {
                blockStack.unshift(newBlock = 'function');
            } else {
                blockStack.unshift(newBlock = 'generic');
            }
        } else {
            newBlock = null;
        }

        // Block end => pop from stack
        if (tokens[i][1] == ')') {
            endBlock = blockStack[0];
            blockStack.shift();
        } else {
            endBlock = null;
        }

        // A subquery is starting
        if (i > 0 && newBlock == 'statement') {
            indentLevel++;
            output += ""\n"" + tabs(indentLevel) + tokens[i][1] + ' ' + tokens[i + 1][1].toUpperCase() + ""\n"" + tabs(indentLevel + 1);
            currentStatement = tokens[i + 1][1];
            i++;
            continue;
        }

        // A subquery is ending
        if (endBlock == 'statement' && indentLevel > 0) {
            output += ""\n"" + tabs(indentLevel);
            indentLevel--;
        }

        // One less indentation for statement parts (from, where, order by, etc.) and a newline
        statementPart = statements[currentStatement].indexOf(tokens[i][1]);
        if (statementPart != -1) {
            if (i > 0) {
                output += ""\n"";
            }
            output += tabs(indentLevel) + tokens[i][1].toUpperCase();
            output += ""\n"" + tabs(indentLevel + 1);
            lastStatementPart = tokens[i][1];
        }
        // Normal indentation and spaces for everything else
        else {
            if (! spaceExceptionsBefore[tokens[i][1]] &&
               ! (i > 0 && spaceExceptionsAfter[tokens[i - 1][1]]) &&
               output.charAt(output.length - 1) != ' ') {
                output += "" "";
            }
            if (tokens[i][0] == 'keyword') {
                output += tokens[i][1].toUpperCase();
            } else {
                output += tokens[i][1];
            }
        }

        // split columns in select and 'update set' clauses, but only inside statements blocks
        if ((lastStatementPart == 'select' || lastStatementPart == 'where'  || lastStatementPart == 'set') &&
            tokens[i][1] == ',' && blockStack[0] == 'statement') {

            output += ""\n"" + tabs(indentLevel + 1);
        }

        // split conditions in where clauses, but only inside statements blocks
        if (lastStatementPart == 'where' &&
            (tokens[i][1] == 'and' || tokens[i][1] == 'or' || tokens[i][1] == 'xor')) {

            if (blockStack[0] == 'statement') {
                output += ""\n"" + tabs(indentLevel + 1);
            }
            // Todo: Also split and or blocks in newlines & indentation++
            //if (blockStack[0] == 'generic')
             //   output += ...
        }
    }
    return output;
}

/**
 * jQuery function that uses jQueryUI's dialogs to confirm with user. Does not
 *  return a jQuery object yet and hence cannot be chained
 *
 * @param string      question
 * @param string      url           URL to be passed to the callbackFn to make
 *                                  an Ajax call to
 * @param function    callbackFn    callback to execute after user clicks on OK
 * @param function    openCallback  optional callback to run when dialog is shown
 */

jQuery.fn.PMA_confirm = function (question, url, callbackFn, openCallback) {
    var confirmState = PMA_commonParams.get('confirm');
    if (! confirmState) {
        // user does not want to confirm
        if ($.isFunction(callbackFn)) {
            callbackFn.call(this, url);
            return true;
        }
    }
    if (PMA_messages.strDoYouReally === '') {
        return true;
    }

    /**
     * @var    button_options  Object that stores the options passed to jQueryUI
     *                          dialog
     */
    var button_options = [
        {
            text: PMA_messages.strOK,
            'class': 'submitOK',
            click: function () {
                $(this).dialog(""close"");
                if ($.isFunction(callbackFn)) {
                    callbackFn.call(this, url);
                }
            }
        },
        {
            text: PMA_messages.strCancel,
            'class': 'submitCancel',
            click: function () {
                $(this).dialog(""close"");
            }
        }
    ];

    $('<div/>', {'id': 'confirm_dialog', 'title': PMA_messages.strConfirm})
    .prepend(question)
    .dialog({
        buttons: button_options,
        close: function () {
            $(this).remove();
        },
        open: openCallback,
        modal: true
    });
};

/**
 * jQuery function to sort a table's body after a new row has been appended to it.
 * Also fixes the even/odd classes of the table rows at the end.
 *
 * @param string      text_selector   string to select the sortKey's text
 *
 * @return jQuery Object for chaining purposes
 */
jQuery.fn.PMA_sort_table = function (text_selector) {
    return this.each(function () {

        /**
         * @var table_body  Object referring to the table's <tbody> element
         */
        var table_body = $(this);
        /**
         * @var rows    Object referring to the collection of rows in {@link table_body}
         */
        var rows = $(this).find('tr').get();

        //get the text of the field that we will sort by
        $.each(rows, function (index, row) {
            row.sortKey = $.trim($(row).find(text_selector).text().toLowerCase());
        });

        //get the sorted order
        rows.sort(function (a, b) {
            if (a.sortKey < b.sortKey) {
                return -1;
            }
            if (a.sortKey > b.sortKey) {
                return 1;
            }
            return 0;
        });

        //pull out each row from the table and then append it according to it's order
        $.each(rows, function (index, row) {
            $(table_body).append(row);
            row.sortKey = null;
        });

        //Re-check the classes of each row
        $(this).find('tr:odd')
        .removeClass('even').addClass('odd')
        .end()
        .find('tr:even')
        .removeClass('odd').addClass('even');
    });
};

/**
 * Unbind all event handlers before tearing down a page
 */
AJAX.registerTeardown('functions.js', function () {
    $(document).off('submit', ""#create_table_form_minimal.ajax"");
    $(document).off('submit', ""form.create_table_form.ajax"");
    $(document).off('click', ""form.create_table_form.ajax input[name=submit_num_fields]"");
    $(document).off('keyup', ""form.create_table_form.ajax input"");
});

/**
 * jQuery coding for 'Create Table'.  Used on db_operations.php,
 * db_structure.php and db_tracking.php (i.e., wherever
 * libraries/display_create_table.lib.php is used)
 *
 * Attach Ajax Event handlers for Create Table
 */
AJAX.registerOnload('functions.js', function () {
    /**
     * Attach event handler for submission of create table form (save)
     */
    $(document).on('submit', ""form.create_table_form.ajax"", function (event) {
        event.preventDefault();

        /**
         * @var    the_form    object referring to the create table form
         */
        var $form = $(this);

        /*
         * First validate the form; if there is a problem, avoid submitting it
         *
         * checkTableEditForm() needs a pure element and not a jQuery object,
         * this is why we pass $form[0] as a parameter (the jQuery object
         * is actually an array of DOM elements)
         */

        if (checkTableEditForm($form[0], $form.find('input[name=orig_num_fields]').val())) {
            PMA_prepareForAjaxRequest($form);
            if (PMA_checkReservedWordColumns($form)) {
                PMA_ajaxShowMessage(PMA_messages.strProcessingRequest);
                //User wants to submit the form
                $.post($form.attr('action'), $form.serialize() + ""&do_save_data=1"", function (data) {
                    if (typeof data !== 'undefined' && data.success === true) {
                        $('#properties_message')
                         .removeClass('error')
                         .html('');
                        PMA_ajaxShowMessage(data.message);
                        // Only if the create table dialog (distinct panel) exists
                        var $createTableDialog = $(""#create_table_dialog"");
                        if ($createTableDialog.length > 0) {
                            $createTableDialog.dialog(""close"").remove();
                        }
                        $('#tableslistcontainer').before(data.formatted_sql);

                        /**
                         * @var tables_table    Object referring to the <tbody> element that holds the list of tables
                         */
                        var tables_table = $(""#tablesForm"").find(""tbody"").not(""#tbl_summary_row"");
                        // this is the first table created in this db
                        if (tables_table.length === 0) {
                            PMA_commonActions.refreshMain(
                                PMA_commonParams.get('opendb_url')
                            );
                        } else {
                            /**
                             * @var curr_last_row   Object referring to the last <tr> element in {@link tables_table}
                             */
                            var curr_last_row = $(tables_table).find('tr:last');
                            /**
                             * @var curr_last_row_index_string   String containing the index of {@link curr_last_row}
                             */
                            var curr_last_row_index_string = $(curr_last_row).find('input:checkbox').attr('id').match(/\d+/)[0];
                            /**
                             * @var curr_last_row_index Index of {@link curr_last_row}
                             */
                            var curr_last_row_index = parseFloat(curr_last_row_index_string);
                            /**
                             * @var new_last_row_index   Index of the new row to be appended to {@link tables_table}
                             */
                            var new_last_row_index = curr_last_row_index + 1;
                            /**
                             * @var new_last_row_id String containing the id of the row to be appended to {@link tables_table}
                             */
                            var new_last_row_id = 'checkbox_tbl_' + new_last_row_index;

                            data.new_table_string = data.new_table_string.replace(/checkbox_tbl_/, new_last_row_id);
                            //append to table
                            $(data.new_table_string)
                             .appendTo(tables_table);

                            //Sort the table
                            $(tables_table).PMA_sort_table('th');

                            // Adjust summary row
                            PMA_adjustTotals();
                        }

                        //Refresh navigation as a new table has been added
                        PMA_reloadNavigation();
                        // Redirect to table structure page on creation of new table
                        var params_12 = 'ajax_request=true&ajax_page_request=true';
                        if (! (history && history.pushState)) {
                            params_12 += PMA_MicroHistory.menus.getRequestParam();
                        }
                        tblStruct_url = 'tbl_structure.php?server=' + data._params.server +
                            '&db='+ data._params.db + '&token=' + data._params.token +
                            '&goto=db_structure.php&table=' + data._params.table + '';
                        $.get(tblStruct_url, params_12, AJAX.responseHandler);
                    } else {
                        PMA_ajaxShowMessage(
                            '<div class=""error"">' + data.error + '</div>',
                            false
                        );
                    }
                }); // end $.post()
            }
        } // end if (checkTableEditForm() )
    }); // end create table form (save)

    /**
     * Attach event handler for create table form (add fields)
     */
    $(document).on('click', ""form.create_table_form.ajax input[name=submit_num_fields]"", function (event) {
        event.preventDefault();
        /**
         * @var    the_form    object referring to the create table form
         */
        var $form = $(this).closest('form');

        if (!checkFormElementInRange(this.form, 'added_fields', PMA_messages.strLeastColumnError, 1)) {
            return;
        }

        var $msgbox = PMA_ajaxShowMessage(PMA_messages.strProcessingRequest);
        PMA_prepareForAjaxRequest($form);

        //User wants to add more fields to the table
        $.post($form.attr('action'), $form.serialize() + ""&submit_num_fields=1"", function (data) {
            if (typeof data !== 'undefined' && data.success) {
                var $pageContent = $(""#page_content"");
                $pageContent.html(data.message);
                PMA_highlightSQL($pageContent);
                PMA_verifyColumnsProperties();
                PMA_hideShowConnection($('.create_table_form select[name=tbl_storage_engine]'));
                PMA_ajaxRemoveMessage($msgbox);
            } else {
                PMA_ajaxShowMessage(data.error);
            }
        }); //end $.post()
    }); // end create table form (add fields)

    $(document).on('keydown', ""form.create_table_form.ajax input[name=added_fields]"", function (event) {
        if (event.keyCode == 13) {
            event.preventDefault();
            event.stopImmediatePropagation();
            $(this)
                .closest('form')
                .find('input[name=submit_num_fields]')
                .click();
        }
    });
    $(""input[value=AUTO_INCREMENT]"").change(function(){
        if (this.checked) {
            var col = /\d/.exec($(this).attr('name'));
            col = col[0];
            var $selectFieldKey = $('select[name=""field_key[' + col + ']""]');
            if ($selectFieldKey.val() === 'none_'+col) {
                $selectFieldKey.val('primary_'+col).change();
            }
        }
    });
    $('body')
    .off('click', 'input.preview_sql')
    .on('click', 'input.preview_sql', function () {
        var $form = $(this).closest('form');
        PMA_previewSQL($form);
    });
});


/**
 * Validates the password field in a form
 *
 * @see    PMA_messages.strPasswordEmpty
 * @see    PMA_messages.strPasswordNotSame
 * @param  object $the_form The form to be validated
 * @return bool
 */
function PMA_checkPassword($the_form)
{
    // Did the user select 'no password'?
    if ($the_form.find('#nopass_1').is(':checked')) {
        return true;
    } else {
        var $pred = $the_form.find('#select_pred_password');
        if ($pred.length && ($pred.val() == 'none' || $pred.val() == 'keep')) {
            return true;
        }
    }

    var $password = $the_form.find('input[name=pma_pw]');
    var $password_repeat = $the_form.find('input[name=pma_pw2]');
    var alert_msg = false;

    if ($password.val() === '') {
        alert_msg = PMA_messages.strPasswordEmpty;
    } else if ($password.val() != $password_repeat.val()) {
        alert_msg = PMA_messages.strPasswordNotSame;
    }

    if (alert_msg) {
        alert(alert_msg);
        $password.val('');
        $password_repeat.val('');
        $password.focus();
        return false;
    }
    return true;
}

/**
 * Unbind all event handlers before tearing down a page
 */
AJAX.registerTeardown('functions.js', function () {
    $(document).off('click', '#change_password_anchor.ajax');
});
/**
 * Attach Ajax event handlers for 'Change Password' on index.php
 */
AJAX.registerOnload('functions.js', function () {

    /**
     * Attach Ajax event handler on the change password anchor
     */
    $(document).on('click', '#change_password_anchor.ajax', function (event) {
        event.preventDefault();

        var $msgbox = PMA_ajaxShowMessage();

        /**
         * @var button_options  Object containing options to be passed to jQueryUI's dialog
         */
        var button_options = {};
        button_options[PMA_messages.strGo] = function () {

            event.preventDefault();

            /**
             * @var $the_form    Object referring to the change password form
             */
            var $the_form = $(""#change_password_form"");

            if (! PMA_checkPassword($the_form)) {
                return false;
            }

            /**
             * @var this_value  String containing the value of the submit button.
             * Need to append this for the change password form on Server Privileges
             * page to work
             */
            var this_value = $(this).val();

            var $msgbox = PMA_ajaxShowMessage(PMA_messages.strProcessingRequest);
            $the_form.append('<input type=""hidden"" name=""ajax_request"" value=""true"" />');

            $.post($the_form.attr('action'), $the_form.serialize() + '&change_pw=' + this_value, function (data) {
                if (typeof data === 'undefined' || data.success !== true) {
                    PMA_ajaxShowMessage(data.error, false);
                    return;
                }

                var $pageContent = $(""#page_content"");
                $pageContent.prepend(data.message);
                PMA_highlightSQL($pageContent);
                $(""#change_password_dialog"").hide().remove();
                $(""#edit_user_dialog"").dialog(""close"").remove();
                PMA_ajaxRemoveMessage($msgbox);
            }); // end $.post()
        };

        button_options[PMA_messages.strCancel] = function () {
            $(this).dialog('close');
        };
        $.get($(this).attr('href'), {'ajax_request': true}, function (data) {
            if (typeof data === 'undefined' || !data.success) {
                PMA_ajaxShowMessage(data.error, false);
                return;
            }

            $('<div id=""change_password_dialog""></div>')
                .dialog({
                    title: PMA_messages.strChangePassword,
                    width: 600,
                    close: function (ev, ui) {
                        $(this).remove();
                    },
                    buttons: button_options,
                    modal: true
                })
                .append(data.message);
            // for this dialog, we remove the fieldset wrapping due to double headings
            $(""fieldset#fieldset_change_password"")
                .find(""legend"").remove().end()
                .find(""table.noclick"").unwrap().addClass(""some-margin"")
                .find(""input#text_pma_pw"").focus();
            displayPasswordGenerateButton();
            $('#fieldset_change_password_footer').hide();
            PMA_ajaxRemoveMessage($msgbox);
            $('#change_password_form').bind('submit', function (e) {
                e.preventDefault();
                $(this)
                    .closest('.ui-dialog')
                    .find('.ui-dialog-buttonpane .ui-button')
                    .first()
                    .click();
            });
        }); // end $.get()
    }); // end handler for change password anchor
}); // end $() for Change Password

/**
 * Unbind all event handlers before tearing down a page
 */
AJAX.registerTeardown('functions.js', function () {
    $(document).off('change', ""select.column_type"");
    $(document).off('change', ""select.default_type"");
    $(document).off('change', ""select.virtuality"");
    $(document).off('change', 'input.allow_null');
    $(document).off('change', '.create_table_form select[name=tbl_storage_engine]');
});
/**
 * Toggle the hiding/showing of the ""Open in ENUM/SET editor"" message when
 * the page loads and when the selected data type changes
 */
AJAX.registerOnload('functions.js', function () {
    // is called here for normal page loads and also when opening
    // the Create table dialog
    PMA_verifyColumnsProperties();
    //
    // needs on() to work also in the Create Table dialog
    $(document).on('change', ""select.column_type"", function () {
        PMA_showNoticeForEnum($(this));
    });
    $(document).on('change', ""select.default_type"", function () {
        PMA_hideShowDefaultValue($(this));
    });
    $(document).on('change', ""select.virtuality"", function () {
        PMA_hideShowExpression($(this));
    });
    $(document).on('change', 'input.allow_null', function () {
        PMA_validateDefaultValue($(this));
    });
    $(document).on('change', '.create_table_form select[name=tbl_storage_engine]', function () {
        PMA_hideShowConnection($(this));
    });
});

/**
 * If the chosen storage engine is FEDERATED show connection field. Hide otherwise
 *
 * @param $engine_selector storage engine selector
 */
function PMA_hideShowConnection($engine_selector)
{
    var $connection = $('.create_table_form input[name=connection]');
    var index = $connection.parent('td').index() + 1;
    var $labelTh = $connection.parents('tr').prev('tr').children('th:nth-child(' + index + ')');
    if ($engine_selector.val() != 'FEDERATED') {
        $connection
            .prop('disabled', true)
            .parent('td').hide();
        $labelTh.hide();
    } else {
        $connection
            .prop('disabled', false)
            .parent('td').show();
        $labelTh.show();
    }
}

/**
 * If the column does not allow NULL values, makes sure that default is not NULL
 */
function PMA_validateDefaultValue($null_checkbox)
{
    if (! $null_checkbox.prop('checked')) {
        var $default = $null_checkbox.closest('tr').find('.default_type');
        if ($default.val() == 'NULL') {
            $default.val('NONE');
        }
    }
}

/**
 * function to populate the input fields on picking a column from central list
 *
 * @param string  input_id input id of the name field for the column to be populated
 * @param integer offset of the selected column in central list of columns
 */
function autoPopulate(input_id, offset)
{
    var db = PMA_commonParams.get('db');
    var table = PMA_commonParams.get('table');
    input_id = input_id.substring(0, input_id.length - 1);
    $('#' + input_id + '1').val(central_column_list[db + '_' + table][offset].col_name);
    var col_type = central_column_list[db + '_' + table][offset].col_type.toUpperCase();
    $('#' + input_id + '2').val(col_type);
    var $input3 = $('#' + input_id + '3');
    $input3.val(central_column_list[db + '_' + table][offset].col_length);
    if(col_type === 'ENUM' || col_type === 'SET') {
        $input3.next().show();
    } else {
        $input3.next().hide();
    }
    var col_default = central_column_list[db + '_' + table][offset].col_default.toUpperCase();
    var $input4 = $('#' + input_id + '4');
    if (col_default !== '' && col_default !== 'NULL' && col_default !== 'CURRENT_TIMESTAMP') {
        $input4.val(""USER_DEFINED"");
        $input4.next().next().show();
        $input4.next().next().val(central_column_list[db + '_' + table][offset].col_default);
    } else {
        $input4.val(central_column_list[db + '_' + table][offset].col_default);
        $input4.next().next().hide();
    }
    $('#' + input_id + '5').val(central_column_list[db + '_' + table][offset].col_collation);
    var $input6 = $('#' + input_id + '6');
    $input6.val(central_column_list[db + '_' + table][offset].col_attribute);
    if(central_column_list[db + '_' + table][offset].col_extra === 'on update CURRENT_TIMESTAMP') {
        $input6.val(central_column_list[db + '_' + table][offset].col_extra);
    }
    if(central_column_list[db + '_' + table][offset].col_extra.toUpperCase() === 'AUTO_INCREMENT') {
        $('#' + input_id + '9').prop(""checked"",true).change();
    } else {
        $('#' + input_id + '9').prop(""checked"",false);
    }
    if(central_column_list[db + '_' + table][offset].col_isNull !== '0') {
        $('#' + input_id + '7').prop(""checked"",true);
    } else {
        $('#' + input_id + '7').prop(""checked"",false);
    }
}

/**
 * Unbind all event handlers before tearing down a page
 */
AJAX.registerTeardown('functions.js', function () {
    $(document).off('click', ""a.open_enum_editor"");
    $(document).off('click', ""input.add_value"");
    $(document).off('click', ""#enum_editor td.drop"");
    $(document).off('click', 'a.central_columns_dialog');
});
/**
 * @var $enum_editor_dialog An object that points to the jQuery
 *                          dialog of the ENUM/SET editor
 */
var $enum_editor_dialog = null;
/**
 * Opens the ENUM/SET editor and controls its functions
 */
AJAX.registerOnload('functions.js', function () {
    $(document).on('click', ""a.open_enum_editor"", function () {
        // Get the name of the column that is being edited
        var colname = $(this).closest('tr').find('input:first').val();
        var title;
        var i;
        // And use it to make up a title for the page
        if (colname.length < 1) {
            title = PMA_messages.enum_newColumnVals;
        } else {
            title = PMA_messages.enum_columnVals.replace(
                /%s/,
                '""' + escapeHtml(decodeURIComponent(colname)) + '""'
            );
        }
        // Get the values as a string
        var inputstring = $(this)
            .closest('td')
            .find(""input"")
            .val();
        // Escape html entities
        inputstring = $('<div/>')
            .text(inputstring)
            .html();
        // Parse the values, escaping quotes and
        // slashes on the fly, into an array
        var values = [];
        var in_string = false;
        var curr, next, buffer = '';
        for (i = 0; i < inputstring.length; i++) {
            curr = inputstring.charAt(i);
            next = i == inputstring.length ? '' : inputstring.charAt(i + 1);
            if (! in_string && curr == ""'"") {
                in_string = true;
            } else if (in_string && curr == ""\\"" && next == ""\\"") {
                buffer += ""&#92;"";
                i++;
            } else if (in_string && next == ""'"" && (curr == ""'"" || curr == ""\\"")) {
                buffer += ""&#39;"";
                i++;
            } else if (in_string && curr == ""'"") {
                in_string = false;
                values.push(buffer);
                buffer = '';
            } else if (in_string) {
                buffer += curr;
            }
        }
        if (buffer.length > 0) {
            // The leftovers in the buffer are the last value (if any)
            values.push(buffer);
        }
        var fields = '';
        // If there are no values, maybe the user is about to make a
        // new list so we add a few for him/her to get started with.
        if (values.length === 0) {
            values.push('', '', '', '');
        }
        // Add the parsed values to the editor
        var drop_icon = PMA_getImage('b_drop.png');
        for (i = 0; i < values.length; i++) {
            fields += ""<tr><td>"" +
                   ""<input type='text' value='"" + values[i] + ""'/>"" +
                   ""</td><td class='drop'>"" +
                   drop_icon +
                   ""</td></tr>"";
        }
        /**
         * @var dialog HTML code for the ENUM/SET dialog
         */
        var dialog = ""<div id='enum_editor'>"" +
                   ""<fieldset>"" +
                    ""<legend>"" + title + ""</legend>"" +
                    ""<p>"" + PMA_getImage('s_notice.png') +
                    PMA_messages.enum_hint + ""</p>"" +
                    ""<table class='values'>"" + fields + ""</table>"" +
                    ""</fieldset><fieldset class='tblFooters'>"" +
                    ""<table class='add'><tr><td>"" +
                    ""<div class='slider'></div>"" +
                    ""</td><td>"" +
                    ""<form><div><input type='submit' class='add_value' value='"" +
                    PMA_sprintf(PMA_messages.enum_addValue, 1) +
                    ""'/></div></form>"" +
                    ""</td></tr></table>"" +
                    ""<input type='hidden' value='"" + // So we know which column's data is being edited
                    $(this).closest('td').find(""input"").attr(""id"") +
                    ""' />"" +
                    ""</fieldset>"" +
                    ""</div>"";
        /**
         * @var  Defines functions to be called when the buttons in
         * the buttonOptions jQuery dialog bar are pressed
         */
        var buttonOptions = {};
        buttonOptions[PMA_messages.strGo] = function () {
            // When the submit button is clicked,
            // put the data back into the original form
            var value_array = [];
            $(this).find("".values input"").each(function (index, elm) {
                var val = elm.value.replace(/\\/g, '\\\\').replace(/'/g, ""''"");
                value_array.push(""'"" + val + ""'"");
            });
            // get the Length/Values text field where this value belongs
            var values_id = $(this).find(""input[type='hidden']"").val();
            $(""input#"" + values_id).val(value_array.join("",""));
            $(this).dialog(""close"");
        };
        buttonOptions[PMA_messages.strClose] = function () {
            $(this).dialog(""close"");
        };
        // Show the dialog
        var width = parseInt(
            (parseInt($('html').css('font-size'), 10) / 13) * 340,
            10
        );
        if (! width) {
            width = 340;
        }
        $enum_editor_dialog = $(dialog).dialog({
            minWidth: width,
            maxHeight: 450,
            modal: true,
            title: PMA_messages.enum_editor,
            buttons: buttonOptions,
            open: function () {
                // Focus the ""Go"" button after opening the dialog
                $(this).closest('.ui-dialog').find('.ui-dialog-buttonpane button:first').focus();
            },
            close: function () {
                $(this).remove();
            }
        });
        // slider for choosing how many fields to add
        $enum_editor_dialog.find("".slider"").slider({
            animate: true,
            range: ""min"",
            value: 1,
            min: 1,
            max: 9,
            slide: function (event, ui) {
                $(this).closest('table').find('input[type=submit]').val(
                    PMA_sprintf(PMA_messages.enum_addValue, ui.value)
                );
            }
        });
        // Focus the slider, otherwise it looks nearly transparent
        $('a.ui-slider-handle').addClass('ui-state-focus');
        return false;
    });

    $(document).on('click', 'a.central_columns_dialog', function (e) {
        var href = ""db_central_columns.php"";
        var db = PMA_commonParams.get('db');
        var table = PMA_commonParams.get('table');
        var maxRows = $(this).data('maxrows');
        var pick = $(this).data('pick');
        if (pick !== false) {
            pick = true;
        }
        var params = {
            'ajax_request' : true,
            'token' : PMA_commonParams.get('token'),
            'server' : PMA_commonParams.get('server'),
            'db' : PMA_commonParams.get('db'),
            'cur_table' : PMA_commonParams.get('table'),
            'getColumnList':true
        };
        var colid = $(this).closest('td').find(""input"").attr(""id"");
        var fields = '';
        if (! (db + '_' + table in central_column_list)) {
            central_column_list.push(db + '_' + table);
            $.ajax({
                type: 'POST',
                url: href,
                data: params,
                success: function (data) {
                    central_column_list[db + '_' + table] = $.parseJSON(data.message);
                },
                async:false
            });
        }
        var i = 0;
        var list_size = central_column_list[db + '_' + table].length;
        var min = (list_size <= maxRows) ? list_size : maxRows;
        for (i = 0; i < min; i++) {

            fields += '<tr><td><div><span style=""font-weight:bold"">' +
                escapeHtml(central_column_list[db + '_' + table][i].col_name) +
                '</span><br><span style=""color:gray"">' + central_column_list[db + '_' + table][i].col_type;

            if (central_column_list[db + '_' + table][i].col_attribute !== '') {
                fields += '(' + escapeHtml(central_column_list[db + '_' + table][i].col_attribute) + ') ';
            }
            if (central_column_list[db + '_' + table][i].col_length !== '') {
                fields += '(' + escapeHtml(central_column_list[db + '_' + table][i].col_length) +') ';
            }
            fields += escapeHtml(central_column_list[db + '_' + table][i].col_extra) + '</span>' +
                '</div></td>';
            if (pick) {
                fields += '<td><input class=""pick"" style=""width:100%"" type=""submit"" value=""' +
                    PMA_messages.pickColumn + '"" onclick=""autoPopulate(\'' + colid + '\',' + i + ')""/></td>';
            }
            fields += '</tr>';
        }
        var result_pointer = i;
        var search_in = '<input type=""text"" class=""filter_rows"" placeholder=""' + PMA_messages.searchList + '"">';
        if (fields === '') {
            fields = PMA_sprintf(PMA_messages.strEmptyCentralList, ""'"" + db + ""'"");
            search_in = '';
        }
        var seeMore = '';
        if (list_size > maxRows) {
            seeMore = ""<fieldset class='tblFooters' style='text-align:center;font-weight:bold'>"" +
                ""<a href='#' id='seeMore'>"" + PMA_messages.seeMore + ""</a></fieldset>"";
        }
        var central_columns_dialog = ""<div style='max-height:400px'>"" +
            ""<fieldset>"" +
            search_in +
            ""<table id='col_list' style='width:100%' class='values'>"" + fields + ""</table>"" +
            ""</fieldset>"" +
            seeMore +
            ""</div>"";

        var width = parseInt(
            (parseInt($('html').css('font-size'), 10) / 13) * 500,
            10
        );
        if (! width) {
            width = 500;
        }
        var buttonOptions = {};
        var $central_columns_dialog = $(central_columns_dialog).dialog({
            minWidth: width,
            maxHeight: 450,
            modal: true,
            title: PMA_messages.pickColumnTitle,
            buttons: buttonOptions,
            open: function () {
                $('#col_list').on(""click"", "".pick"", function (){
                    $central_columns_dialog.remove();
                });
                $("".filter_rows"").on(""keyup"", function () {
                    $.uiTableFilter($(""#col_list""), $(this).val());
                });
                $(""#seeMore"").click(function() {
                    fields = '';
                    min = (list_size <= maxRows + result_pointer) ? list_size : maxRows + result_pointer;
                    for (i = result_pointer; i < min; i++) {

                        fields += '<tr><td><div><span style=""font-weight:bold"">' +
                            central_column_list[db + '_' + table][i].col_name +
                            '</span><br><span style=""color:gray"">' +
                            central_column_list[db + '_' + table][i].col_type;

                        if (central_column_list[db + '_' + table][i].col_attribute !== '') {
                            fields += '(' + central_column_list[db + '_' + table][i].col_attribute + ') ';
                        }
                        if (central_column_list[db + '_' + table][i].col_length !== '') {
                            fields += '(' + central_column_list[db + '_' + table][i].col_length + ') ';
                        }
                        fields += central_column_list[db + '_' + table][i].col_extra + '</span>' +
                            '</div></td>';
                        if (pick) {
                            fields += '<td><input class=""pick"" style=""width:100%"" type=""submit"" value=""' +
                                PMA_messages.pickColumn + '"" onclick=""autoPopulate(\'' + colid + '\',' + i + ')""/></td>';
                        }
                        fields += '</tr>';
                    }
                    $(""#col_list"").append(fields);
                    result_pointer = i;
                    if (result_pointer === list_size) {
                        $('.tblFooters').hide();
                    }
                    return false;
                });
                $(this).closest('.ui-dialog').find('.ui-dialog-buttonpane button:first').focus();
            },
            close: function () {
                $('#col_list').off(""click"", "".pick"");
                $("".filter_rows"").off(""keyup"");
                $(this).remove();
            }
        });
        return false;
    });

   // $(document).on('click', 'a.show_central_list',function(e) {

   // });
    // When ""add a new value"" is clicked, append an empty text field
    $(document).on('click', ""input.add_value"", function (e) {
        e.preventDefault();
        var num_new_rows = $enum_editor_dialog.find(""div.slider"").slider('value');
        while (num_new_rows--) {
            $enum_editor_dialog.find('.values')
                .append(
                    ""<tr style='display: none;'><td>"" +
                    ""<input type='text' />"" +
                    ""</td><td class='drop'>"" +
                    PMA_getImage('b_drop.png') +
                    ""</td></tr>""
                )
                .find('tr:last')
                .show('fast');
        }
    });

    // Removes the specified row from the enum editor
    $(document).on('click', ""#enum_editor td.drop"", function () {
        $(this).closest('tr').hide('fast', function () {
            $(this).remove();
        });
    });
});

/**
 * Ensures indexes names are valid according to their type and, for a primary
 * key, lock index name to 'PRIMARY'
 * @param string   form_id  Variable which parses the form name as
 *                            the input
 * @return boolean  false    if there is no index form, true else
 */
function checkIndexName(form_id)
{
    if ($(""#"" + form_id).length === 0) {
        return false;
    }

    // Gets the elements pointers
    var $the_idx_name = $(""#input_index_name"");
    var $the_idx_choice = $(""#select_index_choice"");

    // Index is a primary key
    if ($the_idx_choice.find(""option:selected"").val() == 'PRIMARY') {
        $the_idx_name.val('PRIMARY');
        $the_idx_name.prop(""disabled"", true);
    }

    // Other cases
    else {
        if ($the_idx_name.val() == 'PRIMARY') {
            $the_idx_name.val("""");
        }
        $the_idx_name.prop(""disabled"", false);
    }

    return true;
} // end of the 'checkIndexName()' function

AJAX.registerTeardown('functions.js', function () {
    $(document).off('click', '#index_frm input[type=submit]');
});
AJAX.registerOnload('functions.js', function () {
    /**
     * Handler for adding more columns to an index in the editor
     */
    $(document).on('click', '#index_frm input[type=submit]', function (event) {
        event.preventDefault();
        var rows_to_add = $(this)
            .closest('fieldset')
            .find('.slider')
            .slider('value');

        var tempEmptyVal = function () {
            $(this).val('');
        };

        var tempSetFocus = function () {
            if ($(this).find(""option:selected"").val() === '') {
                return true;
            }
            $(this).closest(""tr"").find(""input"").focus();
        };

        while (rows_to_add--) {
            var $indexColumns = $('#index_columns');
            var $newrow = $indexColumns
                .find('tbody > tr:first')
                .clone()
                .appendTo(
                    $indexColumns.find('tbody')
                );
            $newrow.find(':input').each(tempEmptyVal);
            // focus index size input on column picked
            $newrow.find('select').change(tempSetFocus);
        }
    });
});

function indexEditorDialog(url, title, callback_success, callback_failure)
{
    /*Remove the hidden dialogs if there are*/
    var $editIndexDialog = $('#edit_index_dialog');
    if ($editIndexDialog.length !== 0) {
        $editIndexDialog.remove();
    }
    var $div = $('<div id=""edit_index_dialog""></div>');

    /**
     * @var button_options Object that stores the options
     *                     passed to jQueryUI dialog
     */
    var button_options = {};
    button_options[PMA_messages.strGo] = function () {
        /**
         * @var    the_form    object referring to the export form
         */
        var $form = $(""#index_frm"");
        var $msgbox = PMA_ajaxShowMessage(PMA_messages.strProcessingRequest);
        PMA_prepareForAjaxRequest($form);
        //User wants to submit the form
        $.post($form.attr('action'), $form.serialize() + ""&do_save_data=1"", function (data) {
            var $sqlqueryresults = $("".sqlqueryresults"");
            if ($sqlqueryresults.length !== 0) {
                $sqlqueryresults.remove();
            }
            if (typeof data !== 'undefined' && data.success === true) {
                PMA_ajaxShowMessage(data.message);
                var $resultQuery = $('.result_query');
                if ($resultQuery.length) {
                    $resultQuery.remove();
                }
                if (data.sql_query) {
                    $('<div class=""result_query""></div>')
                        .html(data.sql_query)
                        .prependTo('#page_content');
                    PMA_highlightSQL($('#page_content'));
                }
                $("".result_query .notice"").remove();
                $resultQuery.prepend(data.message);
                /*Reload the field form*/
                $(""#table_index"").remove();
                $(""<div id='temp_div'><div>"")
                    .append(data.index_table)
                    .find(""#table_index"")
                    .insertAfter(""#index_header"");
                var $editIndexDialog = $(""#edit_index_dialog"");
                if ($editIndexDialog.length > 0) {
                    $editIndexDialog.dialog(""close"");
                }
                $('div.no_indexes_defined').hide();
                if (callback_success) {
                    callback_success();
                }
                PMA_reloadNavigation();
            } else {
                var $temp_div = $(""<div id='temp_div'><div>"").append(data.error);
                var $error;
                if ($temp_div.find("".error code"").length !== 0) {
                    $error = $temp_div.find("".error code"").addClass(""error"");
                } else {
                    $error = $temp_div;
                }
                if (callback_failure) {
                    callback_failure();
                }
                PMA_ajaxShowMessage($error, false);
            }
        }); // end $.post()
    };
    button_options[PMA_messages.strPreviewSQL] = function () {
        // Function for Previewing SQL
        var $form = $('#index_frm');
        PMA_previewSQL($form);
    };
    button_options[PMA_messages.strCancel] = function () {
        $(this).dialog('close');
    };
    var $msgbox = PMA_ajaxShowMessage();
    $.get(""tbl_indexes.php"", url, function (data) {
        if (typeof data !== 'undefined' && data.success === false) {
            //in the case of an error, show the error message returned.
            PMA_ajaxShowMessage(data.error, false);
        } else {
            PMA_ajaxRemoveMessage($msgbox);
            // Show dialog if the request was successful
            $div
            .append(data.message)
            .dialog({
                title: title,
                width: 450,
                height: 350,
                open: PMA_verifyColumnsProperties,
                modal: true,
                buttons: button_options,
                close: function () {
                    $(this).remove();
                }
            });
            $div.find('.tblFooters').remove();
            showIndexEditDialog($div);
        }
    }); // end $.get()
}

function showIndexEditDialog($outer)
{
    checkIndexType();
    checkIndexName(""index_frm"");
    var $indexColumns = $('#index_columns');
    $indexColumns.find('td').each(function () {
        $(this).css(""width"", $(this).width() + 'px');
    });
    $indexColumns.find('tbody').sortable({
        axis: 'y',
        containment: $indexColumns.find(""tbody""),
        tolerance: 'pointer'
    });
    PMA_showHints($outer);
    PMA_init_slider();
    // Add a slider for selecting how many columns to add to the index
    $outer.find('.slider').slider({
        animate: true,
        value: 1,
        min: 1,
        max: 16,
        slide: function (event, ui) {
            $(this).closest('fieldset').find('input[type=submit]').val(
                PMA_sprintf(PMA_messages.strAddToIndex, ui.value)
            );
        }
    });
    $('div.add_fields').removeClass('hide');
    // focus index size input on column picked
    $outer.find('table#index_columns select').change(function () {
        if ($(this).find(""option:selected"").val() === '') {
            return true;
        }
        $(this).closest(""tr"").find(""input"").focus();
    });
    // Focus the slider, otherwise it looks nearly transparent
    $('a.ui-slider-handle').addClass('ui-state-focus');
    // set focus on index name input, if empty
    var input = $outer.find('input#input_index_name');
    input.val() || input.focus();
}

/**
 * Function to display tooltips that were
 * generated on the PHP side by PMA_Util::showHint()
 *
 * @param object $div a div jquery object which specifies the
 *                    domain for searching for tooltips. If we
 *                    omit this parameter the function searches
 *                    in the whole body
 **/
function PMA_showHints($div)
{
    if ($div === undefined || ! $div instanceof jQuery || $div.length === 0) {
        $div = $(""body"");
    }
    $div.find('.pma_hint').each(function () {
        PMA_tooltip(
            $(this).children('img'),
            'img',
            $(this).children('span').html()
        );
    });
}

AJAX.registerOnload('functions.js', function () {
    PMA_showHints();
});

function PMA_mainMenuResizerCallback() {
    // 5 px margin for jumping menu in Chrome
    return $(document.body).width() - 5;
}
// This must be fired only once after the initial page load
$(function () {
    // Initialise the menu resize plugin
    $('#topmenu').menuResizer(PMA_mainMenuResizerCallback);
    // register resize event
    $(window).resize(function () {
        $('#topmenu').menuResizer('resize');
    });
});

/**
 * Get the row number from the classlist (for example, row_1)
 */
function PMA_getRowNumber(classlist)
{
    return parseInt(classlist.split(/\s+row_/)[1], 10);
}

/**
 * Changes status of slider
 */
function PMA_set_status_label($element)
{
    var text;
    if ($element.css('display') == 'none') {
        text = '+ ';
    } else {
        text = '- ';
    }
    $element.closest('.slide-wrapper').prev().find('span').text(text);
}

/**
 * var  toggleButton  This is a function that creates a toggle
 *                    sliding button given a jQuery reference
 *                    to the correct DOM element
 */
var toggleButton = function ($obj) {
    // In rtl mode the toggle switch is flipped horizontally
    // so we need to take that into account
    var right;
    if ($('span.text_direction', $obj).text() == 'ltr') {
        right = 'right';
    } else {
        right = 'left';
    }
    /**
     *  var  h  Height of the button, used to scale the
     *          background image and position the layers
     */
    var h = $obj.height();
    $('img', $obj).height(h);
    $('table', $obj).css('bottom', h - 1);
    /**
     *  var  on   Width of the ""ON"" part of the toggle switch
     *  var  off  Width of the ""OFF"" part of the toggle switch
     */
    var on  = $('td.toggleOn', $obj).width();
    var off = $('td.toggleOff', $obj).width();
    // Make the ""ON"" and ""OFF"" parts of the switch the same size
    // + 2 pixels to avoid overflowed
    $('td.toggleOn > div', $obj).width(Math.max(on, off) + 2);
    $('td.toggleOff > div', $obj).width(Math.max(on, off) + 2);
    /**
     *  var  w  Width of the central part of the switch
     */
    var w = parseInt(($('img', $obj).height() / 16) * 22, 10);
    // Resize the central part of the switch on the top
    // layer to match the background
    $('table td:nth-child(2) > div', $obj).width(w);
    /**
     *  var  imgw    Width of the background image
     *  var  tblw    Width of the foreground layer
     *  var  offset  By how many pixels to move the background
     *               image, so that it matches the top layer
     */
    var imgw = $('img', $obj).width();
    var tblw = $('table', $obj).width();
    var offset = parseInt(((imgw - tblw) / 2), 10);
    // Move the background to match the layout of the top layer
    $obj.find('img').css(right, offset);
    /**
     *  var  offw    Outer width of the ""ON"" part of the toggle switch
     *  var  btnw    Outer width of the central part of the switch
     */
    var offw = $('td.toggleOff', $obj).outerWidth();
    var btnw = $('table td:nth-child(2)', $obj).outerWidth();
    // Resize the main div so that exactly one side of
    // the switch plus the central part fit into it.
    $obj.width(offw + btnw + 2);
    /**
     *  var  move  How many pixels to move the
     *             switch by when toggling
     */
    var move = $('td.toggleOff', $obj).outerWidth();
    // If the switch is initialized to the
    // OFF state we need to move it now.
    if ($('div.container', $obj).hasClass('off')) {
        if (right == 'right') {
            $('div.container', $obj).animate({'left': '-=' + move + 'px'}, 0);
        } else {
            $('div.container', $obj).animate({'left': '+=' + move + 'px'}, 0);
        }
    }
    // Attach an 'onclick' event to the switch
    $('div.container', $obj).click(function () {
        if ($(this).hasClass('isActive')) {
            return false;
        } else {
            $(this).addClass('isActive');
        }
        var $msg = PMA_ajaxShowMessage();
        var $container = $(this);
        var callback = $('span.callback', this).text();
        var operator, url, removeClass, addClass;
        // Perform the actual toggle
        if ($(this).hasClass('on')) {
            if (right == 'right') {
                operator = '-=';
            } else {
                operator = '+=';
            }
            url = $(this).find('td.toggleOff > span').text();
            removeClass = 'on';
            addClass = 'off';
        } else {
            if (right == 'right') {
                operator = '+=';
            } else {
                operator = '-=';
            }
            url = $(this).find('td.toggleOn > span').text();
            removeClass = 'off';
            addClass = 'on';
        }
        $.post(url, {'ajax_request': true}, function (data) {
            if (typeof data !== 'undefined' && data.success === true) {
                PMA_ajaxRemoveMessage($msg);
                $container
                .removeClass(removeClass)
                .addClass(addClass)
                .animate({'left': operator + move + 'px'}, function () {
                    $container.removeClass('isActive');
                });
                eval(callback);
            } else {
                PMA_ajaxShowMessage(data.error, false);
                $container.removeClass('isActive');
            }
        });
    });
};

/**
 * Unbind all event handlers before tearing down a page
 */
AJAX.registerTeardown('functions.js', function () {
    $('div.container').unbind('click');
});
/**
 * Initialise all toggle buttons
 */
AJAX.registerOnload('functions.js', function () {
    $('div.toggleAjax').each(function () {
        var $button = $(this).show();
        $button.find('img').each(function () {
            if (this.complete) {
                toggleButton($button);
            } else {
                $(this).load(function () {
                    toggleButton($button);
                });
            }
        });
    });
});

/**
 * Unbind all event handlers before tearing down a page
 */
AJAX.registerTeardown('functions.js', function () {
    $(document).off('change', 'select.pageselector');
    $(document).off('click', 'a.formLinkSubmit');
    $('#update_recent_tables').unbind('ready');
    $('#sync_favorite_tables').unbind('ready');
});

AJAX.registerOnload('functions.js', function () {

    /**
     * Autosubmit page selector
     */
    $(document).on('change', 'select.pageselector', function (event) {
        event.stopPropagation();
        // Check where to load the new content
        if ($(this).closest(""#pma_navigation"").length === 0) {
            // For the main page we don't need to do anything,
            $(this).closest(""form"").submit();
        } else {
            // but for the navigation we need to manually replace the content
            PMA_navigationTreePagination($(this));
        }
    });

    /**
     * Load version information asynchronously.
     */
    if ($('li.jsversioncheck').length > 0) {
        $.getJSON('version_check.php', {'server' : PMA_commonParams.get('server')}, PMA_current_version);
    }

    if ($('#is_git_revision').length > 0) {
        setTimeout(PMA_display_git_revision, 10);
    }

    /**
     * Slider effect.
     */
    PMA_init_slider();

    /**
     * Enables the text generated by PMA_Util::linkOrButton() to be clickable
     */
    $(document).on('click', 'a.formLinkSubmit', function (e) {
        if (! $(this).hasClass('requireConfirm')) {
            submitFormLink($(this));
            return false;
        }
    });

    var $updateRecentTables = $('#update_recent_tables');
    if ($updateRecentTables.length) {
        $.get(
            $updateRecentTables.attr('href'),
            {no_debug: true},
            function (data) {
                if (typeof data !== 'undefined' && data.success === true) {
                    $('#pma_recent_list').html(data.list);
                }
            }
        );
    }

    // Sync favorite tables from localStorage to pmadb.
    if ($('#sync_favorite_tables').length) {
        $.ajax({
            url: $('#sync_favorite_tables').attr(""href""),
            cache: false,
            type: 'POST',
            data: {
                favorite_tables: (isStorageSupported('localStorage') && typeof window.localStorage.favorite_tables !== 'undefined')
                    ? window.localStorage.favorite_tables
                    : '',
                no_debug: true
            },
            success: function (data) {
                // Update localStorage.
                if (isStorageSupported('localStorage')) {
                    window.localStorage.favorite_tables = data.favorite_tables;
                }
                $('#pma_favorite_list').html(data.list);
            }
        });
    }
}); // end of $()

/**
 * Submits the form placed in place of a link due to the excessive url length
 *
 * @param $link anchor
 * @returns {Boolean}
 */
function submitFormLink($link)
{
    if ($link.attr('href').indexOf('=') != -1) {
        var data = $link.attr('href').substr($link.attr('href').indexOf('#') + 1).split('=', 2);
        $link.parents('form').append('<input type=""hidden"" name=""' + data[0] + '"" value=""' + data[1] + '""/>');
    }
    $link.parents('form').submit();
}

/**
 * Initializes slider effect.
 */
function PMA_init_slider()
{
    $('div.pma_auto_slider').each(function () {
        var $this = $(this);
        if ($this.data('slider_init_done')) {
            return;
        }
        var $wrapper = $('<div>', {'class': 'slide-wrapper'});
        $wrapper.toggle($this.is(':visible'));
        $('<a>', {href: '#' + this.id, ""class"": 'ajax'})
            .text($this.attr('title'))
            .prepend($('<span>'))
            .insertBefore($this)
            .click(function () {
                var $wrapper = $this.closest('.slide-wrapper');
                var visible = $this.is(':visible');
                if (!visible) {
                    $wrapper.show();
                }
                $this[visible ? 'hide' : 'show']('blind', function () {
                    $wrapper.toggle(!visible);
                    $wrapper.parent().toggleClass(""print_ignore"", visible);
                    PMA_set_status_label($this);
                });
                return false;
            });
        $this.wrap($wrapper);
        $this.removeAttr('title');
        PMA_set_status_label($this);
        $this.data('slider_init_done', 1);
    });
}

/**
 * Initializes slider effect.
 */
AJAX.registerOnload('functions.js', function () {
    PMA_init_slider();
});

/**
 * Restores sliders to the state they were in before initialisation.
 */
AJAX.registerTeardown('functions.js', function () {
    $('div.pma_auto_slider').each(function () {
        var $this = $(this);
        $this.removeData();
        $this.parent().replaceWith($this);
        $this.parent().children('a').remove();
    });
});

/**
 * Creates a message inside an object with a sliding effect
 *
 * @param msg    A string containing the text to display
 * @param $obj   a jQuery object containing the reference
 *                 to the element where to put the message
 *                 This is optional, if no element is
 *                 provided, one will be created below the
 *                 navigation links at the top of the page
 *
 * @return bool   True on success, false on failure
 */
function PMA_slidingMessage(msg, $obj)
{
    if (msg === undefined || msg.length === 0) {
        // Don't show an empty message
        return false;
    }
    if ($obj === undefined || ! $obj instanceof jQuery || $obj.length === 0) {
        // If the second argument was not supplied,
        // we might have to create a new DOM node.
        if ($('#PMA_slidingMessage').length === 0) {
            $('#page_content').prepend(
                '<span id=""PMA_slidingMessage"" ' +
                'style=""display: inline-block;""></span>'
            );
        }
        $obj = $('#PMA_slidingMessage');
    }
    if ($obj.has('div').length > 0) {
        // If there already is a message inside the
        // target object, we must get rid of it
        $obj
        .find('div')
        .first()
        .fadeOut(function () {
            $obj
            .children()
            .remove();
            $obj
            .append('<div>' + msg + '</div>');
            // highlight any sql before taking height;
            PMA_highlightSQL($obj);
            $obj.find('div')
                .first()
                .hide();
            $obj
            .animate({
                height: $obj.find('div').first().height()
            })
            .find('div')
            .first()
            .fadeIn();
        });
    } else {
        // Object does not already have a message
        // inside it, so we simply slide it down
        $obj.width('100%')
            .html('<div>' + msg + '</div>');
        // highlight any sql before taking height;
        PMA_highlightSQL($obj);
        var h = $obj
            .find('div')
            .first()
            .hide()
            .height();
        $obj
        .find('div')
        .first()
        .css('height', 0)
        .show()
        .animate({
                height: h
            }, function () {
            // Set the height of the parent
            // to the height of the child
                $obj
                .height(
                    $obj
                    .find('div')
                    .first()
                    .height()
                );
            });
    }
    return true;
} // end PMA_slidingMessage()

/**
 * Attach CodeMirror2 editor to SQL edit area.
 */
AJAX.registerOnload('functions.js', function () {
    var $elm = $('#sqlquery');
    if ($elm.length > 0) {
        if (typeof CodeMirror != 'undefined') {
            codemirror_editor = PMA_getSQLEditor($elm);
            codemirror_editor.focus();
            codemirror_editor.on(""blur"", updateQueryParameters);
        } else {
            // without codemirror
            $elm.focus()
                .bind('blur', updateQueryParameters);
        }
    }
    PMA_highlightSQL($('body'));
});
AJAX.registerTeardown('functions.js', function () {
    if (codemirror_editor) {
        $('#sqlquery').text(codemirror_editor.getValue());
        codemirror_editor.toTextArea();
        codemirror_editor = false;
    }
});
AJAX.registerOnload('functions.js', function () {
    // initializes all lock-page elements lock-id and
    // val-hash data property
    $('#page_content form.lock-page textarea, ' +
            '#page_content form.lock-page input[type=""text""], '+
            '#page_content form.lock-page input[type=""number""], '+
            '#page_content form.lock-page select').each(function (i) {
        $(this).data('lock-id', i);
        // val-hash is the hash of default value of the field
        // so that it can be compared with new value hash
        // to check whether field was modified or not.
        $(this).data('val-hash', AJAX.hash($(this).val()));
    });

    // initializes lock-page elements (input types checkbox and radio buttons)
    // lock-id and val-hash data property
    $('#page_content form.lock-page input[type=""checkbox""], ' +
            '#page_content form.lock-page input[type=""radio""]').each(function (i) {
        $(this).data('lock-id', i);
        $(this).data('val-hash', AJAX.hash($(this).is("":checked"")));
    });
});
/**
 * jQuery plugin to cancel selection in HTML code.
 */
(function ($) {
    $.fn.noSelect = function (p) { //no select plugin by Paulo P.Marinas
        var prevent = (p === null) ? true : p;
        var is_msie = navigator.userAgent.indexOf('MSIE') > -1 || !!window.navigator.userAgent.match(/Trident.*rv\:11\./);
        var is_firefox = navigator.userAgent.indexOf('Firefox') > -1;
        var is_safari = navigator.userAgent.indexOf(""Safari"") > -1;
        var is_opera = navigator.userAgent.indexOf(""Presto"") > -1;
        if (prevent) {
            return this.each(function () {
                if (is_msie || is_safari) {
                    $(this).bind('selectstart', function () {
                        return false;
                    });
                } else if (is_firefox) {
                    $(this).css('MozUserSelect', 'none');
                    $('body').trigger('focus');
                } else if (is_opera) {
                    $(this).bind('mousedown', function () {
                        return false;
                    });
                } else {
                    $(this).attr('unselectable', 'on');
                }
            });
        } else {
            return this.each(function () {
                if (is_msie || is_safari) {
                    $(this).unbind('selectstart');
                } else if (is_firefox) {
                    $(this).css('MozUserSelect', 'inherit');
                } else if (is_opera) {
                    $(this).unbind('mousedown');
                } else {
                    $(this).removeAttr('unselectable');
                }
            });
        }
    }; //end noSelect
})(jQuery);

/**
 * jQuery plugin to correctly filter input fields by value, needed
 * because some nasty values may break selector syntax
 */
(function ($) {
    $.fn.filterByValue = function (value) {
        return this.filter(function () {
            return $(this).val() === value;
        });
    };
})(jQuery);

/**
 * Return value of a cell in a table.
 */
function PMA_getCellValue(td) {
    var $td = $(td);
    if ($td.is('.null')) {
        return '';
    } else if ((! $td.is('.to_be_saved')
        || $td.is('.set'))
        && $td.data('original_data')
    ) {
        return $td.data('original_data');
    } else {
        return $td.text();
    }
}

/**
 * Unbind all event handlers before tearing down a page
 */
AJAX.registerTeardown('functions.js', function () {
    $(document).off('click', 'a.themeselect');
    $(document).off('change', '.autosubmit');
    $('a.take_theme').unbind('click');
});

AJAX.registerOnload('functions.js', function () {
    /**
     * Theme selector.
     */
    $(document).on('click', 'a.themeselect', function (e) {
        window.open(
            e.target,
            'themes',
            'left=10,top=20,width=510,height=350,scrollbars=yes,status=yes,resizable=yes'
            );
        return false;
    });

    /**
     * Automatic form submission on change.
     */
    $(document).on('change', '.autosubmit', function (e) {
        $(this).closest('form').submit();
    });

    /**
     * Theme changer.
     */
    $('a.take_theme').click(function (e) {
        var what = this.name;
        if (window.opener && window.opener.document.forms.setTheme.elements.set_theme) {
            window.opener.document.forms.setTheme.elements.set_theme.value = what;
            window.opener.document.forms.setTheme.submit();
            window.close();
            return false;
        }
        return true;
    });
});

/**
 * Print button
 */
function printPage()
{
    // Do print the page
    if (typeof(window.print) != 'undefined') {
        window.print();
    }
}

/**
 * Unbind all event handlers before tearing down a page
 */
AJAX.registerTeardown('functions.js', function () {
    $('input#print').unbind('click');
    $(document).off('click', 'a.create_view.ajax');
    $(document).off('keydown', '#createViewDialog input, #createViewDialog select');
    $(document).off('change', '#fkc_checkbox');
});

AJAX.registerOnload('functions.js', function () {
    $('input#print').click(printPage);
    /**
     * Ajaxification for the ""Create View"" action
     */
    $(document).on('click', 'a.create_view.ajax', function (e) {
        e.preventDefault();
        PMA_createViewDialog($(this));
    });
    /**
     * Attach Ajax event handlers for input fields in the editor
     * and used to submit the Ajax request when the ENTER key is pressed.
     */
    if ($('#createViewDialog').length !== 0) {
        $(document).on('keydown', '#createViewDialog input, #createViewDialog select', function (e) {
            if (e.which === 13) { // 13 is the ENTER key
                e.preventDefault();

                // with preventing default, selection by <select> tag
                // was also prevented in IE
                $(this).blur();

                $(this).closest('.ui-dialog').find('.ui-button:first').click();
            }
        }); // end $(document).on()
    }

    syntaxHighlighter = PMA_getSQLEditor($('textarea[name=""view[as]""]'));

});

function PMA_createViewDialog($this)
{
    var $msg = PMA_ajaxShowMessage();
    var syntaxHighlighter = null;
    $.get($this.attr('href') + '&ajax_request=1&ajax_dialog=1', function (data) {
        if (typeof data !== 'undefined' && data.success === true) {
            PMA_ajaxRemoveMessage($msg);
            var buttonOptions = {};
            buttonOptions[PMA_messages.strGo] = function () {
                if (typeof CodeMirror !== 'undefined') {
                    syntaxHighlighter.save();
                }
                $msg = PMA_ajaxShowMessage();
                $.get('view_create.php', $('#createViewDialog').find('form').serialize(), function (data) {
                    PMA_ajaxRemoveMessage($msg);
                    if (typeof data !== 'undefined' && data.success === true) {
                        $('#createViewDialog').dialog(""close"");
                        $('.result_query').html(data.message);
                        PMA_reloadNavigation();
                    } else {
                        PMA_ajaxShowMessage(data.error, false);
                    }
                });
            };
            buttonOptions[PMA_messages.strClose] = function () {
                $(this).dialog(""close"");
            };
            var $dialog = $('<div/>').attr('id', 'createViewDialog').append(data.message).dialog({
                width: 600,
                minWidth: 400,
                modal: true,
                buttons: buttonOptions,
                title: PMA_messages.strCreateView,
                close: function () {
                    $(this).remove();
                }
            });
            // Attach syntax highlighted editor
            syntaxHighlighter = PMA_getSQLEditor($dialog.find('textarea'));
            $('input:visible[type=text]', $dialog).first().focus();
        } else {
            PMA_ajaxShowMessage(data.error);
        }
    });
}

/**
 * Makes the breadcrumbs and the menu bar float at the top of the viewport
 */
$(function () {
    if ($(""#floating_menubar"").length && $('#PMA_disable_floating_menubar').length === 0) {
        var left = $('html').attr('dir') == 'ltr' ? 'left' : 'right';
        $(""#floating_menubar"")
            .css('margin-' + left, $('#pma_navigation').width() + $('#pma_navigation_resizer').width())
            .css(left, 0)
            .css({
                'position': 'fixed',
                'top': 0,
                'width': '100%',
                'z-index': 99
            })
            .append($('#serverinfo'))
            .append($('#topmenucontainer'));
        // Allow the DOM to render, then adjust the padding on the body
        setTimeout(function () {
            $('body').css(
                'padding-top',
                $('#floating_menubar').outerHeight(true)
            );
            $('#topmenu').menuResizer('resize');
        }, 4);
    }
});

/**
 * Scrolls the page to the top if clicking the serverinfo bar
 */
$(function () {
    $(document).delegate(""#serverinfo, #goto_pagetop"", ""click"", function (event) {
        event.preventDefault();
        $('html, body').animate({scrollTop: 0}, 'fast');
    });
});

var checkboxes_sel = ""input.checkall:checkbox:enabled"";
/**
 * Watches checkboxes in a form to set the checkall box accordingly
 */
var checkboxes_changed = function () {
    var $form = $(this.form);
    // total number of checkboxes in current form
    var total_boxes = $form.find(checkboxes_sel).length;
    // number of checkboxes checked in current form
    var checked_boxes = $form.find(checkboxes_sel + "":checked"").length;
    var $checkall = $form.find(""input.checkall_box"");
    if (total_boxes == checked_boxes) {
        $checkall.prop({checked: true, indeterminate: false});
    }
    else if (checked_boxes > 0) {
        $checkall.prop({checked: true, indeterminate: true});
    }
    else {
        $checkall.prop({checked: false, indeterminate: false});
    }
};
$(document).on(""change"", checkboxes_sel, checkboxes_changed);

$(document).on(""change"", ""input.checkall_box"", function () {
    var is_checked = $(this).is("":checked"");
    $(this.form).find(checkboxes_sel).prop(""checked"", is_checked)
    .parents(""tr"").toggleClass(""marked"", is_checked);
});

/**
 * Watches checkboxes in a sub form to set the sub checkall box accordingly
 */
var sub_checkboxes_changed = function () {
    var $form = $(this).parent().parent();
    // total number of checkboxes in current sub form
    var total_boxes = $form.find(checkboxes_sel).length;
    // number of checkboxes checked in current sub form
    var checked_boxes = $form.find(checkboxes_sel + "":checked"").length;
    var $checkall = $form.find(""input.sub_checkall_box"");
    if (total_boxes == checked_boxes) {
        $checkall.prop({checked: true, indeterminate: false});
    }
    else if (checked_boxes > 0) {
        $checkall.prop({checked: true, indeterminate: true});
    }
    else {
        $checkall.prop({checked: false, indeterminate: false});
    }
};
$(document).on(""change"", checkboxes_sel + "", input.checkall_box:checkbox:enabled"", sub_checkboxes_changed);

$(document).on(""change"", ""input.sub_checkall_box"", function () {
    var is_checked = $(this).is("":checked"");
    var $form = $(this).parent().parent();
    $form.find(checkboxes_sel).prop(""checked"", is_checked)
    .parents(""tr"").toggleClass(""marked"", is_checked);
});

/**
 * Toggles row colors of a set of 'tr' elements starting from a given element
 *
 * @param $start Starting element
 */
function toggleRowColors($start)
{
    for (var $curr_row = $start; $curr_row.length > 0; $curr_row = $curr_row.next()) {
        if ($curr_row.hasClass('odd')) {
            $curr_row.removeClass('odd').addClass('even');
        } else if ($curr_row.hasClass('even')) {
            $curr_row.removeClass('even').addClass('odd');
        }
    }
}

/**
 * Formats a byte number to human-readable form
 *
 * @param bytes the bytes to format
 * @param optional subdecimals the number of digits after the point
 * @param optional pointchar the char to use as decimal point
 */
function formatBytes(bytes, subdecimals, pointchar) {
    if (!subdecimals) {
        subdecimals = 0;
    }
    if (!pointchar) {
        pointchar = '.';
    }
    var units = ['B', 'KiB', 'MiB', 'GiB'];
    for (var i = 0; bytes > 1024 && i < units.length; i++) {
        bytes /= 1024;
    }
    var factor = Math.pow(10, subdecimals);
    bytes = Math.round(bytes * factor) / factor;
    bytes = bytes.toString().split('.').join(pointchar);
    return bytes + ' ' + units[i];
}

AJAX.registerOnload('functions.js', function () {
    /**
     * Opens pma more themes link in themes browser, in new window instead of popup
     * This way, we don't break HTML validity
     */
    $(""a._blank"").prop(""target"", ""_blank"");
    /**
     * Reveal the login form to users with JS enabled
     * and focus the appropriate input field
     */
    var $loginform = $('#loginform');
    if ($loginform.length) {
        $loginform.find('.js-show').show();
        if ($('#input_username').val()) {
            $('#input_password').focus();
        } else {
            $('#input_username').focus();
        }
    }
});

/**
 * Dynamically adjust the width of the boxes
 * on the table and db operations pages
 */
(function () {
    function DynamicBoxes() {
        var $boxContainer = $('#boxContainer');
        if ($boxContainer.length) {
            var minWidth = $boxContainer.data('box-width');
            var viewport = $(window).width() - $('#pma_navigation').width();
            var slots = Math.floor(viewport / minWidth);
            $boxContainer.children()
            .each(function () {
                if (viewport < minWidth) {
                    $(this).width(minWidth);
                } else {
                    $(this).css('width', ((1 /  slots) * 100) + ""%"");
                }
            })
            .removeClass('clearfloat')
            .filter(':nth-child(' + slots + 'n+1)')
            .addClass('clearfloat');
        }
    }
    AJAX.registerOnload('functions.js', function () {
        DynamicBoxes();
    });
    $(function () {
        $(window).resize(DynamicBoxes);
    });
})();

/**
 * Formats timestamp for display
 */
function PMA_formatDateTime(date, seconds) {
    var result = $.datepicker.formatDate('yy-mm-dd', date);
    var timefmt = 'HH:mm';
    if (seconds) {
        timefmt = 'HH:mm:ss';
    }
    return result + ' ' + $.datepicker.formatTime(
        timefmt, {
            hour: date.getHours(),
            minute: date.getMinutes(),
            second: date.getSeconds()
        }
    );
}

/**
 * Check than forms have less fields than max allowed by PHP.
 */
function checkNumberOfFields() {
    if (typeof maxInputVars === 'undefined') {
        return false;
    }
    if (false === maxInputVars) {
        return false;
    }
    $('form').each(function() {
        var nbInputs = $(this).find(':input').length;
        if (nbInputs > maxInputVars) {
            var warning = PMA_sprintf(PMA_messages.strTooManyInputs, maxInputVars);
            PMA_ajaxShowMessage(warning);
            return false;
        }
        return true;
    });

    return true;
}

/**
 * Ignore the displayed php errors.
 * Simply removes the displayed errors.
 *
 * @param  clearPrevErrors whether to clear errors stored
 *             in $_SESSION['prev_errors'] at server
 *
 */
function PMA_ignorePhpErrors(clearPrevErrors){
    if (typeof(clearPrevErrors) === ""undefined"" ||
        clearPrevErrors === null
    ) {
        str = false;
    }
    // send AJAX request to error_report.php with send_error_report=0, exception_type=php & token.
    // It clears the prev_errors stored in session.
    if(clearPrevErrors){
        var $pmaReportErrorsForm = $('#pma_report_errors_form');
        $pmaReportErrorsForm.find('input[name=""send_error_report""]').val(0); // change send_error_report to '0'
        $pmaReportErrorsForm.submit();
    }

    // remove displayed errors
    var $pmaErrors = $('#pma_errors');
    $pmaErrors.fadeOut( ""slow"");
    $pmaErrors.remove();
}

/**
 * checks whether browser supports web storage
 *
 * @param type the type of storage i.e. localStorage or sessionStorage
 *
 * @returns bool
 */
function isStorageSupported(type)
{
    try {
        window[type].setItem('PMATest', 'test');
        // Check whether key-value pair was set successfully
        if (window[type].getItem('PMATest') === 'test') {
            // Supported, remove test variable from storage
            window[type].removeItem('PMATest');
            return true;
        }
    } catch(error) {
        // Not supported
        PMA_ajaxShowMessage(PMA_messages.strNoLocalStorage, false);
    }
    return false;
}

/**
 * Unbind all event handlers before tearing down a page
 */
AJAX.registerTeardown('functions.js', function(){
    $(document).off('keydown', 'form input, form textarea, form select');
});

AJAX.registerOnload('functions.js', function () {
    /**
     * Handle 'Ctrl/Alt + Enter' form submits
     */
    $('form input, form textarea, form select').on('keydown', function(e){
        if((e.ctrlKey && e.which == 13) || (e.altKey && e.which == 13)) {
            $form = $(this).closest('form');
            if (! $form.find('input[type=""submit""]') ||
                ! $form.find('input[type=""submit""]').click()
            ) {
                $form.submit();
            }
        }
    });
});

/**
 * Unbind all event handlers before tearing down a page
 */
AJAX.registerTeardown('functions.js', function(){
    $(document).off('change', 'input[type=radio][name=""pw_hash""]');
});

AJAX.registerOnload('functions.js', function(){
    /*
     * Display warning regarding SSL when sha256_password
     * method is selected
     * Used in user_password.php (Change Password link on index.php)
     */
    $(document).on(""change"", 'select#select_authentication_plugin_cp', function() {
        if (this.value === 'sha256_password') {
            $('#ssl_reqd_warning_cp').show();
        } else {
            $('#ssl_reqd_warning_cp').hide();
        }
    });
});
"
"'use strict';
/**
 * Copyright 2009 Google Inc., 2011 Peter 'Pita' Martischka (Primary Technology Ltd)
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS-IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const padutils = require('./pad_utils').padutils;
const padcookie = require('./pad_cookie').padcookie;
const Tinycon = require('tinycon/tinycon');
const hooks = require('./pluginfw/hooks');
const padeditor = require('./pad_editor').padeditor;

exports.chat = (() => {
  let isStuck = false;
  let userAndChat = false;
  let chatMentions = 0;
  return {
    show() {
      $('#chaticon').removeClass('visible');
      $('#chatbox').addClass('visible');
      this.scrollDown(true);
      chatMentions = 0;
      Tinycon.setBubble(0);
      $('.chat-gritter-msg').each(function () {
        $.gritter.remove(this.id);
      });
    },
    focus: () => {
      setTimeout(() => {
        $('#chatinput').focus();
      }, 100);
    },
    // Make chat stick to right hand side of screen
    stickToScreen(fromInitialCall) {
      if (pad.settings.hideChat) {
        return;
      }
      this.show();
      isStuck = (!isStuck || fromInitialCall);
      $('#chatbox').hide();
      // Add timeout to disable the chatbox animations
      setTimeout(() => {
        $('#chatbox, .sticky-container').toggleClass('stickyChat', isStuck);
        $('#chatbox').css('display', 'flex');
      }, 0);

      padcookie.setPref('chatAlwaysVisible', isStuck);
      $('#options-stickychat').prop('checked', isStuck);
    },
    chatAndUsers(fromInitialCall) {
      const toEnable = $('#options-chatandusers').is(':checked');
      if (toEnable || !userAndChat || fromInitialCall) {
        this.stickToScreen(true);
        $('#options-stickychat').prop('checked', true);
        $('#options-chatandusers').prop('checked', true);
        $('#options-stickychat').prop('disabled', 'disabled');
        userAndChat = true;
      } else {
        $('#options-stickychat').prop('disabled', false);
        userAndChat = false;
      }
      padcookie.setPref('chatAndUsers', userAndChat);
      $('#users, .sticky-container')
          .toggleClass('chatAndUsers popup-show stickyUsers', userAndChat);
      $('#chatbox').toggleClass('chatAndUsersChat', userAndChat);
    },
    hide() {
      // decide on hide logic based on chat window being maximized or not
      if ($('#options-stickychat').prop('checked')) {
        this.stickToScreen();
        $('#options-stickychat').prop('checked', false);
      } else {
        $('#chatcounter').text('0');
        $('#chaticon').addClass('visible');
        $('#chatbox').removeClass('visible');
      }
    },
    scrollDown(force) {
      if ($('#chatbox').hasClass('visible')) {
        if (force || !this.lastMessage || !this.lastMessage.position() ||
            this.lastMessage.position().top < ($('#chattext').outerHeight() + 20)) {
          // if we use a slow animate here we can have a race condition
          // when a users focus can not be moved away from the last message recieved.
          $('#chattext').animate(
              {scrollTop: $('#chattext')[0].scrollHeight},
              {duration: 400, queue: false});
          this.lastMessage = $('#chattext > p').eq(-1);
        }
      }
    },
    send() {
      const text = $('#chatinput').val();
      if (text.replace(/\s+/, '').length === 0) return;
      this._pad.collabClient.sendMessage({type: 'CHAT_MESSAGE', text});
      $('#chatinput').val('');
    },
    addMessage(msg, increment, isHistoryAdd) {
      // correct the time
      msg.time += this._pad.clientTimeOffset;

      // create the time string
      let minutes = `${new Date(msg.time).getMinutes()}`;
      let hours = `${new Date(msg.time).getHours()}`;
      if (minutes.length === 1) minutes = `0${minutes}`;
      if (hours.length === 1) hours = `0${hours}`;
      const timeStr = `${hours}:${minutes}`;

      // create the authorclass
      if (!msg.userId) {
        /*
         * If, for a bug or a database corruption, the message coming from the
         * server does not contain the userId field (see for example #3731),
         * let's be defensive and replace it with ""unknown"".
         */
        msg.userId = 'unknown';
        console.warn(
            'The ""userId"" field of a chat message coming from the server was not present. ' +
            'Replacing with ""unknown"". This may be a bug or a database corruption.');
      }

      const authorClass = `author-${msg.userId.replace(/[^a-y0-9]/g, (c) => {
        if (c === '.') return '-';
        return `z${c.charCodeAt(0)}z`;
      })}`;

      const text = padutils.escapeHtmlWithClickableLinks(msg.text, '_blank');

      const authorName = msg.userName == null ? html10n.get('pad.userlist.unnamed')
        : padutils.escapeHtml(msg.userName);

      // the hook args
      const ctx = {
        authorName,
        author: msg.userId,
        text,
        sticky: false,
        timestamp: msg.time,
        timeStr,
        duration: 4000,
      };

      // is the users focus already in the chatbox?
      const alreadyFocused = $('#chatinput').is(':focus');

      // does the user already have the chatbox open?
      const chatOpen = $('#chatbox').hasClass('visible');

      // does this message contain this user's name? (is the curretn user mentioned?)
      const myName = $('#myusernameedit').val();
      const wasMentioned =
          text.toLowerCase().indexOf(myName.toLowerCase()) !== -1 && myName !== 'undefined';

      // If the user was mentioned, make the message sticky
      if (wasMentioned && !alreadyFocused && !isHistoryAdd && !chatOpen) {
        chatMentions++;
        Tinycon.setBubble(chatMentions);
        ctx.sticky = true;
      }

      // Call chat message hook
      hooks.aCallAll('chatNewMessage', ctx, () => {
        const html =
            `<p data-authorId='${msg.userId}' class='${authorClass}'><b>${authorName}:</b>` +
            `<span class='time ${authorClass}'>${ctx.timeStr}</span> ${ctx.text}</p>`;
        if (isHistoryAdd) $(html).insertAfter('#chatloadmessagesbutton');
        else $('#chattext').append(html);

        // should we increment the counter??
        if (increment && !isHistoryAdd) {
          // Update the counter of unread messages
          let count = Number($('#chatcounter').text());
          count++;
          $('#chatcounter').text(count);

          if (!chatOpen && ctx.duration > 0) {
            $.gritter.add({
              // Note: ctx.authorName and ctx.text are already HTML-escaped.
              text: $('<p>')
                  .append($('<span>').addClass('author-name').html(ctx.authorName))
                  .append(ctx.text),
              sticky: ctx.sticky,
              time: 5000,
              position: 'bottom',
              class_name: 'chat-gritter-msg',
            });
          }
        }
      });

      // Clear the chat mentions when the user clicks on the chat input box
      $('#chatinput').click(() => {
        chatMentions = 0;
        Tinycon.setBubble(0);
      });
      if (!isHistoryAdd) this.scrollDown();
    },
    init(pad) {
      this._pad = pad;
      $('#chatinput').on('keydown', (evt) => {
        // If the event is Alt C or Escape & we're already in the chat menu
        // Send the users focus back to the pad
        if ((evt.altKey === true && evt.which === 67) || evt.which === 27) {
          // If we're in chat already..
          $(':focus').blur(); // required to do not try to remove!
          padeditor.ace.focus(); // Sends focus back to pad
          evt.preventDefault();
          return false;
        }
      });

      const self = this;
      $('body:not(#chatinput)').on('keypress', function (evt) {
        if (evt.altKey && evt.which === 67) {
          // Alt c focuses on the Chat window
          $(this).blur();
          self.show();
          $('#chatinput').focus();
          evt.preventDefault();
        }
      });

      $('#chatinput').keypress((evt) => {
        // if the user typed enter, fire the send
        if (evt.which === 13 || evt.which === 10) {
          evt.preventDefault();
          this.send();
        }
      });

      // initial messages are loaded in pad.js' _afterHandshake

      $('#chatcounter').text(0);
      $('#chatloadmessagesbutton').click(() => {
        const start = Math.max(this.historyPointer - 20, 0);
        const end = this.historyPointer;

        if (start === end) return; // nothing to load

        $('#chatloadmessagesbutton').css('display', 'none');
        $('#chatloadmessagesball').css('display', 'block');

        pad.collabClient.sendMessage({type: 'GET_CHAT_MESSAGES', start, end});
        this.historyPointer = start;
      });
    },
  };
})();
","'use strict';
/**
 * Copyright 2009 Google Inc., 2011 Peter 'Pita' Martischka (Primary Technology Ltd)
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS-IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const padutils = require('./pad_utils').padutils;
const padcookie = require('./pad_cookie').padcookie;
const Tinycon = require('tinycon/tinycon');
const hooks = require('./pluginfw/hooks');
const padeditor = require('./pad_editor').padeditor;

exports.chat = (() => {
  let isStuck = false;
  let userAndChat = false;
  let chatMentions = 0;
  return {
    show() {
      $('#chaticon').removeClass('visible');
      $('#chatbox').addClass('visible');
      this.scrollDown(true);
      chatMentions = 0;
      Tinycon.setBubble(0);
      $('.chat-gritter-msg').each(function () {
        $.gritter.remove(this.id);
      });
    },
    focus: () => {
      setTimeout(() => {
        $('#chatinput').focus();
      }, 100);
    },
    // Make chat stick to right hand side of screen
    stickToScreen(fromInitialCall) {
      if (pad.settings.hideChat) {
        return;
      }
      this.show();
      isStuck = (!isStuck || fromInitialCall);
      $('#chatbox').hide();
      // Add timeout to disable the chatbox animations
      setTimeout(() => {
        $('#chatbox, .sticky-container').toggleClass('stickyChat', isStuck);
        $('#chatbox').css('display', 'flex');
      }, 0);

      padcookie.setPref('chatAlwaysVisible', isStuck);
      $('#options-stickychat').prop('checked', isStuck);
    },
    chatAndUsers(fromInitialCall) {
      const toEnable = $('#options-chatandusers').is(':checked');
      if (toEnable || !userAndChat || fromInitialCall) {
        this.stickToScreen(true);
        $('#options-stickychat').prop('checked', true);
        $('#options-chatandusers').prop('checked', true);
        $('#options-stickychat').prop('disabled', 'disabled');
        userAndChat = true;
      } else {
        $('#options-stickychat').prop('disabled', false);
        userAndChat = false;
      }
      padcookie.setPref('chatAndUsers', userAndChat);
      $('#users, .sticky-container')
          .toggleClass('chatAndUsers popup-show stickyUsers', userAndChat);
      $('#chatbox').toggleClass('chatAndUsersChat', userAndChat);
    },
    hide() {
      // decide on hide logic based on chat window being maximized or not
      if ($('#options-stickychat').prop('checked')) {
        this.stickToScreen();
        $('#options-stickychat').prop('checked', false);
      } else {
        $('#chatcounter').text('0');
        $('#chaticon').addClass('visible');
        $('#chatbox').removeClass('visible');
      }
    },
    scrollDown(force) {
      if ($('#chatbox').hasClass('visible')) {
        if (force || !this.lastMessage || !this.lastMessage.position() ||
            this.lastMessage.position().top < ($('#chattext').outerHeight() + 20)) {
          // if we use a slow animate here we can have a race condition
          // when a users focus can not be moved away from the last message recieved.
          $('#chattext').animate(
              {scrollTop: $('#chattext')[0].scrollHeight},
              {duration: 400, queue: false});
          this.lastMessage = $('#chattext > p').eq(-1);
        }
      }
    },
    send() {
      const text = $('#chatinput').val();
      if (text.replace(/\s+/, '').length === 0) return;
      this._pad.collabClient.sendMessage({type: 'CHAT_MESSAGE', text});
      $('#chatinput').val('');
    },
    addMessage(msg, increment, isHistoryAdd) {
      // correct the time
      msg.time += this._pad.clientTimeOffset;

      // create the time string
      let minutes = `${new Date(msg.time).getMinutes()}`;
      let hours = `${new Date(msg.time).getHours()}`;
      if (minutes.length === 1) minutes = `0${minutes}`;
      if (hours.length === 1) hours = `0${hours}`;
      const timeStr = `${hours}:${minutes}`;

      // create the authorclass
      if (!msg.userId) {
        /*
         * If, for a bug or a database corruption, the message coming from the
         * server does not contain the userId field (see for example #3731),
         * let's be defensive and replace it with ""unknown"".
         */
        msg.userId = 'unknown';
        console.warn(
            'The ""userId"" field of a chat message coming from the server was not present. ' +
            'Replacing with ""unknown"". This may be a bug or a database corruption.');
      }

      msg.userId = padutils.escapeHtml(msg.userId);
      const authorClass = `author-${msg.userId.replace(/[^a-y0-9]/g, (c) => {
        if (c === '.') return '-';
        return `z${c.charCodeAt(0)}z`;
      })}`;

      const text = padutils.escapeHtmlWithClickableLinks(msg.text, '_blank');

      const authorName = msg.userName == null ? html10n.get('pad.userlist.unnamed')
        : padutils.escapeHtml(msg.userName);

      // the hook args
      const ctx = {
        authorName,
        author: msg.userId,
        text,
        sticky: false,
        timestamp: msg.time,
        timeStr,
        duration: 4000,
      };

      // is the users focus already in the chatbox?
      const alreadyFocused = $('#chatinput').is(':focus');

      // does the user already have the chatbox open?
      const chatOpen = $('#chatbox').hasClass('visible');

      // does this message contain this user's name? (is the curretn user mentioned?)
      const myName = $('#myusernameedit').val();
      const wasMentioned =
          text.toLowerCase().indexOf(myName.toLowerCase()) !== -1 && myName !== 'undefined';

      // If the user was mentioned, make the message sticky
      if (wasMentioned && !alreadyFocused && !isHistoryAdd && !chatOpen) {
        chatMentions++;
        Tinycon.setBubble(chatMentions);
        ctx.sticky = true;
      }

      // Call chat message hook
      hooks.aCallAll('chatNewMessage', ctx, () => {
        const html =
            `<p data-authorId='${msg.userId}' class='${authorClass}'><b>${authorName}:</b>` +
            `<span class='time ${authorClass}'>${ctx.timeStr}</span> ${ctx.text}</p>`;
        if (isHistoryAdd) $(html).insertAfter('#chatloadmessagesbutton');
        else $('#chattext').append(html);

        // should we increment the counter??
        if (increment && !isHistoryAdd) {
          // Update the counter of unread messages
          let count = Number($('#chatcounter').text());
          count++;
          $('#chatcounter').text(count);

          if (!chatOpen && ctx.duration > 0) {
            $.gritter.add({
              // Note: ctx.authorName and ctx.text are already HTML-escaped.
              text: $('<p>')
                  .append($('<span>').addClass('author-name').html(ctx.authorName))
                  .append(ctx.text),
              sticky: ctx.sticky,
              time: 5000,
              position: 'bottom',
              class_name: 'chat-gritter-msg',
            });
          }
        }
      });

      // Clear the chat mentions when the user clicks on the chat input box
      $('#chatinput').click(() => {
        chatMentions = 0;
        Tinycon.setBubble(0);
      });
      if (!isHistoryAdd) this.scrollDown();
    },
    init(pad) {
      this._pad = pad;
      $('#chatinput').on('keydown', (evt) => {
        // If the event is Alt C or Escape & we're already in the chat menu
        // Send the users focus back to the pad
        if ((evt.altKey === true && evt.which === 67) || evt.which === 27) {
          // If we're in chat already..
          $(':focus').blur(); // required to do not try to remove!
          padeditor.ace.focus(); // Sends focus back to pad
          evt.preventDefault();
          return false;
        }
      });

      const self = this;
      $('body:not(#chatinput)').on('keypress', function (evt) {
        if (evt.altKey && evt.which === 67) {
          // Alt c focuses on the Chat window
          $(this).blur();
          self.show();
          $('#chatinput').focus();
          evt.preventDefault();
        }
      });

      $('#chatinput').keypress((evt) => {
        // if the user typed enter, fire the send
        if (evt.which === 13 || evt.which === 10) {
          evt.preventDefault();
          this.send();
        }
      });

      // initial messages are loaded in pad.js' _afterHandshake

      $('#chatcounter').text(0);
      $('#chatloadmessagesbutton').click(() => {
        const start = Math.max(this.historyPointer - 20, 0);
        const end = this.historyPointer;

        if (start === end) return; // nothing to load

        $('#chatloadmessagesbutton').css('display', 'none');
        $('#chatloadmessagesball').css('display', 'block');

        pad.collabClient.sendMessage({type: 'GET_CHAT_MESSAGES', start, end});
        this.historyPointer = start;
      });
    },
  };
})();
"
"/* global Whisper: false */
/* global i18n: false */
/* global textsecure: false */
/* global _: false */
/* global emoji_util: false */
/* global Mustache: false */
/* global $: false */

// eslint-disable-next-line func-names
(function() {
  'use strict';

  const { Signal } = window;
  const { loadAttachmentData } = window.Signal.Migrations;

  window.Whisper = window.Whisper || {};

  const ErrorIconView = Whisper.View.extend({
    templateName: 'error-icon',
    className: 'error-icon-container',
    initialize() {
      if (this.model.name === 'UnregisteredUserError') {
        this.$el.addClass('unregistered-user-error');
      }
    },
  });
  const NetworkErrorView = Whisper.View.extend({
    tagName: 'span',
    className: 'hasRetry',
    templateName: 'hasRetry',
    render_attributes() {
      let messageNotSent;

      if (!this.model.someRecipientsFailed()) {
        messageNotSent = i18n('messageNotSent');
      }

      return {
        messageNotSent,
        resend: i18n('resend'),
      };
    },
  });
  const SomeFailedView = Whisper.View.extend({
    tagName: 'span',
    className: 'some-failed',
    templateName: 'some-failed',
    render_attributes() {
      return {
        someFailed: i18n('someRecipientsFailed'),
      };
    },
  });
  const TimerView = Whisper.View.extend({
    templateName: 'hourglass',
    initialize() {
      this.listenTo(this.model, 'unload', this.remove);
    },
    update() {
      if (this.timeout) {
        clearTimeout(this.timeout);
        this.timeout = null;
      }
      if (this.model.isExpired()) {
        return this;
      }
      if (this.model.isExpiring()) {
        this.render();
        const totalTime = this.model.get('expireTimer') * 1000;
        const remainingTime = this.model.msTilExpire();
        const elapsed = (totalTime - remainingTime) / totalTime;
        this.$('.sand').css('transform', `translateY(${elapsed * 100}%)`);
        this.$el.css('display', 'inline-block');
        this.timeout = setTimeout(
          this.update.bind(this),
          Math.max(totalTime / 100, 500)
        );
      }
      return this;
    },
  });

  Whisper.ExpirationTimerUpdateView = Whisper.View.extend({
    tagName: 'li',
    className: 'expirationTimerUpdate advisory',
    templateName: 'expirationTimerUpdate',
    id() {
      return this.model.id;
    },
    initialize() {
      this.conversation = this.model.getExpirationTimerUpdateSource();
      this.listenTo(this.conversation, 'change', this.render);
      this.listenTo(this.model, 'unload', this.remove);
    },
    render_attributes() {
      const seconds = this.model.get('expirationTimerUpdate').expireTimer;
      let timerMessage;

      const timerUpdate = this.model.get('expirationTimerUpdate');
      const prettySeconds = Whisper.ExpirationTimerOptions.getName(seconds);

      if (timerUpdate && timerUpdate.fromSync) {
        timerMessage = i18n('timerSetOnSync', prettySeconds);
      } else if (this.conversation.id === textsecure.storage.user.getNumber()) {
        timerMessage = i18n('youChangedTheTimer', prettySeconds);
      } else {
        timerMessage = i18n('theyChangedTheTimer', [
          this.conversation.getTitle(),
          prettySeconds,
        ]);
      }
      return { content: timerMessage };
    },
  });

  Whisper.KeyChangeView = Whisper.View.extend({
    tagName: 'li',
    className: 'keychange advisory',
    templateName: 'keychange',
    id() {
      return this.model.id;
    },
    initialize() {
      this.conversation = this.model.getModelForKeyChange();
      this.listenTo(this.conversation, 'change', this.render);
      this.listenTo(this.model, 'unload', this.remove);
    },
    events: {
      'click .content': 'showIdentity',
    },
    render_attributes() {
      return {
        content: this.model.getNotificationText(),
      };
    },
    showIdentity() {
      this.$el.trigger('show-identity', this.conversation);
    },
  });

  Whisper.VerifiedChangeView = Whisper.View.extend({
    tagName: 'li',
    className: 'verified-change advisory',
    templateName: 'verified-change',
    id() {
      return this.model.id;
    },
    initialize() {
      this.conversation = this.model.getModelForVerifiedChange();
      this.listenTo(this.conversation, 'change', this.render);
      this.listenTo(this.model, 'unload', this.remove);
    },
    events: {
      'click .content': 'showIdentity',
    },
    render_attributes() {
      let key;

      if (this.model.get('verified')) {
        if (this.model.get('local')) {
          key = 'youMarkedAsVerified';
        } else {
          key = 'youMarkedAsVerifiedOtherDevice';
        }
        return {
          icon: 'verified',
          content: i18n(key, this.conversation.getTitle()),
        };
      }

      if (this.model.get('local')) {
        key = 'youMarkedAsNotVerified';
      } else {
        key = 'youMarkedAsNotVerifiedOtherDevice';
      }

      return {
        icon: 'shield',
        content: i18n(key, this.conversation.getTitle()),
      };
    },
    showIdentity() {
      this.$el.trigger('show-identity', this.conversation);
    },
  });

  Whisper.MessageView = Whisper.View.extend({
    tagName: 'li',
    templateName: 'message',
    id() {
      return this.model.id;
    },
    initialize() {
      //   loadedAttachmentViews :: Promise (Array AttachmentView) | null
      this.loadedAttachmentViews = null;

      this.listenTo(this.model, 'change:errors', this.onErrorsChanged);
      this.listenTo(this.model, 'change:body', this.render);
      this.listenTo(this.model, 'change:delivered', this.renderDelivered);
      this.listenTo(this.model, 'change:read_by', this.renderRead);
      this.listenTo(
        this.model,
        'change:expirationStartTimestamp',
        this.renderExpiring
      );
      this.listenTo(this.model, 'change', this.onChange);
      this.listenTo(
        this.model,
        'change:flags change:group_update',
        this.renderControl
      );
      this.listenTo(this.model, 'destroy', this.onDestroy);
      this.listenTo(this.model, 'unload', this.onUnload);
      this.listenTo(this.model, 'expired', this.onExpired);
      this.listenTo(this.model, 'pending', this.renderPending);
      this.listenTo(this.model, 'done', this.renderDone);
      this.timeStampView = new Whisper.ExtendedTimestampView();

      this.contact = this.model.isIncoming() ? this.model.getContact() : null;
      if (this.contact) {
        this.listenTo(this.contact, 'change:color', this.updateColor);
      }
    },
    events: {
      'click .retry': 'retryMessage',
      'click .error-icon': 'select',
      'click .timestamp': 'select',
      'click .status': 'select',
      'click .some-failed': 'select',
      'click .error-message': 'select',
      'click .menu-container': 'showMenu',
      'click .menu-list .reply': 'onReply',
    },
    retryMessage() {
      const retrys = _.filter(
        this.model.get('errors'),
        this.model.isReplayableError.bind(this.model)
      );
      _.map(retrys, 'number').forEach(number => {
        this.model.resend(number);
      });
    },
    showMenu(e) {
      if (this.menuVisible) {
        return;
      }

      this.menuVisible = true;
      e.stopPropagation();

      this.$('.menu-list').show();
      $(document).one('click', () => {
        this.hideMenu();
      });
    },
    hideMenu() {
      this.menuVisible = false;
      this.$('.menu-list').hide();
    },
    onReply() {
      this.model.trigger('reply', this.model);
    },
    onExpired() {
      this.$el.addClass('expired');
      this.$el.find('.bubble').one('webkitAnimationEnd animationend', e => {
        if (e.target === this.$('.bubble')[0]) {
          this.remove();
        }
      });

      // Failsafe: if in the background, animation events don't fire
      setTimeout(this.remove.bind(this), 1000);
    },
    onUnload() {
      if (this.avatarView) {
        this.avatarView.remove();
      }
      if (this.errorIconView) {
        this.errorIconView.remove();
      }
      if (this.networkErrorView) {
        this.networkErrorView.remove();
      }
      if (this.someFailedView) {
        this.someFailedView.remove();
      }
      if (this.timeStampView) {
        this.timeStampView.remove();
      }
      if (this.quoteView) {
        this.quoteView.remove();
      }

      // NOTE: We have to do this in the background (`then` instead of `await`)
      // as our tests rely on `onUnload` synchronously removing the view from
      // the DOM.
      // eslint-disable-next-line more/no-then
      this.loadAttachmentViews().then(views =>
        views.forEach(view => view.unload())
      );

      // No need to handle this one, since it listens to 'unload' itself:
      //   this.timerView

      this.remove();
    },
    onDestroy() {
      if (this.$el.hasClass('expired')) {
        return;
      }
      this.onUnload();
    },
    onChange() {
      this.renderSent();
      this.renderQuote();
    },
    select(e) {
      this.$el.trigger('select', { message: this.model });
      e.stopPropagation();
    },
    className() {
      return ['entry', this.model.get('type')].join(' ');
    },
    renderPending() {
      this.$el.addClass('pending');
    },
    renderDone() {
      this.$el.removeClass('pending');
    },
    renderSent() {
      if (this.model.isOutgoing()) {
        this.$el.toggleClass('sent', !!this.model.get('sent'));
      }
    },
    renderDelivered() {
      if (this.model.get('delivered')) {
        this.$el.addClass('delivered');
      }
    },
    renderRead() {
      if (!_.isEmpty(this.model.get('read_by'))) {
        this.$el.addClass('read');
      }
    },
    onErrorsChanged() {
      if (this.model.isIncoming()) {
        this.render();
      } else {
        this.renderErrors();
      }
    },
    renderErrors() {
      const errors = this.model.get('errors');

      this.$('.error-icon-container').remove();
      if (this.errorIconView) {
        this.errorIconView.remove();
        this.errorIconView = null;
      }
      if (_.size(errors) > 0) {
        if (this.model.isIncoming()) {
          this.$('.content')
            .text(this.model.getDescription())
            .addClass('error-message');
        }
        this.errorIconView = new ErrorIconView({ model: errors[0] });
        this.errorIconView.render().$el.appendTo(this.$('.bubble'));
      } else if (!this.hasContents()) {
        const el = this.$('.content');
        if (!el || el.length === 0) {
          this.$('.inner-bubble').append(""<div class='content'></div>"");
        }
        this.$('.content')
          .text(i18n('noContents'))
          .addClass('error-message');
      }

      this.$('.meta .hasRetry').remove();
      if (this.networkErrorView) {
        this.networkErrorView.remove();
        this.networkErrorView = null;
      }
      if (this.model.hasNetworkError()) {
        this.networkErrorView = new NetworkErrorView({ model: this.model });
        this.$('.meta').prepend(this.networkErrorView.render().el);
      }

      this.$('.meta .some-failed').remove();
      if (this.someFailedView) {
        this.someFailedView.remove();
        this.someFailedView = null;
      }
      if (this.model.someRecipientsFailed()) {
        this.someFailedView = new SomeFailedView();
        this.$('.meta').prepend(this.someFailedView.render().el);
      }
    },
    renderControl() {
      if (this.model.isEndSession() || this.model.isGroupUpdate()) {
        this.$el.addClass('control');
        const content = this.$('.content');
        content.text(this.model.getDescription());
        emoji_util.parse(content);
      } else {
        this.$el.removeClass('control');
      }
    },
    renderExpiring() {
      if (!this.timerView) {
        this.timerView = new TimerView({ model: this.model });
      }
      this.timerView.setElement(this.$('.timer'));
      this.timerView.update();
    },
    renderQuote() {
      const props = this.model.getPropsForQuote();
      if (!props) {
        return;
      }

      const contact = this.model.getQuoteContact();
      if (this.quoteView) {
        this.quoteView.remove();
        this.quoteView = null;
      } else if (contact) {
        this.listenTo(contact, 'change:color', this.renderQuote);
      }

      this.quoteView = new Whisper.ReactWrapperView({
        className: 'quote-wrapper',
        Component: window.Signal.Components.Quote,
        props: Object.assign({}, props, {
          text: props.text ? window.emoji.signalReplace(props.text) : null,
        }),
      });
      this.$('.inner-bubble').prepend(this.quoteView.el);
    },
    isImageWithoutCaption() {
      const attachments = this.model.get('attachments');
      const body = this.model.get('body');
      if (!attachments || attachments.length === 0) {
        return false;
      }

      if (body && body.trim()) {
        return false;
      }

      const first = attachments[0];
      if (Signal.Util.GoogleChrome.isImageTypeSupported(first.contentType)) {
        return true;
      }

      return false;
    },
    hasContents() {
      const attachments = this.model.get('attachments');
      const hasAttachments = attachments && attachments.length > 0;

      return this.hasTextContents() || hasAttachments;
    },
    hasTextContents() {
      const body = this.model.get('body');
      const isGroupUpdate = this.model.isGroupUpdate();
      const isEndSession = this.model.isEndSession();

      const errors = this.model.get('errors');
      const hasErrors = errors && errors.length > 0;
      const errorsCanBeContents = this.model.isIncoming() && hasErrors;

      return body || isGroupUpdate || isEndSession || errorsCanBeContents;
    },
    render() {
      const contact = this.model.isIncoming() ? this.model.getContact() : null;
      const attachments = this.model.get('attachments');

      const errors = this.model.get('errors');
      const hasErrors = errors && errors.length > 0;
      const hasAttachments = attachments && attachments.length > 0;
      const hasBody = this.hasTextContents();

      this.$el.html(
        Mustache.render(
          _.result(this, 'template', ''),
          {
            message: this.model.get('body'),
            hasBody,
            timestamp: this.model.get('sent_at'),
            sender: (contact && contact.getTitle()) || '',
            avatar: contact && contact.getAvatar(),
            profileName: contact && contact.getProfileName(),
            innerBubbleClasses: this.isImageWithoutCaption() ? '' : 'with-tail',
            hoverIcon: !hasErrors,
            hasAttachments,
            reply: i18n('replyToMessage'),
          },
          this.render_partials()
        )
      );
      this.timeStampView.setElement(this.$('.timestamp'));
      this.timeStampView.update();

      this.renderControl();

      const body = this.$('.body');

      emoji_util.parse(body);

      if (body.length > 0) {
        const escapedBody = body.html();
        body.html(Signal.HTML.render(escapedBody));
      }

      this.renderSent();
      this.renderDelivered();
      this.renderRead();
      this.renderErrors();
      this.renderExpiring();
      this.renderQuote();

      // NOTE: We have to do this in the background (`then` instead of `await`)
      // as our code / Backbone seems to rely on `render` synchronously returning
      // `this` instead of `Promise MessageView` (this):
      // eslint-disable-next-line more/no-then
      this.loadAttachmentViews().then(views =>
        this.renderAttachmentViews(views)
      );

      return this;
    },
    updateColor() {
      const bubble = this.$('.bubble');

      // this.contact is known to be non-null if we're registered for color changes
      const color = this.contact.getColor();
      if (color) {
        bubble.removeClass(Whisper.Conversation.COLORS);
        bubble.addClass(color);
      }
      this.avatarView = new (Whisper.View.extend({
        templateName: 'avatar',
        render_attributes: { avatar: this.contact.getAvatar() },
      }))();
      this.$('.avatar').replaceWith(this.avatarView.render().$('.avatar'));
    },
    loadAttachmentViews() {
      if (this.loadedAttachmentViews !== null) {
        return this.loadedAttachmentViews;
      }

      const attachments = this.model.get('attachments') || [];
      const loadedAttachmentViews = Promise.all(
        attachments.map(
          attachment =>
            new Promise(async resolve => {
              const attachmentWithData = await loadAttachmentData(attachment);
              const view = new Whisper.AttachmentView({
                model: attachmentWithData,
                timestamp: this.model.get('sent_at'),
              });

              this.listenTo(view, 'update', () => {
                // NOTE: Can we do without `updated` flag now that we use promises?
                view.updated = true;
                resolve(view);
              });

              view.render();
            })
        )
      );

      // Memoize attachment views to avoid double loading:
      this.loadedAttachmentViews = loadedAttachmentViews;

      return loadedAttachmentViews;
    },
    renderAttachmentViews(views) {
      views.forEach(view => this.renderAttachmentView(view));
    },
    renderAttachmentView(view) {
      if (!view.updated) {
        throw new Error(
          'Invariant violation:' +
            ' Cannot render an attachment view that isn’t ready'
        );
      }

      const parent = this.$('.attachments')[0];
      const isViewAlreadyChild = parent === view.el.parentNode;
      if (isViewAlreadyChild) {
        return;
      }

      if (view.el.parentNode) {
        view.el.parentNode.removeChild(view.el);
      }

      this.trigger('beforeChangeHeight');
      this.$('.attachments').append(view.el);
      view.setElement(view.el);
      this.trigger('afterChangeHeight');
    },
  });
})();
","/* global Whisper: false */
/* global i18n: false */
/* global textsecure: false */
/* global _: false */
/* global emoji_util: false */
/* global Mustache: false */
/* global $: false */

// eslint-disable-next-line func-names
(function() {
  'use strict';

  const { Signal } = window;
  const { loadAttachmentData } = window.Signal.Migrations;

  window.Whisper = window.Whisper || {};

  const URL_REGEX = /(^|[\s\n]|<br\/?>)((?:https?|ftp):\/\/[-A-Z0-9\u00A0-\uD7FF\uE000-\uFDCF\uFDF0-\uFFFD+\u0026\u2019@#/%?=()~_|!:,.;]*[-A-Z0-9+\u0026@#/%=~()_|])/gi;

  const ErrorIconView = Whisper.View.extend({
    templateName: 'error-icon',
    className: 'error-icon-container',
    initialize() {
      if (this.model.name === 'UnregisteredUserError') {
        this.$el.addClass('unregistered-user-error');
      }
    },
  });
  const NetworkErrorView = Whisper.View.extend({
    tagName: 'span',
    className: 'hasRetry',
    templateName: 'hasRetry',
    render_attributes() {
      let messageNotSent;

      if (!this.model.someRecipientsFailed()) {
        messageNotSent = i18n('messageNotSent');
      }

      return {
        messageNotSent,
        resend: i18n('resend'),
      };
    },
  });
  const SomeFailedView = Whisper.View.extend({
    tagName: 'span',
    className: 'some-failed',
    templateName: 'some-failed',
    render_attributes() {
      return {
        someFailed: i18n('someRecipientsFailed'),
      };
    },
  });
  const TimerView = Whisper.View.extend({
    templateName: 'hourglass',
    initialize() {
      this.listenTo(this.model, 'unload', this.remove);
    },
    update() {
      if (this.timeout) {
        clearTimeout(this.timeout);
        this.timeout = null;
      }
      if (this.model.isExpired()) {
        return this;
      }
      if (this.model.isExpiring()) {
        this.render();
        const totalTime = this.model.get('expireTimer') * 1000;
        const remainingTime = this.model.msTilExpire();
        const elapsed = (totalTime - remainingTime) / totalTime;
        this.$('.sand').css('transform', `translateY(${elapsed * 100}%)`);
        this.$el.css('display', 'inline-block');
        this.timeout = setTimeout(
          this.update.bind(this),
          Math.max(totalTime / 100, 500)
        );
      }
      return this;
    },
  });

  Whisper.ExpirationTimerUpdateView = Whisper.View.extend({
    tagName: 'li',
    className: 'expirationTimerUpdate advisory',
    templateName: 'expirationTimerUpdate',
    id() {
      return this.model.id;
    },
    initialize() {
      this.conversation = this.model.getExpirationTimerUpdateSource();
      this.listenTo(this.conversation, 'change', this.render);
      this.listenTo(this.model, 'unload', this.remove);
    },
    render_attributes() {
      const seconds = this.model.get('expirationTimerUpdate').expireTimer;
      let timerMessage;

      const timerUpdate = this.model.get('expirationTimerUpdate');
      const prettySeconds = Whisper.ExpirationTimerOptions.getName(seconds);

      if (timerUpdate && timerUpdate.fromSync) {
        timerMessage = i18n('timerSetOnSync', prettySeconds);
      } else if (this.conversation.id === textsecure.storage.user.getNumber()) {
        timerMessage = i18n('youChangedTheTimer', prettySeconds);
      } else {
        timerMessage = i18n('theyChangedTheTimer', [
          this.conversation.getTitle(),
          prettySeconds,
        ]);
      }
      return { content: timerMessage };
    },
  });

  Whisper.KeyChangeView = Whisper.View.extend({
    tagName: 'li',
    className: 'keychange advisory',
    templateName: 'keychange',
    id() {
      return this.model.id;
    },
    initialize() {
      this.conversation = this.model.getModelForKeyChange();
      this.listenTo(this.conversation, 'change', this.render);
      this.listenTo(this.model, 'unload', this.remove);
    },
    events: {
      'click .content': 'showIdentity',
    },
    render_attributes() {
      return {
        content: this.model.getNotificationText(),
      };
    },
    showIdentity() {
      this.$el.trigger('show-identity', this.conversation);
    },
  });

  Whisper.VerifiedChangeView = Whisper.View.extend({
    tagName: 'li',
    className: 'verified-change advisory',
    templateName: 'verified-change',
    id() {
      return this.model.id;
    },
    initialize() {
      this.conversation = this.model.getModelForVerifiedChange();
      this.listenTo(this.conversation, 'change', this.render);
      this.listenTo(this.model, 'unload', this.remove);
    },
    events: {
      'click .content': 'showIdentity',
    },
    render_attributes() {
      let key;

      if (this.model.get('verified')) {
        if (this.model.get('local')) {
          key = 'youMarkedAsVerified';
        } else {
          key = 'youMarkedAsVerifiedOtherDevice';
        }
        return {
          icon: 'verified',
          content: i18n(key, this.conversation.getTitle()),
        };
      }

      if (this.model.get('local')) {
        key = 'youMarkedAsNotVerified';
      } else {
        key = 'youMarkedAsNotVerifiedOtherDevice';
      }

      return {
        icon: 'shield',
        content: i18n(key, this.conversation.getTitle()),
      };
    },
    showIdentity() {
      this.$el.trigger('show-identity', this.conversation);
    },
  });

  Whisper.MessageView = Whisper.View.extend({
    tagName: 'li',
    templateName: 'message',
    id() {
      return this.model.id;
    },
    initialize() {
      //   loadedAttachmentViews :: Promise (Array AttachmentView) | null
      this.loadedAttachmentViews = null;

      this.listenTo(this.model, 'change:errors', this.onErrorsChanged);
      this.listenTo(this.model, 'change:body', this.render);
      this.listenTo(this.model, 'change:delivered', this.renderDelivered);
      this.listenTo(this.model, 'change:read_by', this.renderRead);
      this.listenTo(
        this.model,
        'change:expirationStartTimestamp',
        this.renderExpiring
      );
      this.listenTo(this.model, 'change', this.onChange);
      this.listenTo(
        this.model,
        'change:flags change:group_update',
        this.renderControl
      );
      this.listenTo(this.model, 'destroy', this.onDestroy);
      this.listenTo(this.model, 'unload', this.onUnload);
      this.listenTo(this.model, 'expired', this.onExpired);
      this.listenTo(this.model, 'pending', this.renderPending);
      this.listenTo(this.model, 'done', this.renderDone);
      this.timeStampView = new Whisper.ExtendedTimestampView();

      this.contact = this.model.isIncoming() ? this.model.getContact() : null;
      if (this.contact) {
        this.listenTo(this.contact, 'change:color', this.updateColor);
      }
    },
    events: {
      'click .retry': 'retryMessage',
      'click .error-icon': 'select',
      'click .timestamp': 'select',
      'click .status': 'select',
      'click .some-failed': 'select',
      'click .error-message': 'select',
      'click .menu-container': 'showMenu',
      'click .menu-list .reply': 'onReply',
    },
    retryMessage() {
      const retrys = _.filter(
        this.model.get('errors'),
        this.model.isReplayableError.bind(this.model)
      );
      _.map(retrys, 'number').forEach(number => {
        this.model.resend(number);
      });
    },
    showMenu(e) {
      if (this.menuVisible) {
        return;
      }

      this.menuVisible = true;
      e.stopPropagation();

      this.$('.menu-list').show();
      $(document).one('click', () => {
        this.hideMenu();
      });
    },
    hideMenu() {
      this.menuVisible = false;
      this.$('.menu-list').hide();
    },
    onReply() {
      this.model.trigger('reply', this.model);
    },
    onExpired() {
      this.$el.addClass('expired');
      this.$el.find('.bubble').one('webkitAnimationEnd animationend', e => {
        if (e.target === this.$('.bubble')[0]) {
          this.remove();
        }
      });

      // Failsafe: if in the background, animation events don't fire
      setTimeout(this.remove.bind(this), 1000);
    },
    onUnload() {
      if (this.avatarView) {
        this.avatarView.remove();
      }
      if (this.errorIconView) {
        this.errorIconView.remove();
      }
      if (this.networkErrorView) {
        this.networkErrorView.remove();
      }
      if (this.someFailedView) {
        this.someFailedView.remove();
      }
      if (this.timeStampView) {
        this.timeStampView.remove();
      }
      if (this.quoteView) {
        this.quoteView.remove();
      }

      // NOTE: We have to do this in the background (`then` instead of `await`)
      // as our tests rely on `onUnload` synchronously removing the view from
      // the DOM.
      // eslint-disable-next-line more/no-then
      this.loadAttachmentViews().then(views =>
        views.forEach(view => view.unload())
      );

      // No need to handle this one, since it listens to 'unload' itself:
      //   this.timerView

      this.remove();
    },
    onDestroy() {
      if (this.$el.hasClass('expired')) {
        return;
      }
      this.onUnload();
    },
    onChange() {
      this.renderSent();
      this.renderQuote();
    },
    select(e) {
      this.$el.trigger('select', { message: this.model });
      e.stopPropagation();
    },
    className() {
      return ['entry', this.model.get('type')].join(' ');
    },
    renderPending() {
      this.$el.addClass('pending');
    },
    renderDone() {
      this.$el.removeClass('pending');
    },
    renderSent() {
      if (this.model.isOutgoing()) {
        this.$el.toggleClass('sent', !!this.model.get('sent'));
      }
    },
    renderDelivered() {
      if (this.model.get('delivered')) {
        this.$el.addClass('delivered');
      }
    },
    renderRead() {
      if (!_.isEmpty(this.model.get('read_by'))) {
        this.$el.addClass('read');
      }
    },
    onErrorsChanged() {
      if (this.model.isIncoming()) {
        this.render();
      } else {
        this.renderErrors();
      }
    },
    renderErrors() {
      const errors = this.model.get('errors');

      this.$('.error-icon-container').remove();
      if (this.errorIconView) {
        this.errorIconView.remove();
        this.errorIconView = null;
      }
      if (_.size(errors) > 0) {
        if (this.model.isIncoming()) {
          this.$('.content')
            .text(this.model.getDescription())
            .addClass('error-message');
        }
        this.errorIconView = new ErrorIconView({ model: errors[0] });
        this.errorIconView.render().$el.appendTo(this.$('.bubble'));
      } else if (!this.hasContents()) {
        const el = this.$('.content');
        if (!el || el.length === 0) {
          this.$('.inner-bubble').append(""<div class='content'></div>"");
        }
        this.$('.content')
          .text(i18n('noContents'))
          .addClass('error-message');
      }

      this.$('.meta .hasRetry').remove();
      if (this.networkErrorView) {
        this.networkErrorView.remove();
        this.networkErrorView = null;
      }
      if (this.model.hasNetworkError()) {
        this.networkErrorView = new NetworkErrorView({ model: this.model });
        this.$('.meta').prepend(this.networkErrorView.render().el);
      }

      this.$('.meta .some-failed').remove();
      if (this.someFailedView) {
        this.someFailedView.remove();
        this.someFailedView = null;
      }
      if (this.model.someRecipientsFailed()) {
        this.someFailedView = new SomeFailedView();
        this.$('.meta').prepend(this.someFailedView.render().el);
      }
    },
    renderControl() {
      if (this.model.isEndSession() || this.model.isGroupUpdate()) {
        this.$el.addClass('control');
        const content = this.$('.content');
        content.text(this.model.getDescription());
        emoji_util.parse(content);
      } else {
        this.$el.removeClass('control');
      }
    },
    renderExpiring() {
      if (!this.timerView) {
        this.timerView = new TimerView({ model: this.model });
      }
      this.timerView.setElement(this.$('.timer'));
      this.timerView.update();
    },
    renderQuote() {
      const props = this.model.getPropsForQuote();
      if (!props) {
        return;
      }

      const contact = this.model.getQuoteContact();
      if (this.quoteView) {
        this.quoteView.remove();
        this.quoteView = null;
      } else if (contact) {
        this.listenTo(contact, 'change:color', this.renderQuote);
      }

      this.quoteView = new Whisper.ReactWrapperView({
        className: 'quote-wrapper',
        Component: window.Signal.Components.Quote,
        props: Object.assign({}, props, {
          text: props.text ? window.emoji.signalReplace(props.text) : null,
        }),
      });
      this.$('.inner-bubble').prepend(this.quoteView.el);
    },
    isImageWithoutCaption() {
      const attachments = this.model.get('attachments');
      const body = this.model.get('body');
      if (!attachments || attachments.length === 0) {
        return false;
      }

      if (body && body.trim()) {
        return false;
      }

      const first = attachments[0];
      if (Signal.Util.GoogleChrome.isImageTypeSupported(first.contentType)) {
        return true;
      }

      return false;
    },
    hasContents() {
      const attachments = this.model.get('attachments');
      const hasAttachments = attachments && attachments.length > 0;

      return this.hasTextContents() || hasAttachments;
    },
    hasTextContents() {
      const body = this.model.get('body');
      const isGroupUpdate = this.model.isGroupUpdate();
      const isEndSession = this.model.isEndSession();

      const errors = this.model.get('errors');
      const hasErrors = errors && errors.length > 0;
      const errorsCanBeContents = this.model.isIncoming() && hasErrors;

      return body || isGroupUpdate || isEndSession || errorsCanBeContents;
    },
    render() {
      const contact = this.model.isIncoming() ? this.model.getContact() : null;
      const attachments = this.model.get('attachments');

      const errors = this.model.get('errors');
      const hasErrors = errors && errors.length > 0;
      const hasAttachments = attachments && attachments.length > 0;
      const hasBody = this.hasTextContents();

      this.$el.html(
        Mustache.render(
          _.result(this, 'template', ''),
          {
            message: this.model.get('body'),
            hasBody,
            timestamp: this.model.get('sent_at'),
            sender: (contact && contact.getTitle()) || '',
            avatar: contact && contact.getAvatar(),
            profileName: contact && contact.getProfileName(),
            innerBubbleClasses: this.isImageWithoutCaption() ? '' : 'with-tail',
            hoverIcon: !hasErrors,
            hasAttachments,
            reply: i18n('replyToMessage'),
          },
          this.render_partials()
        )
      );
      this.timeStampView.setElement(this.$('.timestamp'));
      this.timeStampView.update();

      this.renderControl();

      const body = this.$('.body');

      emoji_util.parse(body);

      if (body.length > 0) {
        const escapedBody = body.html();
        body.html(
          escapedBody
            .replace(/\n/g, '<br>')
            .replace(URL_REGEX, ""$1<a href='$2' target='_blank'>$2</a>"")
        );
      }

      this.renderSent();
      this.renderDelivered();
      this.renderRead();
      this.renderErrors();
      this.renderExpiring();
      this.renderQuote();

      // NOTE: We have to do this in the background (`then` instead of `await`)
      // as our code / Backbone seems to rely on `render` synchronously returning
      // `this` instead of `Promise MessageView` (this):
      // eslint-disable-next-line more/no-then
      this.loadAttachmentViews().then(views =>
        this.renderAttachmentViews(views)
      );

      return this;
    },
    updateColor() {
      const bubble = this.$('.bubble');

      // this.contact is known to be non-null if we're registered for color changes
      const color = this.contact.getColor();
      if (color) {
        bubble.removeClass(Whisper.Conversation.COLORS);
        bubble.addClass(color);
      }
      this.avatarView = new (Whisper.View.extend({
        templateName: 'avatar',
        render_attributes: { avatar: this.contact.getAvatar() },
      }))();
      this.$('.avatar').replaceWith(this.avatarView.render().$('.avatar'));
    },
    loadAttachmentViews() {
      if (this.loadedAttachmentViews !== null) {
        return this.loadedAttachmentViews;
      }

      const attachments = this.model.get('attachments') || [];
      const loadedAttachmentViews = Promise.all(
        attachments.map(
          attachment =>
            new Promise(async resolve => {
              const attachmentWithData = await loadAttachmentData(attachment);
              const view = new Whisper.AttachmentView({
                model: attachmentWithData,
                timestamp: this.model.get('sent_at'),
              });

              this.listenTo(view, 'update', () => {
                // NOTE: Can we do without `updated` flag now that we use promises?
                view.updated = true;
                resolve(view);
              });

              view.render();
            })
        )
      );

      // Memoize attachment views to avoid double loading:
      this.loadedAttachmentViews = loadedAttachmentViews;

      return loadedAttachmentViews;
    },
    renderAttachmentViews(views) {
      views.forEach(view => this.renderAttachmentView(view));
    },
    renderAttachmentView(view) {
      if (!view.updated) {
        throw new Error(
          'Invariant violation:' +
            ' Cannot render an attachment view that isn’t ready'
        );
      }

      const parent = this.$('.attachments')[0];
      const isViewAlreadyChild = parent === view.el.parentNode;
      if (isViewAlreadyChild) {
        return;
      }

      if (view.el.parentNode) {
        view.el.parentNode.removeChild(view.el);
      }

      this.trigger('beforeChangeHeight');
      this.$('.attachments').append(view.el);
      view.setElement(view.el);
      this.trigger('afterChangeHeight');
    },
  });
})();
"
"/**
 * View logic for Patient Data
 *
 * application logic specific to the Patient profile page
 *
 * @package   OpenEMR
 * @link      https://www.open-emr.org
 * @author    Jerry Padgett <sjpadgett@gmail.com>
 * @copyright Copyright (c) 2016-2020 Jerry Padgett <sjpadgett@gmail.com>
 * @license   https://github.com/openemr/openemr/blob/master/LICENSE GNU General Public License 3
 */
var page = {
    patientData: new model.PatientCollection(),
    collectionView: null,
    patient: null,
    portalpatient: null,
    modelView: null,
    isInitialized: false,
    isInitializing: false,
    fetchParams: {filter: '', orderBy: '', orderDesc: '', page: 1, patientId: cpid, lookupList: null},
    fetchInProgress: false,
    dialogIsOpen: false,
    isEdited: false,

    /**
     *
     */
    init: function () {
        // ensure initialization only occurs once
        if (page.isInitialized || page.isInitializing) return;
        page.isInitializing = true;
        if (cuser < 1)
            $('#savePatientButton').hide();

        $(""#donePatientButton"").hide();
        $(""#replaceAllButton"").hide();

        if (!$.isReady && console) console.warn('page was initialized before dom is ready.  views may not render properly.');
        // portal or audit
        $(""#formHelp"").click(function (e) {
            e.preventDefault();
            $('#profileHelp').toggle();
        });

        $(""#savePatientButton"").click(function (e) {
            e.preventDefault();
            page.updateModel(1);
        });
        $(""#donePatientButton"").click(function (e) {
            e.preventDefault();
            page.updateModel();
        });
        $(""#replaceAllButton"").click(function (e) {
            e.preventDefault();
            page.revertAll();
            $(""#donePatientButton"").show();
        });

        // initialize the collection view
        this.collectionView = new view.CollectionView({
            el: $(""#patientCollectionContainer""),
            templateEl: $(""#patientCollectionTemplate""),
            collection: page.patientData
        });

        this.collectionView.on('rendered', function () {
            if (!page.isInitialized) {
                var m = page.patientData.first();
                m = (m === undefined) ? """" : m;
                if (m) {
                    if (m.get('pid') < 1) {
                        m = """";
                    }
                }
                page.showDetailForm(m);
            }
            page.isInitialized = true;
            page.isInitializing = false;
        });

        this.fetchPatientData({page: 1, patientId: cpid});

        // initialize the model view
        this.modelView = new view.ModelView({
            el: $(""#patientModelContainer"")
        });

        // tell the model view where it's template is located
        this.modelView.templateEl = $(""#patientModelTemplate"");

        this.modelView.on('rendered', function () { // model rendered
            $(function () {
                $('.jquery-date-picker').datetimepicker({
                    i18n: {
                        en: {
                            months: datepicker_xlMonths,
                            dayOfWeekShort: datepicker_xlDayofwkshort,
                            dayOfWeek: datepicker_xlDayofwk
                        },
                    },
                    yearStart: datepicker_yearStart,
                    rtl: datepicker_rtl,
                    format: datepicker_format,
                    scrollInput: datepicker_scrollInput,
                    scrollMonth: datepicker_scrollMonth,
                    timepicker: false
                });
                // listen for a submit request.
                window.addEventListener(""message"", (e) => {
                    if (e.origin !== window.location.origin) {
                        signerAlertMsg(""Unauthorized! Request is not same origin!"", 15000);
                        return false;
                    }
                    if (e.data.submitForm === true) {
                        page.updateModel(1);
                    }
                });
            });
            // initialize any special controls
            $(function () {
                if (page.portalpatient) {
                    if (page.portalpatient.get('pid')) {
                        $(""#replaceAllButton"").show();
                        page.isEdited = true;
                        $.each(page.portalpatient.attributes, function (key, value) {
                            if (value != page.patient.get(key)) {
                                if (($(""input[name="" + key + ""]"").attr('type') === 'radio' || $('#' + key).is('select')) && value == """") {
                                    value = 'Unassigned';
                                }
                                $('#' + key + 'InputContainer span.help-inline').html(
                                '<a class=""editval text-primary"" onclick=""page.toggleVal(this); return false;"" data-tstate=new data-id=""'+key+'"">'+value+'</a>');
                                $('#' + key + 'InputContainer span.help-inline').show();
                            }
                        });
                    }
                }
                page.replaceAll();
                $('form :input').on(""change"", function () {
                    $(""#donePatientButton"").show();
                    $('#savePatientButton').show();
                });
            });

            $("".controls .inline-inputs"").find(':input:checked').parent('.btn').addClass('active');

            $(function () {
                $('.jquery-date-time-picker').datetimepicker({
                    i18n: {
                        en: {
                            months: datetimepicker_xlMonths,
                            dayOfWeekShort: datetimepicker_xlDayofwkshort,
                            dayOfWeek: datetimepicker_xlDayofwk
                        },
                    },
                    yearStart: datetimepicker_yearStart,
                    rtl: datetimepicker_rtl,
                    format: datetimepicker_format,
                    step: datetimepicker_step,
                    scrollInput: datepicker_scrollInput,
                    scrollMonth: datepicker_scrollMonth,
                    timepicker: true
                });
                // hide excluded from view. from layout edit option 'Exclude in Portal'
                if (typeof exclude !== 'undefined') {
                    exclude.forEach(id => {
                        let elHide = document.getElementById(id) ?? '';
                        if (elHide) {
                            elHide.style.display = ""none"";
                        }
                    });
                }

                $(""#dob"").on('blur', function () {
                    let bday = $(this).val() ?? '';
                    let age = Math.round(Math.abs((new Date().getTime() - new Date(bday).getTime())));
                    age = Math.round(age / 1000 / 60 / 60 / 24);
                    // need to be at least 30 days old otherwise likely an error.
                    if (age < 30) {
                        let msg = xl(""Invalid Date format or value! Type date as YYYY-MM-DD or use the calendar."");
                        $(this).val('');
                        $(this).prop('placeholder', 'Invalid Date');
                        alert(msg);
                        return false;
                    }
                });

                $(""#ss"").on('blur', function () {
                    let el = this;
                    let numbers = el.value.replace(/[^0-9]/g, '');
                    if (numbers.length === 9) {
                        el.value = numbers.substr(0, 3) + '-' + numbers.substr(3, 2) + '-' + numbers.substr(5, 4);
                    }
                });
            });
            /* no idea why previous form inits were here! */
            if (page.portalpatient) {
                $('#note').val(_.escape(page.portalpatient.get('note')));
            }

            $(""#dismissHelp"").click(function (e) {
                e.preventDefault();
                $('#profileHelp').toggle();
            });
            page.isInitialized = true;
            page.isInitializing = false;
        });
    },
    /**
     * Replace field with edit
     * @param element
     */
    replaceVal: function (el) {
        var a = $(el).data('id');
        if (!document.getElementById(a)) {
			$('input[name='+a+'][value=""' +  _.escape(page.portalpatient.get(a)) + '""'+']').prop('checked', true).closest('label').css({""class"":""text-primary""});
		}
		else{
            $('#' + a).prop('value', page.portalpatient.get(a))
				$('#'+a).css({""class"":""text-primary"",""font-weight"":""normal""});
        }
        var v = _.escape(page.patient.get(a));
        if (($(""input[name="" + a + ""]"").attr('type') == 'radio' || $('#' + a).is('select')) && v == """")
            v = 'Unassigned';
        $('#' + a + 'InputContainer span.help-inline').html('');
		$('#'+a+'InputContainer span.help-inline').html( '<a class=""editval text-danger"" style=""font-size: 16px"" onclick=""page.revertVal(this); return false;"" data-tstate=chart data-id=""'+a+'"">'+v+'</a>');
        $('#' + a + 'InputContainer span.help-inline').show();
    },
    revertVal: function (el) {
        var a = $(el).data('id');
        if (!document.getElementById(a)) {
			$('input[name='+a+'][value=""' +  _.escape(page.patient.get(a)) + '""'+']').prop('checked', true).closest('label').css({""class"":""text-danger""});
		}
		else{
            $('#' + a).prop('value', page.patient.get(a))
				$('#'+a).css({""class"":""text-danger"",""font-weight"":""normal""});
        }
        var v = _.escape(page.portalpatient.get(a));
        if (($(""input[name="" + a + ""]"").attr('type') == 'radio' || $('#' + a).is('select')) && v == """")
            v = 'Unassigned';
        $('#' + a + 'InputContainer span.help-inline').html('');
		$('#'+a+'InputContainer span.help-inline').html( '<a class=""editval text-primary"" style=""font-size: 16px"" onclick=""page.replaceVal(this); return false;"" data-tstate=""new"" data-id=""'+a+'"">'+v+'</a>');
        $('#' + a + 'InputContainer span.help-inline').show();
        if (!$(""#donePatientButton"").is("":visible"")) {
            $(""#donePatientButton"").show();
        }
        if (!$(""#savePatientButton"").is("":visible"")) {
            $('#savePatientButton').show();
        }
    },

    /**
     * Replace all fields with edited ie mass replace
     * @param none
     */
    replaceAll: function () {
        $('.editval').each(function () {
            page.replaceVal(this);
        });
    },
    revertAll: function () {
        $('.editval').each(function () {
            page.revertVal(this);
        });
        $(""#replaceAllButton"").hide();
    },
    /**
     * Fetch the collection data from the server
     * @param params
     * @param hideLoader
     */
    fetchPatientData: function (params, hideLoader) {
        // persist the params so that paging/sorting/filtering will play together nicely
        page.fetchParams = params;

        if (page.fetchInProgress) {
            if (console) console.log('supressing fetch because it is already in progress');
        }

        page.fetchInProgress = true;

        if (!hideLoader) app.showProgress('modelLoader');

        page.patientData.fetch({
            data: params,
            success: function () {
                if (page.patientData.collectionHasChanged) {
                    // the sync event will trigger the view to re-render
                }
                app.hideProgress('modelLoader');
                page.fetchInProgress = false;
            },
            error: function (m, r) {
                app.appendAlert(app.getErrorMessage(r), 'alert-danger', 0, 'collectionAlert');
                app.hideProgress('modelLoader');
                page.fetchInProgress = false;
            }
        });
    },

    /**
     * show the form for editing a model
     * @param m
     */
    showDetailForm: function (m) {
        page.patient = m ? m : new model.PatientModel();
        page.modelView.model = page.patient;
        if (page.patient.id == null || page.patient.id === '') {
            page.renderModelView();
            app.hideProgress('modelLoader');
        } else {
            app.showProgress('modelLoader');
            page.patient.fetch({
                data: {'patientId': cpid},
                success: function () {
                    var pm = page.portalpatient;
                    page.getEditedPatient(pm)
                },
                error: function (m, r) {
                    app.appendAlert(app.getErrorMessage(r), 'alert-danger', 0, 'modelAlert');
                    app.hideProgress('modelLoader');
                }
            });
        }
    },
    /**
     * get edited from audit table if any
     * @param m
     */
    getEditedPatient: function (m) {
        page.portalpatient = m ? m : new model.PortalPatientModel();
        page.portalpatient.set('id', page.patient.get('id'))
        page.portalpatient.fetch({
            data: {'patientId': cpid},
            success: function () {
                // audit profile data returned. render needs to be here due to chaining
                page.renderModelView();
                return true;
            },
            error: function (m, r) {
                // still have to render live data even if no changes pending
                page.renderModelView();
                return false;
            }
        });
    },
    /**
     * Render the model template in the popup
     * @param bool show the delete button
     */
    renderModelView: function () {
        page.modelView.render();
        app.hideProgress('modelLoader');
    },

    /**
     * update the model that is currently displayed in the dialog
     */
    updateModel: function (live = 0) {
        // reset any previous errors
        $('#modelAlert').html('');
        $('.form-group').removeClass('error');
        $('.help-inline').html('');

        // if this is new then on success we need to add it to the collection
        var isNew = page.patient.isNew();

        app.showProgress('modelLoader');

        if (live !== 1)
            page.patient.urlRoot = 'api/portalpatient';

        page.patient.save({
            'title': $('select#title').val(),
            'language': $('input#language').val(),
            //'financial': $('input#financial').val(),
            'fname': $('input#fname').val(),
            'lname': $('input#lname').val(),
            'mname': $('input#mname').val(),
            'dob': $('input#dob').val(),
            'street': $('input#street').val(),
            'postalCode': $('input#postalCode').val(),
            'city': $('input#city').val(),
            'state': $('select#state').val(),
            'countryCode': $('input#countryCode').val(),
            'driversLicense': $('input#driversLicense').val(),
            'ss': $('input#ss').val(),
            'occupation': $('textarea#occupation').val(),
            'phoneHome': $('input#phoneHome').val(),
            'phoneBiz': $('input#phoneBiz').val(),
            'phoneContact': $('input#phoneContact').val(),
            'phoneCell': $('input#phoneCell').val(),
            'pharmacyId': $('input#pharmacyId').val() || 0,
            'status': $('select#status').val(),
            'contactRelationship': $('input#contactRelationship').val(),
            'date': $('input#date').val(),
            'sex': $('select#sex').val(),
            'referrer': $('input#referrer').val(),
            'referrerid': $('input#referrerid').val(),
            'providerid': $('select#providerid').val(),
            'refProviderid': $('select#refProviderid').val() || 0,
            'email': $('input#email').val(),
            'emailDirect': $('input#emailDirect').val(),
            'ethnoracial': $('input#ethnoracial').val(),
            'race': $('select#race').val(),
            'ethnicity': $('select#ethnicity').val(),
            'religion': $('select#religion').val(),
            //'interpretter': $('input#interpretter').val(),
            //'migrantseasonal': $('input#migrantseasonal').val(),
            'familySize': $('input#familySize').val(),
            'monthlyIncome': $('input#monthlyIncome').val(),
            //	'billingNote': $('textarea#billingNote').val(),
            //	'homeless': $('input#homeless').val(),
            //	'financialReview': $('input#financialReview').val()+' '+$('input#financialReview-time').val(),
            'pubpid': $('input#pubpid').val(),
            'pid': $('input#pid').val(),
            'hipaaMail': $('input[name=hipaaMail]:checked').val(),
            'hipaaVoice': $('input[name=hipaaVoice]:checked').val(),
            'hipaaNotice': $('input[name=hipaaNotice]:checked').val(),
            'hipaaMessage': $('input#hipaaMessage').val(),
            'hipaaAllowsms': $('input[name=hipaaAllowsms]:checked').val(),
            'hipaaAllowemail': $('input[name=hipaaAllowemail]:checked').val(),
            //'referralSource': $('select#referralSource').val(),
            //'pricelevel': $('input#pricelevel').val(),
            //'regdate': $('input#regdate').val(),
            //'contrastart': $('input#contrastart').val(),
            //'completedAd': $('input[name=completedAd]:checked').val(),
            //'adReviewed': $('input#adReviewed').val(),
            //'vfc': $('input#vfc').val(),
            'mothersname': $('input#mothersname').val(),
            'guardiansname': $('input#guardiansname').val(),
            'allowImmRegUse': $('input[name=allowImmRegUse]:checked').val(),
            'allowImmInfoShare': $('input[name=allowImmInfoShare]:checked').val(),
            'allowHealthInfoEx': $('input[name=allowHealthInfoEx]:checked').val(),
            'allowPatientPortal': $('input[name=allowPatientPortal]:checked').val(),
            //'deceasedDate': $('input#deceasedDate').val()+' '+$('input#deceasedDate-time').val(),
            //'deceasedReason': $('input#deceasedReason').val(),
            //'soapImportStatus': $('input#soapImportStatus').val(),
            //'cmsportalLogin': $('input#cmsportalLogin').val(),
            'careTeam': $('select#careTeam').val() || 0,
            'county': $('input#county').val(),
            //'industry': $('textarea#industry').val(),
            'note': $('textarea#note').val()
        }, {
            wait: true,
            success: function () {
                if (live !== 1) {
                    setTimeout(""app.appendAlert('Patient was successfully "" + (isNew ? ""inserted"" : ""updated"") + ""','alert-success',2000,'collectionAlert')"", 200);
                    setTimeout(""window.location.href ='"" + webRoot + ""/portal/home.php'"", 2500);
                } else if (live === 1 && register !== '0') { // for testing
                    //alert('Save Success');
                } else {
                    window.dlgCloseAjax();
                }
                app.hideProgress('modelLoader');
                if (isNew) {
                    page.renderModelView();
                }
                if (model.reloadCollectionOnModelUpdate) {
                    // re-fetch and render the collection after the model has been updated
                    //page.fetchPatientData(page.fetchParams,true);
                }
            },
            error: function (model, response, scope) {
                app.hideProgress('modelLoader');
                app.appendAlert(app.getErrorMessage(response), 'alert-danger', 0, 'modelAlert');
                try {
                    var json = $.parseJSON(response.responseText);
                    if (json.errors) {
                        $.each(json.errors, function (key, value) {
                            $('#' + key + 'InputContainer').addClass('error');
                            $('#' + key + 'InputContainer span.help-inline').html(value);
                            $('#' + key + 'InputContainer span.help-inline').show();
                        });
                    }
                } catch (e2) {
                    if (console) console.log('error parsing server response: ' + e2.message);
                }
            }
        });

    },

    /**
     * delete the model that is currently displayed in the dialog
     */
    deleteModel: function () {
        // reset any previous errors
        $('#modelAlert').html('');

        app.showProgress('modelLoader');

        page.patient.destroy({
            wait: true,
            success: function () {
                $('#patientDetailDialog').modal('hide');
                setTimeout(""app.appendAlert('The Patient record was deleted','alert-success',3000,'collectionAlert')"", 500);
                app.hideProgress('modelLoader');

                if (model.reloadCollectionOnModelUpdate) {
                    // re-fetch and render the collection after the model has been updated
                    page.fetchPatientData(page.fetchParams, true);
                }
            },
            error: function (model, response, scope) {
                app.appendAlert(app.getErrorMessage(response), 'alert-danger', 0, 'modelAlert');
                app.hideProgress('modelLoader');
            }
        });
    }
};
","/**
 * View logic for Patient Data
 *
 * application logic specific to the Patient profile page
 *
 * @package   OpenEMR
 * @link      https://www.open-emr.org
 * @author    Jerry Padgett <sjpadgett@gmail.com>
 * @copyright Copyright (c) 2016-2020 Jerry Padgett <sjpadgett@gmail.com>
 * @license   https://github.com/openemr/openemr/blob/master/LICENSE GNU General Public License 3
 */
var page = {
    patientData: new model.PatientCollection(),
    collectionView: null,
    patient: null,
    portalpatient: null,
    modelView: null,
    isInitialized: false,
    isInitializing: false,
    fetchParams: {filter: '', orderBy: '', orderDesc: '', page: 1, patientId: cpid, lookupList: null},
    fetchInProgress: false,
    dialogIsOpen: false,
    isEdited: false,

    /**
     *
     */
    init: function () {
        // ensure initialization only occurs once
        if (page.isInitialized || page.isInitializing) return;
        page.isInitializing = true;
        if (cuser < 1)
            $('#savePatientButton').hide();

        $(""#donePatientButton"").hide();
        $(""#replaceAllButton"").hide();

        if (!$.isReady && console) console.warn('page was initialized before dom is ready.  views may not render properly.');
        // portal or audit
        $(""#formHelp"").click(function (e) {
            e.preventDefault();
            $('#profileHelp').toggle();
        });

        $(""#savePatientButton"").click(function (e) {
            e.preventDefault();
            page.updateModel(1);
        });
        $(""#donePatientButton"").click(function (e) {
            e.preventDefault();
            page.updateModel();
        });
        $(""#replaceAllButton"").click(function (e) {
            e.preventDefault();
            page.revertAll();
            $(""#donePatientButton"").show();
        });

        // initialize the collection view
        this.collectionView = new view.CollectionView({
            el: $(""#patientCollectionContainer""),
            templateEl: $(""#patientCollectionTemplate""),
            collection: page.patientData
        });

        this.collectionView.on('rendered', function () {
            if (!page.isInitialized) {
                var m = page.patientData.first();
                m = (m === undefined) ? """" : m;
                if (m) {
                    if (m.get('pid') < 1) {
                        m = """";
                    }
                }
                page.showDetailForm(m);
            }
            page.isInitialized = true;
            page.isInitializing = false;
        });

        this.fetchPatientData({page: 1, patientId: cpid});

        // initialize the model view
        this.modelView = new view.ModelView({
            el: $(""#patientModelContainer"")
        });

        // tell the model view where it's template is located
        this.modelView.templateEl = $(""#patientModelTemplate"");

        this.modelView.on('rendered', function () { // model rendered
            $(function () {
                $('.jquery-date-picker').datetimepicker({
                    i18n: {
                        en: {
                            months: datepicker_xlMonths,
                            dayOfWeekShort: datepicker_xlDayofwkshort,
                            dayOfWeek: datepicker_xlDayofwk
                        },
                    },
                    yearStart: datepicker_yearStart,
                    rtl: datepicker_rtl,
                    format: datepicker_format,
                    scrollInput: datepicker_scrollInput,
                    scrollMonth: datepicker_scrollMonth,
                    timepicker: false
                });
                // listen for a submit request.
                window.addEventListener(""message"", (e) => {
                    if (e.origin !== window.location.origin) {
                        signerAlertMsg(""Unauthorized! Request is not same origin!"", 15000);
                        return false;
                    }
                    if (e.data.submitForm === true) {
                        page.updateModel(1);
                    }
                });
            });
            // initialize any special controls
            $(function () {
                if (page.portalpatient) {
                    if (page.portalpatient.get('pid')) {
                        $(""#replaceAllButton"").show();
                        page.isEdited = true;
                        $.each(page.portalpatient.attributes, function (key, value) {
                            if (value != page.patient.get(key)) {
                                if (($(""input[name="" + key + ""]"").attr('type') === 'radio' || $('#' + key).is('select')) && value == """") {
                                    value = 'Unassigned';
                                }
                                $('#' + key + 'InputContainer span.help-inline').html(
                                '<a class=""editval text-primary"" onclick=""page.toggleVal(this); return false;"" data-tstate=new data-id=""' + _.escape(key) + '"">' + _.escape(value) + '</a>');
                                $('#' + key + 'InputContainer span.help-inline').show();
                            }
                        });
                    }
                }
                page.replaceAll();
                $('form :input').on(""change"", function () {
                    $(""#donePatientButton"").show();
                    $('#savePatientButton').show();
                });
            });

            $("".controls .inline-inputs"").find(':input:checked').parent('.btn').addClass('active');

            $(function () {
                $('.jquery-date-time-picker').datetimepicker({
                    i18n: {
                        en: {
                            months: datetimepicker_xlMonths,
                            dayOfWeekShort: datetimepicker_xlDayofwkshort,
                            dayOfWeek: datetimepicker_xlDayofwk
                        },
                    },
                    yearStart: datetimepicker_yearStart,
                    rtl: datetimepicker_rtl,
                    format: datetimepicker_format,
                    step: datetimepicker_step,
                    scrollInput: datepicker_scrollInput,
                    scrollMonth: datepicker_scrollMonth,
                    timepicker: true
                });
                // hide excluded from view. from layout edit option 'Exclude in Portal'
                if (typeof exclude !== 'undefined') {
                    exclude.forEach(id => {
                        let elHide = document.getElementById(id) ?? '';
                        if (elHide) {
                            elHide.style.display = ""none"";
                        }
                    });
                }

                $(""#dob"").on('blur', function () {
                    let bday = $(this).val() ?? '';
                    let age = Math.round(Math.abs((new Date().getTime() - new Date(bday).getTime())));
                    age = Math.round(age / 1000 / 60 / 60 / 24);
                    // need to be at least 30 days old otherwise likely an error.
                    if (age < 30) {
                        let msg = xl(""Invalid Date format or value! Type date as YYYY-MM-DD or use the calendar."");
                        $(this).val('');
                        $(this).prop('placeholder', 'Invalid Date');
                        alert(msg);
                        return false;
                    }
                });

                $(""#ss"").on('blur', function () {
                    let el = this;
                    let numbers = el.value.replace(/[^0-9]/g, '');
                    if (numbers.length === 9) {
                        el.value = numbers.substr(0, 3) + '-' + numbers.substr(3, 2) + '-' + numbers.substr(5, 4);
                    }
                });
            });
            /* no idea why previous form inits were here! */
            if (page.portalpatient) {
                $('#note').val(_.escape(page.portalpatient.get('note')));
            }

            $(""#dismissHelp"").click(function (e) {
                e.preventDefault();
                $('#profileHelp').toggle();
            });
            page.isInitialized = true;
            page.isInitializing = false;
        });
    },
    /**
     * Replace field with edit
     * @param element
     */
    replaceVal: function (el) {
        var a = $(el).data('id');
        if (!document.getElementById(a)) {
			$('input[name='+a+'][value=""' +  _.escape(page.portalpatient.get(a)) + '""'+']').prop('checked', true).closest('label').css({""class"":""text-primary""});
		}
		else{
            $('#' + a).prop('value', page.portalpatient.get(a))
				$('#'+a).css({""class"":""text-primary"",""font-weight"":""normal""});
        }
        var v = _.escape(page.patient.get(a));
        if (($(""input[name="" + a + ""]"").attr('type') == 'radio' || $('#' + a).is('select')) && v == """")
            v = 'Unassigned';
        $('#' + a + 'InputContainer span.help-inline').html('');
		$('#'+a+'InputContainer span.help-inline').html( '<a class=""editval text-danger"" style=""font-size: 16px"" onclick=""page.revertVal(this); return false;"" data-tstate=chart data-id=""'+a+'"">'+v+'</a>');
        $('#' + a + 'InputContainer span.help-inline').show();
    },
    revertVal: function (el) {
        var a = $(el).data('id');
        if (!document.getElementById(a)) {
			$('input[name='+a+'][value=""' +  _.escape(page.patient.get(a)) + '""'+']').prop('checked', true).closest('label').css({""class"":""text-danger""});
		}
		else{
            $('#' + a).prop('value', page.patient.get(a))
				$('#'+a).css({""class"":""text-danger"",""font-weight"":""normal""});
        }
        var v = _.escape(page.portalpatient.get(a));
        if (($(""input[name="" + a + ""]"").attr('type') == 'radio' || $('#' + a).is('select')) && v == """")
            v = 'Unassigned';
        $('#' + a + 'InputContainer span.help-inline').html('');
		$('#'+a+'InputContainer span.help-inline').html( '<a class=""editval text-primary"" style=""font-size: 16px"" onclick=""page.replaceVal(this); return false;"" data-tstate=""new"" data-id=""'+a+'"">'+v+'</a>');
        $('#' + a + 'InputContainer span.help-inline').show();
        if (!$(""#donePatientButton"").is("":visible"")) {
            $(""#donePatientButton"").show();
        }
        if (!$(""#savePatientButton"").is("":visible"")) {
            $('#savePatientButton').show();
        }
    },

    /**
     * Replace all fields with edited ie mass replace
     * @param none
     */
    replaceAll: function () {
        $('.editval').each(function () {
            page.replaceVal(this);
        });
    },
    revertAll: function () {
        $('.editval').each(function () {
            page.revertVal(this);
        });
        $(""#replaceAllButton"").hide();
    },
    /**
     * Fetch the collection data from the server
     * @param params
     * @param hideLoader
     */
    fetchPatientData: function (params, hideLoader) {
        // persist the params so that paging/sorting/filtering will play together nicely
        page.fetchParams = params;

        if (page.fetchInProgress) {
            if (console) console.log('supressing fetch because it is already in progress');
        }

        page.fetchInProgress = true;

        if (!hideLoader) app.showProgress('modelLoader');

        page.patientData.fetch({
            data: params,
            success: function () {
                if (page.patientData.collectionHasChanged) {
                    // the sync event will trigger the view to re-render
                }
                app.hideProgress('modelLoader');
                page.fetchInProgress = false;
            },
            error: function (m, r) {
                app.appendAlert(app.getErrorMessage(r), 'alert-danger', 0, 'collectionAlert');
                app.hideProgress('modelLoader');
                page.fetchInProgress = false;
            }
        });
    },

    /**
     * show the form for editing a model
     * @param m
     */
    showDetailForm: function (m) {
        page.patient = m ? m : new model.PatientModel();
        page.modelView.model = page.patient;
        if (page.patient.id == null || page.patient.id === '') {
            page.renderModelView();
            app.hideProgress('modelLoader');
        } else {
            app.showProgress('modelLoader');
            page.patient.fetch({
                data: {'patientId': cpid},
                success: function () {
                    var pm = page.portalpatient;
                    page.getEditedPatient(pm)
                },
                error: function (m, r) {
                    app.appendAlert(app.getErrorMessage(r), 'alert-danger', 0, 'modelAlert');
                    app.hideProgress('modelLoader');
                }
            });
        }
    },
    /**
     * get edited from audit table if any
     * @param m
     */
    getEditedPatient: function (m) {
        page.portalpatient = m ? m : new model.PortalPatientModel();
        page.portalpatient.set('id', page.patient.get('id'))
        page.portalpatient.fetch({
            data: {'patientId': cpid},
            success: function () {
                // audit profile data returned. render needs to be here due to chaining
                page.renderModelView();
                return true;
            },
            error: function (m, r) {
                // still have to render live data even if no changes pending
                page.renderModelView();
                return false;
            }
        });
    },
    /**
     * Render the model template in the popup
     * @param bool show the delete button
     */
    renderModelView: function () {
        page.modelView.render();
        app.hideProgress('modelLoader');
    },

    /**
     * update the model that is currently displayed in the dialog
     */
    updateModel: function (live = 0) {
        // reset any previous errors
        $('#modelAlert').html('');
        $('.form-group').removeClass('error');
        $('.help-inline').html('');

        // if this is new then on success we need to add it to the collection
        var isNew = page.patient.isNew();

        app.showProgress('modelLoader');

        if (live !== 1)
            page.patient.urlRoot = 'api/portalpatient';

        page.patient.save({
            'title': $('select#title').val(),
            'language': $('input#language').val(),
            //'financial': $('input#financial').val(),
            'fname': $('input#fname').val(),
            'lname': $('input#lname').val(),
            'mname': $('input#mname').val(),
            'dob': $('input#dob').val(),
            'street': $('input#street').val(),
            'postalCode': $('input#postalCode').val(),
            'city': $('input#city').val(),
            'state': $('select#state').val(),
            'countryCode': $('input#countryCode').val(),
            'driversLicense': $('input#driversLicense').val(),
            'ss': $('input#ss').val(),
            'occupation': $('textarea#occupation').val(),
            'phoneHome': $('input#phoneHome').val(),
            'phoneBiz': $('input#phoneBiz').val(),
            'phoneContact': $('input#phoneContact').val(),
            'phoneCell': $('input#phoneCell').val(),
            'pharmacyId': $('input#pharmacyId').val() || 0,
            'status': $('select#status').val(),
            'contactRelationship': $('input#contactRelationship').val(),
            'date': $('input#date').val(),
            'sex': $('select#sex').val(),
            'referrer': $('input#referrer').val(),
            'referrerid': $('input#referrerid').val(),
            'providerid': $('select#providerid').val(),
            'refProviderid': $('select#refProviderid').val() || 0,
            'email': $('input#email').val(),
            'emailDirect': $('input#emailDirect').val(),
            'ethnoracial': $('input#ethnoracial').val(),
            'race': $('select#race').val(),
            'ethnicity': $('select#ethnicity').val(),
            'religion': $('select#religion').val(),
            //'interpretter': $('input#interpretter').val(),
            //'migrantseasonal': $('input#migrantseasonal').val(),
            'familySize': $('input#familySize').val(),
            'monthlyIncome': $('input#monthlyIncome').val(),
            //	'billingNote': $('textarea#billingNote').val(),
            //	'homeless': $('input#homeless').val(),
            //	'financialReview': $('input#financialReview').val()+' '+$('input#financialReview-time').val(),
            'pubpid': $('input#pubpid').val(),
            'pid': $('input#pid').val(),
            'hipaaMail': $('input[name=hipaaMail]:checked').val(),
            'hipaaVoice': $('input[name=hipaaVoice]:checked').val(),
            'hipaaNotice': $('input[name=hipaaNotice]:checked').val(),
            'hipaaMessage': $('input#hipaaMessage').val(),
            'hipaaAllowsms': $('input[name=hipaaAllowsms]:checked').val(),
            'hipaaAllowemail': $('input[name=hipaaAllowemail]:checked').val(),
            //'referralSource': $('select#referralSource').val(),
            //'pricelevel': $('input#pricelevel').val(),
            //'regdate': $('input#regdate').val(),
            //'contrastart': $('input#contrastart').val(),
            //'completedAd': $('input[name=completedAd]:checked').val(),
            //'adReviewed': $('input#adReviewed').val(),
            //'vfc': $('input#vfc').val(),
            'mothersname': $('input#mothersname').val(),
            'guardiansname': $('input#guardiansname').val(),
            'allowImmRegUse': $('input[name=allowImmRegUse]:checked').val(),
            'allowImmInfoShare': $('input[name=allowImmInfoShare]:checked').val(),
            'allowHealthInfoEx': $('input[name=allowHealthInfoEx]:checked').val(),
            'allowPatientPortal': $('input[name=allowPatientPortal]:checked').val(),
            //'deceasedDate': $('input#deceasedDate').val()+' '+$('input#deceasedDate-time').val(),
            //'deceasedReason': $('input#deceasedReason').val(),
            //'soapImportStatus': $('input#soapImportStatus').val(),
            //'cmsportalLogin': $('input#cmsportalLogin').val(),
            'careTeam': $('select#careTeam').val() || 0,
            'county': $('input#county').val(),
            //'industry': $('textarea#industry').val(),
            'note': $('textarea#note').val()
        }, {
            wait: true,
            success: function () {
                if (live !== 1) {
                    setTimeout(""app.appendAlert('Patient was successfully "" + (isNew ? ""inserted"" : ""updated"") + ""','alert-success',2000,'collectionAlert')"", 200);
                    setTimeout(""window.location.href ='"" + webRoot + ""/portal/home.php'"", 2500);
                } else if (live === 1 && register !== '0') { // for testing
                    //alert('Save Success');
                } else {
                    window.dlgCloseAjax();
                }
                app.hideProgress('modelLoader');
                if (isNew) {
                    page.renderModelView();
                }
                if (model.reloadCollectionOnModelUpdate) {
                    // re-fetch and render the collection after the model has been updated
                    //page.fetchPatientData(page.fetchParams,true);
                }
            },
            error: function (model, response, scope) {
                app.hideProgress('modelLoader');
                app.appendAlert(app.getErrorMessage(response), 'alert-danger', 0, 'modelAlert');
                try {
                    var json = $.parseJSON(response.responseText);
                    if (json.errors) {
                        $.each(json.errors, function (key, value) {
                            $('#' + key + 'InputContainer').addClass('error');
                            $('#' + key + 'InputContainer span.help-inline').html(value);
                            $('#' + key + 'InputContainer span.help-inline').show();
                        });
                    }
                } catch (e2) {
                    if (console) console.log('error parsing server response: ' + e2.message);
                }
            }
        });

    },

    /**
     * delete the model that is currently displayed in the dialog
     */
    deleteModel: function () {
        // reset any previous errors
        $('#modelAlert').html('');

        app.showProgress('modelLoader');

        page.patient.destroy({
            wait: true,
            success: function () {
                $('#patientDetailDialog').modal('hide');
                setTimeout(""app.appendAlert('The Patient record was deleted','alert-success',3000,'collectionAlert')"", 500);
                app.hideProgress('modelLoader');

                if (model.reloadCollectionOnModelUpdate) {
                    // re-fetch and render the collection after the model has been updated
                    page.fetchPatientData(page.fetchParams, true);
                }
            },
            error: function (model, response, scope) {
                app.appendAlert(app.getErrorMessage(response), 'alert-danger', 0, 'modelAlert');
                app.hideProgress('modelLoader');
            }
        });
    }
};
"
"//For jQuery 1.3.2

dojo.provide(""dojox.jq"");
dojo.require(""dojo.NodeList-traverse"");
dojo.require(""dojo.NodeList-manipulate"");
dojo.require(""dojo.io.script"");

/*
To get jquery tests to pass:
- add spaces between span>form selectors, other ones like one,two
- .last() instead of :last
- $(""<div>"").find(""#foo"") does not work unless the div is attached to the body.

- trigger .test not work
- No jquery.Event thing.

- jQuery.ajax() modifies incoming arguments?
- test framework not good for our io methods, async, poll.
- Dojo ajax is async: we fire ajaxStop more than jquery.

- jquery makes assumptions of a value to set for an element
by inserting an element and checking display. Does not seem to
account for nested styles, only captures generic tag name style off
of body. Why can't we just set display to empty?





OK for failures:
- test(""jQuery.ajax - beforeSend, cancel request (#2688)""
  We cancel the deferred which triggers error and complete callbacks.


Looked at jquery code for:
- how it handled text(): did not use textContent/innerText, but use recursive look over childNodes and nodeValue,
so it may have impact on how <br> is serialized, but it has uniform behavior across browsers.
- Looked at trigger: how it triggered actions on dom nodes. This seemed unsafe.
*/

/*
dojo.query differences that cause some tests to fail:
- does not support XML queries
- $(""#sap>form"") does not find a match but $(""#sap > form"") does. Similar issue with comma instead of > (see is() tests)
- ""$(""form:last"") should return the last form object, not if that particular form is that last related
  to its siblings? Same issue with :first?
- $(""p"").filter(""#ap, #sndp""): filter does not work.
- dojo.NodeList uses d.NodeList a few places in the code. Would be nice to use a ctor that can be configured.
  That would make the filter function operate better.
- filterQueryResult, cannot handle queries like ""p, div""? See andSelf test with parents().
- adjacent ""p + p"" not supported?
= a:only-child not supported?
- nth(1)
- even/odd
- eq/gt/lt
- #form :radio:checked does not run the first :radio psuedo selector? Seems to be a general issue where only the last pseud
  is run. For example, ""#form :checked:radio"" does only the radio pseudo.
*/

(function(){
	//Enable io topic publishing.   But don't mask the original definition of ioPublish from the doc parser.
	/*===== var ioPublish = dojo.config.ioPublish; =====*/
	dojo.config.ioPublish = true;
	/*===== dojo.config.ioPublish = ioPublish; =====*/

	//Support stuff for toDom
	var selfClosedTags = ""|img|meta|hr|br|input|"";

	function toDom(/*String*/html, /*Document?*/doc){
		//summary converts HTML string into DOM nodes.
		//Make sure html is a string.
		html += """";

		//Convert <tag/> into <tag></tag>
		html = html.replace(/<\s*(\w+)([^\/\>]*)\/\s*>/g, function(tag, name, contents){
			if(selfClosedTags.indexOf(""|"" + name + ""|"") == -1){
				return ""<"" + name + contents + ""></"" + name + "">"";
			}else{
				return tag;
			}
		});

		return dojo._toDom(html, doc);
	}

	function cssNameToJs(name){
		var index = name.indexOf(""-"");
		if(index != -1){
			//Strip off beginning dash
			if(index == 0){
				name = name.substring(1);
			}
			name = name.replace(/-(\w)/g, function(match, match1){
				return match1.toUpperCase();
			});
		}
		return name;
	}

	var _old$ = dojo.global.$;
	var _oldJQuery = dojo.global.jQuery;

	var $ = dojo.global.$ = dojo.global.jQuery = function(){
		var arg = arguments[0];
		if(!arg){
			return $._wrap([], null, $);
		}else if(dojo.isString(arg)){
			if(arg.charAt(0) == ""<""){
				//String of html that needs nodes created.
				arg = toDom(arg);
				//If a DocumentFragment, convert to use its children
				//since we want to treat all top level nodes as elements
				//in the NodeList array.
				if(arg.nodeType == 11){
					arg = arg.childNodes;
				}else{
					return $._wrap([arg], null, $);
				}
				//Use end case of nodelist to finish work.
			}else{
				//Normal dojo.query selector.
				//Switch out query's NodeList constructor to be our specialized
				//NodeList constructor.
				var listCtor = dojo._NodeListCtor;
				dojo._NodeListCtor = $;

				//If the second arg is one of our fake NodeLists then
				//use the first parent for the call.
				var arg2 = arguments[1];
				if(arg2 && arg2._is$){
					arg2 = arg2[0];
				}else if(dojo.isString(arg2)){
					arg2 = dojo.query(arg2)[0];
				}

				var nl = dojo.query.call(this, arg, arg2);
				dojo._NodeListCtor = listCtor;
				return nl;
			}
		}else if(dojo.isFunction(arg)){
			//The addOnLoad case
			$.ready(arg);
			return $;
		}else if(arg == document || arg == window){
			//If the arg is the document or window,
			//then just use it directly.
			return $._wrap([arg], null, $);
		}else if(dojo.isArray(arg)){
			//Input is a plain array.
			//Filter out duplicates.
			var ary = [];
			for(var i = 0; i < arg.length; i++){
				if(dojo.indexOf(ary, arg[i]) == -1){
					ary.push(arg[i]);
				}
			}
			return $._wrap(arg, null, $);
		}else if(""nodeType"" in arg){
			//A DOM Node
			return $._wrap([arg], null, $);
		}

		//A native NodeList that does not conform to dojo.isArray().
		//Convert it to a workable array and create new NodeList.
		return $._wrap(dojo._toArray(arg), null, $);

	};

	//Set up plugin extension point.
	var nlProto = dojo.NodeList.prototype;

	//Need a delegate, because at least one method conflicts with jquery
	//API: attr(name) in jQuery only returns a single, first value, where
	//dojo.attr will return an array.
	var f = $.fn = $.prototype = dojo.delegate(nlProto);

	//_wrap is required for proper use in dojo.query, but the _adaptAs* methods
	//do not have to placed on $ -- they can be used directly off dojo.NodeList.
	$._wrap = dojo.NodeList._wrap;

	//Add in some pseudos selectors
	var headerRegExp = /^H\d/i;
	var pseudos = dojo.query.pseudos;
	dojo.mixin(pseudos, {
		has: function(name, condition){
			return function(elem){
				return $(condition, elem).length;
			}
		},
		visible: function(name, condition){
			return function(elem){
				return dojo.style(elem, ""visible"") != ""hidden"" && dojo.style(elem, ""display"") != ""none"";
			}
		},
		hidden: function(name, condition){
			return function(elem){
				return elem.type == ""hidden"" || dojo.style(elem, ""visible"") == ""hidden"" || dojo.style(elem, ""display"") == ""none"";
			}
		},
		selected: function(name, condition){
			return function(elem){
				return elem.selected;
			}
		},
		checked: function(name, condition){
			return function(elem){
				return elem.nodeName.toUpperCase() == ""INPUT"" && elem.checked;
			}
		},
		disabled: function(name, condition){
			return function(elem){
				return elem.getAttribute(""disabled"");
			}
		},
		enabled: function(name, condition){
			return function(elem){
				return !elem.getAttribute(""disabled"");
			}
		},
		input: function(name, condition){
			return function(elem){
				var n = elem.nodeName.toUpperCase();
				return n == ""INPUT"" || n == ""SELECT"" || n == ""TEXTAREA"" || n == ""BUTTON"";
			}
		},
		button: function(name, condition){
			return function(elem){
				return (elem.nodeName.toUpperCase() == ""INPUT"" && elem.type == ""button"") || elem.nodeName.toUpperCase() == ""BUTTON"";
			}
		},
		header: function(name, condition){
			return function(elem){
				return elem.nodeName.match(headerRegExp);
			}
		}
		//TODO: implement :animated
	});


	//Add the input type selectors to pseudos
	var inputPseudos = {};
	dojo.forEach([
		""text"", ""password"", ""radio"", ""checkbox"", ""submit"", ""image"", ""reset"", ""file""
	], function(type) {
		inputPseudos[type] = function(name, condition){
			return function(elem){
				return elem.nodeName.toUpperCase() == ""INPUT"" && elem.type == type;
			}
		};
	});
	dojo.mixin(pseudos, inputPseudos);

	//Set up browser sniff.
	$.browser = {
		mozilla: dojo.isMoz,
		msie: dojo.isIE,
		opera: dojo.isOpera,
		safari: dojo.isSafari
	};
	$.browser.version = dojo.isIE || dojo.isMoz || dojo.isOpera || dojo.isSafari || dojo.isWebKit;
	
	//Map back into dojo
	//Hmm maybe this is not so good. Dojo
	//modules may still be holding on to old
	//dojo (example: the d._NodeListCtor in query.js)
	//dojo = dojo.mixin($, dojo);

	// Add $.ready
	$.ready = $.fn.ready = function(callback){
		dojo.addOnLoad(dojo.hitch(null, callback, $));
		return this;
	}

	//START jquery Core API methods
	//http://docs.jquery.com/Core
	f._is$ = true;
	f.size = function(){return this.length; };

	$.prop = function(node, propCheck){
		//TODO: not sure about this one, could not find the docs?
		if(dojo.isFunction(propCheck)){
			return propCheck.call(node);
		}else{
			return propCheck;
		}
	}

	$.className = {
		add: dojo.addClass,
		remove: dojo.removeClass,
		has: dojo.hasClass
	};

	$.makeArray = function(thing){
		if(typeof thing == ""undefined""){
			return [];
		}else if(thing.length && !dojo.isString(thing) && !(""location"" in thing)){
			//Location check was for excluding window objects that have a length.
			return dojo._toArray(thing);
		}else{
			return [thing];
		}
	}
	
	$.merge = function(ary1, ary2){
		//Alters first array by adding in the element.
		var args = [ary1.length, 0];
		args = args.concat(ary2);
		ary1.splice.apply(ary1, args);
		return ary1;
	}

	$.each = function(/*Array||ArrayLike*/list, /*Function*/cb){
		//each differs from dojo.NodeList.forEach in that
		//""this"" is the current cycled node. Breaking
		//the loop is also possible. Also, index is first arg
		//to the callback.
		if(dojo.isArrayLike(list)){
			for(var i = 0; i < list.length; i++){
				if(cb.call(list[i], i, list[i]) === false){
					break;
				}
			}
		}else if(dojo.isObject(list)){
			for(var param in list){
				if(cb.call(list[param], param, list[param]) === false){
					break;
				}
			}
		}
		return this;
	};
	f.each = function(/*Function*/cb){
		return $.each.call(this, this, cb);
	};
	//f.length already implemented by NodeList
	f.eq = function(){
		//Direct copy of dojo.NodeList.at, but want
		//to use our NodeList class.
		var nl = $();
		dojo.forEach(arguments, function(i) { if(this[i]) { nl.push(this[i]); } }, this);
		return nl; // dojo.NodeList
	};
	f.get = function(/*Number*/index){
		if(index || index == 0){
			return this[index];
		}
		return this;
	};
	f.index = function(arg){
		//Hmm, allows passing in a $ nodelist. Apparently in that
		//case take the first item in that array and match
		if(arg._is$){
			arg = arg[0];
		}
		return this.indexOf(arg);
	}

	//.data implementation
	var dataStore = [];
	var dataId = 0;
	var dataAttr = dojo._scopeName + ""DataId"";
	
	var getDataId = function(node){
		var id = node.getAttribute(dataAttr);
		if(!id){
			id = dataId++;
			node.setAttribute(dataAttr, id);
		}
	}
	
	var getData = function(node){
		var data = {};
		if(node.nodeType == 1){
			var id = getDataId(node);
			data = dataStore[id];
			if(!data){
				data = dataStore[id] = {};
			}
		}
		return data;
	}

	$.data = function(/*DOMNode*/node, /*String*/name, /*String*/value){
		var result = null;
		if(name == ""events""){
			//Special case ""events"", since jquery tests seem to use it to
			//get the event handler storage for jquery. So for jquery apps
			//""events"" is probably a reserved word anyway.
			result = listeners[node.getAttribute(eventAttr)];
			var isEmpty = true;
			if(result){
				for(var param in result){
					isEmpty = false;
					break;
				}
			}
			return isEmpty ? null : result;
		}

		var data = getData(node);
		if(typeof value != ""undefined""){
			data[name] = value;
		}else{
			result = data[name];
		}
		return value ? this : result;
	}

	$.removeData = function(/*DOMNode*/node, /*String*/name){
		var data = getData(node);
		delete data[name];
		if(node.nodeType == 1){
			var isEmpty = true;
			for(var param in data){
				isEmpty = false;
				break;
			}
			if(isEmpty){
				node.removeAttribute(dataAttr);
			}
		}
		return this;
	}

	f.data = function(/*String*/name, /*String*/value){
		var result = null;
		this.forEach(function(node){
			result = $.data(node, name, value);
		});

		return value ? this : result;
	}

	f.removeData = function(/*String*/name){
		this.forEach(function(node){
			$.removeData(node, name);
		});
		return this;
	}
	
	function jqMix(obj, props){
		// summary:
		//		an attempt at a mixin that follows
		//		jquery's .extend rules. Seems odd. Not sure how
		//		to resolve this with dojo.mixin and what the use
		//		cases are for the jquery version.
		//		Copying some code from dojo._mixin.
		if(obj == props){
			return obj;
		}
		var tobj = {};
		for(var x in props){
			// the ""tobj"" condition avoid copying properties in ""props""
			// inherited from Object.prototype.  For example, if obj has a custom
			// toString() method, don't overwrite it with the toString() method
			// that props inherited from Object.prototype
			if((tobj[x] === undefined || tobj[x] != props[x]) && props[x] !== undefined && obj != props[x]){
				if(dojo.isObject(obj[x]) && dojo.isObject(props[x])){
					if(dojo.isArray(props[x])){
						obj[x] = props[x];
					}else{
						obj[x] = jqMix(obj[x], props[x]);
					}
				}else{
					obj[x] = props[x];
				}
			}
		}
		// IE doesn't recognize custom toStrings in for..in
		if(dojo.isIE && props){
			var p = props.toString;
			if(typeof p == ""function"" && p != obj.toString && p != tobj.toString &&
				p != ""\nfunction toString() {\n    [native code]\n}\n""){
					obj.toString = props.toString;
			}
		}
		return obj; // Object
	}

	f.extend = function(){
		var args = [this];
		args = args.concat(arguments);
		return $.extend.apply($, args);
	}

	$.extend = function(){
		//Could have multiple args to mix in. Similar to dojo.mixin,
		//but has some different rules, and the mixins all get applied
		//to the first arg.
		var args = arguments, finalObj;
		for(var i = 0; i < args.length; i++){
			var obj = args[i];
			if(obj && dojo.isObject(obj)){
				if(!finalObj){
					finalObj = obj;
				}else{
					jqMix(finalObj, obj);
				}
			}
		}
		return finalObj;
	}

	$.noConflict = function(/*Boolean*/extreme){
		var me = $;
		dojo.global.$ = _old$;
		if(extreme){
			dojo.global.jQuery = _oldJQuery;
		}
		return me;
	}
	//END jquery Core API methods
	
	//START jquery Attribute API methods
	//http://docs.jquery.com/Attributes
	f.attr = function(name, value){
		//The isObject tests below are to weed out where something
		//like a form node has an input called ""action"" but we really
		//want to get the attribute ""action"". But in general, favor
		//a property value over a DOM attribute value.
		if(arguments.length == 1 && dojo.isString(arguments[0])){
			//The get case, return first match.
			var first = this[0];
			
			//Weed out empty nodes
			if(!first){
				return null;
			}

			var arg = arguments[0];
			//favor properties over attributes.
			var attr = dojo.attr(first, arg);
			var prop = first[arg];
			if((arg in first) && !dojo.isObject(prop) && name != ""href""){
				return prop;
			}else{
				return attr || prop;
			}
		}else if(dojo.isObject(name)){
			//A setter, using an object.
			for(var param in name){
				this.attr(param, name[param]);
			}
			return this;
		}else{
			//The setter case. Figure out if value is a function.
			var isFunc = dojo.isFunction(value);
			this.forEach(function(node, index){
				var prop = node[name];
				if((name in node) && !dojo.isObject(prop) && name != ""href""){
					node[name] = (isFunc ? value.call(node, index) : value);
				}else if(node.nodeType == 1){
					dojo.attr(node, name, (isFunc ? value.call(node, index) : value));
				}
			});
			return this;
		}
	}

	f.removeAttr = function(name){
		this.forEach(function(node, index){
			var prop = node[name];
			if((name in node) && !dojo.isObject(prop) && name != ""href""){
				delete node[name];
			}else if(node.nodeType == 1){
				if(name == ""class""){
					//TODO: push this fix into dojo.removeAttr
					node.removeAttribute(name);
				}else{
					dojo.removeAttr(node, name);
				}
			}
		});
		return this;
	}

	//addClass, removeClass exist in dojo.NodeList. toggleClass in jQuery case
	//just means add/remove the classname if it missing/exists. So need custom override.
	f.toggleClass = function(/*String*/name, /*Expression?*/condition){
		var hasCondition = arguments.length > 1;
		this.forEach(function(node){
			dojo.toggleClass(node, name,  hasCondition ? condition : !dojo.hasClass(node, name));
		});
		return this;
	}

	//Action depends on arguments: if an array of functions do one thing,
	//If no args, do a display toggle,
	//If an expression, something that evaluates to true or false,
	//then toggle display accordingly.
	//If first arg is a String/Number, then do animation. Second arg
	//is an optional callback.
	f.toggle = function(){
		//If more than two args and we have a function as first arg, then
		//probably the onclick toggle variant: takes variable args that are
		//functions and cycles through them on click actions.
		var args = arguments;
		if(arguments.length > 1 && dojo.isFunction(arguments[0])){
			var index = 0;
			var func = function(){
				var result = args[index].apply(this, arguments);
				index += 1;
				if(index > args.length - 1){
					index = 0;
				}
			};
			return this.bind(""click"", func);
		}else{
			//The display/hide/show case.
			var condition = arguments.length == 1 ? arguments[0] : undefined;
			this.forEach(function(node){
				var result = typeof condition == ""undefined"" ? dojo.style(node, ""display"") == ""none"" : condition;
				var action = (result ? ""show"" : ""hide"");
				var nl = $(node);
				nl[action].apply(nl, args);
			});
			return this;
		}
	}

	//hasClass just returns true if any of the nodes has the class.
	f.hasClass = function(/*String*/name){
		return this.some(function(node){
			return dojo.hasClass(node, name);
		});
	}

	//use the html method from dojo.NodeList-manipulate.
	f.html = f.innerHTML;

	//END jquery Attribute API methods

	
	//START jquery Traversing API methods
	//http://docs.jquery.com/Traversing
	dojo.forEach([""filter"", ""slice""], function(item){
		f[item] = function(){
			//Convert the ""this"" value for functions passed in:
			var nl;
			if(dojo.isFunction(arguments[0])){
				var origFunc = arguments[0];
				arguments[0] = function(item, index){
					return origFunc.call(item, item, index);
				}
			}
			
			if(item == ""filter"" && dojo.isString(arguments[0])){
				var nl = this._filterQueryResult(this, arguments[0]);
			}else{
				var oldCtor = dojo._NodeListCtor;
				dojo._NodeListCtor = f;
				//Need to wrap in a $() call since internally some
				//dojo.NodeList functions reference dojo.NodeList directly.
				//Need to get a configurable constructor for dojo.NodeList.
				nl = $(nlProto[item].apply(this, arguments));
				dojo._NodeListCtor = oldCtor;
			}

			return nl._stash(this);
		}
	});

	f.map = function(/*Function*/callback){
		//Hmm, this is not like array map/dojo.map where you get one item back for
		//each input.
		return this._buildArrayFromCallback(callback);
	}
	$.map = function(/*Array*/ary, /*Function*/callback){
		//Hmm, this is not like array map/dojo.map where you get one item back for
		//each input.
		return f._buildArrayFromCallback.call(ary, callback);
	}

	$.inArray = function(value, /*Array*/ary){
		return dojo.indexOf(ary, value);
	}

	f.is = function(query){
		return (query ? !!this.filter(query).length : false);
	}

	//TODO: probably a better way to do this.
	f.not = function(){
		var notList = $.apply($, arguments);
		//TODO: another place where if dojo.NodeList can configure a constructor,
		//then we could avoid the $() wrapper below.
		var nl = $(nlProto.filter.call(this, function(node){
			return notList.indexOf(node) == -1;
		}));
		return nl._stash(this);
	}

	f.add = function(){
		return this.concat.apply(this, arguments);
	}

	function iframeDoc(/*DOMNode*/iframeNode){
		// summary:
		//		Returns the document object associated with the iframe DOM Node argument.

		//Taken from dojo.io.iframe.doc(). Needed for contents() function below.

		var doc = iframeNode.contentDocument || // W3
			(
				(
					(iframeNode.name) && (iframeNode.document) &&
					(document.getElementsByTagName(""iframe"")[iframeNode.name].contentWindow) &&
					(document.getElementsByTagName(""iframe"")[iframeNode.name].contentWindow.document)
				)
			) ||  // IE
			(
				(iframeNode.name)&&(document.frames[iframeNode.name])&&
				(document.frames[iframeNode.name].document)
			) || null;
		return doc;
	}

	f.contents = function(){
		var ary = [];
		this.forEach(function(node){
			if(node.nodeName.toUpperCase() == ""IFRAME""){
				var doc = iframeDoc(node);
				if(doc){
					ary.push(doc);
				}
			}else{
				//TODO: code similar to children() function. Refactor?
				var children = node.childNodes;
				//Using for loop for better speed.
				for(var i = 0; i < children.length; i++){
					ary.push(children[i]);
				}
			}
		});
		return this._wrap(ary)._stash(this);
	}

	f.find = function(/*String*/query){
		var ary = [];
		this.forEach(function(node){
			if(node.nodeType == 1){
				ary = ary.concat(dojo._toArray($(query, node)));
			}
		});
		return this._getUniqueAsNodeList(ary)._stash(this);
	}

	f.andSelf = function(){
		return this.add(this._parent);
	}

	//END jquery Traversing API methods

	//START jquery Manipulation API methods
	//http://docs.jquery.com/Manipulation

	f.remove = function(/*String?*/query){
		//Override NodeList-manipulate's remove so we can remove data.
		var nl = (query ? this._filterQueryResult(this, query) : this);
		
		//Remove data
		nl.removeData();
		
		//Remove event listeners.
		//TODO! do this, once event stuff is built out.
		
		//Remove the items from the DOM, but keep them in this
		//node list.
		nl.forEach(function(node){
			node.parentNode.removeChild(node);
		});
		
		return this;
	}

	//START jquery CSS API methods
	//http://docs.jquery.com/CSS
	$.css = function(/*DOMNode*/node, /*String|Object*/name, /*String|Number?*/value){
		name = cssNameToJs(name);
		
		//Hmm, dojo.style does an arguments. length check.
		var result = (value ? dojo.style(node, name, value) : dojo.style(node, name));
		return result;
	}

	f.css = function(/*String|Object*/name, /*String|Number?*/value){
		if(dojo.isString(name)){
			//Convert name to JS name if needed.
			name = cssNameToJs(name);
			if(arguments.length == 2){
				//set the value. Cannot directly delegate to
				//this.style, since non-element nodes may be in the mix?
				//this.contents() in particular will return some funky stuff.
				
				//Need to be sure to add ""px"" if appropriate.
				if(!dojo.isString(value) && name != ""zIndex""){
					value = value + ""px"";
				}

				this.forEach(function(node){
					if(node.nodeType == 1){
						dojo.style(node, name, value);
					}
				});
				return this;
			}else{
				//return the value
				value = dojo.style(this[0], name);
				//Need to be sure to add ""px"" if appropriate.
				if(!dojo.isString(value) && name != ""zIndex""){
					value = value + ""px"";
				}
				return value;
			}
		}else{
			for(var param in name){
				this.css(param, name[param]);
			}
			return this;
		}
	}
	
	function doBox(/*NodeList*/nl, /*String*/boxType, /*String*/prop, /*String||Number*/value){;
		if(value){
			//Set height for all elements.
			var mod = {};
			mod[prop] = value;
			nl.forEach(function(node){
				dojo[boxType](node, mod);
			});
			return nl;
		}else{
			//Just get first node's height.
			//Hmm. width is negative when element is display none in FF3?
			return Math.abs(Math.round(dojo[boxType](nl[0])[prop]));
		}
	}

	f.height = function(value){
		return doBox(this, ""contentBox"", ""h"", value);
	}

	f.width = function(value){
		return doBox(this, ""contentBox"", ""w"", value);
	}

	function getDimensions(/*DOMNode*/node, /*String*/type, /*Boolean*/usePadding, /*Boolean*/useBorder, /*Boolean*/useMargin){
		// summary:
		//		sums up the different parts of the width/height based on arguments.

		//If hidden, temporarily show it, do measurements then close.
		var rehide = false;
		if((rehide = node.style.display == ""none"")){
			node.style.display = ""block"";
		}

		var cs = dojo.getComputedStyle(node);
		var content = Math.abs(Math.round(dojo._getContentBox(node, cs)[type]));
		var pad = usePadding ? Math.abs(Math.round(dojo._getPadExtents(node, cs)[type])) : 0;
		var border = useBorder ? Math.abs(Math.round(dojo._getBorderExtents(node, cs)[type])) : 0;
		var margin = useMargin ? Math.abs(Math.round(dojo._getMarginExtents(node, cs)[type])) : 0;
		
		if(rehide){
			node.style.display = ""none"";
		}

		return pad + content + border + margin;
	}

	f.innerHeight = function(){
		return getDimensions(this[0], ""h"", true);
	}

	f.innerWidth = function(){
		return getDimensions(this[0], ""w"", true);
	}

	f.outerHeight = function(useMargin){
		return getDimensions(this[0], ""h"", true, true, useMargin);
	}

	f.outerWidth = function(useMargin){
		return getDimensions(this[0], ""w"", true, true, useMargin);
	}

	//END jquery CSS API methods


	//START jquery Events API methods
	//http://docs.jquery.com/Events
	
	//ready() already defined above.

	//Event plumbing.
	var listeners = [];
	var listenId = 1;
	var eventAttr = dojo._scopeName + ""eventid"";
	var currentEvtData;

	function getNonNamespacedName(/*String*/evtName){
		// summary:
		//		gets name of the event before the first ""."".

		//The $$ stuff is special ids used to create unique names
		//for bound functions that did not have a unique namespace name.
		evtName = evtName.split(""$$"")[0];
		var dotIndex = evtName.indexOf(""."");
		if(dotIndex != -1){
			evtName = evtName.substring(0, dotIndex);
		}
		return evtName;
	}

	function domConnect(/*DOMNode*/node, /*String*/evtName){
		// summary:
		//		handles creating the connection with a real DOM event.

		//This work should only be done one time per evName type.
		//If the event if an ajax event, use dojo.subscribe instead.
		if(evtName.indexOf(""ajax"") == 0){
			return dojo.subscribe(topics[evtName], function(dfd, res){
				var fakeEvt = new $.Event(evtName);
				if(""ajaxComplete|ajaxSend|ajaxSuccess"".indexOf(evtName) != -1){
					triggerHandlers(node, [fakeEvt, dfd.ioArgs.xhr, dfd.ioArgs.args]);
				}else if(evtName == ""ajaxError""){
					triggerHandlers(node, [fakeEvt, dfd.ioArgs.xhr, dfd.ioArgs.args, res]);
				}else{
					//ajaxStart|ajaxStop
					triggerHandlers(node, [fakeEvt]);
				}
			});
		}else{
			return dojo.connect(node, ""on"" + evtName, function(e){
				triggerHandlers(node, arguments);
			}); //Object
		}
	}

	//Event object for compatibility for some tests.
	$.Event = function(/*String*/type){
		//Allow for calling function without ""new""
		if(this == $){
			return new $.Event(type);
		}
		if(typeof type == ""string""){
			this.type = type.replace(/!/, """");
		}else{
			dojo.mixin(this, type);
		}
		this.timeStamp = (new Date()).getTime();
		this._isFake = true;
		this._isStrict = (this.type.indexOf(""!"") != -1);
		
	}
	
	var ep = $.Event.prototype = {
		preventDefault: function(){
			this.isDefaultPrevented = this._true;
		},
		stopPropagation: function(){
			this.isPropagationStopped = this._true;
		},
		stopImmediatePropagation: function(){
			this.isPropagationStopped = this._true;
			this.isImmediatePropagationStopped = this._true;
		},
		_true: function(){ return true; },
		_false: function(){ return false; }
	}
	dojo.mixin(ep, {
		isPropagationStopped: ep._false,
		isImmediatePropagationStopped: ep._false,
		isDefaultPrevented: ep._false
	});

	function makeTriggerData(data, type){
		// summary:
		//		makes sure that the data array is copied
		//		and has an event as the first arg. If this function generates
		//		a fake event (known by the data[0]._isFake property being true)
		//		then the data[0].target needs to be set by the consumer of this function.
		
		data = data || [];
		data = [].concat(data);

		//If first data item is not an event, make one up.
		//Need to set up target: prop in the consumers of this
		//function.
		var evt = data[0];
		if(!evt || !evt.preventDefault){
			evt = type && type.preventDefault ? type : new $.Event(type);
			data.unshift(evt);
		}
		return data;
	}
	
	var triggerHandlersCalled = false;

	function triggerHandlers(/*DOMNode*/node, /*Array*/data, /*Function?*/extraFunc){
		// summary:
		//		handles the actual callbacks to the handlers.
		
		//Indicate triggerHandlers was called.
		triggerHandlersCalled = true;
		
		//Uses currentEvtData if this is a simulated event.
		data = data || currentEvtData;
		extraFunc = extraFunc;

		//Normalize on a real element if dealing with a document.
		if(node.nodeType == 9){
			node = node.documentElement;
		}

		var nodeId = node.getAttribute(eventAttr);
		if(!nodeId){
			return;
		}

		var evt = data[0];
		var evtFullName = evt.type;
		var evtName = getNonNamespacedName(evtFullName);

		var cbs = listeners[nodeId][evtName];

		var result;
		//Apply the extra function. What is that about? Not mentioned in the
		//public APIs?
		if(extraFunc){
			result = extraFunc.apply(node, data);
		}

		if (result !== false){
			for(var param in cbs){
				if(param != ""_connectId"" && (!evt._isStrict && (param.indexOf(evtFullName) == 0) || (evt._isStrict && param == evtFullName))){
					//Store the callback ID in case unbind is called with this event
					//so we can only unbind that one callback.
					evt[dojo._scopeName + ""callbackId""] = param;

					var cb = cbs[param];
					if(typeof cb.data != ""undefined""){
						evt.data = cb.data;
					}else{
						evt.data = null;
					}
	
					//Do the actual callback.
					if ((result = cb.fn.apply(evt.target, data)) === false && !evt._isFake){
						dojo.stopEvent(evt);
					}
					evt.result = result;
				}
			}
		}

		return result;
	}

	f.triggerHandler = function(/*String*/type, /*Array?*/data, /*Function?*/extraFunc){
		//Only triggers handlers on the first node. Huh.
		var node = this[0];
		if(node && node.nodeType != 3 && node.nodeType != 8){
			data = makeTriggerData(data, type);
			return triggerHandlers(node, data, extraFunc);
		}else{
			return undefined;
		}
	}

	f.trigger = function(/*String*/type, /*Array?*/data, /*Function?*/extraFunc){
		//Copy data since we may need to modify by adding a
		data = makeTriggerData(data, type);
		var evt = data[0];
		var type = getNonNamespacedName(evt.type);
		
		//Store the current event data in case handlers need
		//to reference it because of a simulated event.
		currentEvtData = data;
		currentExtraFunc = extraFunc;

		var result = null;
		var needTarget = !evt.target;
		this.forEach(function(node){
			//Only handle non text/comment nodes.
			if(node.nodeType != 3 && node.nodeType != 8){

				//Normalize on a real element if dealing with a document.
				if(node.nodeType == 9){
					node = node.documentElement;
				}

				//Set the node target appropriately for fake events.
				if(evt._isFake){
					evt.currentTarget = node;
					if(needTarget){
						evt.target = node;
					}
				}

				//Bizarre extra function thing. Not really demonstrated in public
				//API docs.
				if(extraFunc){
					var funcData = data.slice(1);
					result = extraFunc.apply(node, (result = null ? funcData : funcData.concat(result)));
				}

				if(result !== false){
					//Trigger DOM event. onclick is handled differently than
					//others.
					/*
					if(type == 'click' && node.onclick && node.nodeName.toUpperCase() == ""A""){
						result = node.onclick.apply(node, data);
					}
					*/
					
					//Set the ""global"" flag that indicates if triggerHandlers was called.
					//If the direct node.event/onevent does not trigger the handlers, do so
					//manually at the end.
					triggerHandlersCalled = false;
					
					//Trigger functions registered directly on the DOM node.
					if(node[type]){
						try{
							result = node[type]();
						}catch(e){
							//Apparently IE throws on some hidden elements. Just eat it.
						}
					}else if(node[""on"" + type]){
						try{
							result = node[""on"" + type]();
						}catch(e){
							//Apparently IE throws on some hidden elements. Just eat it.
						}
					}
					
					if(!triggerHandlersCalled){
						//Finally triggerHandlers directly if the above code did not trigger it yet.
						result = triggerHandlers(node, data);
					}

					//Bubble the event up.
					//TODO: optimize this path so we don't have to do forEach and NodeList work.
					var parentNode = node.parentNode;
					if(result !== false && !evt.isImmediatePropagationStopped() && !evt.isPropagationStopped() && parentNode && parentNode.nodeType == 1){
						$(parentNode).trigger(type, data, extraFunc);
					}
				}
			}
		});

		//Clear current event data.
		currentEvtData = null;
		currentExtraFunc = null;

		return this;
	}

	var bindIdCounter = 0;

	f.bind = function(/*String*/type, /*Array||Function?*/data, /*Function*/fn){
		//Type can be space separated values.
		type = type.split("" "");
		
		//May not have data argument.
		if(!fn){
			fn = data;
			data = null;
		}

		this.forEach(function(node){
			//Only handle non text/comment nodes.
			if(node.nodeType != 3 && node.nodeType != 8){
			
				//If document, bind to documentElement
				if(node.nodeType == 9){
					node = node.documentElement;
				}

				//If no nodeId, then create one and attach it to the DOM node.
				var nodeId = node.getAttribute(eventAttr);
				if(!nodeId){
					nodeId = listenId++;
					node.setAttribute(eventAttr, nodeId);
					listeners[nodeId] = {};
				}
	
				//Process each event type.
				for(var i = 0; i < type.length; i++){
					//Get event name, if have a dot on it, it is namespaced,
					//be sure to get the core event name.
					var evtFullName = type[i];
					var evtName = getNonNamespacedName(evtFullName);
					if(evtName == evtFullName){
						//Generate a unique ID for this function binding
						evtFullName = evtName + ""$$"" + (bindIdCounter++);
					}
	
					//Get the event listeners for the event name, the complete name.
					var lls = listeners[nodeId];
					if(!lls[evtName]){
						lls[evtName] = {
							_connectId: domConnect(node, evtName)
						};
					}
	
					//Add the callback to the list of listeners.
					lls[evtName][evtFullName] = {
						fn: fn,
						data: data
					};
				}
			}
		});
		
		return this;
	}

	function copyEventHandlers(/*DOMNode*/ src, /*DOMNode*/ target){
		// summary:
		//		copies the event handlers from onne src *element* node to
		//		another target *element* node. Assumes that target had
		//		no previous events on it, and is a clone of the src node.

		//Get src listeners.
		var srcNodeId = target.getAttribute(eventAttr);
		var sls = listeners[srcNodeId];
		if(!sls){
			return;
		}

		//Generate listeners area for target.
		var nodeId = nodeId = listenId++;
		target.setAttribute(eventAttr, nodeId);
		var tls = listeners[nodeId] = {};

		//Loope through events in source. Protect against bad
		//code modifying Object.prototype.
		var empty = {};
		for (var evtName in sls){
			var tEvtData = tls[evtName] = {
				_connectId: domConnect(target, evtName)
			};
			var sEvtData = sls[evtName];

			for (var evtFullName in sEvtData){
				tEvtData[evtFullName] = {
					fn: sEvtData[evtFullName].fn,
					data: sEvtData[evtFullName].data
				};
			}
		}
	}

	function listenerUnbind(lls, evtName, evtFullName, callbackId, fn){
		//Handles the real remove of an event and dojo.disconnects DOM handler if necessary.
		//This has to be broken out of the main unbind function because we have to support
		//things like unbind("".test"") that go across major event names. Yuck.
		var handles = lls[evtName];
		if(handles){
			var hasDot = evtFullName.indexOf(""."") != -1;
			var forceDelete = false;

			if(callbackId){
				//Only need to unbind that one callback
				delete handles[callbackId];
			}else if(!hasDot && !fn){
				forceDelete = true;
			}else if(hasDot){
				//A namespaced event.
				//Problem is the namespaced event could be something like
				//"".test"" which means remove all that end in .test. Yuck.
				if(evtFullName.charAt(0) == "".""){
					for(var param in handles){
						if(param.indexOf(evtFullName) == param.length - evtFullName.length){
							delete handles[param];
						}
					}
				}else{
					delete handles[evtFullName];
				}
			}else{
				//Not a namespaced event. Cycle through the $$ names
				//to find a function match.
				for(var param in handles){
					if(param.indexOf(""$$"") != -1 && handles[param].fn == fn){
						delete handles[param];
						break;
					}
				}
			}

			//Remove handles/disconnect dom if no other params.
			var allDone = true;
			for(var param in handles){
				if(param != ""_connectId""){
					allDone = false;
					break;
				}
			}
			if(forceDelete || allDone){
				if(evtName.indexOf(""ajax"") != -1){
					dojo.unsubscribe(handles._connectId);
				}else{
					dojo.disconnect(handles._connectId);
				}
				delete lls[evtName];
			}
		}
	}

	f.unbind = function(/*String*/type, /*Function*/fn){
		
		//See if event has a callbackId, if so, then we only unbind
		//that one callback.
		var callbackId = type ? type[dojo._scopeName + ""callbackId""] : null;

		//Type can be space separated values.
		type = type && type.type ? type.type : type;
		type = type ? type.split("" "") : type;

		this.forEach(function(node){
			//Only handle non text/comment nodes.
			if(node.nodeType != 3 && node.nodeType != 8){
				//If document, bind to documentElement
				if(node.nodeType == 9){
					node = node.documentElement;
				}

				//If no nodeId, then create one and attach it to the DOM node.
				var nodeId = node.getAttribute(eventAttr);
				
				if(nodeId){
					//Get the event listeners for the event name, the complete name.
					var lls = listeners[nodeId];
					if(lls){
						//If no type, then it means do all bound types. Make a list of them.
						var etypes = type;
						if(!etypes){
							etypes = [];
							for(var param in lls){
								etypes.push(param);
							}
						}

						//Process each event type.
						for(var i = 0; i < etypes.length; i++){
							//Get event name, if have a dot on it, it is namespaced,
							//be sure to get the core event name.
							var evtFullName = etypes[i];
							var evtName = getNonNamespacedName(evtFullName);
			
							//Problem is the namespaced event could be something like
							//"".test"" which means remove all that end in .test. Yuck.
							if(evtFullName.charAt(0) == "".""){
								for(var param in lls) {
									listenerUnbind(lls, param, evtFullName, callbackId, fn);
								}
							}else{
								listenerUnbind(lls, evtName, evtFullName, callbackId, fn);
							}
						}
					}
				}
			}
		});

		return this;
	}

	f.one = function(/*String*/evtName, /*Function*/func){
		var oneFunc = function(){
			$(this).unbind(evtName, arguments.callee);
			return func.apply(this, arguments);
		}

		return this.bind(evtName, oneFunc);
	};

	f._cloneNode = function(/*DOMNode*/ src){
		// summary:
		//		private utiltity to clone a node. Copies event handlers too.
		var target = src.cloneNode(true);

		if(src.nodeType == 1){
			//Look for event handlers in target.
			var evNodes = dojo.query(""["" + eventAttr + ""]"", target);
			for(var i = 0, newNode; newNode = evNodes[i]; i++){
				var oldNode = dojo.query('[' + eventAttr + '=""' + newNode.getAttribute(eventAttr) + '""]', src)[0];
				if(oldNode){
					copyEventHandlers(oldNode, newNode);
				}
			}
		}
		return target;
	};

	//Temporary testing shim to get past jquery test setup errors.
	dojo.getObject(""$.event.global"", true);

	//Set up event handlers
	dojo.forEach([
		""blur"", ""focus"", ""dblclick"", ""click"", ""error"", ""keydown"", ""keypress"", ""keyup"", ""load"", ""mousedown"",
		""mouseenter"", ""mouseleave"", ""mousemove"", ""mouseout"", ""mouseover"", ""mouseup"", ""submit"",
		""ajaxStart"", ""ajaxSend"", ""ajaxSuccess"", ""ajaxError"", ""ajaxComplete"", ""ajaxStop""
		], function(evt){
			f[evt] = function(callback){
				if(callback){
					this.bind(evt, callback);
				}else{
					this.trigger(evt);
				}
				return this;
			}
		}
	);

	//END jquery Events API methods


	//START jquery Effects API methods
	//http://docs.jquery.com/Effects
	function speedInt(speed){
		//Fix speed setting, translate string values to numbers.
		if(dojo.isString(speed)){
			if(speed == ""slow""){
				speed = 700;
			}else if(speed == ""fast""){
				speed = 300;
			}else{
				//Everything else is considered normal speed.
				speed = 500;
			}
		}
		return speed;
	}
	
	f.hide = function(/*String||Number*/speed, /*Function?*/callback){
		//Fix speed setting, translate string values to numbers.
		speed = speedInt(speed);

		this.forEach(function(node){
			var style = node.style;
			
			//Skip if already hidden
			var cs = dojo.getComputedStyle(node);
			if(cs.display == ""none""){
				return;
			}

			style.overflow = ""hidden"";
			style.display = ""block"";
			
			if(speed){
				//It is alive!
				dojo.anim(
					node,
					{
						width: 0,
						height: 0,
						opacity: 0
					},
					speed,
					null,
					function(){
						style.width = """";
						style.height = """";
						style.display = ""none"";
						return callback && callback.call(node);
					}
				);
			}else{
				//No need for animation, fast path it.
				dojo.style(node, ""display"", ""none"");
				if(callback){
					callback.call(node);
				}
			}
		});
		return this;
	}

	f.show = function(/*String||Number*/speed, /*Function?*/callback){
		//Fix speed setting, translate string values to numbers.
		speed = speedInt(speed);

		this.forEach(function(node){
			var style = node.style;
			//Skip if the node is already showing.
			var cs = dojo.getComputedStyle(node);
			if(cs.display != ""none""){
				return;
			}

			if(speed){
				//Figure out size of element
				//so we know when to stop animation.
				//Try the easy path first.
				var width = parseFloat(style.width);
				var height = parseFloat(style.height);
				if(!width || !height){
					//temporarily show the element to get
					//dimensions
					style.display = ""block"";
					var box = dojo.marginBox(node);
					width = box.w;
					height = box.h;
				}

				//Make sure values are set to hidden state.
				style.width = 0;
				style.height = 0;
				style.overflow = ""hidden"";
				dojo.attr(node, ""opacity"", 0);
				style.display = ""block"";

				//It is alive!
				dojo.anim(
					node,
					{
						width: width,
						height: height,
						opacity: 1
					},
					speed,
					null,
					callback ? dojo.hitch(node, callback) : undefined
				);
			}else{
				dojo.style(node, ""display"", ""block"");
				if(callback){
					callback.call(node);
				}
			}
		});
		return this;
	}


	//END jquery Effects API methods


	//START jquery Ajax API methods
	//http://docs.jquery.com/Ajax
	
	$.ajaxSettings = {
	};

	$.ajaxSetup = function(/*Object*/args){
		dojo.mixin($.ajaxSettings, args);
	}

	var topics = {
		""ajaxStart"": ""/dojo/io/start"",
		""ajaxSend"": ""/dojo/io/send"",
		""ajaxSuccess"": ""/dojo/io/load"",
		""ajaxError"": ""/dojo/io/error"",
		""ajaxComplete"": ""/dojo/io/done"",
		""ajaxStop"": ""/dojo/io/stop""
	};

	for(var fnName in topics){
		//Make sure we are dealing with properties
		//we care about and not something another toolkit added.
		if(fnName.indexOf(""ajax"") == 0){
			;(function(fnName){
				f[fnName] = function(callback){
					this.forEach(function(node){
						dojo.subscribe(topics[fnName], function(){
							var fakeEvt = new $.Event(fnName);
							var ioArgs = arguments[0] && arguments[0].ioArgs;
							var xhr = ioArgs && ioArgs.xhr;
							var args = ioArgs && ioArgs.args;
							var res = arguments[1];
							if(""ajaxComplete|ajaxSend|ajaxSuccess"".indexOf(fnName) != -1){
								return callback.call(node, fakeEvt, xhr, args);
							}else if(fnName == ""ajaxError""){
								return callback.call(node, fakeEvt, xhr, args, res);
							}else{
								//ajaxStart|ajaxStop
								return callback.call(node, fakeEvt);
							}
						});
					});
					return this;
				}
			})(fnName);
		}
	};

	//Override dojo._xhrObj(dfd.ioArgs.args) to support beforeSend
	//Do not understand the reason for beforeSend, particularly
	//returning false stops the request.
	//WARNING: even with this code, the error and complete callbacks
	//will be fired because the deferred is cancelled. I feel this is
	//correct behavior for dojo, and not sure why beforeSend is needed.
	var _oldXhrObj = dojo._xhrObj;
	dojo._xhrObj = function(args){
		var xhr = _oldXhrObj.apply(dojo, arguments);
		if(args && args.beforeSend){
			if(args.beforeSend(xhr) === false){
				return false;
			}
		}
		return xhr;
	}

	$.ajax = function(/*Object*/args){
		//Not sure if the args are considered mutable.
		//Copy them to be safe.
		var temp = dojo.delegate($.ajaxSettings);
		for(var param in args){
			//For data objects merge the data do not overwrite.
			if(param == ""data"" && dojo.isObject(args[param]) && dojo.isObject(temp.data)){
				for(var prop in args[param]){
					temp.data[prop] = args[param][prop];
				}
			}else{
				temp[param] = args[param];
			}
		}
		args = temp;
		var url = args.url;

		if(""async"" in args){
			args.sync = !args.async;
		}

		//Turn off topic publications
		if(args.global === false){
			args.ioPublish = false;
		}

		if(args.data){
			var data = args.data;
			if(dojo.isString(data)){
				//convert to an object.
				args.content = dojo.queryToObject(data);
			}else{
				//data property values could be a function, be sure to call them if so.
				//Hmm, this seems to be of dubious value.
				for(var param in data){
					if(dojo.isFunction(data[param])){
						data[param] = data[param]();
					}
				}
				args.content = data;
			}
		}

		//dataType
		var dataType = args.dataType;
		if(""dataType"" in args){
			if(dataType == ""script""){
				dataType = ""javascript"";
			}else if(dataType == ""html""){
				dataType = ""text"";
			}
			args.handleAs = dataType;
		}else{
			//Make a guess based on the URL.
			dataType = args.handleAs = ""text"";
			args.guessedType = true;
		}

		//cache:
		if(""cache"" in args){
			args.preventCache = !args.cache;
		}else{
			if(args.dataType == ""script"" || args.dataType == ""jsonp""){
				args.preventCache = true;
			}
		}

		//Hide error since dojo treats it different.
		if(args.error){
			args._jqueryError = args.error;
			delete args.error;
		}
		
		//TODO: dataFilter

		//Set up callbacks.
		args.handle = function(result, ioArgs){
			var textStatus = ""success"";
			if(result instanceof Error){
				textStatus = (result.dojoType == ""timeout"" ? ""timeout"" : ""error"");
				if(args._jqueryError){
					args._jqueryError(ioArgs.xhr, textStatus, result);
				}
			}else{
				//If we guessed the type, see if it should be XML.
				var xml = (ioArgs.args.guessedType && ioArgs.xhr && ioArgs.xhr.responseXML);
				if(xml){
					result = xml;
				}

				if(args.success){
					args.success(result, textStatus, ioArgs.xhr);
				}
			}
			if(args.complete){
				args.complete(result, textStatus, ioArgs.xhr);
			}
			
			return result;
		};
		
		//Use a script tag if the request is xdomain or a jsonp thing.
		var useScript = (dataType == ""jsonp"");
		if(dataType == ""javascript""){
			//Get protocol and domain.
			var colonIndex = url.indexOf("":"");
			var slashIndex = url.indexOf(""/"");
			if(colonIndex > 0 && colonIndex < slashIndex){
				//Possibly xdomain. Peel off protocol and hostname to find out.
				var lastSlash = url.indexOf(""/"", slashIndex + 2);
				if(lastSlash == -1){
					lastSlash = url.length;
				}
				if(location.protocol != url.substring(0, colonIndex + 1) ||
					location.hostname != url.substring(slashIndex + 2, lastSlash)){
					useScript = true;
				}
			}
		}

		if(useScript){
			if(dataType == ""jsonp""){
				//Look for callback param
				var cb = args.jsonp;
				if(!cb){
					//Look in the URL
					var params = args.url.split(""?"")[1];
					if(params && (params = dojo.queryToObject(params))){
						cb = findJsonpCallback(params);
						if(cb){
							//Remove the cb from the url.
							var regex = new RegExp(""([&\\?])?"" + cb + ""=?"");
							args.url = args.url.replace(regex + ""=?"");
						}
					}
					//Look in the content.
					if(!cb){
						cb = findJsonpCallback(args.content);
						if(cb){
							delete args.content[cb];
						}
					}
				}
				args.jsonp = cb || ""callback"";
			}
			var dfd = dojo.io.script.get(args);
			return dfd;
		}else{
			var dfd = dojo.xhr(args.type || ""GET"", args);
			//If the XHR object is false, it means beforeSend canceled the request.
			return dfd.ioArgs.xhr === false ? false : dfd.ioArgs.xhr;
		}
	}

	function findJsonpCallback(obj){
		for(var prop in obj){
			if(prop.indexOf(""callback"") == prop.length - 8){
				return prop;
			}
		}
		return null;
	}
	
	$.getpost = function(httpType, url, data, callback, dataType){
		var args = {
			url: url,
			type: httpType
		};

		//Normalize data, considering it may be the real
		//callback.
		if(data){
			if(dojo.isFunction(data) && !callback){
				args.complete = data;
			}else{
				args.data = data;
			}
		}

		//Normalize callback, considering it may be
		//the datatype.
		if(callback){
			if(dojo.isString(callback) && !dataType){
				dataType = callback;
			}else{
				args.complete = callback;
			}
		}

		if(dataType){
			args.dataType = dataType;
		}

		return $.ajax(args);
	};

	$.get = dojo.hitch($, ""getpost"", ""GET"");
	$.post = dojo.hitch($, ""getpost"", ""POST"");
	$.getJSON = function(url, data, callback){
		return $.getpost(""GET"", url, data, callback, ""json"");
	}
	$.getScript = function(url, callback){
		return $.ajax({
			url: url,
			success: callback,
			dataType: ""script""
		});
	}

	f.load = function(url, data, callback){
		
		//See if this is a window or document. If so, then want to
		//register onload handler.
		var node = this[0];
		if(!node || !node.nodeType || node.nodeType == 9){
			dojo.addOnLoad(url);
			return this;
		}

		//The rest of this function is the ajax HTML load case.
		//Pull off selector if it is on the url.
		var parts = url.split(/\s+/);
		url = parts[0];
		var query = parts[1];
		
		var finalCb = callback || data;

		var cb = dojo.hitch(this, function(result, textStatus, xhr){
			//Try to find all the body content.
			var match = result.match(/\<\s*body[^>]+>.*<\/body\s*>/i);
			if(match){
				result = match;
			}

			//Convert to DOM nodes.
			var nodes = dojo._toDom(result);

			//Apply query, using a temp div to do the filtering.
			if(query){
				var temp = $(dojo.create(""div""));
				temp.append(nodes);
				nodes = temp.find(query);
			}else{
				nodes = $(nodes.nodeType == 11 ? nodes.childNodes : nodes);
			}

			//Add the HTML to all nodes in this node list.
			this.html(nodes);

			//Call the user's callback.
			//Use a timeout to allow any embedded scripts that
			//were just inserted to run.
			if(finalCb){
				setTimeout(dojo.hitch(this, function(){
					this.forEach(function(node){
						finalCb.call(node, result, textStatus, xhr);
					});
				}), 10);
			}
		});

		//Adjust parameters since they are variable.
		if(!callback){
			data = cb;
		}else{
			callback = cb;
		}

		//Set HTTP method. If the data is a string, use get, if it is an object,
		//use post.
		var method = ""GET"";
		if(data && dojo.isObject(data)){
			method = ""POST"";
		}

		$.getpost(method, url, data, callback, ""html"");
		return this;
	}

	var serializeExclude = ""file|submit|image|reset|button|"";
	f.serialize = function(){
		var ret = """";
		var strs = this.map(function(node){
			if(node.nodeName.toUpperCase() == ""FORM""){
				return dojo.formToQuery(node);
			}else{
				var type = (node.type||"""").toLowerCase();
				if(serializeExclude.indexOf(type) == -1){
					var val = dojo.fieldToObject(node);
					if(node.name && val != null){
						var q = {};
						q[node.name] = val;
						return dojo.objectToQuery(q);
					}
				}
			}
		});
		return ret + strs.join(""&"");
	}

	$.param = function(obj){
		if(obj._is$ && obj.serialize){
			return obj.serialize();
		}else if(dojo.isArray(obj)){
			return dojo.map(obj, function(item){
				return $.param(item);
			}).join(""&"");
		}else{
			return dojo.objectToQuery(obj);
		}
	}
	
	//END jquery Ajax API methods

	//START jquery Utilities API methods
	//http://docs.jquery.com/Utilities
	//TODO:
	
	$.isFunction = function(){
		var result = dojo.isFunction.apply(dojo, arguments);
		//Make sure Object does not return true
		if(result){
			result = (typeof(arguments[0]) != ""object"");
		}
		return result;
	}

	//END jquery Utilities API methods

	
})();

","//For jQuery 1.3.2

dojo.provide(""dojox.jq"");
dojo.require(""dojo.NodeList-traverse"");
dojo.require(""dojo.NodeList-manipulate"");
dojo.require(""dojo.io.script"");

/*
To get jquery tests to pass:
- add spaces between span>form selectors, other ones like one,two
- .last() instead of :last
- $(""<div>"").find(""#foo"") does not work unless the div is attached to the body.

- trigger .test not work
- No jquery.Event thing.

- jQuery.ajax() modifies incoming arguments?
- test framework not good for our io methods, async, poll.
- Dojo ajax is async: we fire ajaxStop more than jquery.

- jquery makes assumptions of a value to set for an element
by inserting an element and checking display. Does not seem to
account for nested styles, only captures generic tag name style off
of body. Why can't we just set display to empty?





OK for failures:
- test(""jQuery.ajax - beforeSend, cancel request (#2688)""
  We cancel the deferred which triggers error and complete callbacks.


Looked at jquery code for:
- how it handled text(): did not use textContent/innerText, but use recursive look over childNodes and nodeValue,
so it may have impact on how <br> is serialized, but it has uniform behavior across browsers.
- Looked at trigger: how it triggered actions on dom nodes. This seemed unsafe.
*/

/*
dojo.query differences that cause some tests to fail:
- does not support XML queries
- $(""#sap>form"") does not find a match but $(""#sap > form"") does. Similar issue with comma instead of > (see is() tests)
- ""$(""form:last"") should return the last form object, not if that particular form is that last related
  to its siblings? Same issue with :first?
- $(""p"").filter(""#ap, #sndp""): filter does not work.
- dojo.NodeList uses d.NodeList a few places in the code. Would be nice to use a ctor that can be configured.
  That would make the filter function operate better.
- filterQueryResult, cannot handle queries like ""p, div""? See andSelf test with parents().
- adjacent ""p + p"" not supported?
= a:only-child not supported?
- nth(1)
- even/odd
- eq/gt/lt
- #form :radio:checked does not run the first :radio psuedo selector? Seems to be a general issue where only the last pseud
  is run. For example, ""#form :checked:radio"" does only the radio pseudo.
*/

(function(){
	//Enable io topic publishing.   But don't mask the original definition of ioPublish from the doc parser.
	/*===== var ioPublish = dojo.config.ioPublish; =====*/
	dojo.config.ioPublish = true;
	/*===== dojo.config.ioPublish = ioPublish; =====*/

	//Support stuff for toDom
	var selfClosedTags = ""|img|meta|hr|br|input|"";

	function toDom(/*String*/html, /*Document?*/doc){
		//summary converts HTML string into DOM nodes.
		//Make sure html is a string.
		html += """";

		//Convert <tag/> into <tag></tag>
		html = html.replace(/<\s*(\w+)([^\/\>]*)\/\s*>/g, function(tag, name, contents){
			if(selfClosedTags.indexOf(""|"" + name + ""|"") == -1){
				return ""<"" + name + contents + ""></"" + name + "">"";
			}else{
				return tag;
			}
		});

		return dojo._toDom(html, doc);
	}

	function cssNameToJs(name){
		var index = name.indexOf(""-"");
		if(index != -1){
			//Strip off beginning dash
			if(index == 0){
				name = name.substring(1);
			}
			name = name.replace(/-(\w)/g, function(match, match1){
				return match1.toUpperCase();
			});
		}
		return name;
	}

	var _old$ = dojo.global.$;
	var _oldJQuery = dojo.global.jQuery;

	var $ = dojo.global.$ = dojo.global.jQuery = function(){
		var arg = arguments[0];
		if(!arg){
			return $._wrap([], null, $);
		}else if(dojo.isString(arg)){
			if(arg.charAt(0) == ""<""){
				//String of html that needs nodes created.
				arg = toDom(arg);
				//If a DocumentFragment, convert to use its children
				//since we want to treat all top level nodes as elements
				//in the NodeList array.
				if(arg.nodeType == 11){
					arg = arg.childNodes;
				}else{
					return $._wrap([arg], null, $);
				}
				//Use end case of nodelist to finish work.
			}else{
				//Normal dojo.query selector.
				//Switch out query's NodeList constructor to be our specialized
				//NodeList constructor.
				var listCtor = dojo._NodeListCtor;
				dojo._NodeListCtor = $;

				//If the second arg is one of our fake NodeLists then
				//use the first parent for the call.
				var arg2 = arguments[1];
				if(arg2 && arg2._is$){
					arg2 = arg2[0];
				}else if(dojo.isString(arg2)){
					arg2 = dojo.query(arg2)[0];
				}

				var nl = dojo.query.call(this, arg, arg2);
				dojo._NodeListCtor = listCtor;
				return nl;
			}
		}else if(dojo.isFunction(arg)){
			//The addOnLoad case
			$.ready(arg);
			return $;
		}else if(arg == document || arg == window){
			//If the arg is the document or window,
			//then just use it directly.
			return $._wrap([arg], null, $);
		}else if(dojo.isArray(arg)){
			//Input is a plain array.
			//Filter out duplicates.
			var ary = [];
			for(var i = 0; i < arg.length; i++){
				if(dojo.indexOf(ary, arg[i]) == -1){
					ary.push(arg[i]);
				}
			}
			return $._wrap(arg, null, $);
		}else if(""nodeType"" in arg){
			//A DOM Node
			return $._wrap([arg], null, $);
		}

		//A native NodeList that does not conform to dojo.isArray().
		//Convert it to a workable array and create new NodeList.
		return $._wrap(dojo._toArray(arg), null, $);

	};

	//Set up plugin extension point.
	var nlProto = dojo.NodeList.prototype;

	//Need a delegate, because at least one method conflicts with jquery
	//API: attr(name) in jQuery only returns a single, first value, where
	//dojo.attr will return an array.
	var f = $.fn = $.prototype = dojo.delegate(nlProto);

	//_wrap is required for proper use in dojo.query, but the _adaptAs* methods
	//do not have to placed on $ -- they can be used directly off dojo.NodeList.
	$._wrap = dojo.NodeList._wrap;

	//Add in some pseudos selectors
	var headerRegExp = /^H\d/i;
	var pseudos = dojo.query.pseudos;
	dojo.mixin(pseudos, {
		has: function(name, condition){
			return function(elem){
				return $(condition, elem).length;
			}
		},
		visible: function(name, condition){
			return function(elem){
				return dojo.style(elem, ""visible"") != ""hidden"" && dojo.style(elem, ""display"") != ""none"";
			}
		},
		hidden: function(name, condition){
			return function(elem){
				return elem.type == ""hidden"" || dojo.style(elem, ""visible"") == ""hidden"" || dojo.style(elem, ""display"") == ""none"";
			}
		},
		selected: function(name, condition){
			return function(elem){
				return elem.selected;
			}
		},
		checked: function(name, condition){
			return function(elem){
				return elem.nodeName.toUpperCase() == ""INPUT"" && elem.checked;
			}
		},
		disabled: function(name, condition){
			return function(elem){
				return elem.getAttribute(""disabled"");
			}
		},
		enabled: function(name, condition){
			return function(elem){
				return !elem.getAttribute(""disabled"");
			}
		},
		input: function(name, condition){
			return function(elem){
				var n = elem.nodeName.toUpperCase();
				return n == ""INPUT"" || n == ""SELECT"" || n == ""TEXTAREA"" || n == ""BUTTON"";
			}
		},
		button: function(name, condition){
			return function(elem){
				return (elem.nodeName.toUpperCase() == ""INPUT"" && elem.type == ""button"") || elem.nodeName.toUpperCase() == ""BUTTON"";
			}
		},
		header: function(name, condition){
			return function(elem){
				return elem.nodeName.match(headerRegExp);
			}
		}
		//TODO: implement :animated
	});


	//Add the input type selectors to pseudos
	var inputPseudos = {};
	dojo.forEach([
		""text"", ""password"", ""radio"", ""checkbox"", ""submit"", ""image"", ""reset"", ""file""
	], function(type) {
		inputPseudos[type] = function(name, condition){
			return function(elem){
				return elem.nodeName.toUpperCase() == ""INPUT"" && elem.type == type;
			}
		};
	});
	dojo.mixin(pseudos, inputPseudos);

	//Set up browser sniff.
	$.browser = {
		mozilla: dojo.isMoz,
		msie: dojo.isIE,
		opera: dojo.isOpera,
		safari: dojo.isSafari
	};
	$.browser.version = dojo.isIE || dojo.isMoz || dojo.isOpera || dojo.isSafari || dojo.isWebKit;
	
	//Map back into dojo
	//Hmm maybe this is not so good. Dojo
	//modules may still be holding on to old
	//dojo (example: the d._NodeListCtor in query.js)
	//dojo = dojo.mixin($, dojo);

	// Add $.ready
	$.ready = $.fn.ready = function(callback){
		dojo.addOnLoad(dojo.hitch(null, callback, $));
		return this;
	}

	//START jquery Core API methods
	//http://docs.jquery.com/Core
	f._is$ = true;
	f.size = function(){return this.length; };

	$.prop = function(node, propCheck){
		//TODO: not sure about this one, could not find the docs?
		if(dojo.isFunction(propCheck)){
			return propCheck.call(node);
		}else{
			return propCheck;
		}
	}

	$.className = {
		add: dojo.addClass,
		remove: dojo.removeClass,
		has: dojo.hasClass
	};

	$.makeArray = function(thing){
		if(typeof thing == ""undefined""){
			return [];
		}else if(thing.length && !dojo.isString(thing) && !(""location"" in thing)){
			//Location check was for excluding window objects that have a length.
			return dojo._toArray(thing);
		}else{
			return [thing];
		}
	}
	
	$.merge = function(ary1, ary2){
		//Alters first array by adding in the element.
		var args = [ary1.length, 0];
		args = args.concat(ary2);
		ary1.splice.apply(ary1, args);
		return ary1;
	}

	$.each = function(/*Array||ArrayLike*/list, /*Function*/cb){
		//each differs from dojo.NodeList.forEach in that
		//""this"" is the current cycled node. Breaking
		//the loop is also possible. Also, index is first arg
		//to the callback.
		if(dojo.isArrayLike(list)){
			for(var i = 0; i < list.length; i++){
				if(cb.call(list[i], i, list[i]) === false){
					break;
				}
			}
		}else if(dojo.isObject(list)){
			for(var param in list){
				if(cb.call(list[param], param, list[param]) === false){
					break;
				}
			}
		}
		return this;
	};
	f.each = function(/*Function*/cb){
		return $.each.call(this, this, cb);
	};
	//f.length already implemented by NodeList
	f.eq = function(){
		//Direct copy of dojo.NodeList.at, but want
		//to use our NodeList class.
		var nl = $();
		dojo.forEach(arguments, function(i) { if(this[i]) { nl.push(this[i]); } }, this);
		return nl; // dojo.NodeList
	};
	f.get = function(/*Number*/index){
		if(index || index == 0){
			return this[index];
		}
		return this;
	};
	f.index = function(arg){
		//Hmm, allows passing in a $ nodelist. Apparently in that
		//case take the first item in that array and match
		if(arg._is$){
			arg = arg[0];
		}
		return this.indexOf(arg);
	}

	//.data implementation
	var dataStore = [];
	var dataId = 0;
	var dataAttr = dojo._scopeName + ""DataId"";
	
	var getDataId = function(node){
		var id = node.getAttribute(dataAttr);
		if(!id){
			id = dataId++;
			node.setAttribute(dataAttr, id);
		}
	}
	
	var getData = function(node){
		var data = {};
		if(node.nodeType == 1){
			var id = getDataId(node);
			data = dataStore[id];
			if(!data){
				data = dataStore[id] = {};
			}
		}
		return data;
	}

	$.data = function(/*DOMNode*/node, /*String*/name, /*String*/value){
		var result = null;
		if(name == ""events""){
			//Special case ""events"", since jquery tests seem to use it to
			//get the event handler storage for jquery. So for jquery apps
			//""events"" is probably a reserved word anyway.
			result = listeners[node.getAttribute(eventAttr)];
			var isEmpty = true;
			if(result){
				for(var param in result){
					isEmpty = false;
					break;
				}
			}
			return isEmpty ? null : result;
		}

		var data = getData(node);
		if(typeof value != ""undefined""){
			data[name] = value;
		}else{
			result = data[name];
		}
		return value ? this : result;
	}

	$.removeData = function(/*DOMNode*/node, /*String*/name){
		var data = getData(node);
		delete data[name];
		if(node.nodeType == 1){
			var isEmpty = true;
			for(var param in data){
				isEmpty = false;
				break;
			}
			if(isEmpty){
				node.removeAttribute(dataAttr);
			}
		}
		return this;
	}

	f.data = function(/*String*/name, /*String*/value){
		var result = null;
		this.forEach(function(node){
			result = $.data(node, name, value);
		});

		return value ? this : result;
	}

	f.removeData = function(/*String*/name){
		this.forEach(function(node){
			$.removeData(node, name);
		});
		return this;
	}
	
	function jqMix(obj, props){
		// summary:
		//		an attempt at a mixin that follows
		//		jquery's .extend rules. Seems odd. Not sure how
		//		to resolve this with dojo.mixin and what the use
		//		cases are for the jquery version.
		//		Copying some code from dojo._mixin.
		if(obj == props){
			return obj;
		}
		var tobj = {};
		for(var x in props){
			// the ""tobj"" condition avoid copying properties in ""props""
			// inherited from Object.prototype.  For example, if obj has a custom
			// toString() method, don't overwrite it with the toString() method
			// that props inherited from Object.prototype
			if(x !== '__proto__ ' && ((tobj[x] === undefined || tobj[x] != props[x])) && props[x] !== undefined && obj != props[x]){
				if(dojo.isObject(obj[x]) && dojo.isObject(props[x])){
					if(dojo.isArray(props[x])){
						obj[x] = props[x];
					}else{
						obj[x] = jqMix(obj[x], props[x]);
					}
				}else{
					obj[x] = props[x];
				}
			}
		}
		// IE doesn't recognize custom toStrings in for..in
		if(dojo.isIE && props){
			var p = props.toString;
			if(typeof p == ""function"" && p != obj.toString && p != tobj.toString &&
				p != ""\nfunction toString() {\n    [native code]\n}\n""){
					obj.toString = props.toString;
			}
		}
		return obj; // Object
	}

	f.extend = function(){
		var args = [this];
		args = args.concat(arguments);
		return $.extend.apply($, args);
	}

	$.extend = function(){
		//Could have multiple args to mix in. Similar to dojo.mixin,
		//but has some different rules, and the mixins all get applied
		//to the first arg.
		var args = arguments, finalObj;
		for(var i = 0; i < args.length; i++){
			var obj = args[i];
			if(obj && dojo.isObject(obj)){
				if(!finalObj){
					finalObj = obj;
				}else{
					jqMix(finalObj, obj);
				}
			}
		}
		return finalObj;
	}

	$.noConflict = function(/*Boolean*/extreme){
		var me = $;
		dojo.global.$ = _old$;
		if(extreme){
			dojo.global.jQuery = _oldJQuery;
		}
		return me;
	}
	//END jquery Core API methods
	
	//START jquery Attribute API methods
	//http://docs.jquery.com/Attributes
	f.attr = function(name, value){
		//The isObject tests below are to weed out where something
		//like a form node has an input called ""action"" but we really
		//want to get the attribute ""action"". But in general, favor
		//a property value over a DOM attribute value.
		if(arguments.length == 1 && dojo.isString(arguments[0])){
			//The get case, return first match.
			var first = this[0];
			
			//Weed out empty nodes
			if(!first){
				return null;
			}

			var arg = arguments[0];
			//favor properties over attributes.
			var attr = dojo.attr(first, arg);
			var prop = first[arg];
			if((arg in first) && !dojo.isObject(prop) && name != ""href""){
				return prop;
			}else{
				return attr || prop;
			}
		}else if(dojo.isObject(name)){
			//A setter, using an object.
			for(var param in name){
				this.attr(param, name[param]);
			}
			return this;
		}else{
			//The setter case. Figure out if value is a function.
			var isFunc = dojo.isFunction(value);
			this.forEach(function(node, index){
				var prop = node[name];
				if((name in node) && !dojo.isObject(prop) && name != ""href""){
					node[name] = (isFunc ? value.call(node, index) : value);
				}else if(node.nodeType == 1){
					dojo.attr(node, name, (isFunc ? value.call(node, index) : value));
				}
			});
			return this;
		}
	}

	f.removeAttr = function(name){
		this.forEach(function(node, index){
			var prop = node[name];
			if((name in node) && !dojo.isObject(prop) && name != ""href""){
				delete node[name];
			}else if(node.nodeType == 1){
				if(name == ""class""){
					//TODO: push this fix into dojo.removeAttr
					node.removeAttribute(name);
				}else{
					dojo.removeAttr(node, name);
				}
			}
		});
		return this;
	}

	//addClass, removeClass exist in dojo.NodeList. toggleClass in jQuery case
	//just means add/remove the classname if it missing/exists. So need custom override.
	f.toggleClass = function(/*String*/name, /*Expression?*/condition){
		var hasCondition = arguments.length > 1;
		this.forEach(function(node){
			dojo.toggleClass(node, name,  hasCondition ? condition : !dojo.hasClass(node, name));
		});
		return this;
	}

	//Action depends on arguments: if an array of functions do one thing,
	//If no args, do a display toggle,
	//If an expression, something that evaluates to true or false,
	//then toggle display accordingly.
	//If first arg is a String/Number, then do animation. Second arg
	//is an optional callback.
	f.toggle = function(){
		//If more than two args and we have a function as first arg, then
		//probably the onclick toggle variant: takes variable args that are
		//functions and cycles through them on click actions.
		var args = arguments;
		if(arguments.length > 1 && dojo.isFunction(arguments[0])){
			var index = 0;
			var func = function(){
				var result = args[index].apply(this, arguments);
				index += 1;
				if(index > args.length - 1){
					index = 0;
				}
			};
			return this.bind(""click"", func);
		}else{
			//The display/hide/show case.
			var condition = arguments.length == 1 ? arguments[0] : undefined;
			this.forEach(function(node){
				var result = typeof condition == ""undefined"" ? dojo.style(node, ""display"") == ""none"" : condition;
				var action = (result ? ""show"" : ""hide"");
				var nl = $(node);
				nl[action].apply(nl, args);
			});
			return this;
		}
	}

	//hasClass just returns true if any of the nodes has the class.
	f.hasClass = function(/*String*/name){
		return this.some(function(node){
			return dojo.hasClass(node, name);
		});
	}

	//use the html method from dojo.NodeList-manipulate.
	f.html = f.innerHTML;

	//END jquery Attribute API methods

	
	//START jquery Traversing API methods
	//http://docs.jquery.com/Traversing
	dojo.forEach([""filter"", ""slice""], function(item){
		f[item] = function(){
			//Convert the ""this"" value for functions passed in:
			var nl;
			if(dojo.isFunction(arguments[0])){
				var origFunc = arguments[0];
				arguments[0] = function(item, index){
					return origFunc.call(item, item, index);
				}
			}
			
			if(item == ""filter"" && dojo.isString(arguments[0])){
				var nl = this._filterQueryResult(this, arguments[0]);
			}else{
				var oldCtor = dojo._NodeListCtor;
				dojo._NodeListCtor = f;
				//Need to wrap in a $() call since internally some
				//dojo.NodeList functions reference dojo.NodeList directly.
				//Need to get a configurable constructor for dojo.NodeList.
				nl = $(nlProto[item].apply(this, arguments));
				dojo._NodeListCtor = oldCtor;
			}

			return nl._stash(this);
		}
	});

	f.map = function(/*Function*/callback){
		//Hmm, this is not like array map/dojo.map where you get one item back for
		//each input.
		return this._buildArrayFromCallback(callback);
	}
	$.map = function(/*Array*/ary, /*Function*/callback){
		//Hmm, this is not like array map/dojo.map where you get one item back for
		//each input.
		return f._buildArrayFromCallback.call(ary, callback);
	}

	$.inArray = function(value, /*Array*/ary){
		return dojo.indexOf(ary, value);
	}

	f.is = function(query){
		return (query ? !!this.filter(query).length : false);
	}

	//TODO: probably a better way to do this.
	f.not = function(){
		var notList = $.apply($, arguments);
		//TODO: another place where if dojo.NodeList can configure a constructor,
		//then we could avoid the $() wrapper below.
		var nl = $(nlProto.filter.call(this, function(node){
			return notList.indexOf(node) == -1;
		}));
		return nl._stash(this);
	}

	f.add = function(){
		return this.concat.apply(this, arguments);
	}

	function iframeDoc(/*DOMNode*/iframeNode){
		// summary:
		//		Returns the document object associated with the iframe DOM Node argument.

		//Taken from dojo.io.iframe.doc(). Needed for contents() function below.

		var doc = iframeNode.contentDocument || // W3
			(
				(
					(iframeNode.name) && (iframeNode.document) &&
					(document.getElementsByTagName(""iframe"")[iframeNode.name].contentWindow) &&
					(document.getElementsByTagName(""iframe"")[iframeNode.name].contentWindow.document)
				)
			) ||  // IE
			(
				(iframeNode.name)&&(document.frames[iframeNode.name])&&
				(document.frames[iframeNode.name].document)
			) || null;
		return doc;
	}

	f.contents = function(){
		var ary = [];
		this.forEach(function(node){
			if(node.nodeName.toUpperCase() == ""IFRAME""){
				var doc = iframeDoc(node);
				if(doc){
					ary.push(doc);
				}
			}else{
				//TODO: code similar to children() function. Refactor?
				var children = node.childNodes;
				//Using for loop for better speed.
				for(var i = 0; i < children.length; i++){
					ary.push(children[i]);
				}
			}
		});
		return this._wrap(ary)._stash(this);
	}

	f.find = function(/*String*/query){
		var ary = [];
		this.forEach(function(node){
			if(node.nodeType == 1){
				ary = ary.concat(dojo._toArray($(query, node)));
			}
		});
		return this._getUniqueAsNodeList(ary)._stash(this);
	}

	f.andSelf = function(){
		return this.add(this._parent);
	}

	//END jquery Traversing API methods

	//START jquery Manipulation API methods
	//http://docs.jquery.com/Manipulation

	f.remove = function(/*String?*/query){
		//Override NodeList-manipulate's remove so we can remove data.
		var nl = (query ? this._filterQueryResult(this, query) : this);
		
		//Remove data
		nl.removeData();
		
		//Remove event listeners.
		//TODO! do this, once event stuff is built out.
		
		//Remove the items from the DOM, but keep them in this
		//node list.
		nl.forEach(function(node){
			node.parentNode.removeChild(node);
		});
		
		return this;
	}

	//START jquery CSS API methods
	//http://docs.jquery.com/CSS
	$.css = function(/*DOMNode*/node, /*String|Object*/name, /*String|Number?*/value){
		name = cssNameToJs(name);
		
		//Hmm, dojo.style does an arguments. length check.
		var result = (value ? dojo.style(node, name, value) : dojo.style(node, name));
		return result;
	}

	f.css = function(/*String|Object*/name, /*String|Number?*/value){
		if(dojo.isString(name)){
			//Convert name to JS name if needed.
			name = cssNameToJs(name);
			if(arguments.length == 2){
				//set the value. Cannot directly delegate to
				//this.style, since non-element nodes may be in the mix?
				//this.contents() in particular will return some funky stuff.
				
				//Need to be sure to add ""px"" if appropriate.
				if(!dojo.isString(value) && name != ""zIndex""){
					value = value + ""px"";
				}

				this.forEach(function(node){
					if(node.nodeType == 1){
						dojo.style(node, name, value);
					}
				});
				return this;
			}else{
				//return the value
				value = dojo.style(this[0], name);
				//Need to be sure to add ""px"" if appropriate.
				if(!dojo.isString(value) && name != ""zIndex""){
					value = value + ""px"";
				}
				return value;
			}
		}else{
			for(var param in name){
				this.css(param, name[param]);
			}
			return this;
		}
	}
	
	function doBox(/*NodeList*/nl, /*String*/boxType, /*String*/prop, /*String||Number*/value){;
		if(value){
			//Set height for all elements.
			var mod = {};
			mod[prop] = value;
			nl.forEach(function(node){
				dojo[boxType](node, mod);
			});
			return nl;
		}else{
			//Just get first node's height.
			//Hmm. width is negative when element is display none in FF3?
			return Math.abs(Math.round(dojo[boxType](nl[0])[prop]));
		}
	}

	f.height = function(value){
		return doBox(this, ""contentBox"", ""h"", value);
	}

	f.width = function(value){
		return doBox(this, ""contentBox"", ""w"", value);
	}

	function getDimensions(/*DOMNode*/node, /*String*/type, /*Boolean*/usePadding, /*Boolean*/useBorder, /*Boolean*/useMargin){
		// summary:
		//		sums up the different parts of the width/height based on arguments.

		//If hidden, temporarily show it, do measurements then close.
		var rehide = false;
		if((rehide = node.style.display == ""none"")){
			node.style.display = ""block"";
		}

		var cs = dojo.getComputedStyle(node);
		var content = Math.abs(Math.round(dojo._getContentBox(node, cs)[type]));
		var pad = usePadding ? Math.abs(Math.round(dojo._getPadExtents(node, cs)[type])) : 0;
		var border = useBorder ? Math.abs(Math.round(dojo._getBorderExtents(node, cs)[type])) : 0;
		var margin = useMargin ? Math.abs(Math.round(dojo._getMarginExtents(node, cs)[type])) : 0;
		
		if(rehide){
			node.style.display = ""none"";
		}

		return pad + content + border + margin;
	}

	f.innerHeight = function(){
		return getDimensions(this[0], ""h"", true);
	}

	f.innerWidth = function(){
		return getDimensions(this[0], ""w"", true);
	}

	f.outerHeight = function(useMargin){
		return getDimensions(this[0], ""h"", true, true, useMargin);
	}

	f.outerWidth = function(useMargin){
		return getDimensions(this[0], ""w"", true, true, useMargin);
	}

	//END jquery CSS API methods


	//START jquery Events API methods
	//http://docs.jquery.com/Events
	
	//ready() already defined above.

	//Event plumbing.
	var listeners = [];
	var listenId = 1;
	var eventAttr = dojo._scopeName + ""eventid"";
	var currentEvtData;

	function getNonNamespacedName(/*String*/evtName){
		// summary:
		//		gets name of the event before the first ""."".

		//The $$ stuff is special ids used to create unique names
		//for bound functions that did not have a unique namespace name.
		evtName = evtName.split(""$$"")[0];
		var dotIndex = evtName.indexOf(""."");
		if(dotIndex != -1){
			evtName = evtName.substring(0, dotIndex);
		}
		return evtName;
	}

	function domConnect(/*DOMNode*/node, /*String*/evtName){
		// summary:
		//		handles creating the connection with a real DOM event.

		//This work should only be done one time per evName type.
		//If the event if an ajax event, use dojo.subscribe instead.
		if(evtName.indexOf(""ajax"") == 0){
			return dojo.subscribe(topics[evtName], function(dfd, res){
				var fakeEvt = new $.Event(evtName);
				if(""ajaxComplete|ajaxSend|ajaxSuccess"".indexOf(evtName) != -1){
					triggerHandlers(node, [fakeEvt, dfd.ioArgs.xhr, dfd.ioArgs.args]);
				}else if(evtName == ""ajaxError""){
					triggerHandlers(node, [fakeEvt, dfd.ioArgs.xhr, dfd.ioArgs.args, res]);
				}else{
					//ajaxStart|ajaxStop
					triggerHandlers(node, [fakeEvt]);
				}
			});
		}else{
			return dojo.connect(node, ""on"" + evtName, function(e){
				triggerHandlers(node, arguments);
			}); //Object
		}
	}

	//Event object for compatibility for some tests.
	$.Event = function(/*String*/type){
		//Allow for calling function without ""new""
		if(this == $){
			return new $.Event(type);
		}
		if(typeof type == ""string""){
			this.type = type.replace(/!/, """");
		}else{
			dojo.mixin(this, type);
		}
		this.timeStamp = (new Date()).getTime();
		this._isFake = true;
		this._isStrict = (this.type.indexOf(""!"") != -1);
		
	}
	
	var ep = $.Event.prototype = {
		preventDefault: function(){
			this.isDefaultPrevented = this._true;
		},
		stopPropagation: function(){
			this.isPropagationStopped = this._true;
		},
		stopImmediatePropagation: function(){
			this.isPropagationStopped = this._true;
			this.isImmediatePropagationStopped = this._true;
		},
		_true: function(){ return true; },
		_false: function(){ return false; }
	}
	dojo.mixin(ep, {
		isPropagationStopped: ep._false,
		isImmediatePropagationStopped: ep._false,
		isDefaultPrevented: ep._false
	});

	function makeTriggerData(data, type){
		// summary:
		//		makes sure that the data array is copied
		//		and has an event as the first arg. If this function generates
		//		a fake event (known by the data[0]._isFake property being true)
		//		then the data[0].target needs to be set by the consumer of this function.
		
		data = data || [];
		data = [].concat(data);

		//If first data item is not an event, make one up.
		//Need to set up target: prop in the consumers of this
		//function.
		var evt = data[0];
		if(!evt || !evt.preventDefault){
			evt = type && type.preventDefault ? type : new $.Event(type);
			data.unshift(evt);
		}
		return data;
	}
	
	var triggerHandlersCalled = false;

	function triggerHandlers(/*DOMNode*/node, /*Array*/data, /*Function?*/extraFunc){
		// summary:
		//		handles the actual callbacks to the handlers.
		
		//Indicate triggerHandlers was called.
		triggerHandlersCalled = true;
		
		//Uses currentEvtData if this is a simulated event.
		data = data || currentEvtData;
		extraFunc = extraFunc;

		//Normalize on a real element if dealing with a document.
		if(node.nodeType == 9){
			node = node.documentElement;
		}

		var nodeId = node.getAttribute(eventAttr);
		if(!nodeId){
			return;
		}

		var evt = data[0];
		var evtFullName = evt.type;
		var evtName = getNonNamespacedName(evtFullName);

		var cbs = listeners[nodeId][evtName];

		var result;
		//Apply the extra function. What is that about? Not mentioned in the
		//public APIs?
		if(extraFunc){
			result = extraFunc.apply(node, data);
		}

		if (result !== false){
			for(var param in cbs){
				if(param != ""_connectId"" && (!evt._isStrict && (param.indexOf(evtFullName) == 0) || (evt._isStrict && param == evtFullName))){
					//Store the callback ID in case unbind is called with this event
					//so we can only unbind that one callback.
					evt[dojo._scopeName + ""callbackId""] = param;

					var cb = cbs[param];
					if(typeof cb.data != ""undefined""){
						evt.data = cb.data;
					}else{
						evt.data = null;
					}
	
					//Do the actual callback.
					if ((result = cb.fn.apply(evt.target, data)) === false && !evt._isFake){
						dojo.stopEvent(evt);
					}
					evt.result = result;
				}
			}
		}

		return result;
	}

	f.triggerHandler = function(/*String*/type, /*Array?*/data, /*Function?*/extraFunc){
		//Only triggers handlers on the first node. Huh.
		var node = this[0];
		if(node && node.nodeType != 3 && node.nodeType != 8){
			data = makeTriggerData(data, type);
			return triggerHandlers(node, data, extraFunc);
		}else{
			return undefined;
		}
	}

	f.trigger = function(/*String*/type, /*Array?*/data, /*Function?*/extraFunc){
		//Copy data since we may need to modify by adding a
		data = makeTriggerData(data, type);
		var evt = data[0];
		var type = getNonNamespacedName(evt.type);
		
		//Store the current event data in case handlers need
		//to reference it because of a simulated event.
		currentEvtData = data;
		currentExtraFunc = extraFunc;

		var result = null;
		var needTarget = !evt.target;
		this.forEach(function(node){
			//Only handle non text/comment nodes.
			if(node.nodeType != 3 && node.nodeType != 8){

				//Normalize on a real element if dealing with a document.
				if(node.nodeType == 9){
					node = node.documentElement;
				}

				//Set the node target appropriately for fake events.
				if(evt._isFake){
					evt.currentTarget = node;
					if(needTarget){
						evt.target = node;
					}
				}

				//Bizarre extra function thing. Not really demonstrated in public
				//API docs.
				if(extraFunc){
					var funcData = data.slice(1);
					result = extraFunc.apply(node, (result = null ? funcData : funcData.concat(result)));
				}

				if(result !== false){
					//Trigger DOM event. onclick is handled differently than
					//others.
					/*
					if(type == 'click' && node.onclick && node.nodeName.toUpperCase() == ""A""){
						result = node.onclick.apply(node, data);
					}
					*/
					
					//Set the ""global"" flag that indicates if triggerHandlers was called.
					//If the direct node.event/onevent does not trigger the handlers, do so
					//manually at the end.
					triggerHandlersCalled = false;
					
					//Trigger functions registered directly on the DOM node.
					if(node[type]){
						try{
							result = node[type]();
						}catch(e){
							//Apparently IE throws on some hidden elements. Just eat it.
						}
					}else if(node[""on"" + type]){
						try{
							result = node[""on"" + type]();
						}catch(e){
							//Apparently IE throws on some hidden elements. Just eat it.
						}
					}
					
					if(!triggerHandlersCalled){
						//Finally triggerHandlers directly if the above code did not trigger it yet.
						result = triggerHandlers(node, data);
					}

					//Bubble the event up.
					//TODO: optimize this path so we don't have to do forEach and NodeList work.
					var parentNode = node.parentNode;
					if(result !== false && !evt.isImmediatePropagationStopped() && !evt.isPropagationStopped() && parentNode && parentNode.nodeType == 1){
						$(parentNode).trigger(type, data, extraFunc);
					}
				}
			}
		});

		//Clear current event data.
		currentEvtData = null;
		currentExtraFunc = null;

		return this;
	}

	var bindIdCounter = 0;

	f.bind = function(/*String*/type, /*Array||Function?*/data, /*Function*/fn){
		//Type can be space separated values.
		type = type.split("" "");
		
		//May not have data argument.
		if(!fn){
			fn = data;
			data = null;
		}

		this.forEach(function(node){
			//Only handle non text/comment nodes.
			if(node.nodeType != 3 && node.nodeType != 8){
			
				//If document, bind to documentElement
				if(node.nodeType == 9){
					node = node.documentElement;
				}

				//If no nodeId, then create one and attach it to the DOM node.
				var nodeId = node.getAttribute(eventAttr);
				if(!nodeId){
					nodeId = listenId++;
					node.setAttribute(eventAttr, nodeId);
					listeners[nodeId] = {};
				}
	
				//Process each event type.
				for(var i = 0; i < type.length; i++){
					//Get event name, if have a dot on it, it is namespaced,
					//be sure to get the core event name.
					var evtFullName = type[i];
					var evtName = getNonNamespacedName(evtFullName);
					if(evtName == evtFullName){
						//Generate a unique ID for this function binding
						evtFullName = evtName + ""$$"" + (bindIdCounter++);
					}
	
					//Get the event listeners for the event name, the complete name.
					var lls = listeners[nodeId];
					if(!lls[evtName]){
						lls[evtName] = {
							_connectId: domConnect(node, evtName)
						};
					}
	
					//Add the callback to the list of listeners.
					lls[evtName][evtFullName] = {
						fn: fn,
						data: data
					};
				}
			}
		});
		
		return this;
	}

	function copyEventHandlers(/*DOMNode*/ src, /*DOMNode*/ target){
		// summary:
		//		copies the event handlers from onne src *element* node to
		//		another target *element* node. Assumes that target had
		//		no previous events on it, and is a clone of the src node.

		//Get src listeners.
		var srcNodeId = target.getAttribute(eventAttr);
		var sls = listeners[srcNodeId];
		if(!sls){
			return;
		}

		//Generate listeners area for target.
		var nodeId = nodeId = listenId++;
		target.setAttribute(eventAttr, nodeId);
		var tls = listeners[nodeId] = {};

		//Loope through events in source. Protect against bad
		//code modifying Object.prototype.
		var empty = {};
		for (var evtName in sls){
			var tEvtData = tls[evtName] = {
				_connectId: domConnect(target, evtName)
			};
			var sEvtData = sls[evtName];

			for (var evtFullName in sEvtData){
				tEvtData[evtFullName] = {
					fn: sEvtData[evtFullName].fn,
					data: sEvtData[evtFullName].data
				};
			}
		}
	}

	function listenerUnbind(lls, evtName, evtFullName, callbackId, fn){
		//Handles the real remove of an event and dojo.disconnects DOM handler if necessary.
		//This has to be broken out of the main unbind function because we have to support
		//things like unbind("".test"") that go across major event names. Yuck.
		var handles = lls[evtName];
		if(handles){
			var hasDot = evtFullName.indexOf(""."") != -1;
			var forceDelete = false;

			if(callbackId){
				//Only need to unbind that one callback
				delete handles[callbackId];
			}else if(!hasDot && !fn){
				forceDelete = true;
			}else if(hasDot){
				//A namespaced event.
				//Problem is the namespaced event could be something like
				//"".test"" which means remove all that end in .test. Yuck.
				if(evtFullName.charAt(0) == "".""){
					for(var param in handles){
						if(param.indexOf(evtFullName) == param.length - evtFullName.length){
							delete handles[param];
						}
					}
				}else{
					delete handles[evtFullName];
				}
			}else{
				//Not a namespaced event. Cycle through the $$ names
				//to find a function match.
				for(var param in handles){
					if(param.indexOf(""$$"") != -1 && handles[param].fn == fn){
						delete handles[param];
						break;
					}
				}
			}

			//Remove handles/disconnect dom if no other params.
			var allDone = true;
			for(var param in handles){
				if(param != ""_connectId""){
					allDone = false;
					break;
				}
			}
			if(forceDelete || allDone){
				if(evtName.indexOf(""ajax"") != -1){
					dojo.unsubscribe(handles._connectId);
				}else{
					dojo.disconnect(handles._connectId);
				}
				delete lls[evtName];
			}
		}
	}

	f.unbind = function(/*String*/type, /*Function*/fn){
		
		//See if event has a callbackId, if so, then we only unbind
		//that one callback.
		var callbackId = type ? type[dojo._scopeName + ""callbackId""] : null;

		//Type can be space separated values.
		type = type && type.type ? type.type : type;
		type = type ? type.split("" "") : type;

		this.forEach(function(node){
			//Only handle non text/comment nodes.
			if(node.nodeType != 3 && node.nodeType != 8){
				//If document, bind to documentElement
				if(node.nodeType == 9){
					node = node.documentElement;
				}

				//If no nodeId, then create one and attach it to the DOM node.
				var nodeId = node.getAttribute(eventAttr);
				
				if(nodeId){
					//Get the event listeners for the event name, the complete name.
					var lls = listeners[nodeId];
					if(lls){
						//If no type, then it means do all bound types. Make a list of them.
						var etypes = type;
						if(!etypes){
							etypes = [];
							for(var param in lls){
								etypes.push(param);
							}
						}

						//Process each event type.
						for(var i = 0; i < etypes.length; i++){
							//Get event name, if have a dot on it, it is namespaced,
							//be sure to get the core event name.
							var evtFullName = etypes[i];
							var evtName = getNonNamespacedName(evtFullName);
			
							//Problem is the namespaced event could be something like
							//"".test"" which means remove all that end in .test. Yuck.
							if(evtFullName.charAt(0) == "".""){
								for(var param in lls) {
									listenerUnbind(lls, param, evtFullName, callbackId, fn);
								}
							}else{
								listenerUnbind(lls, evtName, evtFullName, callbackId, fn);
							}
						}
					}
				}
			}
		});

		return this;
	}

	f.one = function(/*String*/evtName, /*Function*/func){
		var oneFunc = function(){
			$(this).unbind(evtName, arguments.callee);
			return func.apply(this, arguments);
		}

		return this.bind(evtName, oneFunc);
	};

	f._cloneNode = function(/*DOMNode*/ src){
		// summary:
		//		private utiltity to clone a node. Copies event handlers too.
		var target = src.cloneNode(true);

		if(src.nodeType == 1){
			//Look for event handlers in target.
			var evNodes = dojo.query(""["" + eventAttr + ""]"", target);
			for(var i = 0, newNode; newNode = evNodes[i]; i++){
				var oldNode = dojo.query('[' + eventAttr + '=""' + newNode.getAttribute(eventAttr) + '""]', src)[0];
				if(oldNode){
					copyEventHandlers(oldNode, newNode);
				}
			}
		}
		return target;
	};

	//Temporary testing shim to get past jquery test setup errors.
	dojo.getObject(""$.event.global"", true);

	//Set up event handlers
	dojo.forEach([
		""blur"", ""focus"", ""dblclick"", ""click"", ""error"", ""keydown"", ""keypress"", ""keyup"", ""load"", ""mousedown"",
		""mouseenter"", ""mouseleave"", ""mousemove"", ""mouseout"", ""mouseover"", ""mouseup"", ""submit"",
		""ajaxStart"", ""ajaxSend"", ""ajaxSuccess"", ""ajaxError"", ""ajaxComplete"", ""ajaxStop""
		], function(evt){
			f[evt] = function(callback){
				if(callback){
					this.bind(evt, callback);
				}else{
					this.trigger(evt);
				}
				return this;
			}
		}
	);

	//END jquery Events API methods


	//START jquery Effects API methods
	//http://docs.jquery.com/Effects
	function speedInt(speed){
		//Fix speed setting, translate string values to numbers.
		if(dojo.isString(speed)){
			if(speed == ""slow""){
				speed = 700;
			}else if(speed == ""fast""){
				speed = 300;
			}else{
				//Everything else is considered normal speed.
				speed = 500;
			}
		}
		return speed;
	}
	
	f.hide = function(/*String||Number*/speed, /*Function?*/callback){
		//Fix speed setting, translate string values to numbers.
		speed = speedInt(speed);

		this.forEach(function(node){
			var style = node.style;
			
			//Skip if already hidden
			var cs = dojo.getComputedStyle(node);
			if(cs.display == ""none""){
				return;
			}

			style.overflow = ""hidden"";
			style.display = ""block"";
			
			if(speed){
				//It is alive!
				dojo.anim(
					node,
					{
						width: 0,
						height: 0,
						opacity: 0
					},
					speed,
					null,
					function(){
						style.width = """";
						style.height = """";
						style.display = ""none"";
						return callback && callback.call(node);
					}
				);
			}else{
				//No need for animation, fast path it.
				dojo.style(node, ""display"", ""none"");
				if(callback){
					callback.call(node);
				}
			}
		});
		return this;
	}

	f.show = function(/*String||Number*/speed, /*Function?*/callback){
		//Fix speed setting, translate string values to numbers.
		speed = speedInt(speed);

		this.forEach(function(node){
			var style = node.style;
			//Skip if the node is already showing.
			var cs = dojo.getComputedStyle(node);
			if(cs.display != ""none""){
				return;
			}

			if(speed){
				//Figure out size of element
				//so we know when to stop animation.
				//Try the easy path first.
				var width = parseFloat(style.width);
				var height = parseFloat(style.height);
				if(!width || !height){
					//temporarily show the element to get
					//dimensions
					style.display = ""block"";
					var box = dojo.marginBox(node);
					width = box.w;
					height = box.h;
				}

				//Make sure values are set to hidden state.
				style.width = 0;
				style.height = 0;
				style.overflow = ""hidden"";
				dojo.attr(node, ""opacity"", 0);
				style.display = ""block"";

				//It is alive!
				dojo.anim(
					node,
					{
						width: width,
						height: height,
						opacity: 1
					},
					speed,
					null,
					callback ? dojo.hitch(node, callback) : undefined
				);
			}else{
				dojo.style(node, ""display"", ""block"");
				if(callback){
					callback.call(node);
				}
			}
		});
		return this;
	}


	//END jquery Effects API methods


	//START jquery Ajax API methods
	//http://docs.jquery.com/Ajax
	
	$.ajaxSettings = {
	};

	$.ajaxSetup = function(/*Object*/args){
		dojo.mixin($.ajaxSettings, args);
	}

	var topics = {
		""ajaxStart"": ""/dojo/io/start"",
		""ajaxSend"": ""/dojo/io/send"",
		""ajaxSuccess"": ""/dojo/io/load"",
		""ajaxError"": ""/dojo/io/error"",
		""ajaxComplete"": ""/dojo/io/done"",
		""ajaxStop"": ""/dojo/io/stop""
	};

	for(var fnName in topics){
		//Make sure we are dealing with properties
		//we care about and not something another toolkit added.
		if(fnName.indexOf(""ajax"") == 0){
			;(function(fnName){
				f[fnName] = function(callback){
					this.forEach(function(node){
						dojo.subscribe(topics[fnName], function(){
							var fakeEvt = new $.Event(fnName);
							var ioArgs = arguments[0] && arguments[0].ioArgs;
							var xhr = ioArgs && ioArgs.xhr;
							var args = ioArgs && ioArgs.args;
							var res = arguments[1];
							if(""ajaxComplete|ajaxSend|ajaxSuccess"".indexOf(fnName) != -1){
								return callback.call(node, fakeEvt, xhr, args);
							}else if(fnName == ""ajaxError""){
								return callback.call(node, fakeEvt, xhr, args, res);
							}else{
								//ajaxStart|ajaxStop
								return callback.call(node, fakeEvt);
							}
						});
					});
					return this;
				}
			})(fnName);
		}
	};

	//Override dojo._xhrObj(dfd.ioArgs.args) to support beforeSend
	//Do not understand the reason for beforeSend, particularly
	//returning false stops the request.
	//WARNING: even with this code, the error and complete callbacks
	//will be fired because the deferred is cancelled. I feel this is
	//correct behavior for dojo, and not sure why beforeSend is needed.
	var _oldXhrObj = dojo._xhrObj;
	dojo._xhrObj = function(args){
		var xhr = _oldXhrObj.apply(dojo, arguments);
		if(args && args.beforeSend){
			if(args.beforeSend(xhr) === false){
				return false;
			}
		}
		return xhr;
	}

	$.ajax = function(/*Object*/args){
		//Not sure if the args are considered mutable.
		//Copy them to be safe.
		var temp = dojo.delegate($.ajaxSettings);
		for(var param in args){
			//For data objects merge the data do not overwrite.
			if(param == ""data"" && dojo.isObject(args[param]) && dojo.isObject(temp.data)){
				for(var prop in args[param]){
					temp.data[prop] = args[param][prop];
				}
			}else{
				temp[param] = args[param];
			}
		}
		args = temp;
		var url = args.url;

		if(""async"" in args){
			args.sync = !args.async;
		}

		//Turn off topic publications
		if(args.global === false){
			args.ioPublish = false;
		}

		if(args.data){
			var data = args.data;
			if(dojo.isString(data)){
				//convert to an object.
				args.content = dojo.queryToObject(data);
			}else{
				//data property values could be a function, be sure to call them if so.
				//Hmm, this seems to be of dubious value.
				for(var param in data){
					if(dojo.isFunction(data[param])){
						data[param] = data[param]();
					}
				}
				args.content = data;
			}
		}

		//dataType
		var dataType = args.dataType;
		if(""dataType"" in args){
			if(dataType == ""script""){
				dataType = ""javascript"";
			}else if(dataType == ""html""){
				dataType = ""text"";
			}
			args.handleAs = dataType;
		}else{
			//Make a guess based on the URL.
			dataType = args.handleAs = ""text"";
			args.guessedType = true;
		}

		//cache:
		if(""cache"" in args){
			args.preventCache = !args.cache;
		}else{
			if(args.dataType == ""script"" || args.dataType == ""jsonp""){
				args.preventCache = true;
			}
		}

		//Hide error since dojo treats it different.
		if(args.error){
			args._jqueryError = args.error;
			delete args.error;
		}
		
		//TODO: dataFilter

		//Set up callbacks.
		args.handle = function(result, ioArgs){
			var textStatus = ""success"";
			if(result instanceof Error){
				textStatus = (result.dojoType == ""timeout"" ? ""timeout"" : ""error"");
				if(args._jqueryError){
					args._jqueryError(ioArgs.xhr, textStatus, result);
				}
			}else{
				//If we guessed the type, see if it should be XML.
				var xml = (ioArgs.args.guessedType && ioArgs.xhr && ioArgs.xhr.responseXML);
				if(xml){
					result = xml;
				}

				if(args.success){
					args.success(result, textStatus, ioArgs.xhr);
				}
			}
			if(args.complete){
				args.complete(result, textStatus, ioArgs.xhr);
			}
			
			return result;
		};
		
		//Use a script tag if the request is xdomain or a jsonp thing.
		var useScript = (dataType == ""jsonp"");
		if(dataType == ""javascript""){
			//Get protocol and domain.
			var colonIndex = url.indexOf("":"");
			var slashIndex = url.indexOf(""/"");
			if(colonIndex > 0 && colonIndex < slashIndex){
				//Possibly xdomain. Peel off protocol and hostname to find out.
				var lastSlash = url.indexOf(""/"", slashIndex + 2);
				if(lastSlash == -1){
					lastSlash = url.length;
				}
				if(location.protocol != url.substring(0, colonIndex + 1) ||
					location.hostname != url.substring(slashIndex + 2, lastSlash)){
					useScript = true;
				}
			}
		}

		if(useScript){
			if(dataType == ""jsonp""){
				//Look for callback param
				var cb = args.jsonp;
				if(!cb){
					//Look in the URL
					var params = args.url.split(""?"")[1];
					if(params && (params = dojo.queryToObject(params))){
						cb = findJsonpCallback(params);
						if(cb){
							//Remove the cb from the url.
							var regex = new RegExp(""([&\\?])?"" + cb + ""=?"");
							args.url = args.url.replace(regex + ""=?"");
						}
					}
					//Look in the content.
					if(!cb){
						cb = findJsonpCallback(args.content);
						if(cb){
							delete args.content[cb];
						}
					}
				}
				args.jsonp = cb || ""callback"";
			}
			var dfd = dojo.io.script.get(args);
			return dfd;
		}else{
			var dfd = dojo.xhr(args.type || ""GET"", args);
			//If the XHR object is false, it means beforeSend canceled the request.
			return dfd.ioArgs.xhr === false ? false : dfd.ioArgs.xhr;
		}
	}

	function findJsonpCallback(obj){
		for(var prop in obj){
			if(prop.indexOf(""callback"") == prop.length - 8){
				return prop;
			}
		}
		return null;
	}
	
	$.getpost = function(httpType, url, data, callback, dataType){
		var args = {
			url: url,
			type: httpType
		};

		//Normalize data, considering it may be the real
		//callback.
		if(data){
			if(dojo.isFunction(data) && !callback){
				args.complete = data;
			}else{
				args.data = data;
			}
		}

		//Normalize callback, considering it may be
		//the datatype.
		if(callback){
			if(dojo.isString(callback) && !dataType){
				dataType = callback;
			}else{
				args.complete = callback;
			}
		}

		if(dataType){
			args.dataType = dataType;
		}

		return $.ajax(args);
	};

	$.get = dojo.hitch($, ""getpost"", ""GET"");
	$.post = dojo.hitch($, ""getpost"", ""POST"");
	$.getJSON = function(url, data, callback){
		return $.getpost(""GET"", url, data, callback, ""json"");
	}
	$.getScript = function(url, callback){
		return $.ajax({
			url: url,
			success: callback,
			dataType: ""script""
		});
	}

	f.load = function(url, data, callback){
		
		//See if this is a window or document. If so, then want to
		//register onload handler.
		var node = this[0];
		if(!node || !node.nodeType || node.nodeType == 9){
			dojo.addOnLoad(url);
			return this;
		}

		//The rest of this function is the ajax HTML load case.
		//Pull off selector if it is on the url.
		var parts = url.split(/\s+/);
		url = parts[0];
		var query = parts[1];
		
		var finalCb = callback || data;

		var cb = dojo.hitch(this, function(result, textStatus, xhr){
			//Try to find all the body content.
			var match = result.match(/\<\s*body[^>]+>.*<\/body\s*>/i);
			if(match){
				result = match;
			}

			//Convert to DOM nodes.
			var nodes = dojo._toDom(result);

			//Apply query, using a temp div to do the filtering.
			if(query){
				var temp = $(dojo.create(""div""));
				temp.append(nodes);
				nodes = temp.find(query);
			}else{
				nodes = $(nodes.nodeType == 11 ? nodes.childNodes : nodes);
			}

			//Add the HTML to all nodes in this node list.
			this.html(nodes);

			//Call the user's callback.
			//Use a timeout to allow any embedded scripts that
			//were just inserted to run.
			if(finalCb){
				setTimeout(dojo.hitch(this, function(){
					this.forEach(function(node){
						finalCb.call(node, result, textStatus, xhr);
					});
				}), 10);
			}
		});

		//Adjust parameters since they are variable.
		if(!callback){
			data = cb;
		}else{
			callback = cb;
		}

		//Set HTTP method. If the data is a string, use get, if it is an object,
		//use post.
		var method = ""GET"";
		if(data && dojo.isObject(data)){
			method = ""POST"";
		}

		$.getpost(method, url, data, callback, ""html"");
		return this;
	}

	var serializeExclude = ""file|submit|image|reset|button|"";
	f.serialize = function(){
		var ret = """";
		var strs = this.map(function(node){
			if(node.nodeName.toUpperCase() == ""FORM""){
				return dojo.formToQuery(node);
			}else{
				var type = (node.type||"""").toLowerCase();
				if(serializeExclude.indexOf(type) == -1){
					var val = dojo.fieldToObject(node);
					if(node.name && val != null){
						var q = {};
						q[node.name] = val;
						return dojo.objectToQuery(q);
					}
				}
			}
		});
		return ret + strs.join(""&"");
	}

	$.param = function(obj){
		if(obj._is$ && obj.serialize){
			return obj.serialize();
		}else if(dojo.isArray(obj)){
			return dojo.map(obj, function(item){
				return $.param(item);
			}).join(""&"");
		}else{
			return dojo.objectToQuery(obj);
		}
	}
	
	//END jquery Ajax API methods

	//START jquery Utilities API methods
	//http://docs.jquery.com/Utilities
	//TODO:
	
	$.isFunction = function(){
		var result = dojo.isFunction.apply(dojo, arguments);
		//Make sure Object does not return true
		if(result){
			result = (typeof(arguments[0]) != ""object"");
		}
		return result;
	}

	//END jquery Utilities API methods

	
})();

"
"module.exports = function gopher_parsedir (dirent) { // eslint-disable-line camelcase
  //  discuss at: https://locutus.io/php/gopher_parsedir/
  // original by: Brett Zamir (https://brett-zamir.me)
  //   example 1: var entry = gopher_parsedir('0All about my gopher site.\t/allabout.txt\tgopher.example.com\t70\u000d\u000a')
  //   example 1: entry.title
  //   returns 1: 'All about my gopher site.'

  /* Types
   * 0 = plain text file
   * 1 = directory menu listing
   * 2 = CSO search query
   * 3 = error message
   * 4 = BinHex encoded text file
   * 5 = binary archive file
   * 6 = UUEncoded text file
   * 7 = search engine query
   * 8 = telnet session pointer
   * 9 = binary file
   * g = Graphics file format, primarily a GIF file
   * h = HTML file
   * i = informational message
   * s = Audio file format, primarily a WAV file
   */

  const entryPattern = /^(.)(.*?)\t(.*?)\t(.*?)\t(.*?)\u000d\u000a$/
  const entry = dirent.match(entryPattern)

  if (entry === null) {
    throw new Error('Could not parse the directory entry')
    // return false;
  }

  let type = entry[1]
  switch (type) {
    case 'i':
    // GOPHER_INFO
      type = 255
      break
    case '1':
    // GOPHER_DIRECTORY
      type = 1
      break
    case '0':
    // GOPHER_DOCUMENT
      type = 0
      break
    case '4':
    // GOPHER_BINHEX
      type = 4
      break
    case '5':
    // GOPHER_DOSBINARY
      type = 5
      break
    case '6':
    // GOPHER_UUENCODED
      type = 6
      break
    case '9':
    // GOPHER_BINARY
      type = 9
      break
    case 'h':
    // GOPHER_HTTP
      type = 254
      break
    default:
      return {
        type: -1,
        data: dirent
      } // GOPHER_UNKNOWN
  }
  return {
    type: type,
    title: entry[2],
    path: entry[3],
    host: entry[4],
    port: entry[5]
  }
}
","module.exports = function gopher_parsedir (dirent) { // eslint-disable-line camelcase
  //  discuss at: https://locutus.io/php/gopher_parsedir/
  // original by: Brett Zamir (https://brett-zamir.me)
  //   example 1: var entry = gopher_parsedir('0All about my gopher site.\t/allabout.txt\tgopher.example.com\t70\u000d\u000a')
  //   example 1: entry.title
  //   returns 1: 'All about my gopher site.'

  /* Types
   * 0 = plain text file
   * 1 = directory menu listing
   * 2 = CSO search query
   * 3 = error message
   * 4 = BinHex encoded text file
   * 5 = binary archive file
   * 6 = UUEncoded text file
   * 7 = search engine query
   * 8 = telnet session pointer
   * 9 = binary file
   * g = Graphics file format, primarily a GIF file
   * h = HTML file
   * i = informational message
   * s = Audio file format, primarily a WAV file
   */

  const entryPattern = /^(.)([^\t]*)\t([^\t]*)\t([^\t]*)\t([^\t]*)\r\n$/
  const entry = dirent.match(entryPattern)

  if (entry === null) {
    throw new Error('Could not parse the directory entry')
    // return false;
  }

  let type = entry[1]
  switch (type) {
    case 'i':
    // GOPHER_INFO
      type = 255
      break
    case '1':
    // GOPHER_DIRECTORY
      type = 1
      break
    case '0':
    // GOPHER_DOCUMENT
      type = 0
      break
    case '4':
    // GOPHER_BINHEX
      type = 4
      break
    case '5':
    // GOPHER_DOSBINARY
      type = 5
      break
    case '6':
    // GOPHER_UUENCODED
      type = 6
      break
    case '9':
    // GOPHER_BINARY
      type = 9
      break
    case 'h':
    // GOPHER_HTTP
      type = 254
      break
    default:
      return {
        type: -1,
        data: dirent
      } // GOPHER_UNKNOWN
  }
  return {
    type: type,
    title: entry[2],
    path: entry[3],
    host: entry[4],
    port: entry[5]
  }
}
"
"import isArray from '../utils/is-array';
import isUndefined from '../utils/is-undefined';
import { deprecateSimple } from '../utils/deprecate';
import { mergeConfigs } from './set';
import { Locale } from './constructor';
import keys from '../utils/keys';

import { baseConfig } from './base-config';

// internal storage for locale config files
var locales = {},
    localeFamilies = {},
    globalLocale;

function commonPrefix(arr1, arr2) {
    var i,
        minl = Math.min(arr1.length, arr2.length);
    for (i = 0; i < minl; i += 1) {
        if (arr1[i] !== arr2[i]) {
            return i;
        }
    }
    return minl;
}

function normalizeLocale(key) {
    return key ? key.toLowerCase().replace('_', '-') : key;
}

// pick the locale from the array
// try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
// substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
function chooseLocale(names) {
    var i = 0,
        j,
        next,
        locale,
        split;

    while (i < names.length) {
        split = normalizeLocale(names[i]).split('-');
        j = split.length;
        next = normalizeLocale(names[i + 1]);
        next = next ? next.split('-') : null;
        while (j > 0) {
            locale = loadLocale(split.slice(0, j).join('-'));
            if (locale) {
                return locale;
            }
            if (
                next &&
                next.length >= j &&
                commonPrefix(split, next) >= j - 1
            ) {
                //the next array item is better than a shallower substring of this one
                break;
            }
            j--;
        }
        i++;
    }
    return globalLocale;
}

function loadLocale(name) {
    var oldLocale = null,
        aliasedRequire;
    // TODO: Find a better way to register and load all the locales in Node
    if (
        locales[name] === undefined &&
        typeof module !== 'undefined' &&
        module &&
        module.exports
    ) {
        try {
            oldLocale = globalLocale._abbr;
            aliasedRequire = require;
            aliasedRequire('./locale/' + name);
            getSetGlobalLocale(oldLocale);
        } catch (e) {
            // mark as not found to avoid repeating expensive file require call causing high CPU
            // when trying to find en-US, en_US, en-us for every format call
            locales[name] = null; // null means not found
        }
    }
    return locales[name];
}

// This function will load locale and then set the global locale.  If
// no arguments are passed in, it will simply return the current global
// locale key.
export function getSetGlobalLocale(key, values) {
    var data;
    if (key) {
        if (isUndefined(values)) {
            data = getLocale(key);
        } else {
            data = defineLocale(key, values);
        }

        if (data) {
            // moment.duration._locale = moment._locale = data;
            globalLocale = data;
        } else {
            if (typeof console !== 'undefined' && console.warn) {
                //warn user if arguments are passed but the locale could not be set
                console.warn(
                    'Locale ' + key + ' not found. Did you forget to load it?'
                );
            }
        }
    }

    return globalLocale._abbr;
}

export function defineLocale(name, config) {
    if (config !== null) {
        var locale,
            parentConfig = baseConfig;
        config.abbr = name;
        if (locales[name] != null) {
            deprecateSimple(
                'defineLocaleOverride',
                'use moment.updateLocale(localeName, config) to change ' +
                    'an existing locale. moment.defineLocale(localeName, ' +
                    'config) should only be used for creating a new locale ' +
                    'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.'
            );
            parentConfig = locales[name]._config;
        } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
                parentConfig = locales[config.parentLocale]._config;
            } else {
                locale = loadLocale(config.parentLocale);
                if (locale != null) {
                    parentConfig = locale._config;
                } else {
                    if (!localeFamilies[config.parentLocale]) {
                        localeFamilies[config.parentLocale] = [];
                    }
                    localeFamilies[config.parentLocale].push({
                        name: name,
                        config: config,
                    });
                    return null;
                }
            }
        }
        locales[name] = new Locale(mergeConfigs(parentConfig, config));

        if (localeFamilies[name]) {
            localeFamilies[name].forEach(function (x) {
                defineLocale(x.name, x.config);
            });
        }

        // backwards compat for now: also set the locale
        // make sure we set the locale AFTER all child locales have been
        // created, so we won't end up with the child locale set.
        getSetGlobalLocale(name);

        return locales[name];
    } else {
        // useful for testing
        delete locales[name];
        return null;
    }
}

export function updateLocale(name, config) {
    if (config != null) {
        var locale,
            tmpLocale,
            parentConfig = baseConfig;

        if (locales[name] != null && locales[name].parentLocale != null) {
            // Update existing child locale in-place to avoid memory-leaks
            locales[name].set(mergeConfigs(locales[name]._config, config));
        } else {
            // MERGE
            tmpLocale = loadLocale(name);
            if (tmpLocale != null) {
                parentConfig = tmpLocale._config;
            }
            config = mergeConfigs(parentConfig, config);
            if (tmpLocale == null) {
                // updateLocale is called for creating a new locale
                // Set abbr so it will have a name (getters return
                // undefined otherwise).
                config.abbr = name;
            }
            locale = new Locale(config);
            locale.parentLocale = locales[name];
            locales[name] = locale;
        }

        // backwards compat for now: also set the locale
        getSetGlobalLocale(name);
    } else {
        // pass null for config to unupdate, useful for tests
        if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
                locales[name] = locales[name].parentLocale;
                if (name === getSetGlobalLocale()) {
                    getSetGlobalLocale(name);
                }
            } else if (locales[name] != null) {
                delete locales[name];
            }
        }
    }
    return locales[name];
}

// returns locale data
export function getLocale(key) {
    var locale;

    if (key && key._locale && key._locale._abbr) {
        key = key._locale._abbr;
    }

    if (!key) {
        return globalLocale;
    }

    if (!isArray(key)) {
        //short-circuit everything else
        locale = loadLocale(key);
        if (locale) {
            return locale;
        }
        key = [key];
    }

    return chooseLocale(key);
}

export function listLocales() {
    return keys(locales);
}
","import isArray from '../utils/is-array';
import isUndefined from '../utils/is-undefined';
import { deprecateSimple } from '../utils/deprecate';
import { mergeConfigs } from './set';
import { Locale } from './constructor';
import keys from '../utils/keys';

import { baseConfig } from './base-config';

// internal storage for locale config files
var locales = {},
    localeFamilies = {},
    globalLocale;

function commonPrefix(arr1, arr2) {
    var i,
        minl = Math.min(arr1.length, arr2.length);
    for (i = 0; i < minl; i += 1) {
        if (arr1[i] !== arr2[i]) {
            return i;
        }
    }
    return minl;
}

function normalizeLocale(key) {
    return key ? key.toLowerCase().replace('_', '-') : key;
}

// pick the locale from the array
// try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
// substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
function chooseLocale(names) {
    var i = 0,
        j,
        next,
        locale,
        split;

    while (i < names.length) {
        split = normalizeLocale(names[i]).split('-');
        j = split.length;
        next = normalizeLocale(names[i + 1]);
        next = next ? next.split('-') : null;
        while (j > 0) {
            locale = loadLocale(split.slice(0, j).join('-'));
            if (locale) {
                return locale;
            }
            if (
                next &&
                next.length >= j &&
                commonPrefix(split, next) >= j - 1
            ) {
                //the next array item is better than a shallower substring of this one
                break;
            }
            j--;
        }
        i++;
    }
    return globalLocale;
}

function isLocaleNameSane(name) {
    // Prevent names that look like filesystem paths, i.e contain '/' or '\'
    return name.match('^[^/\\\\]*$') != null;
}

function loadLocale(name) {
    var oldLocale = null,
        aliasedRequire;
    // TODO: Find a better way to register and load all the locales in Node
    if (
        locales[name] === undefined &&
        typeof module !== 'undefined' &&
        module &&
        module.exports &&
        isLocaleNameSane(name)
    ) {
        try {
            oldLocale = globalLocale._abbr;
            aliasedRequire = require;
            aliasedRequire('./locale/' + name);
            getSetGlobalLocale(oldLocale);
        } catch (e) {
            // mark as not found to avoid repeating expensive file require call causing high CPU
            // when trying to find en-US, en_US, en-us for every format call
            locales[name] = null; // null means not found
        }
    }
    return locales[name];
}

// This function will load locale and then set the global locale.  If
// no arguments are passed in, it will simply return the current global
// locale key.
export function getSetGlobalLocale(key, values) {
    var data;
    if (key) {
        if (isUndefined(values)) {
            data = getLocale(key);
        } else {
            data = defineLocale(key, values);
        }

        if (data) {
            // moment.duration._locale = moment._locale = data;
            globalLocale = data;
        } else {
            if (typeof console !== 'undefined' && console.warn) {
                //warn user if arguments are passed but the locale could not be set
                console.warn(
                    'Locale ' + key + ' not found. Did you forget to load it?'
                );
            }
        }
    }

    return globalLocale._abbr;
}

export function defineLocale(name, config) {
    if (config !== null) {
        var locale,
            parentConfig = baseConfig;
        config.abbr = name;
        if (locales[name] != null) {
            deprecateSimple(
                'defineLocaleOverride',
                'use moment.updateLocale(localeName, config) to change ' +
                    'an existing locale. moment.defineLocale(localeName, ' +
                    'config) should only be used for creating a new locale ' +
                    'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.'
            );
            parentConfig = locales[name]._config;
        } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
                parentConfig = locales[config.parentLocale]._config;
            } else {
                locale = loadLocale(config.parentLocale);
                if (locale != null) {
                    parentConfig = locale._config;
                } else {
                    if (!localeFamilies[config.parentLocale]) {
                        localeFamilies[config.parentLocale] = [];
                    }
                    localeFamilies[config.parentLocale].push({
                        name: name,
                        config: config,
                    });
                    return null;
                }
            }
        }
        locales[name] = new Locale(mergeConfigs(parentConfig, config));

        if (localeFamilies[name]) {
            localeFamilies[name].forEach(function (x) {
                defineLocale(x.name, x.config);
            });
        }

        // backwards compat for now: also set the locale
        // make sure we set the locale AFTER all child locales have been
        // created, so we won't end up with the child locale set.
        getSetGlobalLocale(name);

        return locales[name];
    } else {
        // useful for testing
        delete locales[name];
        return null;
    }
}

export function updateLocale(name, config) {
    if (config != null) {
        var locale,
            tmpLocale,
            parentConfig = baseConfig;

        if (locales[name] != null && locales[name].parentLocale != null) {
            // Update existing child locale in-place to avoid memory-leaks
            locales[name].set(mergeConfigs(locales[name]._config, config));
        } else {
            // MERGE
            tmpLocale = loadLocale(name);
            if (tmpLocale != null) {
                parentConfig = tmpLocale._config;
            }
            config = mergeConfigs(parentConfig, config);
            if (tmpLocale == null) {
                // updateLocale is called for creating a new locale
                // Set abbr so it will have a name (getters return
                // undefined otherwise).
                config.abbr = name;
            }
            locale = new Locale(config);
            locale.parentLocale = locales[name];
            locales[name] = locale;
        }

        // backwards compat for now: also set the locale
        getSetGlobalLocale(name);
    } else {
        // pass null for config to unupdate, useful for tests
        if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
                locales[name] = locales[name].parentLocale;
                if (name === getSetGlobalLocale()) {
                    getSetGlobalLocale(name);
                }
            } else if (locales[name] != null) {
                delete locales[name];
            }
        }
    }
    return locales[name];
}

// returns locale data
export function getLocale(key) {
    var locale;

    if (key && key._locale && key._locale._abbr) {
        key = key._locale._abbr;
    }

    if (!key) {
        return globalLocale;
    }

    if (!isArray(key)) {
        //short-circuit everything else
        locale = loadLocale(key);
        if (locale) {
            return locale;
        }
        key = [key];
    }

    return chooseLocale(key);
}

export function listLocales() {
    return keys(locales);
}
"
"/* global Gallery, escapeHTML */

(function ($, Gallery) {
	""use strict"";

	/**
	 * @typedef {Object} Gallery.Share.Types.ShareInfo
	 * @property {Number} share_type
	 * @property {Number} permissions
	 * @property {Number} file_source optional
	 * @property {Number} item_source
	 * @property {String} token
	 * @property {String} share_with
	 * @property {String} share_with_displayname
	 * @property {String} mail_send
	 * @property {String} displayname_file_owner
	 * @property {String} displayname_owner
	 * @property {String} uid_owner
	 * @property {String} uid_file_owner
	 * @property {String} expiration optional
	 * @property {Number} stime
	 */

	// copied and stripped out from the old core
	var Share = {
		SHARE_TYPE_USER: 0,
		SHARE_TYPE_GROUP: 1,
		SHARE_TYPE_LINK: 3,
		SHARE_TYPE_EMAIL: 4,
		SHARE_TYPE_REMOTE: 6,

		/**
		 * @deprecated use OC.Share.currentShares instead
		 */
		itemShares: [],

		/**
		 * Shares for the currently selected file.
		 * (for which the dropdown is open)
		 *
		 * Key is item type and value is an array or
		 * shares of the given item type.
		 */
		currentShares: {},

		/**
		 * Whether the share dropdown is opened.
		 */
		droppedDown: false,

		/**
		 *
		 * @param path {String} path to the file/folder which should be shared
		 * @param shareType {Number} 0 = user; 1 = group; 3 = public link; 6 = federated cloud
		 *     share
		 * @param shareWith {String} user / group id with which the file should be shared
		 * @param publicUpload {Boolean} allow public upload to a public shared folder
		 * @param password {String} password to protect public link Share with
		 * @param permissions {Number} 1 = read; 2 = update; 4 = create; 8 = delete; 16 = share; 31
		 *     = all (default: 31, for public shares: 1)
		 * @param callback {Function} method to call back after a successful share creation
		 * @param errorCallback {Function} method to call back after a failed share creation
		 *
		 * @returns {*}
		 */
		share: function (path, shareType, shareWith, publicUpload, password, permissions, callback, errorCallback) {
			return $.ajax({
				url: OC.linkToOCS('apps/files_sharing/api/v1', 2) + 'shares' + '?format=json',
				type: 'POST',
				data: {
					path: path,
					shareType: shareType,
					shareWith: shareWith,
					publicUpload: publicUpload,
					password: password,
					permissions: permissions
				},
				dataType: 'json'
			}).done(function (result) {
				if (callback) {
					callback(result.ocs.data);
				}
			}).fail(function (xhr) {
				var result = xhr.responseJSON;
				if (_.isFunction(errorCallback)) {
					errorCallback(result);
				} else {
					var msg = t('core', 'Error');
					if (result.ocs && result.ocs.meta.message) {
						msg = result.ocs.meta.message;
					}
					OC.dialogs.alert(msg, t('core', 'Error while sharing'));
				}
			});
		},
		/**
		 *
		 * @param {Number} shareId
		 * @param {Function} callback
		 */
		unshare: function (shareId, callback) {
			$.ajax({
				url: OC.linkToOCS('apps/files_sharing/api/v1', 2) + 'shares/' + shareId +
				'?format=json',
				type: 'DELETE'
			}).done(function () {
				if (callback) {
					callback();
				}
			}).fail(function () {
				OC.dialogs.alert(t('core', 'Error while unsharing'), t('core', 'Error'));

			});
		},
		/**
		 *
		 * @param {Number} shareId
		 * @param {Number} permissions
		 */
		setPermissions: function (shareId, permissions) {
			$.ajax({
				url: OC.linkToOCS('apps/files_sharing/api/v1', 2) + 'shares/' + shareId +
				'?format=json',
				type: 'PUT',
				data: {
					permissions: permissions
				}
			}).fail(function () {
				OC.dialogs.alert(t('core', 'Error while changing permissions'),
					t('core', 'Error'));
			});
		},
		/**
		 *
		 * @param {String} itemType
		 * @param {String} path
		 * @param {String} appendTo
		 * @param {String} link
		 * @param {Number} possiblePermissions
		 * @param {String} filename
		 */
		showDropDown: function (itemType, path, appendTo, link, possiblePermissions, filename) {
			// This is a sync AJAX request on the main thread...
			var data = this._loadShares(path);
			var dropDownEl;
			var self = this;
			var html = '<div id=""dropdown"" class=""drop shareDropDown"" data-item-type=""' + itemType +
				'"" data-item-source=""' + path + '"">';
			if (data !== false && data[0] && !_.isUndefined(data[0].uid_file_owner) &&
				data[0].uid_file_owner !== OC.currentUser
			) {
				html += '<span class=""reshare"">';
				if (oc_config.enable_avatars === true) {
					html += '<div class=""avatar""></div>';
				}

				if (data[0].share_type == this.SHARE_TYPE_GROUP) {
					html += t('core', 'Shared with you and the group {group} by {owner}', {
						group: data[0].share_with,
						owner: data[0].displayname_owner
					});
				} else {
					html += t('core', 'Shared with you by {owner}',
						{owner: data[0].displayname_owner});
				}
				html += '</span><br />';
				// reduce possible permissions to what the original share allowed
				possiblePermissions = possiblePermissions & data[0].permissions;
			}

			if (possiblePermissions & OC.PERMISSION_SHARE) {
				// Determine the Allow Public Upload status.
				// Used later on to determine if the
				// respective checkbox should be checked or
				// not.
				// FIXME public uploading is not supported in Gallery
				/*var publicUploadEnabled = $('#filestable').data('allow-public-upload');
				 if (typeof publicUploadEnabled == 'undefined') {
				 publicUploadEnabled = 'no';
				 }
				 var allowPublicUploadStatus = false;

				 $.each(data, function (key, value) {
				 if (value.share_type === self.SHARE_TYPE_LINK) {
				 allowPublicUploadStatus =
				 (value.permissions & OC.PERMISSION_CREATE) ? true : false;
				 return true;
				 }
				 });*/

				var sharePlaceholder = t('core', 'Share with users or groups …');
				if (oc_appconfig.core.remoteShareAllowed) {
					sharePlaceholder = t('core', 'Share with users, groups or remote users …');
				}

				html += '<label for=""shareWith"" class=""hidden-visually"">' + t('core', 'Share') +
					'</label>';
				html +=
					'<input id=""shareWith"" type=""text"" placeholder=""' + sharePlaceholder + '"" />';
				if (oc_appconfig.core.remoteShareAllowed) {
					var federatedCloudSharingDoc =
						'<a target=""_blank"" class=""icon-info svg shareWithRemoteInfo"" ' +
						'href=""{docLink}"" title=""' + t('core',
							'Share with people on other ownClouds using the syntax username@example.com/owncloud') +
						'""></a>';
					html += federatedCloudSharingDoc.replace('{docLink}',
						oc_appconfig.core.federatedCloudShareDoc);
				}
				html += '<span class=""shareWithLoading icon-loading-small hidden""></span>';
				html += '<ul id=""shareWithList"">';
				html += '</ul>';
				var linksAllowed = $('#allowShareWithLink').val() === 'yes';
				if (link && linksAllowed) {
					html += '<div id=""link"" class=""linkShare"">';
					html += '<span class=""icon-loading-small hidden""></span>';
					html +=
						'<input type=""checkbox"" class=""checkbox checkbox--right"" ' +
						'name=""linkCheckbox"" id=""linkCheckbox"" value=""1"" />' +
						'<label for=""linkCheckbox"">' + t('core', 'Share link') + '</label>';
					html += '<br />';

					var defaultExpireMessage = '';
					if ((itemType === 'folder' || itemType === 'file') &&
						oc_appconfig.core.defaultExpireDateEnforced) {
						defaultExpireMessage =
							t('core',
								'The public link will expire no later than {days} days after it is created',
								{'days': oc_appconfig.core.defaultExpireDate}) + '<br/>';
					}

					html += '<label for=""linkText"" class=""hidden-visually"">' + t('core', 'Link') +
						'</label>';
					html += '<input id=""linkText"" type=""text"" readonly=""readonly"" />';
					html +=
						'<input type=""checkbox"" class=""checkbox checkbox--right"" ' +
						'name=""showPassword"" id=""showPassword"" value=""1"" />' +
						'<label for=""showPassword"" style=""display:none;"">' +
						t('core', 'Password protect') + '</label>';
					html += '<div id=""linkPass"">';
					html += '<label for=""linkPassText"" class=""hidden-visually"">' +
						t('core', 'Password') + '</label>';
					html += '<input id=""linkPassText"" type=""password"" placeholder=""' +
						t('core', 'Choose a password for the public link') + '"" />';
					html += '<span class=""icon-loading-small hidden""></span>';
					html += '</div>';

					// FIXME public uploading is not supported in Gallery
					/*if (itemType === 'folder' && (possiblePermissions & OC.PERMISSION_CREATE) &&
					 publicUploadEnabled === 'yes') {
					 html += '<div id=""allowPublicUploadWrapper"" style=""display:none;"">';
					 html += '<span class=""icon-loading-small hidden""></span>';
					 html +=
					 '<input type=""checkbox"" class=""checkbox checkbox--right"" value=""1"" name=""allowPublicUpload"" id=""sharingDialogAllowPublicUpload""' +
					 ((allowPublicUploadStatus) ? 'checked=""checked""' : '') + ' />';
					 html += '<label for=""sharingDialogAllowPublicUpload"">' +
					 t('core', 'Allow editing') + '</label>';
					 html += '</div>';
					 }
					 html += '</div>';
					 var mailPublicNotificationEnabled = $(
					 'input:hidden[name=mailPublicNotificationEnabled]').val();
					 if (mailPublicNotificationEnabled === 'yes') {
					 html += '<form id=""emailPrivateLink"">';
					 html +=
					 '<input id=""email"" style=""display:none; width:62%;"" value="""" placeholder=""' +
					 t('core', 'Email link to person') + '"" type=""text"" />';
					 html +=
					 '<input id=""emailButton"" style=""display:none;"" type=""submit"" value=""' +
					 t('core', 'Send') + '"" />';
					 html += '</form>';
					 }*/
				}

				html += '<div id=""expiration"">';
				html +=
					'<input type=""checkbox"" class=""checkbox checkbox--right"" ' +
					'name=""expirationCheckbox"" id=""expirationCheckbox"" value=""1"" />' +
					'<label for=""expirationCheckbox"">' +
					t('core', 'Set expiration date') + '</label>';
				html += '<label for=""expirationDate"" class=""hidden-visually"">' +
					t('core', 'Expiration') + '</label>';
				html += '<input id=""expirationDate"" type=""text"" placeholder=""' +
					t('core', 'Expiration date') + '"" style=""display:none; width:90%;"" />';
				html += '<em id=""defaultExpireMessage"">' + defaultExpireMessage + '</em>';
				html += '</div>';
				dropDownEl = $(html);
				dropDownEl = dropDownEl.appendTo(appendTo);

				// trigger remote share info tooltip
				if (oc_appconfig.core.remoteShareAllowed) {
					$('.shareWithRemoteInfo').tooltip({placement: 'top'});
				}

				//Get owner avatars
				if (oc_config.enable_avatars === true && data !== false && data[0] !== false &&
					!_.isUndefined(data[0]) && !_.isUndefined(data[0].uid_file_owner)) {
					dropDownEl.find("".avatar"").avatar(data[0].uid_file_owner, 32);
				}

				// Reset item shares
				this.itemShares = [];
				this.currentShares = {};
				if (data) {
					$.each(data, function (index, share) {
						if (share.share_type === self.SHARE_TYPE_LINK) {
							self.showLink(share.id, share.token, share.share_with);
						} else {
							if (share.share_with !== OC.currentUser) {
								if (share.share_type === self.SHARE_TYPE_REMOTE) {
									self._addShareWith(share.id,
										share.share_type,
										share.share_with,
										share.share_with_displayname,
										share.permissions,
										OC.PERMISSION_READ | OC.PERMISSION_UPDATE |
										OC.PERMISSION_CREATE,
										share.mail_send,
										false);
								} else {
									self._addShareWith(share.id,
										share.share_type,
										share.share_with,
										share.share_with_displayname,
										share.permissions,
										possiblePermissions,
										share.mail_send,
										false);
								}
							}
						}
						if (share.expiration != null) {
							var expireDate = moment(share.expiration, 'YYYY-MM-DD').format(
								'DD-MM-YYYY');
							self.showExpirationDate(expireDate, share.stime);
						}
					});
				}
				$('#shareWith').autocomplete({
					minLength: 2,
					delay: 750,
					source: function (search, response) {
						var $loading = $('#dropdown .shareWithLoading');
						$loading.removeClass('hidden');
						// Can be replaced with Sharee API
						// https://github.com/owncloud/core/pull/18234
						$.get(OC.filePath('core', 'ajax', 'share.php'), {
							fetch: 'getShareWith',
							search: search.term.trim(),
							limit: 200,
							itemShares: this.itemShares,
							itemType: itemType
						}, function (result) {
							$loading.addClass('hidden');
							if (result.status == 'success' && result.data.length > 0) {
								$(""#shareWith"").autocomplete(""option"", ""autoFocus"", true);
								response(result.data);
							} else {
								response();
							}
						}).fail(function () {
							$('#dropdown').find('.shareWithLoading').addClass('hidden');
							OC.Notification.show(t('core', 'An error occured. Please try again'));
							window.setTimeout(OC.Notification.hide, 5000);
						});
					},
					focus: function (event) {
						event.preventDefault();
					},
					select: function (event, selected) {
						event.stopPropagation();
						var $dropDown = $('#dropdown');
						var itemSource = $dropDown.data('item-source');
						var expirationDate = '';
						if ($('#expirationCheckbox').is(':checked') === true) {
							expirationDate = $(""#expirationDate"").val();
						}
						var shareType = selected.item.value.shareType;
						var shareWith = selected.item.value.shareWith;
						$(this).val(shareWith);
						// Default permissions are Edit (CRUD) and Share
						// Check if these permissions are possible
						var permissions = OC.PERMISSION_READ;
						if (shareType === Gallery.Share.SHARE_TYPE_REMOTE) {
							permissions =
								OC.PERMISSION_CREATE | OC.PERMISSION_UPDATE | OC.PERMISSION_READ;
						} else {
							if (possiblePermissions & OC.PERMISSION_UPDATE) {
								permissions = permissions | OC.PERMISSION_UPDATE;
							}
							if (possiblePermissions & OC.PERMISSION_CREATE) {
								permissions = permissions | OC.PERMISSION_CREATE;
							}
							if (possiblePermissions & OC.PERMISSION_DELETE) {
								permissions = permissions | OC.PERMISSION_DELETE;
							}
							if (oc_appconfig.core.resharingAllowed &&
								(possiblePermissions & OC.PERMISSION_SHARE)) {
								permissions = permissions | OC.PERMISSION_SHARE;
							}
						}

						var $input = $(this);
						var $loading = $dropDown.find('.shareWithLoading');
						$loading.removeClass('hidden');
						$input.val(t('core', 'Adding user...'));
						$input.prop('disabled', true);
						Gallery.Share.share(
							itemSource,
							shareType,
							shareWith,
							0,
							null,
							permissions,
							function (data) {
								var posPermissions = possiblePermissions;
								if (shareType === Gallery.Share.SHARE_TYPE_REMOTE) {
									posPermissions = permissions;
								}
								Gallery.Share._addShareWith(data.id, shareType, shareWith,
									selected.item.label,
									permissions, posPermissions);
							});
						$input.prop('disabled', false);
						$loading.addClass('hidden');
						$('#shareWith').val('');
						return false;
					}
				}).data(""ui-autocomplete"")._renderItem = function (ul, item) {
					// customize internal _renderItem function to display groups and users
					// differently
					var insert = $(""<a>"");
					var text = item.label;
					if (item.value.shareType === Gallery.Share.SHARE_TYPE_GROUP) {
						text = text + ' (' + t('core', 'group') + ')';
					} else if (item.value.shareType === Gallery.Share.SHARE_TYPE_REMOTE) {
						text = text + ' (' + t('core', 'remote') + ')';
					}
					insert.text(text);
					if (item.value.shareType === Gallery.Share.SHARE_TYPE_GROUP) {
						insert = insert.wrapInner('<strong></strong>');
					}
					return $(""<li>"")
						.addClass(
							(item.value.shareType ===
							Gallery.Share.SHARE_TYPE_GROUP) ? 'group' : 'user')
						.append(insert)
						.appendTo(ul);
				};
				// FIXME Emailing links is not supported in Gallery
				/*if (link && linksAllowed && $('#email').length != 0) {
				 $('#email').autocomplete({
				 minLength: 1,
				 source: function (search, response) {
				 $.get(OC.filePath('core', 'ajax', 'share.php'), {
				 fetch: 'getShareWithEmail',
				 search: search.term
				 }, function (result) {
				 if (result.status == 'success' && result.data.length > 0) {
				 response(result.data);
				 }
				 });
				 },
				 select: function (event, item) {
				 $('#email').val(item.item.email);
				 return false;
				 }
				 })
				 .data(""ui-autocomplete"")._renderItem = function (ul, item) {
				 return $('<li>')
				 .append('<a>' + escapeHTML(item.displayname) + ""<br>"" +
				 escapeHTML(item.email) + '</a>')
				 .appendTo(ul);
				 };
				 }*/

			} else {
				html += '<input id=""shareWith"" type=""text"" placeholder=""' +
					t('core', 'Resharing is not allowed') +
					'"" style=""width:90%;"" disabled=""disabled""/>';
				html += '</div>';
				dropDownEl = $(html);
				dropDownEl.appendTo(appendTo);
			}
			dropDownEl.attr('data-item-source-name', filename);
			$('#dropdown').slideDown(OC.menuSpeed, function () {
				Gallery.Share.droppedDown = true;
			});
			if ($('html').hasClass('lte9')) {
				$('#dropdown input[placeholder]').placeholder();
			}
			$('#shareWith').focus();
		},
		/**
		 *
		 * @param callback
		 */
		hideDropDown: function (callback) {
			this.currentShares = null;
			$('#dropdown').slideUp(OC.menuSpeed, function () {
				Gallery.Share.droppedDown = false;
				$('#dropdown').remove();
				if (typeof FileActions !== 'undefined') {
					$('tr').removeClass('mouseOver');
				}
				if (callback) {
					callback.call();
				}
			});
		},
		/**
		 *
		 * @param id
		 * @param token
		 * @param password
		 */
		showLink: function (id, token, password) {
			var $linkCheckbox = $('#linkCheckbox');
			this.itemShares[this.SHARE_TYPE_LINK] = true;
			$linkCheckbox.attr('checked', true);
			$linkCheckbox.attr('data-id', id);
			var $linkText = $('#linkText');

			var link = parent.location.protocol + '//' + location.host +
				OC.generateUrl('/apps/' + Gallery.appName + '/s/') + token;

			$linkText.val(link);
			$linkText.slideDown(OC.menuSpeed);
			$linkText.css('display', 'block');
			if (oc_appconfig.core.enforcePasswordForPublicLink === false || password === null) {
				$('#showPassword+label').show();
			}
			if (password != null) {
				$('#linkPass').slideDown(OC.menuSpeed);
				$('#showPassword').attr('checked', true);
				$('#linkPassText').attr('placeholder', '**********');
			}
			$('#expiration').show();
			$('#emailPrivateLink #email').show();
			$('#emailPrivateLink #emailButton').show();
			$('#allowPublicUploadWrapper').show();
		},
		/**
		 *
		 */
		hideLink: function () {
			$('#linkText').slideUp(OC.menuSpeed);
			$('#defaultExpireMessage').hide();
			$('#showPassword+label').hide();
			$('#linkPass').slideUp(OC.menuSpeed);
			$('#emailPrivateLink #email').hide();
			$('#emailPrivateLink #emailButton').hide();
			$('#allowPublicUploadWrapper').hide();
		},
		/**
		 * Displays the expiration date field
		 *
		 * @param {String} date current expiration date
		 * @param {Date|Number|String} [shareTime] share timestamp in seconds, defaults to now
		 */
		showExpirationDate: function (date, shareTime) {
			var $expirationDate = $('#expirationDate');
			var $expirationCheckbox = $('#expirationCheckbox');
			var now = new Date();
			// min date should always be the next day
			var minDate = new Date();
			minDate.setDate(minDate.getDate() + 1);
			var datePickerOptions = {
				minDate: minDate,
				maxDate: null
			};
			// TODO: hack: backend returns string instead of integer
			shareTime = this._parseTime(shareTime);
			if (_.isNumber(shareTime)) {
				shareTime = new Date(shareTime * 1000);
			}
			if (!shareTime) {
				shareTime = now;
			}
			$expirationCheckbox.attr('checked', true);
			$expirationDate.val(date);
			$expirationDate.slideDown(OC.menuSpeed);
			$expirationDate.css('display', 'block');
			$expirationDate.datepicker({
				dateFormat: 'dd-mm-yy'
			});
			if (oc_appconfig.core.defaultExpireDateEnforced) {
				$expirationCheckbox.attr('disabled', true);
				shareTime = OC.Util.stripTime(shareTime).getTime();
				// max date is share date + X days
				datePickerOptions.maxDate =
					new Date(shareTime + oc_appconfig.core.defaultExpireDate * 24 * 3600 * 1000);
			}
			if (oc_appconfig.core.defaultExpireDateEnabled) {
				$('#defaultExpireMessage').slideDown(OC.menuSpeed);
			}
			$.datepicker.setDefaults(datePickerOptions);
		},
		/**
		 * Get the default Expire date
		 *
		 * @return {String} The expire date
		 */
		getDefaultExpirationDate: function () {
			var expireDateString = '';
			if (oc_appconfig.core.defaultExpireDateEnabled) {
				var date = new Date().getTime();
				var expireAfterMs = oc_appconfig.core.defaultExpireDate * 24 * 60 * 60 * 1000;
				var expireDate = new Date(date + expireAfterMs);
				var month = expireDate.getMonth() + 1;
				var year = expireDate.getFullYear();
				var day = expireDate.getDate();
				expireDateString = year + ""-"" + month + '-' + day + ' 00:00:00';
			}
			return expireDateString;
		},
		/**
		 * Loads all shares associated with a path
		 *
		 * @param path
		 *
		 * @returns {Gallery.Share.Types.ShareInfo|Boolean}
		 * @private
		 */
		_loadShares: function (path) {
			var data = false;
			var url = OC.linkToOCS('apps/files_sharing/api/v1', 2) + 'shares' + '?format=json';
			$.ajax({
				url: url,
				type: 'GET',
				data: {
					path: path,
					shared_with_me: true
				},
				async: false
			}).done(function (result) {
				data = result.ocs.data;
				$.ajax({
					url: url,
					type: 'GET',
					data: {
						path: path,
						reshares: true
					},
					async: false
				}).done(function (result) {
					data = _.union(data, result.ocs.data);
				})

			});

			if (data === false) {
				OC.dialogs.alert(t('gallery', 'Error while retrieving shares'),
					t('core', 'Error'));
			}

			return data;
		},
		/**
		 *
		 * @param shareId
		 * @param shareType
		 * @param shareWith
		 * @param shareWithDisplayName
		 * @param permissions
		 * @param possiblePermissions
		 * @param mailSend
		 *
		 * @private
		 */
		_addShareWith: function (shareId, shareType, shareWith, shareWithDisplayName, permissions, possiblePermissions, mailSend) {
			var shareItem = {
				share_id: shareId,
				share_type: shareType,
				share_with: shareWith,
				share_with_displayname: shareWithDisplayName,
				permissions: permissions
			};
			if (shareType === this.SHARE_TYPE_GROUP) {
				shareWithDisplayName = shareWithDisplayName + "" ("" + t('core', 'group') + ')';
			}
			if (shareType === this.SHARE_TYPE_REMOTE) {
				shareWithDisplayName = shareWithDisplayName + "" ("" + t('core', 'remote') + ')';
			}
			if (!this.itemShares[shareType]) {
				this.itemShares[shareType] = [];
			}
			this.itemShares[shareType].push(shareWith);

			var editChecked = '',
				createChecked = '',
				updateChecked = '',
				deleteChecked = '',
				shareChecked = '';
			if (permissions & OC.PERMISSION_CREATE) {
				createChecked = 'checked=""checked""';
				editChecked = 'checked=""checked""';
			}
			if (permissions & OC.PERMISSION_UPDATE) {
				updateChecked = 'checked=""checked""';
				editChecked = 'checked=""checked""';
			}
			if (permissions & OC.PERMISSION_DELETE) {
				deleteChecked = 'checked=""checked""';
				editChecked = 'checked=""checked""';
			}
			if (permissions & OC.PERMISSION_SHARE) {
				shareChecked = 'checked=""checked""';
			}
			var html = '<li style=""clear: both;"" ' +
				'data-id=""' + escapeHTML(shareId) + '""' +
				'data-share-type=""' + escapeHTML(shareType) + '""' +
				'data-share-with=""' + escapeHTML(shareWith) + '""' +
				'title=""' + escapeHTML(shareWith) + '"">';
			var showCrudsButton;
			html +=
				'<a href=""#"" class=""unshare""><img class=""svg"" alt=""' + t('core', 'Unshare') +
				'"" title=""' + t('core', 'Unshare') + '"" src=""' +
				OC.imagePath('core', 'actions/delete') + '""/></a>';
			if (oc_config.enable_avatars === true) {
				html += '<div class=""avatar""></div>';
			}
			html += '<span class=""username"">' + escapeHTML(shareWithDisplayName) + '</span>';
			var mailNotificationEnabled = $('input:hidden[name=mailNotificationEnabled]').val();
			if (mailNotificationEnabled === 'yes' &&
				shareType !== this.SHARE_TYPE_REMOTE) {
				var checked = '';
				if (mailSend === '1') {
					checked = 'checked';
				}
				html +=
					'<input type=""checkbox"" class=""checkbox checkbox--right"" ' +
					'name=""mailNotification"" class=""mailNotification"" ' +
					checked + ' />';
				html +=
					'<label>' + t('core', 'notify by email') + '</label>';
			}
			if (oc_appconfig.core.resharingAllowed &&
				(possiblePermissions & OC.PERMISSION_SHARE)) {
				html += '<input id=""canShare-' + escapeHTML(shareWith) +
					'"" type=""checkbox"" class=""permissions checkbox checkbox--right"" name=""share"" ' +
					shareChecked + ' data-permissions=""' + OC.PERMISSION_SHARE + '"" />';
				html += '<label for=""canShare-' + escapeHTML(shareWith) + '"">' +
					t('core', 'can share') + '</label>';
			}
			if (possiblePermissions & OC.PERMISSION_CREATE ||
				possiblePermissions & OC.PERMISSION_UPDATE ||
				possiblePermissions & OC.PERMISSION_DELETE) {
				html += '<input id=""canEdit-' + escapeHTML(shareWith) +
					'"" type=""checkbox"" class=""permissions checkbox checkbox--right"" name=""edit"" ' +
					editChecked + ' />';
				html += '<label for=""canEdit-' + escapeHTML(shareWith) + '"">' +
					t('core', 'can edit') + '</label>';
			}
			if (shareType !== this.SHARE_TYPE_REMOTE) {
				showCrudsButton = '<a href=""#"" class=""showCruds""><img class=""svg"" alt=""' +
					t('core', 'access control') + '"" src=""' +
					OC.imagePath('core', 'actions/triangle-s') + '""/></a>';
			}
			html += '<div class=""cruds"" style=""display:none;"">';
			if (possiblePermissions & OC.PERMISSION_CREATE) {
				html += '<input id=""canCreate-' + escapeHTML(shareWith) +
					'"" type=""checkbox"" class=""permissions checkbox checkbox--right"" name=""create"" ' +
					createChecked + ' data-permissions=""' + OC.PERMISSION_CREATE + '""/>';
				html += '<label for=""canCreate-' + escapeHTML(shareWith) + '"">' +
					t('core', 'create') + '</label>';
			}
			if (possiblePermissions & OC.PERMISSION_UPDATE) {
				html += '<input id=""canUpdate-' + escapeHTML(shareWith) +
					'"" type=""checkbox"" class=""permissions checkbox checkbox--right"" name=""update"" ' +
					updateChecked + ' data-permissions=""' + OC.PERMISSION_UPDATE + '""/>';
				html += '<label for=""canUpdate-' + escapeHTML(shareWith) + '"">' +
					t('core', 'change') + '</label>';
			}
			if (possiblePermissions & OC.PERMISSION_DELETE) {
				html += '<input id=""canDelete-' + escapeHTML(shareWith) +
					'"" type=""checkbox"" class=""permissions checkbox checkbox--right"" name=""delete"" ' +
					deleteChecked + ' data-permissions=""' + OC.PERMISSION_DELETE + '""/>';
				html += '<label for=""canDelete-' + escapeHTML(shareWith) + '"">' +
					t('core', 'delete') + '</label>';
			}
			html += '</div>';
			html += '</li>';
			html = $(html).appendTo('#shareWithList');
			if (oc_config.enable_avatars === true) {
				if (shareType === this.SHARE_TYPE_USER) {
					html.find('.avatar').avatar(escapeHTML(shareWith), 32);
				} else {
					//Add sharetype to generate different seed if there is a group and use with
					// the same name
					html.find('.avatar').imageplaceholder(
						escapeHTML(shareWith) + ' ' + shareType);
				}
			}
			// insert cruds button into last label element
			var lastLabel = html.find('>label:last');
			if (lastLabel.exists()) {
				lastLabel.append(showCrudsButton);
			}
			else {
				html.find('.cruds').before(showCrudsButton);
			}
			if (!this.currentShares[shareType]) {
				this.currentShares[shareType] = [];
			}
			this.currentShares[shareType].push(shareItem);
		},
		/**
		 * Parses a string to an valid integer (unix timestamp)
		 * @param time
		 * @returns {*}
		 * @internal Only used to work around a bug in the backend
		 * @private
		 */
		_parseTime: function (time) {
			if (_.isString(time)) {
				// skip empty strings and hex values
				if (time === '' || (time.length > 1 && time[0] === '0' && time[1] === 'x')) {
					return null;
				}
				time = parseInt(time, 10);
				if (isNaN(time)) {
					time = null;
				}
			}
			return time;
		}
	};

	Gallery.Share = Share;
})(jQuery, Gallery);

$(document).ready(function () {

	if (typeof monthNames != 'undefined') {
		// min date should always be the next day
		var minDate = new Date();
		minDate.setDate(minDate.getDate() + 1);
		$.datepicker.setDefaults({
			monthNames: monthNames,
			monthNamesShort: $.map(monthNames, function (v) {
				return v.slice(0, 3) + '.';
			}),
			dayNames: dayNames,
			dayNamesMin: $.map(dayNames, function (v) {
				return v.slice(0, 2);
			}),
			dayNamesShort: $.map(dayNames, function (v) {
				return v.slice(0, 3) + '.';
			}),
			firstDay: firstDay,
			minDate: minDate
		});
	}
	$(document).on('click', 'a.share', function (event) {
		event.stopPropagation();
		if ($(this).data('item-type') !== undefined && $(this).data('path') !== undefined) {
			var itemType = $(this).data('item-type');
			var path = $(this).data('path');
			var appendTo = $(this).parent().parent();
			var link = false;
			var possiblePermissions = $(this).data('possible-permissions');
			if ($(this).data('link') !== undefined && $(this).data('link') == true) {
				link = true;
			}
			if (Gallery.Share.droppedDown) {
				if (path != $('#dropdown').data('path')) {
					Gallery.Share.hideDropDown(function () {
						Gallery.Share.showDropDown(itemType, path, appendTo, link,
							possiblePermissions);
					});
				} else {
					Gallery.Share.hideDropDown();
				}
			} else {
				Gallery.Share.showDropDown(itemType, path, appendTo, link, possiblePermissions);
			}
		}
	});

	$(this).click(function (event) {
		var target = $(event.target);
		var isMatched = !target.is('.drop, .ui-datepicker-next, .ui-datepicker-prev, .ui-icon')
			&& !target.closest('#ui-datepicker-div').length &&
			!target.closest('.ui-autocomplete').length;
		if (Gallery.Share.droppedDown && isMatched &&
			$('#dropdown').has(event.target).length === 0) {
			Gallery.Share.hideDropDown();
		}
	});

	$(document).on('click', '#dropdown .showCruds', function () {
		$(this).closest('li').find('.cruds').toggle();
		return false;
	});

	$(document).on('click', '#dropdown .unshare', function () {
		var $li = $(this).closest('li');
		var shareType = $li.data('share-type');
		var shareWith = $li.attr('data-share-with');
		var shareId = $li.attr('data-id');
		var $button = $(this);

		if (!$button.is('a')) {
			$button = $button.closest('a');
		}

		if ($button.hasClass('icon-loading-small')) {
			// deletion in progress
			return false;
		}
		$button.empty().addClass('icon-loading-small');
		Gallery.Share.unshare(shareId, function () {
			$li.remove();
			var index = Gallery.Share.itemShares[shareType].indexOf(shareWith);
			Gallery.Share.itemShares[shareType].splice(index, 1);
			// updated list of shares
			Gallery.Share.currentShares[shareType].splice(index, 1);
		});

		return false;
	});

	$(document).on('change', '#dropdown .permissions', function () {
		var $li = $(this).closest('li');
		var checkboxes = $('.permissions', $li);
		if ($(this).attr('name') == 'edit') {
			var checked = $(this).is(':checked');
			// Check/uncheck Create, Update, and Delete checkboxes if Edit is checked/unck
			$(checkboxes).filter('input[name=""create""]').attr('checked', checked);
			$(checkboxes).filter('input[name=""update""]').attr('checked', checked);
			$(checkboxes).filter('input[name=""delete""]').attr('checked', checked);
		} else {
			// Uncheck Edit if Create, Update, and Delete are not checked
			if (!$(this).is(':checked')
				&& !$(checkboxes).filter('input[name=""create""]').is(':checked')
				&& !$(checkboxes).filter('input[name=""update""]').is(':checked')
				&& !$(checkboxes).filter('input[name=""delete""]').is(':checked')) {
				$(checkboxes).filter('input[name=""edit""]').attr('checked', false);
				// Check Edit if Create, Update, or Delete is checked
			} else if (($(this).attr('name') == 'create'
				|| $(this).attr('name') == 'update'
				|| $(this).attr('name') == 'delete')) {
				$(checkboxes).filter('input[name=""edit""]').attr('checked', true);
			}
		}
		var permissions = OC.PERMISSION_READ;
		$(checkboxes).filter(':not(input[name=""edit""])').filter(':checked').each(
			function (index, checkbox) {
				permissions |= $(checkbox).data('permissions');
			});

		Gallery.Share.setPermissions($li.attr('data-id'), permissions);
	});

	$(document).on('change', '#dropdown #linkCheckbox', function () {
		var $dropDown = $('#dropdown');
		var path = $dropDown.data('item-source');
		var shareId = $('#linkCheckbox').data('id');
		var shareWith = '';
		var publicUpload = 0;
		var $loading = $dropDown.find('#link .icon-loading-small');
		var $button = $(this);

		if (!$loading.hasClass('hidden')) {
			// already in progress
			return false;
		}

		if (this.checked) {
			// Reset password placeholder
			$('#linkPassText').attr('placeholder',
				t('core', 'Choose a password for the public link'));
			// Reset link
			$('#linkText').val('');
			$('#showPassword').prop('checked', false);
			$('#linkPass').hide();
			$('#sharingDialogAllowPublicUpload').prop('checked', false);
			$('#expirationCheckbox').prop('checked', false);
			$('#expirationDate').hide();
			var expireDateString = '';
			// Create a link
			if (oc_appconfig.core.enforcePasswordForPublicLink === false) {
				expireDateString = Gallery.Share.getDefaultExpirationDate();
				$loading.removeClass('hidden');
				$button.addClass('hidden');
				$button.prop('disabled', true);
				Gallery.Share.share(
					path,
					Gallery.Share.SHARE_TYPE_LINK,
					shareWith,
					publicUpload,
					null,
					OC.PERMISSION_READ,
					function (data) {
						$loading.addClass('hidden');
						$button.removeClass('hidden');
						$button.prop('disabled', false);
						Gallery.Share.showLink(data.id, data.token, null);
					});
			} else {
				$('#linkPass').slideToggle(OC.menuSpeed);
				$('#linkPassText').focus();
			}
			if (expireDateString !== '') {
				Gallery.Share.showExpirationDate(expireDateString);
			}
		} else {
			// Delete private link
			Gallery.Share.hideLink();
			$('#expiration').slideUp(OC.menuSpeed);
			if ($('#linkText').val() !== '') {
				$loading.removeClass('hidden');
				$button.addClass('hidden');
				$button.prop('disabled', true);
				Gallery.Share.unshare(shareId, function () {
					$loading.addClass('hidden');
					$button.removeClass('hidden');
					$button.prop('disabled', false);
					Gallery.Share.itemShares[Gallery.Share.SHARE_TYPE_LINK] = false;
				});
			}
		}
	});

	$(document).on('click', '#dropdown #linkText', function () {
		$(this).focus();
		$(this).select();
	});

	// Handle the Allow Public Upload Checkbox
	// FIXME public uploading is not supported in Gallery
	/*$(document).on('click', '#sharingDialogAllowPublicUpload', function () {

	 // Gather data
	 var $dropDown = $('#dropdown');
	 var allowPublicUpload = $(this).is(':checked');
	 var $button = $(this);
	 var $loading = $dropDown.find('#allowPublicUploadWrapper .icon-loading-small');

	 if (!$loading.hasClass('hidden')) {
	 // already in progress
	 return false;
	 }

	 // Update the share information
	 $button.addClass('hidden');
	 $button.prop('disabled', true);
	 $loading.removeClass('hidden');
	 //(path, shareType, shareWith, publicUpload, password, permissions)
	 $.ajax({
	 url: OC.linkToOCS('apps/files_sharing/api/v1', 2) + 'shares/' + shareId +
	 '?format=json',
	 type: 'PUT',
	 data: {
	 publicUpload: allowPublicUpload
	 }
	 }).done(function () {
	 $loading.addClass('hidden');
	 $button.removeClass('hidden');
	 $button.prop('disabled', false);
	 });
	 });*/

	$(document).on('click', '#dropdown #showPassword', function () {
		$('#linkPass').slideToggle(OC.menuSpeed);
		if (!$('#showPassword').is(':checked')) {
			var shareId = $('#linkCheckbox').data('id');
			var $loading = $('#showPassword .icon-loading-small');

			$loading.removeClass('hidden');
			$.ajax({
				url: OC.linkToOCS('apps/files_sharing/api/v1', 2) + 'shares/' + shareId +
				'?format=json',
				type: 'PUT',
				data: {
					password: null
				}
			}).done(function () {
				$loading.addClass('hidden');
				$('#linkPassText').attr('placeholder',
					t('core', 'Choose a password for the public link'));
			});
		} else {
			$('#linkPassText').focus();
		}
	});

	$(document).on('focusout keyup', '#dropdown #linkPassText', function (event) {
		var linkPassText = $('#linkPassText');
		if (linkPassText.val() != '' && (event.type == 'focusout' || event.keyCode == 13)) {
			var dropDown = $('#dropdown');
			var $loading = dropDown.find('#linkPass .icon-loading-small');
			var shareId = $('#linkCheckbox').data('id');

			$loading.removeClass('hidden');
			$.ajax({
				url: OC.linkToOCS('apps/files_sharing/api/v1', 2) + 'shares/' + shareId +
				'?format=json',
				type: 'PUT',
				data: {
					password: $('#linkPassText').val()
				}
			}).done(function (data) {
				$loading.addClass('hidden');
				linkPassText.val('');
				linkPassText.attr('placeholder', t('core', 'Password protected'));

				if (oc_appconfig.core.enforcePasswordForPublicLink) {
					Gallery.Share.showLink(data.id, data.token, ""password set"");
				}
			}).fail(function (xhr) {
				var result = xhr.responseJSON;
				$loading.addClass('hidden');
				linkPassText.val('');
				linkPassText.attr('placeholder', result.data.message);
			});
		}
	});

	$(document).on('click', '#dropdown #expirationCheckbox', function () {
		if (this.checked) {
			Gallery.Share.showExpirationDate('');
		} else {
			var shareId = $('#linkCheckbox').data('id');
			$.ajax({
				url: OC.linkToOCS('apps/files_sharing/api/v1', 2) + 'shares/' + shareId +
				'?format=json',
				type: 'PUT',
				data: {
					expireDate: ''
				}
			}).done(function () {
				$('#expirationDate').slideUp(OC.menuSpeed);
				if (oc_appconfig.core.defaultExpireDateEnforced === false) {
					$('#defaultExpireMessage').slideDown(OC.menuSpeed);
				}
			}).fail(function () {
				OC.dialogs.alert(t('core', 'Error unsetting expiration date'),
					t('core', 'Error'));
			});
		}
	});

	$(document).on('change', '#dropdown #expirationDate', function () {
		var shareId = $('#linkCheckbox').data('id');

		$(this).tooltip('hide');
		$(this).removeClass('error');

		$.ajax({
			url: OC.linkToOCS('apps/files_sharing/api/v1', 2) + 'shares/' + shareId +
			'?format=json',
			type: 'PUT',
			data: {
				expireDate: $(this).val()
			}
		}).done(function () {
			if (oc_appconfig.core.defaultExpireDateEnforced === 'no') {
				$('#defaultExpireMessage').slideUp(OC.menuSpeed);
			}
		}).fail(function (xhr) {
			var result = xhr.responseJSON;
			var expirationDateField = $('#dropdown #expirationDate');
			if (result && !result.ocs.meta.message) {
				expirationDateField.attr('original-title',
					t('core', 'Error setting expiration date'));
			} else {
				expirationDateField.attr('original-title', result.ocs.meta.message);
			}
			expirationDateField.tooltip({placement: 'top'});
			expirationDateField.tooltip('show');
			expirationDateField.addClass('error');
		});
	});


	// FIXME Emailing links is not supported in Gallery
	/*$(document).on('submit', '#dropdown #emailPrivateLink', function (event) {
	 event.preventDefault();
	 var link = $('#linkText').val();
	 var itemType = $('#dropdown').data('item-type');
	 var itemSource = $('#dropdown').data('item-source');
	 var file = $('tr').filterAttr('data-id', String(itemSource)).data('file');
	 var email = $('#email').val();
	 var expirationDate = '';
	 if ($('#expirationCheckbox').is(':checked') === true) {
	 expirationDate = $(""#expirationDate"").val();
	 }
	 if (email != '') {
	 $('#email').prop('disabled', true);
	 $('#email').val(t('core', 'Sending ...'));
	 $('#emailButton').prop('disabled', true);

	 $.post(OC.filePath('core', 'ajax', 'share.php'), {
	 action: 'email',
	 toaddress: email,
	 link: link,
	 itemType: itemType,
	 itemSource: itemSource,
	 file: file,
	 expiration: expirationDate
	 },
	 function (result) {
	 $('#email').prop('disabled', false);
	 $('#emailButton').prop('disabled', false);
	 if (result && result.status == 'success') {
	 $('#email').css('font-weight', 'bold').val(t('core', 'Email sent'));
	 setTimeout(function () {
	 $('#email').css('font-weight', 'normal').val('');
	 }, 2000);
	 } else {
	 OC.dialogs.alert(result.data.message, t('core', 'Error while sharing'));
	 }
	 });
	 }
	 });*/

	// FIXME Emailing links is not supported in Gallery
	/*$(document).on('click', '#dropdown input[name=mailNotification]', function () {
	 var $li = $(this).closest('li');
	 var itemType = $('#dropdown').data('item-type');
	 var itemSource = $('#dropdown').data('item-source');
	 var action = '';
	 if (this.checked) {
	 action = 'informRecipients';
	 } else {
	 action = 'informRecipientsDisabled';
	 }

	 var shareType = $li.data('share-type');
	 var shareWith = $li.attr('data-share-with');

	 $.post(OC.filePath('core', 'ajax', 'share.php'), {
	 action: action,
	 recipient: shareWith,
	 shareType: shareType,
	 itemSource: itemSource,
	 itemType: itemType
	 }, function (result) {
	 if (result.status !== 'success') {
	 OC.dialogs.alert(t('core', result.data.message), t('core', 'Warning'));
	 }
	 });

	 });*/
});
","/* global Gallery, escapeHTML */

(function ($, Gallery) {
	""use strict"";

	/**
	 * @typedef {Object} Gallery.Share.Types.ShareInfo
	 * @property {Number} share_type
	 * @property {Number} permissions
	 * @property {Number} file_source optional
	 * @property {Number} item_source
	 * @property {String} token
	 * @property {String} share_with
	 * @property {String} share_with_displayname
	 * @property {String} mail_send
	 * @property {String} displayname_file_owner
	 * @property {String} displayname_owner
	 * @property {String} uid_owner
	 * @property {String} uid_file_owner
	 * @property {String} expiration optional
	 * @property {Number} stime
	 */

	// copied and stripped out from the old core
	var Share = {
		SHARE_TYPE_USER: 0,
		SHARE_TYPE_GROUP: 1,
		SHARE_TYPE_LINK: 3,
		SHARE_TYPE_EMAIL: 4,
		SHARE_TYPE_REMOTE: 6,

		/**
		 * @deprecated use OC.Share.currentShares instead
		 */
		itemShares: [],

		/**
		 * Shares for the currently selected file.
		 * (for which the dropdown is open)
		 *
		 * Key is item type and value is an array or
		 * shares of the given item type.
		 */
		currentShares: {},

		/**
		 * Whether the share dropdown is opened.
		 */
		droppedDown: false,

		/**
		 *
		 * @param path {String} path to the file/folder which should be shared
		 * @param shareType {Number} 0 = user; 1 = group; 3 = public link; 6 = federated cloud
		 *     share
		 * @param shareWith {String} user / group id with which the file should be shared
		 * @param publicUpload {Boolean} allow public upload to a public shared folder
		 * @param password {String} password to protect public link Share with
		 * @param permissions {Number} 1 = read; 2 = update; 4 = create; 8 = delete; 16 = share; 31
		 *     = all (default: 31, for public shares: 1)
		 * @param callback {Function} method to call back after a successful share creation
		 * @param errorCallback {Function} method to call back after a failed share creation
		 *
		 * @returns {*}
		 */
		share: function (path, shareType, shareWith, publicUpload, password, permissions, callback, errorCallback) {
			return $.ajax({
				url: OC.linkToOCS('apps/files_sharing/api/v1', 2) + 'shares' + '?format=json',
				type: 'POST',
				data: {
					path: path,
					shareType: shareType,
					shareWith: shareWith,
					publicUpload: publicUpload,
					password: password,
					permissions: permissions
				},
				dataType: 'json'
			}).done(function (result) {
				if (callback) {
					callback(result.ocs.data);
				}
			}).fail(function (xhr) {
				var result = xhr.responseJSON;
				if (_.isFunction(errorCallback)) {
					errorCallback(result);
				} else {
					var msg = t('core', 'Error');
					if (result.ocs && result.ocs.meta.message) {
						msg = result.ocs.meta.message;
					}
					OC.dialogs.alert(msg, t('core', 'Error while sharing'));
				}
			});
		},
		/**
		 *
		 * @param {Number} shareId
		 * @param {Function} callback
		 */
		unshare: function (shareId, callback) {
			$.ajax({
				url: OC.linkToOCS('apps/files_sharing/api/v1', 2) + 'shares/' + shareId +
				'?format=json',
				type: 'DELETE'
			}).done(function () {
				if (callback) {
					callback();
				}
			}).fail(function () {
				OC.dialogs.alert(t('core', 'Error while unsharing'), t('core', 'Error'));

			});
		},
		/**
		 *
		 * @param {Number} shareId
		 * @param {Number} permissions
		 */
		setPermissions: function (shareId, permissions) {
			$.ajax({
				url: OC.linkToOCS('apps/files_sharing/api/v1', 2) + 'shares/' + shareId +
				'?format=json',
				type: 'PUT',
				data: {
					permissions: permissions
				}
			}).fail(function () {
				OC.dialogs.alert(t('core', 'Error while changing permissions'),
					t('core', 'Error'));
			});
		},
		/**
		 *
		 * @param {String} itemType
		 * @param {String} path
		 * @param {String} appendTo
		 * @param {String} link
		 * @param {Number} possiblePermissions
		 * @param {String} filename
		 */
		showDropDown: function (itemType, path, appendTo, link, possiblePermissions, filename) {
			// This is a sync AJAX request on the main thread...
			var data = this._loadShares(path);
			var dropDownEl;
			var self = this;
			var html = '<div id=""dropdown"" class=""drop shareDropDown"" data-item-type=""' + escapeHTML(itemType) +
				'"" data-item-source=""' + escapeHTML(path) + '"">';
			if (data !== false && data[0] && !_.isUndefined(data[0].uid_file_owner) &&
				data[0].uid_file_owner !== OC.currentUser
			) {
				html += '<span class=""reshare"">';
				if (oc_config.enable_avatars === true) {
					html += '<div class=""avatar""></div>';
				}

				if (data[0].share_type == this.SHARE_TYPE_GROUP) {
					html += t('core', 'Shared with you and the group {group} by {owner}', {
						group: data[0].share_with,
						owner: data[0].displayname_owner
					});
				} else {
					html += t('core', 'Shared with you by {owner}',
						{owner: data[0].displayname_owner});
				}
				html += '</span><br />';
				// reduce possible permissions to what the original share allowed
				possiblePermissions = possiblePermissions & data[0].permissions;
			}

			if (possiblePermissions & OC.PERMISSION_SHARE) {
				// Determine the Allow Public Upload status.
				// Used later on to determine if the
				// respective checkbox should be checked or
				// not.
				// FIXME public uploading is not supported in Gallery
				/*var publicUploadEnabled = $('#filestable').data('allow-public-upload');
				 if (typeof publicUploadEnabled == 'undefined') {
				 publicUploadEnabled = 'no';
				 }
				 var allowPublicUploadStatus = false;

				 $.each(data, function (key, value) {
				 if (value.share_type === self.SHARE_TYPE_LINK) {
				 allowPublicUploadStatus =
				 (value.permissions & OC.PERMISSION_CREATE) ? true : false;
				 return true;
				 }
				 });*/

				var sharePlaceholder = t('core', 'Share with users or groups …');
				if (oc_appconfig.core.remoteShareAllowed) {
					sharePlaceholder = t('core', 'Share with users, groups or remote users …');
				}

				html += '<label for=""shareWith"" class=""hidden-visually"">' + t('core', 'Share') +
					'</label>';
				html +=
					'<input id=""shareWith"" type=""text"" placeholder=""' + sharePlaceholder + '"" />';
				if (oc_appconfig.core.remoteShareAllowed) {
					var federatedCloudSharingDoc =
						'<a target=""_blank"" class=""icon-info svg shareWithRemoteInfo"" ' +
						'href=""{docLink}"" title=""' + t('core',
							'Share with people on other ownClouds using the syntax username@example.com/owncloud') +
						'""></a>';
					html += federatedCloudSharingDoc.replace('{docLink}',
						oc_appconfig.core.federatedCloudShareDoc);
				}
				html += '<span class=""shareWithLoading icon-loading-small hidden""></span>';
				html += '<ul id=""shareWithList"">';
				html += '</ul>';
				var linksAllowed = $('#allowShareWithLink').val() === 'yes';
				if (link && linksAllowed) {
					html += '<div id=""link"" class=""linkShare"">';
					html += '<span class=""icon-loading-small hidden""></span>';
					html +=
						'<input type=""checkbox"" class=""checkbox checkbox--right"" ' +
						'name=""linkCheckbox"" id=""linkCheckbox"" value=""1"" />' +
						'<label for=""linkCheckbox"">' + t('core', 'Share link') + '</label>';
					html += '<br />';

					var defaultExpireMessage = '';
					if ((itemType === 'folder' || itemType === 'file') &&
						oc_appconfig.core.defaultExpireDateEnforced) {
						defaultExpireMessage =
							t('core',
								'The public link will expire no later than {days} days after it is created',
								{'days': oc_appconfig.core.defaultExpireDate}) + '<br/>';
					}

					html += '<label for=""linkText"" class=""hidden-visually"">' + t('core', 'Link') +
						'</label>';
					html += '<input id=""linkText"" type=""text"" readonly=""readonly"" />';
					html +=
						'<input type=""checkbox"" class=""checkbox checkbox--right"" ' +
						'name=""showPassword"" id=""showPassword"" value=""1"" />' +
						'<label for=""showPassword"" style=""display:none;"">' +
						t('core', 'Password protect') + '</label>';
					html += '<div id=""linkPass"">';
					html += '<label for=""linkPassText"" class=""hidden-visually"">' +
						t('core', 'Password') + '</label>';
					html += '<input id=""linkPassText"" type=""password"" placeholder=""' +
						t('core', 'Choose a password for the public link') + '"" />';
					html += '<span class=""icon-loading-small hidden""></span>';
					html += '</div>';

					// FIXME public uploading is not supported in Gallery
					/*if (itemType === 'folder' && (possiblePermissions & OC.PERMISSION_CREATE) &&
					 publicUploadEnabled === 'yes') {
					 html += '<div id=""allowPublicUploadWrapper"" style=""display:none;"">';
					 html += '<span class=""icon-loading-small hidden""></span>';
					 html +=
					 '<input type=""checkbox"" class=""checkbox checkbox--right"" value=""1"" name=""allowPublicUpload"" id=""sharingDialogAllowPublicUpload""' +
					 ((allowPublicUploadStatus) ? 'checked=""checked""' : '') + ' />';
					 html += '<label for=""sharingDialogAllowPublicUpload"">' +
					 t('core', 'Allow editing') + '</label>';
					 html += '</div>';
					 }
					 html += '</div>';
					 var mailPublicNotificationEnabled = $(
					 'input:hidden[name=mailPublicNotificationEnabled]').val();
					 if (mailPublicNotificationEnabled === 'yes') {
					 html += '<form id=""emailPrivateLink"">';
					 html +=
					 '<input id=""email"" style=""display:none; width:62%;"" value="""" placeholder=""' +
					 t('core', 'Email link to person') + '"" type=""text"" />';
					 html +=
					 '<input id=""emailButton"" style=""display:none;"" type=""submit"" value=""' +
					 t('core', 'Send') + '"" />';
					 html += '</form>';
					 }*/
				}

				html += '<div id=""expiration"">';
				html +=
					'<input type=""checkbox"" class=""checkbox checkbox--right"" ' +
					'name=""expirationCheckbox"" id=""expirationCheckbox"" value=""1"" />' +
					'<label for=""expirationCheckbox"">' +
					t('core', 'Set expiration date') + '</label>';
				html += '<label for=""expirationDate"" class=""hidden-visually"">' +
					t('core', 'Expiration') + '</label>';
				html += '<input id=""expirationDate"" type=""text"" placeholder=""' +
					t('core', 'Expiration date') + '"" style=""display:none; width:90%;"" />';
				html += '<em id=""defaultExpireMessage"">' + defaultExpireMessage + '</em>';
				html += '</div>';
				dropDownEl = $(html);
				dropDownEl = dropDownEl.appendTo(appendTo);

				// trigger remote share info tooltip
				if (oc_appconfig.core.remoteShareAllowed) {
					$('.shareWithRemoteInfo').tooltip({placement: 'top'});
				}

				//Get owner avatars
				if (oc_config.enable_avatars === true && data !== false && data[0] !== false &&
					!_.isUndefined(data[0]) && !_.isUndefined(data[0].uid_file_owner)) {
					dropDownEl.find("".avatar"").avatar(data[0].uid_file_owner, 32);
				}

				// Reset item shares
				this.itemShares = [];
				this.currentShares = {};
				if (data) {
					$.each(data, function (index, share) {
						if (share.share_type === self.SHARE_TYPE_LINK) {
							self.showLink(share.id, share.token, share.share_with);
						} else {
							if (share.share_with !== OC.currentUser) {
								if (share.share_type === self.SHARE_TYPE_REMOTE) {
									self._addShareWith(share.id,
										share.share_type,
										share.share_with,
										share.share_with_displayname,
										share.permissions,
										OC.PERMISSION_READ | OC.PERMISSION_UPDATE |
										OC.PERMISSION_CREATE,
										share.mail_send,
										false);
								} else {
									self._addShareWith(share.id,
										share.share_type,
										share.share_with,
										share.share_with_displayname,
										share.permissions,
										possiblePermissions,
										share.mail_send,
										false);
								}
							}
						}
						if (share.expiration != null) {
							var expireDate = moment(share.expiration, 'YYYY-MM-DD').format(
								'DD-MM-YYYY');
							self.showExpirationDate(expireDate, share.stime);
						}
					});
				}
				$('#shareWith').autocomplete({
					minLength: 2,
					delay: 750,
					source: function (search, response) {
						var $loading = $('#dropdown .shareWithLoading');
						$loading.removeClass('hidden');
						// Can be replaced with Sharee API
						// https://github.com/owncloud/core/pull/18234
						$.get(OC.filePath('core', 'ajax', 'share.php'), {
							fetch: 'getShareWith',
							search: search.term.trim(),
							limit: 200,
							itemShares: this.itemShares,
							itemType: itemType
						}, function (result) {
							$loading.addClass('hidden');
							if (result.status == 'success' && result.data.length > 0) {
								$(""#shareWith"").autocomplete(""option"", ""autoFocus"", true);
								response(result.data);
							} else {
								response();
							}
						}).fail(function () {
							$('#dropdown').find('.shareWithLoading').addClass('hidden');
							OC.Notification.show(t('core', 'An error occured. Please try again'));
							window.setTimeout(OC.Notification.hide, 5000);
						});
					},
					focus: function (event) {
						event.preventDefault();
					},
					select: function (event, selected) {
						event.stopPropagation();
						var $dropDown = $('#dropdown');
						var itemSource = $dropDown.data('item-source');
						var expirationDate = '';
						if ($('#expirationCheckbox').is(':checked') === true) {
							expirationDate = $(""#expirationDate"").val();
						}
						var shareType = selected.item.value.shareType;
						var shareWith = selected.item.value.shareWith;
						$(this).val(shareWith);
						// Default permissions are Edit (CRUD) and Share
						// Check if these permissions are possible
						var permissions = OC.PERMISSION_READ;
						if (shareType === Gallery.Share.SHARE_TYPE_REMOTE) {
							permissions =
								OC.PERMISSION_CREATE | OC.PERMISSION_UPDATE | OC.PERMISSION_READ;
						} else {
							if (possiblePermissions & OC.PERMISSION_UPDATE) {
								permissions = permissions | OC.PERMISSION_UPDATE;
							}
							if (possiblePermissions & OC.PERMISSION_CREATE) {
								permissions = permissions | OC.PERMISSION_CREATE;
							}
							if (possiblePermissions & OC.PERMISSION_DELETE) {
								permissions = permissions | OC.PERMISSION_DELETE;
							}
							if (oc_appconfig.core.resharingAllowed &&
								(possiblePermissions & OC.PERMISSION_SHARE)) {
								permissions = permissions | OC.PERMISSION_SHARE;
							}
						}

						var $input = $(this);
						var $loading = $dropDown.find('.shareWithLoading');
						$loading.removeClass('hidden');
						$input.val(t('core', 'Adding user...'));
						$input.prop('disabled', true);
						Gallery.Share.share(
							itemSource,
							shareType,
							shareWith,
							0,
							null,
							permissions,
							function (data) {
								var posPermissions = possiblePermissions;
								if (shareType === Gallery.Share.SHARE_TYPE_REMOTE) {
									posPermissions = permissions;
								}
								Gallery.Share._addShareWith(data.id, shareType, shareWith,
									selected.item.label,
									permissions, posPermissions);
							});
						$input.prop('disabled', false);
						$loading.addClass('hidden');
						$('#shareWith').val('');
						return false;
					}
				}).data(""ui-autocomplete"")._renderItem = function (ul, item) {
					// customize internal _renderItem function to display groups and users
					// differently
					var insert = $(""<a>"");
					var text = item.label;
					if (item.value.shareType === Gallery.Share.SHARE_TYPE_GROUP) {
						text = text + ' (' + t('core', 'group') + ')';
					} else if (item.value.shareType === Gallery.Share.SHARE_TYPE_REMOTE) {
						text = text + ' (' + t('core', 'remote') + ')';
					}
					insert.text(text);
					if (item.value.shareType === Gallery.Share.SHARE_TYPE_GROUP) {
						insert = insert.wrapInner('<strong></strong>');
					}
					return $(""<li>"")
						.addClass(
							(item.value.shareType ===
							Gallery.Share.SHARE_TYPE_GROUP) ? 'group' : 'user')
						.append(insert)
						.appendTo(ul);
				};
				// FIXME Emailing links is not supported in Gallery
				/*if (link && linksAllowed && $('#email').length != 0) {
				 $('#email').autocomplete({
				 minLength: 1,
				 source: function (search, response) {
				 $.get(OC.filePath('core', 'ajax', 'share.php'), {
				 fetch: 'getShareWithEmail',
				 search: search.term
				 }, function (result) {
				 if (result.status == 'success' && result.data.length > 0) {
				 response(result.data);
				 }
				 });
				 },
				 select: function (event, item) {
				 $('#email').val(item.item.email);
				 return false;
				 }
				 })
				 .data(""ui-autocomplete"")._renderItem = function (ul, item) {
				 return $('<li>')
				 .append('<a>' + escapeHTML(item.displayname) + ""<br>"" +
				 escapeHTML(item.email) + '</a>')
				 .appendTo(ul);
				 };
				 }*/

			} else {
				html += '<input id=""shareWith"" type=""text"" placeholder=""' +
					t('core', 'Resharing is not allowed') +
					'"" style=""width:90%;"" disabled=""disabled""/>';
				html += '</div>';
				dropDownEl = $(html);
				dropDownEl.appendTo(appendTo);
			}
			dropDownEl.attr('data-item-source-name', filename);
			$('#dropdown').slideDown(OC.menuSpeed, function () {
				Gallery.Share.droppedDown = true;
			});
			if ($('html').hasClass('lte9')) {
				$('#dropdown input[placeholder]').placeholder();
			}
			$('#shareWith').focus();
		},
		/**
		 *
		 * @param callback
		 */
		hideDropDown: function (callback) {
			this.currentShares = null;
			$('#dropdown').slideUp(OC.menuSpeed, function () {
				Gallery.Share.droppedDown = false;
				$('#dropdown').remove();
				if (typeof FileActions !== 'undefined') {
					$('tr').removeClass('mouseOver');
				}
				if (callback) {
					callback.call();
				}
			});
		},
		/**
		 *
		 * @param id
		 * @param token
		 * @param password
		 */
		showLink: function (id, token, password) {
			var $linkCheckbox = $('#linkCheckbox');
			this.itemShares[this.SHARE_TYPE_LINK] = true;
			$linkCheckbox.attr('checked', true);
			$linkCheckbox.attr('data-id', id);
			var $linkText = $('#linkText');

			var link = parent.location.protocol + '//' + location.host +
				OC.generateUrl('/apps/' + Gallery.appName + '/s/') + token;

			$linkText.val(link);
			$linkText.slideDown(OC.menuSpeed);
			$linkText.css('display', 'block');
			if (oc_appconfig.core.enforcePasswordForPublicLink === false || password === null) {
				$('#showPassword+label').show();
			}
			if (password != null) {
				$('#linkPass').slideDown(OC.menuSpeed);
				$('#showPassword').attr('checked', true);
				$('#linkPassText').attr('placeholder', '**********');
			}
			$('#expiration').show();
			$('#emailPrivateLink #email').show();
			$('#emailPrivateLink #emailButton').show();
			$('#allowPublicUploadWrapper').show();
		},
		/**
		 *
		 */
		hideLink: function () {
			$('#linkText').slideUp(OC.menuSpeed);
			$('#defaultExpireMessage').hide();
			$('#showPassword+label').hide();
			$('#linkPass').slideUp(OC.menuSpeed);
			$('#emailPrivateLink #email').hide();
			$('#emailPrivateLink #emailButton').hide();
			$('#allowPublicUploadWrapper').hide();
		},
		/**
		 * Displays the expiration date field
		 *
		 * @param {String} date current expiration date
		 * @param {Date|Number|String} [shareTime] share timestamp in seconds, defaults to now
		 */
		showExpirationDate: function (date, shareTime) {
			var $expirationDate = $('#expirationDate');
			var $expirationCheckbox = $('#expirationCheckbox');
			var now = new Date();
			// min date should always be the next day
			var minDate = new Date();
			minDate.setDate(minDate.getDate() + 1);
			var datePickerOptions = {
				minDate: minDate,
				maxDate: null
			};
			// TODO: hack: backend returns string instead of integer
			shareTime = this._parseTime(shareTime);
			if (_.isNumber(shareTime)) {
				shareTime = new Date(shareTime * 1000);
			}
			if (!shareTime) {
				shareTime = now;
			}
			$expirationCheckbox.attr('checked', true);
			$expirationDate.val(date);
			$expirationDate.slideDown(OC.menuSpeed);
			$expirationDate.css('display', 'block');
			$expirationDate.datepicker({
				dateFormat: 'dd-mm-yy'
			});
			if (oc_appconfig.core.defaultExpireDateEnforced) {
				$expirationCheckbox.attr('disabled', true);
				shareTime = OC.Util.stripTime(shareTime).getTime();
				// max date is share date + X days
				datePickerOptions.maxDate =
					new Date(shareTime + oc_appconfig.core.defaultExpireDate * 24 * 3600 * 1000);
			}
			if (oc_appconfig.core.defaultExpireDateEnabled) {
				$('#defaultExpireMessage').slideDown(OC.menuSpeed);
			}
			$.datepicker.setDefaults(datePickerOptions);
		},
		/**
		 * Get the default Expire date
		 *
		 * @return {String} The expire date
		 */
		getDefaultExpirationDate: function () {
			var expireDateString = '';
			if (oc_appconfig.core.defaultExpireDateEnabled) {
				var date = new Date().getTime();
				var expireAfterMs = oc_appconfig.core.defaultExpireDate * 24 * 60 * 60 * 1000;
				var expireDate = new Date(date + expireAfterMs);
				var month = expireDate.getMonth() + 1;
				var year = expireDate.getFullYear();
				var day = expireDate.getDate();
				expireDateString = year + ""-"" + month + '-' + day + ' 00:00:00';
			}
			return expireDateString;
		},
		/**
		 * Loads all shares associated with a path
		 *
		 * @param path
		 *
		 * @returns {Gallery.Share.Types.ShareInfo|Boolean}
		 * @private
		 */
		_loadShares: function (path) {
			var data = false;
			var url = OC.linkToOCS('apps/files_sharing/api/v1', 2) + 'shares' + '?format=json';
			$.ajax({
				url: url,
				type: 'GET',
				data: {
					path: path,
					shared_with_me: true
				},
				async: false
			}).done(function (result) {
				data = result.ocs.data;
				$.ajax({
					url: url,
					type: 'GET',
					data: {
						path: path,
						reshares: true
					},
					async: false
				}).done(function (result) {
					data = _.union(data, result.ocs.data);
				})

			});

			if (data === false) {
				OC.dialogs.alert(t('gallery', 'Error while retrieving shares'),
					t('core', 'Error'));
			}

			return data;
		},
		/**
		 *
		 * @param shareId
		 * @param shareType
		 * @param shareWith
		 * @param shareWithDisplayName
		 * @param permissions
		 * @param possiblePermissions
		 * @param mailSend
		 *
		 * @private
		 */
		_addShareWith: function (shareId, shareType, shareWith, shareWithDisplayName, permissions, possiblePermissions, mailSend) {
			var shareItem = {
				share_id: shareId,
				share_type: shareType,
				share_with: shareWith,
				share_with_displayname: shareWithDisplayName,
				permissions: permissions
			};
			if (shareType === this.SHARE_TYPE_GROUP) {
				shareWithDisplayName = shareWithDisplayName + "" ("" + t('core', 'group') + ')';
			}
			if (shareType === this.SHARE_TYPE_REMOTE) {
				shareWithDisplayName = shareWithDisplayName + "" ("" + t('core', 'remote') + ')';
			}
			if (!this.itemShares[shareType]) {
				this.itemShares[shareType] = [];
			}
			this.itemShares[shareType].push(shareWith);

			var editChecked = '',
				createChecked = '',
				updateChecked = '',
				deleteChecked = '',
				shareChecked = '';
			if (permissions & OC.PERMISSION_CREATE) {
				createChecked = 'checked=""checked""';
				editChecked = 'checked=""checked""';
			}
			if (permissions & OC.PERMISSION_UPDATE) {
				updateChecked = 'checked=""checked""';
				editChecked = 'checked=""checked""';
			}
			if (permissions & OC.PERMISSION_DELETE) {
				deleteChecked = 'checked=""checked""';
				editChecked = 'checked=""checked""';
			}
			if (permissions & OC.PERMISSION_SHARE) {
				shareChecked = 'checked=""checked""';
			}
			var html = '<li style=""clear: both;"" ' +
				'data-id=""' + escapeHTML(shareId) + '""' +
				'data-share-type=""' + escapeHTML(shareType) + '""' +
				'data-share-with=""' + escapeHTML(shareWith) + '""' +
				'title=""' + escapeHTML(shareWith) + '"">';
			var showCrudsButton;
			html +=
				'<a href=""#"" class=""unshare""><img class=""svg"" alt=""' + t('core', 'Unshare') +
				'"" title=""' + t('core', 'Unshare') + '"" src=""' +
				OC.imagePath('core', 'actions/delete') + '""/></a>';
			if (oc_config.enable_avatars === true) {
				html += '<div class=""avatar""></div>';
			}
			html += '<span class=""username"">' + escapeHTML(shareWithDisplayName) + '</span>';
			var mailNotificationEnabled = $('input:hidden[name=mailNotificationEnabled]').val();
			if (mailNotificationEnabled === 'yes' &&
				shareType !== this.SHARE_TYPE_REMOTE) {
				var checked = '';
				if (mailSend === '1') {
					checked = 'checked';
				}
				html +=
					'<input type=""checkbox"" class=""checkbox checkbox--right"" ' +
					'name=""mailNotification"" class=""mailNotification"" ' +
					checked + ' />';
				html +=
					'<label>' + t('core', 'notify by email') + '</label>';
			}
			if (oc_appconfig.core.resharingAllowed &&
				(possiblePermissions & OC.PERMISSION_SHARE)) {
				html += '<input id=""canShare-' + escapeHTML(shareWith) +
					'"" type=""checkbox"" class=""permissions checkbox checkbox--right"" name=""share"" ' +
					shareChecked + ' data-permissions=""' + OC.PERMISSION_SHARE + '"" />';
				html += '<label for=""canShare-' + escapeHTML(shareWith) + '"">' +
					t('core', 'can share') + '</label>';
			}
			if (possiblePermissions & OC.PERMISSION_CREATE ||
				possiblePermissions & OC.PERMISSION_UPDATE ||
				possiblePermissions & OC.PERMISSION_DELETE) {
				html += '<input id=""canEdit-' + escapeHTML(shareWith) +
					'"" type=""checkbox"" class=""permissions checkbox checkbox--right"" name=""edit"" ' +
					editChecked + ' />';
				html += '<label for=""canEdit-' + escapeHTML(shareWith) + '"">' +
					t('core', 'can edit') + '</label>';
			}
			if (shareType !== this.SHARE_TYPE_REMOTE) {
				showCrudsButton = '<a href=""#"" class=""showCruds""><img class=""svg"" alt=""' +
					t('core', 'access control') + '"" src=""' +
					OC.imagePath('core', 'actions/triangle-s') + '""/></a>';
			}
			html += '<div class=""cruds"" style=""display:none;"">';
			if (possiblePermissions & OC.PERMISSION_CREATE) {
				html += '<input id=""canCreate-' + escapeHTML(shareWith) +
					'"" type=""checkbox"" class=""permissions checkbox checkbox--right"" name=""create"" ' +
					createChecked + ' data-permissions=""' + OC.PERMISSION_CREATE + '""/>';
				html += '<label for=""canCreate-' + escapeHTML(shareWith) + '"">' +
					t('core', 'create') + '</label>';
			}
			if (possiblePermissions & OC.PERMISSION_UPDATE) {
				html += '<input id=""canUpdate-' + escapeHTML(shareWith) +
					'"" type=""checkbox"" class=""permissions checkbox checkbox--right"" name=""update"" ' +
					updateChecked + ' data-permissions=""' + OC.PERMISSION_UPDATE + '""/>';
				html += '<label for=""canUpdate-' + escapeHTML(shareWith) + '"">' +
					t('core', 'change') + '</label>';
			}
			if (possiblePermissions & OC.PERMISSION_DELETE) {
				html += '<input id=""canDelete-' + escapeHTML(shareWith) +
					'"" type=""checkbox"" class=""permissions checkbox checkbox--right"" name=""delete"" ' +
					deleteChecked + ' data-permissions=""' + OC.PERMISSION_DELETE + '""/>';
				html += '<label for=""canDelete-' + escapeHTML(shareWith) + '"">' +
					t('core', 'delete') + '</label>';
			}
			html += '</div>';
			html += '</li>';
			html = $(html).appendTo('#shareWithList');
			if (oc_config.enable_avatars === true) {
				if (shareType === this.SHARE_TYPE_USER) {
					html.find('.avatar').avatar(escapeHTML(shareWith), 32);
				} else {
					//Add sharetype to generate different seed if there is a group and use with
					// the same name
					html.find('.avatar').imageplaceholder(
						escapeHTML(shareWith) + ' ' + shareType);
				}
			}
			// insert cruds button into last label element
			var lastLabel = html.find('>label:last');
			if (lastLabel.exists()) {
				lastLabel.append(showCrudsButton);
			}
			else {
				html.find('.cruds').before(showCrudsButton);
			}
			if (!this.currentShares[shareType]) {
				this.currentShares[shareType] = [];
			}
			this.currentShares[shareType].push(shareItem);
		},
		/**
		 * Parses a string to an valid integer (unix timestamp)
		 * @param time
		 * @returns {*}
		 * @internal Only used to work around a bug in the backend
		 * @private
		 */
		_parseTime: function (time) {
			if (_.isString(time)) {
				// skip empty strings and hex values
				if (time === '' || (time.length > 1 && time[0] === '0' && time[1] === 'x')) {
					return null;
				}
				time = parseInt(time, 10);
				if (isNaN(time)) {
					time = null;
				}
			}
			return time;
		}
	};

	Gallery.Share = Share;
})(jQuery, Gallery);

$(document).ready(function () {

	if (typeof monthNames != 'undefined') {
		// min date should always be the next day
		var minDate = new Date();
		minDate.setDate(minDate.getDate() + 1);
		$.datepicker.setDefaults({
			monthNames: monthNames,
			monthNamesShort: $.map(monthNames, function (v) {
				return v.slice(0, 3) + '.';
			}),
			dayNames: dayNames,
			dayNamesMin: $.map(dayNames, function (v) {
				return v.slice(0, 2);
			}),
			dayNamesShort: $.map(dayNames, function (v) {
				return v.slice(0, 3) + '.';
			}),
			firstDay: firstDay,
			minDate: minDate
		});
	}
	$(document).on('click', 'a.share', function (event) {
		event.stopPropagation();
		if ($(this).data('item-type') !== undefined && $(this).data('path') !== undefined) {
			var itemType = $(this).data('item-type');
			var path = $(this).data('path');
			var appendTo = $(this).parent().parent();
			var link = false;
			var possiblePermissions = $(this).data('possible-permissions');
			if ($(this).data('link') !== undefined && $(this).data('link') == true) {
				link = true;
			}
			if (Gallery.Share.droppedDown) {
				if (path != $('#dropdown').data('path')) {
					Gallery.Share.hideDropDown(function () {
						Gallery.Share.showDropDown(itemType, path, appendTo, link,
							possiblePermissions);
					});
				} else {
					Gallery.Share.hideDropDown();
				}
			} else {
				Gallery.Share.showDropDown(itemType, path, appendTo, link, possiblePermissions);
			}
		}
	});

	$(this).click(function (event) {
		var target = $(event.target);
		var isMatched = !target.is('.drop, .ui-datepicker-next, .ui-datepicker-prev, .ui-icon')
			&& !target.closest('#ui-datepicker-div').length &&
			!target.closest('.ui-autocomplete').length;
		if (Gallery.Share.droppedDown && isMatched &&
			$('#dropdown').has(event.target).length === 0) {
			Gallery.Share.hideDropDown();
		}
	});

	$(document).on('click', '#dropdown .showCruds', function () {
		$(this).closest('li').find('.cruds').toggle();
		return false;
	});

	$(document).on('click', '#dropdown .unshare', function () {
		var $li = $(this).closest('li');
		var shareType = $li.data('share-type');
		var shareWith = $li.attr('data-share-with');
		var shareId = $li.attr('data-id');
		var $button = $(this);

		if (!$button.is('a')) {
			$button = $button.closest('a');
		}

		if ($button.hasClass('icon-loading-small')) {
			// deletion in progress
			return false;
		}
		$button.empty().addClass('icon-loading-small');
		Gallery.Share.unshare(shareId, function () {
			$li.remove();
			var index = Gallery.Share.itemShares[shareType].indexOf(shareWith);
			Gallery.Share.itemShares[shareType].splice(index, 1);
			// updated list of shares
			Gallery.Share.currentShares[shareType].splice(index, 1);
		});

		return false;
	});

	$(document).on('change', '#dropdown .permissions', function () {
		var $li = $(this).closest('li');
		var checkboxes = $('.permissions', $li);
		if ($(this).attr('name') == 'edit') {
			var checked = $(this).is(':checked');
			// Check/uncheck Create, Update, and Delete checkboxes if Edit is checked/unck
			$(checkboxes).filter('input[name=""create""]').attr('checked', checked);
			$(checkboxes).filter('input[name=""update""]').attr('checked', checked);
			$(checkboxes).filter('input[name=""delete""]').attr('checked', checked);
		} else {
			// Uncheck Edit if Create, Update, and Delete are not checked
			if (!$(this).is(':checked')
				&& !$(checkboxes).filter('input[name=""create""]').is(':checked')
				&& !$(checkboxes).filter('input[name=""update""]').is(':checked')
				&& !$(checkboxes).filter('input[name=""delete""]').is(':checked')) {
				$(checkboxes).filter('input[name=""edit""]').attr('checked', false);
				// Check Edit if Create, Update, or Delete is checked
			} else if (($(this).attr('name') == 'create'
				|| $(this).attr('name') == 'update'
				|| $(this).attr('name') == 'delete')) {
				$(checkboxes).filter('input[name=""edit""]').attr('checked', true);
			}
		}
		var permissions = OC.PERMISSION_READ;
		$(checkboxes).filter(':not(input[name=""edit""])').filter(':checked').each(
			function (index, checkbox) {
				permissions |= $(checkbox).data('permissions');
			});

		Gallery.Share.setPermissions($li.attr('data-id'), permissions);
	});

	$(document).on('change', '#dropdown #linkCheckbox', function () {
		var $dropDown = $('#dropdown');
		var path = $dropDown.data('item-source');
		var shareId = $('#linkCheckbox').data('id');
		var shareWith = '';
		var publicUpload = 0;
		var $loading = $dropDown.find('#link .icon-loading-small');
		var $button = $(this);

		if (!$loading.hasClass('hidden')) {
			// already in progress
			return false;
		}

		if (this.checked) {
			// Reset password placeholder
			$('#linkPassText').attr('placeholder',
				t('core', 'Choose a password for the public link'));
			// Reset link
			$('#linkText').val('');
			$('#showPassword').prop('checked', false);
			$('#linkPass').hide();
			$('#sharingDialogAllowPublicUpload').prop('checked', false);
			$('#expirationCheckbox').prop('checked', false);
			$('#expirationDate').hide();
			var expireDateString = '';
			// Create a link
			if (oc_appconfig.core.enforcePasswordForPublicLink === false) {
				expireDateString = Gallery.Share.getDefaultExpirationDate();
				$loading.removeClass('hidden');
				$button.addClass('hidden');
				$button.prop('disabled', true);
				Gallery.Share.share(
					path,
					Gallery.Share.SHARE_TYPE_LINK,
					shareWith,
					publicUpload,
					null,
					OC.PERMISSION_READ,
					function (data) {
						$loading.addClass('hidden');
						$button.removeClass('hidden');
						$button.prop('disabled', false);
						Gallery.Share.showLink(data.id, data.token, null);
					});
			} else {
				$('#linkPass').slideToggle(OC.menuSpeed);
				$('#linkPassText').focus();
			}
			if (expireDateString !== '') {
				Gallery.Share.showExpirationDate(expireDateString);
			}
		} else {
			// Delete private link
			Gallery.Share.hideLink();
			$('#expiration').slideUp(OC.menuSpeed);
			if ($('#linkText').val() !== '') {
				$loading.removeClass('hidden');
				$button.addClass('hidden');
				$button.prop('disabled', true);
				Gallery.Share.unshare(shareId, function () {
					$loading.addClass('hidden');
					$button.removeClass('hidden');
					$button.prop('disabled', false);
					Gallery.Share.itemShares[Gallery.Share.SHARE_TYPE_LINK] = false;
				});
			}
		}
	});

	$(document).on('click', '#dropdown #linkText', function () {
		$(this).focus();
		$(this).select();
	});

	// Handle the Allow Public Upload Checkbox
	// FIXME public uploading is not supported in Gallery
	/*$(document).on('click', '#sharingDialogAllowPublicUpload', function () {

	 // Gather data
	 var $dropDown = $('#dropdown');
	 var allowPublicUpload = $(this).is(':checked');
	 var $button = $(this);
	 var $loading = $dropDown.find('#allowPublicUploadWrapper .icon-loading-small');

	 if (!$loading.hasClass('hidden')) {
	 // already in progress
	 return false;
	 }

	 // Update the share information
	 $button.addClass('hidden');
	 $button.prop('disabled', true);
	 $loading.removeClass('hidden');
	 //(path, shareType, shareWith, publicUpload, password, permissions)
	 $.ajax({
	 url: OC.linkToOCS('apps/files_sharing/api/v1', 2) + 'shares/' + shareId +
	 '?format=json',
	 type: 'PUT',
	 data: {
	 publicUpload: allowPublicUpload
	 }
	 }).done(function () {
	 $loading.addClass('hidden');
	 $button.removeClass('hidden');
	 $button.prop('disabled', false);
	 });
	 });*/

	$(document).on('click', '#dropdown #showPassword', function () {
		$('#linkPass').slideToggle(OC.menuSpeed);
		if (!$('#showPassword').is(':checked')) {
			var shareId = $('#linkCheckbox').data('id');
			var $loading = $('#showPassword .icon-loading-small');

			$loading.removeClass('hidden');
			$.ajax({
				url: OC.linkToOCS('apps/files_sharing/api/v1', 2) + 'shares/' + shareId +
				'?format=json',
				type: 'PUT',
				data: {
					password: null
				}
			}).done(function () {
				$loading.addClass('hidden');
				$('#linkPassText').attr('placeholder',
					t('core', 'Choose a password for the public link'));
			});
		} else {
			$('#linkPassText').focus();
		}
	});

	$(document).on('focusout keyup', '#dropdown #linkPassText', function (event) {
		var linkPassText = $('#linkPassText');
		if (linkPassText.val() != '' && (event.type == 'focusout' || event.keyCode == 13)) {
			var dropDown = $('#dropdown');
			var $loading = dropDown.find('#linkPass .icon-loading-small');
			var shareId = $('#linkCheckbox').data('id');

			$loading.removeClass('hidden');
			$.ajax({
				url: OC.linkToOCS('apps/files_sharing/api/v1', 2) + 'shares/' + shareId +
				'?format=json',
				type: 'PUT',
				data: {
					password: $('#linkPassText').val()
				}
			}).done(function (data) {
				$loading.addClass('hidden');
				linkPassText.val('');
				linkPassText.attr('placeholder', t('core', 'Password protected'));

				if (oc_appconfig.core.enforcePasswordForPublicLink) {
					Gallery.Share.showLink(data.id, data.token, ""password set"");
				}
			}).fail(function (xhr) {
				var result = xhr.responseJSON;
				$loading.addClass('hidden');
				linkPassText.val('');
				linkPassText.attr('placeholder', result.data.message);
			});
		}
	});

	$(document).on('click', '#dropdown #expirationCheckbox', function () {
		if (this.checked) {
			Gallery.Share.showExpirationDate('');
		} else {
			var shareId = $('#linkCheckbox').data('id');
			$.ajax({
				url: OC.linkToOCS('apps/files_sharing/api/v1', 2) + 'shares/' + shareId +
				'?format=json',
				type: 'PUT',
				data: {
					expireDate: ''
				}
			}).done(function () {
				$('#expirationDate').slideUp(OC.menuSpeed);
				if (oc_appconfig.core.defaultExpireDateEnforced === false) {
					$('#defaultExpireMessage').slideDown(OC.menuSpeed);
				}
			}).fail(function () {
				OC.dialogs.alert(t('core', 'Error unsetting expiration date'),
					t('core', 'Error'));
			});
		}
	});

	$(document).on('change', '#dropdown #expirationDate', function () {
		var shareId = $('#linkCheckbox').data('id');

		$(this).tooltip('hide');
		$(this).removeClass('error');

		$.ajax({
			url: OC.linkToOCS('apps/files_sharing/api/v1', 2) + 'shares/' + shareId +
			'?format=json',
			type: 'PUT',
			data: {
				expireDate: $(this).val()
			}
		}).done(function () {
			if (oc_appconfig.core.defaultExpireDateEnforced === 'no') {
				$('#defaultExpireMessage').slideUp(OC.menuSpeed);
			}
		}).fail(function (xhr) {
			var result = xhr.responseJSON;
			var expirationDateField = $('#dropdown #expirationDate');
			if (result && !result.ocs.meta.message) {
				expirationDateField.attr('original-title',
					t('core', 'Error setting expiration date'));
			} else {
				expirationDateField.attr('original-title', result.ocs.meta.message);
			}
			expirationDateField.tooltip({placement: 'top'});
			expirationDateField.tooltip('show');
			expirationDateField.addClass('error');
		});
	});


	// FIXME Emailing links is not supported in Gallery
	/*$(document).on('submit', '#dropdown #emailPrivateLink', function (event) {
	 event.preventDefault();
	 var link = $('#linkText').val();
	 var itemType = $('#dropdown').data('item-type');
	 var itemSource = $('#dropdown').data('item-source');
	 var file = $('tr').filterAttr('data-id', String(itemSource)).data('file');
	 var email = $('#email').val();
	 var expirationDate = '';
	 if ($('#expirationCheckbox').is(':checked') === true) {
	 expirationDate = $(""#expirationDate"").val();
	 }
	 if (email != '') {
	 $('#email').prop('disabled', true);
	 $('#email').val(t('core', 'Sending ...'));
	 $('#emailButton').prop('disabled', true);

	 $.post(OC.filePath('core', 'ajax', 'share.php'), {
	 action: 'email',
	 toaddress: email,
	 link: link,
	 itemType: itemType,
	 itemSource: itemSource,
	 file: file,
	 expiration: expirationDate
	 },
	 function (result) {
	 $('#email').prop('disabled', false);
	 $('#emailButton').prop('disabled', false);
	 if (result && result.status == 'success') {
	 $('#email').css('font-weight', 'bold').val(t('core', 'Email sent'));
	 setTimeout(function () {
	 $('#email').css('font-weight', 'normal').val('');
	 }, 2000);
	 } else {
	 OC.dialogs.alert(result.data.message, t('core', 'Error while sharing'));
	 }
	 });
	 }
	 });*/

	// FIXME Emailing links is not supported in Gallery
	/*$(document).on('click', '#dropdown input[name=mailNotification]', function () {
	 var $li = $(this).closest('li');
	 var itemType = $('#dropdown').data('item-type');
	 var itemSource = $('#dropdown').data('item-source');
	 var action = '';
	 if (this.checked) {
	 action = 'informRecipients';
	 } else {
	 action = 'informRecipientsDisabled';
	 }

	 var shareType = $li.data('share-type');
	 var shareWith = $li.attr('data-share-with');

	 $.post(OC.filePath('core', 'ajax', 'share.php'), {
	 action: action,
	 recipient: shareWith,
	 shareType: shareType,
	 itemSource: itemSource,
	 itemType: itemType
	 }, function (result) {
	 if (result.status !== 'success') {
	 OC.dialogs.alert(t('core', result.data.message), t('core', 'Warning'));
	 }
	 });

	 });*/
});
"
"  'use strict';

var Utils = require('../../utils')
  , SqlString = require('../../sql-string')
  , Model = require('../../model')
  , DataTypes = require('../../data-types')
  , _ = require('lodash')
  , util = require('util')
  , Dottie = require('dottie')
  , BelongsTo = require('../../associations/belongs-to')
  , BelongsToMany = require('../../associations/belongs-to-many')
  , HasMany = require('../../associations/has-many')
  , uuid = require('uuid')
  , semver = require('semver')
  , deprecate = require('depd')('sequelize');

/* istanbul ignore next */
var throwMethodUndefined = function(methodName) {
  throw new Error('The method ""' + methodName + '"" is not defined! Please add it to your sql dialect.');
};

var QueryGenerator = {
  options: {},

  extractTableDetails: function(tableName, options) {
    options = options || {};
    tableName = tableName || {};
    return {
      schema: tableName.schema || options.schema || 'public',
      tableName: _.isPlainObject(tableName) ? tableName.tableName : tableName,
      delimiter: tableName.delimiter || options.delimiter || '.'
    };
  },

  addSchema: function(param) {
    var self = this;

    if (!param.$schema) return param.tableName || param;

    return {
      tableName: param.tableName || param,
      table: param.tableName || param,
      name: param.name || param,
      schema: param.$schema,
      delimiter: param.$schemaDelimiter || '.',
      toString: function() {
        return self.quoteTable(this);
      }
    };
  },

  /*
    Returns a query for dropping a schema
  */
  dropSchema: function(tableName, options) {
    return this.dropTableQuery(tableName, options);
  },

  /*
    Returns a query for creating a table.
    Parameters:
      - tableName: Name of the new table.
      - attributes: An object with containing attribute-attributeType-pairs.
                    Attributes should have the format:
                    {attributeName: type, attr2: type2}
                    --> e.g. {title: 'VARCHAR(255)'}
      - options: An object with options.
                 Defaults: { engine: 'InnoDB', charset: null }
  */
  /* istanbul ignore next */
  createTableQuery: function(tableName, attributes, options) {
    throwMethodUndefined('createTableQuery');
  },

  versionQuery: function(tableName, attributes, options) {
    throwMethodUndefined('versionQuery');
  },

  describeTableQuery: function(tableName, schema, schemaDelimiter) {
    var table = this.quoteTable(
      this.addSchema({
        tableName: tableName,
        $schema: schema,
        $schemaDelimiter: schemaDelimiter
      })
    );

    return 'DESCRIBE ' + table + ';';
  },

  /*
    Returns a query for dropping a table.
  */
  dropTableQuery: function(tableName, options) {
    options = options || {};

    var query = 'DROP TABLE IF EXISTS <%= table %>;';

    return Utils._.template(query)({
      table: this.quoteTable(tableName)
    });
  },

  /*
    Returns a rename table query.
    Parameters:
      - originalTableName: Name of the table before execution.
      - futureTableName: Name of the table after execution.
  */
  renameTableQuery: function(before, after) {
    var query = 'ALTER TABLE <%= before %> RENAME TO <%= after %>;';
    return Utils._.template(query)({
      before: this.quoteTable(before),
      after: this.quoteTable(after)
    });
  },

  /*
    Returns a query, which gets all available table names in the database.
  */
  /* istanbul ignore next */
  showTablesQuery: function() {
    throwMethodUndefined('showTablesQuery');
  },

  /*
    Returns a query, which adds an attribute to an existing table.
    Parameters:
      - tableName: Name of the existing table.
      - attributes: A hash with attribute-attributeOptions-pairs.
        - key: attributeName
        - value: A hash with attribute specific options:
          - type: DataType
          - defaultValue: A String with the default value
          - allowNull: Boolean
  */
  /* istanbul ignore next */
  addColumnQuery: function(tableName, attributes) {
    throwMethodUndefined('addColumnQuery');
  },

  /*
    Returns a query, which removes an attribute from an existing table.
    Parameters:
      - tableName: Name of the existing table
      - attributeName: Name of the obsolete attribute.
  */
  /* istanbul ignore next */
  removeColumnQuery: function(tableName, attributeName) {
    throwMethodUndefined('removeColumnQuery');
  },

  /*
    Returns a query, which modifies an existing attribute from a table.
    Parameters:
      - tableName: Name of the existing table.
      - attributes: A hash with attribute-attributeOptions-pairs.
        - key: attributeName
        - value: A hash with attribute specific options:
          - type: DataType
          - defaultValue: A String with the default value
          - allowNull: Boolean
  */
  /* istanbul ignore next */
  changeColumnQuery: function(tableName, attributes) {
    throwMethodUndefined('changeColumnQuery');
  },

  /*
    Returns a query, which renames an existing attribute.
    Parameters:
      - tableName: Name of an existing table.
      - attrNameBefore: The name of the attribute, which shall be renamed.
      - attrNameAfter: The name of the attribute, after renaming.
  */
  /* istanbul ignore next */
  renameColumnQuery: function(tableName, attrNameBefore, attrNameAfter) {
    throwMethodUndefined('renameColumnQuery');
  },

  /*
    Returns an insert into command. Parameters: table name + hash of attribute-value-pairs.
  */
  insertQuery: function(table, valueHash, modelAttributes, options) {
    options = options || {};
    _.defaults(options, this.options);

    var query
      , valueQuery = '<%= tmpTable %>INSERT<%= ignore %> INTO <%= table %> (<%= attributes %>)<%= output %> VALUES (<%= values %>)'
      , emptyQuery = '<%= tmpTable %>INSERT<%= ignore %> INTO <%= table %><%= output %>'
      , outputFragment
      , fields = []
      , values = []
      , key
      , value
      , identityWrapperRequired = false
      , modelAttributeMap = {}
      , tmpTable = ''         //tmpTable declaration for trigger
      , selectFromTmp = ''    //Select statement for trigger
      , tmpColumns = ''       //Columns for temp table for trigger
      , outputColumns = ''    //Columns to capture into temp table for trigger
      , attribute             //Model attribute holder
      , modelKey;             //key for model

    if (modelAttributes) {
      Utils._.each(modelAttributes, function(attribute, key) {
        modelAttributeMap[key] = attribute;
        if (attribute.field) {
          modelAttributeMap[attribute.field] = attribute;
        }
      });
    }

    if (this._dialect.supports['DEFAULT VALUES']) {
      emptyQuery += ' DEFAULT VALUES';
    } else if (this._dialect.supports['VALUES ()']) {
      emptyQuery += ' VALUES ()';
    }

    if (this._dialect.supports.returnValues && options.returning) {
      if (!!this._dialect.supports.returnValues.returning) {
        valueQuery += ' RETURNING *';
        emptyQuery += ' RETURNING *';
      } else if (!!this._dialect.supports.returnValues.output) {
        outputFragment = ' OUTPUT INSERTED.*';

        //To capture output rows when there is a trigger on MSSQL DB
        if (modelAttributes && options.hasTrigger && this._dialect.supports.tmpTableTrigger) {
            tmpTable = 'declare @tmp table (<%= columns %>); ';

            for (modelKey in modelAttributes){
              attribute = modelAttributes[modelKey];
              if(!(attribute.type instanceof DataTypes.VIRTUAL)){
                if (tmpColumns.length > 0){
                  tmpColumns += ',';
                  outputColumns += ',';
                }

                tmpColumns += this.quoteIdentifier(attribute.field) + ' ' + attribute.type.toSql();
                outputColumns += 'INSERTED.' + this.quoteIdentifier(attribute.field);
              }
            }

            var replacement ={
              columns : tmpColumns
            };

            tmpTable = Utils._.template(tmpTable)(replacement).trim();
            outputFragment = ' OUTPUT ' + outputColumns + ' into @tmp';
            selectFromTmp = ';select * from @tmp';

            valueQuery += selectFromTmp;
            emptyQuery += selectFromTmp;
        }
      }
    }

    if (this._dialect.supports.EXCEPTION && options.exception) {
      // Mostly for internal use, so we expect the user to know what he's doing!
      // pg_temp functions are private per connection, so we never risk this function interfering with another one.
      if (semver.gte(this.sequelize.options.databaseVersion, '9.2.0')) {
        // >= 9.2 - Use a UUID but prefix with 'func_' (numbers first not allowed)
        var delimiter = '$func_' + uuid.v4().replace(/-/g, '') + '$';

        options.exception = 'WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL;';
        valueQuery = 'CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response <%= table %>, OUT sequelize_caught_exception text) RETURNS RECORD AS ' + delimiter +
          ' BEGIN ' + valueQuery + ' INTO response; EXCEPTION ' + options.exception + ' END ' + delimiter +
          ' LANGUAGE plpgsql; SELECT (testfunc.response).*, testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc()';
      } else {
        options.exception = 'WHEN unique_violation THEN NULL;';
        valueQuery = 'CREATE OR REPLACE FUNCTION pg_temp.testfunc() RETURNS SETOF <%= table %> AS $body$ BEGIN RETURN QUERY ' + valueQuery + '; EXCEPTION ' + options.exception + ' END; $body$ LANGUAGE plpgsql; SELECT * FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc();';
      }
    }

    if (this._dialect.supports['ON DUPLICATE KEY'] && options.onDuplicate) {
      valueQuery += ' ON DUPLICATE KEY ' + options.onDuplicate;
      emptyQuery += ' ON DUPLICATE KEY ' + options.onDuplicate;
    }

    valueHash = Utils.removeNullValuesFromHash(valueHash, this.options.omitNull);
    for (key in valueHash) {
      if (valueHash.hasOwnProperty(key)) {
        value = valueHash[key];
        fields.push(this.quoteIdentifier(key));

        // SERIALS' can't be NULL in postgresql, use DEFAULT where supported
        if (modelAttributeMap && modelAttributeMap[key] && modelAttributeMap[key].autoIncrement === true && !value) {
          if (!this._dialect.supports.autoIncrement.defaultValue) {
            fields.splice(-1,1);
          } else if (this._dialect.supports.DEFAULT) {
            values.push('DEFAULT');
          } else {
            values.push(this.escape(null));
          }
        } else {
          if (modelAttributeMap && modelAttributeMap[key] && modelAttributeMap[key].autoIncrement === true) {
            identityWrapperRequired = true;
          }

          values.push(this.escape(value, (modelAttributeMap && modelAttributeMap[key]) || undefined, { context: 'INSERT' }));
        }
      }
    }

    var replacements = {
      ignore: options.ignore ? this._dialect.supports.IGNORE : '',
      table: this.quoteTable(table),
      attributes: fields.join(','),
      output: outputFragment,
      values: values.join(','),
      tmpTable: tmpTable
    };

    query = (replacements.attributes.length ? valueQuery : emptyQuery) + ';';
    if (identityWrapperRequired && this._dialect.supports.autoIncrement.identityInsert) {
      query = [
        'SET IDENTITY_INSERT', this.quoteTable(table), 'ON;',
        query,
        'SET IDENTITY_INSERT', this.quoteTable(table), 'OFF;',
      ].join(' ');
    }

    return Utils._.template(query)(replacements);
  },

  /*
    Returns an insert into command for multiple values.
    Parameters: table name + list of hashes of attribute-value-pairs.
  */
  bulkInsertQuery: function(tableName, attrValueHashes, options, rawAttributes) {
    options = options || {};
    rawAttributes = rawAttributes || {};

    var query = 'INSERT<%= ignoreDuplicates %> INTO <%= table %> (<%= attributes %>) VALUES <%= tuples %><%= onDuplicateKeyUpdate %><%= returning %>;'
      , tuples = []
      , serials = []
      , allAttributes = []
      , onDuplicateKeyUpdate = '';

    attrValueHashes.forEach(function(attrValueHash) {
      _.forOwn(attrValueHash, function(value, key) {
        if (allAttributes.indexOf(key) === -1) {
          allAttributes.push(key);
        }

        if (rawAttributes[key] && rawAttributes[key].autoIncrement === true) {
          serials.push(key);
        }
      });
    });

    attrValueHashes.forEach(function(attrValueHash) {
      tuples.push('(' +
        allAttributes.map(function(key) {
          if (this._dialect.supports.bulkDefault && serials.indexOf(key) !== -1) {
            return attrValueHash[key] || 'DEFAULT';
          }
          return this.escape(attrValueHash[key], rawAttributes[key], { context: 'INSERT' });
        }, this).join(',') +
        ')');
    }, this);

    if (this._dialect.supports.updateOnDuplicate && options.updateOnDuplicate) {
      onDuplicateKeyUpdate += ' ON DUPLICATE KEY UPDATE ' + options.updateOnDuplicate.map(function(attr) {
        var field = rawAttributes && rawAttributes[attr] && rawAttributes[attr].field || attr;
        var key = this.quoteIdentifier(field);
        return key + '=VALUES(' + key + ')';
      }, this).join(',');
    }

    var replacements = {
      ignoreDuplicates: options.ignoreDuplicates ? this._dialect.supports.ignoreDuplicates : '',
      table: this.quoteTable(tableName),
      attributes: allAttributes.map(function(attr) {
        return this.quoteIdentifier(attr);
      }, this).join(','),
      tuples: tuples.join(','),
      onDuplicateKeyUpdate: onDuplicateKeyUpdate,
      returning: this._dialect.supports.returnValues && options.returning ? ' RETURNING *' : ''
    };

    return _.template(query)(replacements);
  },

  /*
    Returns an update query.
    Parameters:
      - tableName -> Name of the table
      - values -> A hash with attribute-value-pairs
      - where -> A hash with conditions (e.g. {name: 'foo'})
                 OR an ID as integer
                 OR a string with conditions (e.g. 'name=""foo""').
                 If you use a string, you have to escape it on your own.
  */
  updateQuery: function(tableName, attrValueHash, where, options, attributes) {
    options = options || {};
    _.defaults(options, this.options);

    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);

    var query
      , values = []
      , outputFragment
      , modelAttributeMap = {}
      , tmpTable = ''         //tmpTable declaration for trigger
      , selectFromTmp = ''    //Select statement for trigger
      , tmpColumns = ''       //Columns for temp table for trigger
      , outputColumns = ''    //Columns to capture into temp table for trigger
      , attribute             //Model attribute holder
      , modelKey;             //key for model

    query = '<%= tmpTable %>UPDATE <%= table %> SET <%= values %><%= output %> <%= where %>';

    if (this._dialect.supports['LIMIT ON UPDATE'] && options.limit) {
      query += ' LIMIT ' + this.escape(options.limit) + ' ';
    }

    if (this._dialect.supports.returnValues) {
      if (!!this._dialect.supports.returnValues.output) {
        // we always need this for mssql
        outputFragment = ' OUTPUT INSERTED.*';

        //To capture output rows when there is a trigger on MSSQL DB
        if (attributes && options.hasTrigger && this._dialect.supports.tmpTableTrigger) {
            tmpTable = 'declare @tmp table (<%= columns %>); ';

            for (modelKey in attributes){
              attribute = attributes[modelKey];
              if(!(attribute.type instanceof DataTypes.VIRTUAL)){
                if (tmpColumns.length > 0){
                  tmpColumns += ',';
                  outputColumns += ',';
                }

                tmpColumns += this.quoteIdentifier(attribute.field) + ' ' + attribute.type.toSql();
                outputColumns += 'INSERTED.' + this.quoteIdentifier(attribute.field);
              }
            }

            var replacement ={
              columns : tmpColumns
            };

            tmpTable = Utils._.template(tmpTable)(replacement).trim();
            outputFragment = ' OUTPUT ' + outputColumns + ' into @tmp';
            selectFromTmp = ';select * from @tmp';

            query += selectFromTmp;
        }
      } else if (this._dialect.supports.returnValues && options.returning) {
        // ensure that the return output is properly mapped to model fields.
        options.mapToModel = true;
        query += ' RETURNING *';
      }
    }

    if (attributes) {
      Utils._.each(attributes, function(attribute, key) {
        modelAttributeMap[key] = attribute;
        if (attribute.field) {
          modelAttributeMap[attribute.field] = attribute;
        }
      });
    }

    for (var key in attrValueHash) {
      if (modelAttributeMap && modelAttributeMap[key] &&
          modelAttributeMap[key].autoIncrement === true &&
          !this._dialect.supports.autoIncrement.update) {
        // not allowed to update identity column
        continue;
      }

      var value = attrValueHash[key];
      values.push(this.quoteIdentifier(key) + '=' + this.escape(value, (modelAttributeMap && modelAttributeMap[key] || undefined), { context: 'UPDATE' }));
    }

    var replacements = {
      table: this.quoteTable(tableName),
      values: values.join(','),
      output: outputFragment,
      where: this.whereQuery(where),
      tmpTable: tmpTable
    };

    if (values.length === 0) {
      return '';
    }

    return Utils._.template(query)(replacements).trim();
  },

  /*
    Returns an upsert query.
  */
  upsertQuery: function (tableName, insertValues, updateValues, where, rawAttributes, options) {
    throwMethodUndefined('upsertQuery');
  },

  /*
    Returns a deletion query.
    Parameters:
      - tableName -> Name of the table
      - where -> A hash with conditions (e.g. {name: 'foo'})
                 OR an ID as integer
                 OR a string with conditions (e.g. 'name=""foo""').
                 If you use a string, you have to escape it on your own.
    Options:
      - limit -> Maximaum count of lines to delete
      - truncate -> boolean - whether to use an 'optimized' mechanism (i.e. TRUNCATE) if available,
                              note that this should not be the default behaviour because TRUNCATE does not
                              always play nicely (e.g. InnoDB tables with FK constraints)
                              (@see http://dev.mysql.com/doc/refman/5.6/en/truncate-table.html).
                              Note that truncate must ignore limit and where
  */
  /* istanbul ignore next */
  deleteQuery: function(tableName, where, options) {
    throwMethodUndefined('deleteQuery');
  },

  /*
    Returns an update query.
    Parameters:
      - tableName -> Name of the table
      - values -> A hash with attribute-value-pairs
      - where -> A hash with conditions (e.g. {name: 'foo'})
                 OR an ID as integer
                 OR a string with conditions (e.g. 'name=""foo""').
                 If you use a string, you have to escape it on your own.
  */
  incrementQuery: function(tableName, attrValueHash, where, options) {
    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, this.options.omitNull);

    var query
      , key
      , value
      , values = []
      , outputFragment;

    query = 'UPDATE <%= table %> SET <%= values %><%= output %> <%= where %>';
    if (this._dialect.supports.returnValues) {
      if (!!this._dialect.supports.returnValues.returning) {
        query += ' RETURNING *';
      } else if (!!this._dialect.supports.returnValues.output) {
        outputFragment = ' OUTPUT INSERTED.*';
      }
    }

    for (key in attrValueHash) {
      value = attrValueHash[key];
      values.push(this.quoteIdentifier(key) + '=' + this.quoteIdentifier(key) + ' + ' + this.escape(value));
    }

    options = options || {};
    for (key in options) {
      value = options[key];
      values.push(this.quoteIdentifier(key) + '=' + this.escape(value));
    }

    var replacements = {
      table: this.quoteTable(tableName),
      values: values.join(','),
      output: outputFragment,
      where: this.whereQuery(where)
    };

    return Utils._.template(query)(replacements);
  },

  nameIndexes: function (indexes, rawTablename) {
    return Utils._.map(indexes, function (index) {
      if (!index.hasOwnProperty('name')) {
        var onlyAttributeNames = index.fields.map(function(field) {
          return (typeof field === 'string') ? field : (field.name || field.attribute);
        }.bind(this));

        index.name = Utils.inflection.underscore(rawTablename + '_' + onlyAttributeNames.join('_'));
      }

      return index;
    });
  },

  /*
    Returns an add index query.
    Parameters:
      - tableName -> Name of an existing table, possibly with schema.
      - options:
        - type: UNIQUE|FULLTEXT|SPATIAL
        - name: The name of the index. Default is <table>_<attr1>_<attr2>
        - fields: An array of attributes as string or as hash.
                  If the attribute is a hash, it must have the following content:
                  - name: The name of the attribute/column
                  - length: An integer. Optional
                  - order: 'ASC' or 'DESC'. Optional
        - parser
      - rawTablename, the name of the table, without schema. Used to create the name of the index
  */
  addIndexQuery: function(tableName, attributes, options, rawTablename) {
    var fieldsSql;
    options = options || {};

    if (!Array.isArray(attributes)) {
      options = attributes;
      attributes = undefined;
    } else {
      options.fields = attributes;
    }

    // Backwards compatability
    if (options.indexName) {
      options.name = options.indexName;
    }
    if (options.indicesType) {
      options.type = options.indicesType;
    }
    if (options.indexType || options.method) {
      options.using = options.indexType || options.method;
    }

    options.prefix = options.prefix || rawTablename || tableName;
    if (options.prefix && _.isString(options.prefix)) {
      options.prefix = options.prefix.replace(/\./g, '_');
      options.prefix = options.prefix.replace(/(\""|\')/g, '');
    }

    fieldsSql = options.fields.map(function(field) {
      if (typeof field === 'string') {
        return this.quoteIdentifier(field);
      } else if (field._isSequelizeMethod) {
        return this.handleSequelizeMethod(field);
      } else {
        var result = '';

        if (field.attribute) {
          field.name = field.attribute;
        }

        if (!field.name) {
          throw new Error('The following index field has no name: ' + util.inspect(field));
        }

        result += this.quoteIdentifier(field.name);

        if (this._dialect.supports.index.collate && field.collate) {
          result += ' COLLATE ' + this.quoteIdentifier(field.collate);
        }

        if (this._dialect.supports.index.length && field.length) {
          result += '(' + field.length + ')';
        }

        if (field.order) {
          result += ' ' + field.order;
        }

        return result;
      }
    }.bind(this));

    if (!options.name) {
      // Mostly for cases where addIndex is called directly by the user without an options object (for example in migrations)
      // All calls that go through sequelize should already have a name
      options = this.nameIndexes([options], options.prefix)[0];
    }

    options = Model.prototype.$conformIndex(options);

    if (!this._dialect.supports.index.type) {
      delete options.type;
    }

    if (options.where) {
      options.where = this.whereQuery(options.where);
    }

    if (_.isString(tableName)) {
      tableName = this.quoteIdentifiers(tableName);
    } else {
      tableName = this.quoteTable(tableName);
    }

    var concurrently = this._dialect.supports.index.concurrently && options.concurrently ? 'CONCURRENTLY' : undefined
      , ind;
    if (this._dialect.supports.indexViaAlter) {
      ind = [
        'ALTER TABLE',
        tableName,
        concurrently,
        'ADD'
      ];
    } else {
      ind = ['CREATE'];
    }

    ind = ind.concat(
      options.unique ? 'UNIQUE' : '',
      options.type, 'INDEX',
      !this._dialect.supports.indexViaAlter ? concurrently : undefined,
      this.quoteIdentifiers(options.name),
      this._dialect.supports.index.using === 1 && options.using ? 'USING ' + options.using : '',
      !this._dialect.supports.indexViaAlter ? 'ON ' + tableName : undefined,
      this._dialect.supports.index.using === 2 && options.using ? 'USING ' + options.using : '',
      '(' + fieldsSql.join(', ') + (options.operator ? ' '+options.operator : '') + ')',
      (this._dialect.supports.index.parser && options.parser ? 'WITH PARSER ' + options.parser : undefined),
      (this._dialect.supports.index.where && options.where ? options.where : undefined)
    );

    return Utils._.compact(ind).join(' ');
  },

  /*
    Returns a query listing indexes for a given table.
    Parameters:
      - tableName: Name of an existing table.
      - options:
        - database: Name of the database.
  */
  /* istanbul ignore next */
  showIndexesQuery: function(tableName, options) {
    throwMethodUndefined('showIndexesQuery');
  },

  /*
    Returns a remove index query.
    Parameters:
      - tableName: Name of an existing table.
      - indexNameOrAttributes: The name of the index as string or an array of attribute names.
  */
  /* istanbul ignore next */
  removeIndexQuery: function(tableName, indexNameOrAttributes) {
    throwMethodUndefined('removeIndexQuery');
  },

  /*
    This method transforms an array of attribute hashes into equivalent
    sql attribute definition.
  */
  /* istanbul ignore next */
  attributesToSQL: function(attributes) {
    throwMethodUndefined('attributesToSQL');
  },

  /*
    Returns all auto increment fields of a factory.
  */
  /* istanbul ignore next */
  findAutoIncrementField: function(factory) {
    throwMethodUndefined('findAutoIncrementField');
  },


  quoteTable: function(param, as) {
    var table = '';

    if (as === true) {
      as = param.as || param.name || param;
    }

    if (_.isObject(param)) {
      if (this._dialect.supports.schemas) {
        if (param.schema) {
          table += this.quoteIdentifier(param.schema) + '.';
        }

        table += this.quoteIdentifier(param.tableName);
      } else {
        if (param.schema) {
          table += param.schema + (param.delimiter || '.');
        }

        table += param.tableName;
        table = this.quoteIdentifier(table);
      }


    } else {
      table = this.quoteIdentifier(param);
    }

    if (as) {
      table += ' AS ' + this.quoteIdentifier(as);
    }
    return table;
  },

  /*
    Quote an object based on its type. This is a more general version of quoteIdentifiers
    Strings: should proxy to quoteIdentifiers
    Arrays:
      * Expects array in the form: [<model> (optional), <model> (optional),... String, String (optional)]
        Each <model> can be a model or an object {model: Model, as: String}, matching include
      * Zero or more models can be included in the array and are used to trace a path through the tree of
        included nested associations. This produces the correct table name for the ORDER BY/GROUP BY SQL
        and quotes it.
      * If a single string is appended to end of array, it is quoted.
        If two strings appended, the 1st string is quoted, the 2nd string unquoted.
    Objects:
      * If raw is set, that value should be returned verbatim, without quoting
      * If fn is set, the string should start with the value of fn, starting paren, followed by
        the values of cols (which is assumed to be an array), quoted and joined with ', ',
        unless they are themselves objects
      * If direction is set, should be prepended

    Currently this function is only used for ordering / grouping columns and Sequelize.col(), but it could
    potentially also be used for other places where we want to be able to call SQL functions (e.g. as default values)
  */
  quote: function(obj, parent, force) {
    if (Utils._.isString(obj)) {
      return this.quoteIdentifiers(obj, force);
    } else if (Array.isArray(obj)) {
      // loop through array, adding table names of models to quoted
      // (checking associations to see if names should be singularised or not)
      var tableNames = []
        , parentAssociation
        , len = obj.length
        , item
        , model
        , as
        , association;

      for (var i = 0; i < len - 1; i++) {
        item = obj[i];
        if (item._modelAttribute || Utils._.isString(item) || item._isSequelizeMethod || 'raw' in item) {
          break;
        }

        if (item instanceof Model) {
          model = item;
          as = undefined;
        } else {
          model = item.model;
          as = item.as;
        }

        // check if model provided is through table
        if (!as && parentAssociation && parentAssociation.through && parentAssociation.through.model === model) {
          association = {as: model.name};
        } else {
          // find applicable association for linking parent to this model
          association = parent.getAssociation(model, as);
        }

        if (association) {
          tableNames[i] = association.as;
          parent = model;
          parentAssociation = association;
        } else {
          tableNames[i] = model.tableName;
          throw new Error('\'' + tableNames.join('.') + '\' in order / group clause is not valid association');
        }
      }

      // add 1st string as quoted, 2nd as unquoted raw
      var sql = (i > 0 ? this.quoteIdentifier(tableNames.join('.')) + '.' : (Utils._.isString(obj[0]) && parent ? this.quoteIdentifier(parent.name) + '.' : '')) + this.quote(obj[i], parent, force);
      if (i < len - 1) {
        if (obj[i + 1]._isSequelizeMethod) {
          sql += this.handleSequelizeMethod(obj[i + 1]);
        } else {
          sql += ' ' + obj[i + 1];
        }
      }
      return sql;
    } else if (obj._modelAttribute) {
      return this.quoteTable(obj.Model.name) + '.' + obj.fieldName;
    } else if (obj._isSequelizeMethod) {
      return this.handleSequelizeMethod(obj);
    } else if (Utils._.isObject(obj) && 'raw' in obj) {
      return obj.raw;
    } else {
      throw new Error('Unknown structure passed to order / group: ' + JSON.stringify(obj));
    }
  },

  /*
   Create a trigger
   */
  /* istanbul ignore next */
  createTrigger: function(tableName, triggerName, timingType, fireOnArray, functionName, functionParams, optionsArray) {
    throwMethodUndefined('createTrigger');
  },

  /*
   Drop a trigger
   */
  /* istanbul ignore next */
  dropTrigger: function(tableName, triggerName) {
    throwMethodUndefined('dropTrigger');
  },

  /*
   Rename a trigger
  */
  /* istanbul ignore next */
  renameTrigger: function(tableName, oldTriggerName, newTriggerName) {
    throwMethodUndefined('renameTrigger');
  },

  /*
   Create a function
   */
  /* istanbul ignore next */
  createFunction: function(functionName, params, returnType, language, body, options) {
    throwMethodUndefined('createFunction');
  },

  /*
   Drop a function
   */
  /* istanbul ignore next */
  dropFunction: function(functionName, params) {
    throwMethodUndefined('dropFunction');
  },

  /*
   Rename a function
   */
  /* istanbul ignore next */
  renameFunction: function(oldFunctionName, params, newFunctionName) {
    throwMethodUndefined('renameFunction');
  },

  /*
    Escape an identifier (e.g. a table or attribute name)
  */
  /* istanbul ignore next */
  quoteIdentifier: function(identifier, force) {
    throwMethodUndefined('quoteIdentifier');
  },

  /*
    Split an identifier into .-separated tokens and quote each part
  */
  quoteIdentifiers: function(identifiers, force) {
    if (identifiers.indexOf('.') !== -1) {
      identifiers = identifiers.split('.');
      return this.quoteIdentifier(identifiers.slice(0, identifiers.length - 1).join('.')) + '.' + this.quoteIdentifier(identifiers[identifiers.length - 1]);
    } else {
      return this.quoteIdentifier(identifiers);
    }
  },

  /*
    Escape a value (e.g. a string, number or date)
  */
  escape: function(value, field, options) {
    options = options || {};

    if (value !== null && value !== undefined) {
      if (value._isSequelizeMethod) {
        return this.handleSequelizeMethod(value);
      } else {
        if (field && field.type) {
          if (this.typeValidation && field.type.validate && value) {
            if (options.isList && Array.isArray(value)) {
              _.forEach(value, function(item) {
                field.type.validate(item, options);
              });
            } else {
              field.type.validate(value, options);
            }
          }

          if (field.type.stringify) {
            // Users shouldn't have to worry about these args - just give them a function that takes a single arg
            var simpleEscape = _.partialRight(SqlString.escape, this.options.timezone, this.dialect);

            value = field.type.stringify(value, { escape: simpleEscape, field: field, timezone: this.options.timezone });

            if (field.type.escape === false) {
              // The data-type already did the required escaping
              return value;
            }
          }
        }
      }
    }

    return SqlString.escape(value, this.options.timezone, this.dialect);
  },

  /**
   * Generates an SQL query that returns all foreign keys of a table.
   *
   * @param  {String} tableName  The name of the table.
   * @param  {String} schemaName The name of the schema.
   * @return {String}            The generated sql query.
   */
  /* istanbul ignore next */
  getForeignKeysQuery: function(tableName, schemaName) {
    throwMethodUndefined('getForeignKeysQuery');
  },

  /**
   * Generates an SQL query that removes a foreign key from a table.
   *
   * @param  {String} tableName  The name of the table.
   * @param  {String} foreignKey The name of the foreign key constraint.
   * @return {String}            The generated sql query.
   */
  /* istanbul ignore next */
  dropForeignKeyQuery: function(tableName, foreignKey) {
    throwMethodUndefined('dropForeignKeyQuery');
  },


  /*
    Returns a query for selecting elements in the table <tableName>.
    Options:
      - attributes -> An array of attributes (e.g. ['name', 'birthday']). Default: *
      - where -> A hash with conditions (e.g. {name: 'foo'})
                 OR an ID as integer
                 OR a string with conditions (e.g. 'name=""foo""').
                 If you use a string, you have to escape it on your own.
      - order -> e.g. 'id DESC'
      - group
      - limit -> The maximum count you want to get.
      - offset -> An offset value to start from. Only useable with limit!
  */

  selectQuery: function(tableName, options, model) {
    // Enter and change at your own peril -- Mick Hansen

    options = options || {};

    var table = null
      , self = this
      , query
      , limit = options.limit
      , mainModel = model
      , mainQueryItems = []
      , mainAttributes = options.attributes && options.attributes.slice()
      , mainJoinQueries = []
      // We'll use a subquery if we have a hasMany association and a limit
      , subQuery = options.subQuery === undefined ?
                   limit && options.hasMultiAssociation :
                   options.subQuery
      , subQueryItems = []
      , subQueryAttributes = null
      , subJoinQueries = []
      , mainTableAs = null;

    if (options.tableAs) {
      mainTableAs = this.quoteTable(options.tableAs);
    } else if (!Array.isArray(tableName) && model) {
      mainTableAs = this.quoteTable(model.name);
    }

    table = !Array.isArray(tableName) ? this.quoteTable(tableName) : tableName.map(function(t) {
      if (Array.isArray(t)) {
        return this.quoteTable(t[0], t[1]);
      }
      return this.quoteTable(t, true);
    }.bind(this)).join(', ');

    if (subQuery && mainAttributes) {
      model.primaryKeyAttributes.forEach(function(keyAtt) {
        // Check if mainAttributes contain the primary key of the model either as a field or an aliased field
        if (!_.find(mainAttributes, function (attr) {
          return keyAtt === attr || keyAtt === attr[0] || keyAtt === attr[1];
        })) {
          mainAttributes.push(model.rawAttributes[keyAtt].field ? [keyAtt, model.rawAttributes[keyAtt].field] : keyAtt);
        }
      });
    }

    // Escape attributes
    mainAttributes = mainAttributes && mainAttributes.map(function(attr) {
      var addTable = true;

      if (attr._isSequelizeMethod) {
        return self.handleSequelizeMethod(attr);
      }

      if (Array.isArray(attr) && attr.length === 2) {
        attr = attr.slice();

        if (attr[0]._isSequelizeMethod) {
          attr[0] = self.handleSequelizeMethod(attr[0]);
          addTable = false;
        } else if (
          attr[0].indexOf('(') === -1 &&
          attr[0].indexOf(')') === -1
        ) {
          attr[0] = self.quoteIdentifier(attr[0]);
        } else {
          deprecate('Use sequelize.fn / sequelize.literal to construct attributes');
        }

        attr = [attr[0], self.quoteIdentifier(attr[1])].join(' AS ');
      } else {
        if (
          attr.indexOf(Utils.TICK_CHAR) < 0 &&
          attr.indexOf('""') < 0
        ) {
          attr = self.quoteIdentifiers(attr);
        } else {
          attr = self.escape(attr);
        }
      }

      if (options.include && attr.indexOf('.') === -1 && addTable) {
        attr = mainTableAs + '.' + attr;
      }

      return attr;
    });

    // If no attributes specified, use *
    mainAttributes = mainAttributes || (options.include ? [mainTableAs + '.*'] : ['*']);

    // If subquery, we ad the mainAttributes to the subQuery and set the mainAttributes to select * from subquery
    if (subQuery || options.groupedLimit) {
      // We need primary keys
      subQueryAttributes = mainAttributes;
      mainAttributes = [(mainTableAs || table) + '.*'];
    }

    if (options.include) {
      var generateJoinQueries = function(include, parentTable) {
        var table = include.model.getTableName()
          , as = include.as
          , joinQueryItem = ''
          , joinQueries = {
            mainQuery: [],
            subQuery: []
          }
          , attributes
          , association = include.association
          , through = include.through
          , joinType = include.required ? ' INNER JOIN ' : ' LEFT OUTER JOIN '
          , parentIsTop = !include.parent.association && include.parent.model.name === options.model.name
          , whereOptions = Utils._.clone(options)
          , targetWhere;

        whereOptions.keysEscaped = true;

        if (tableName !== parentTable && mainTableAs !== parentTable) {
          as = parentTable + '.' + include.as;
        }

        // includeIgnoreAttributes is used by aggregate functions
        if (options.includeIgnoreAttributes !== false) {
          attributes = include.attributes.map(function(attr) {
            var attrAs = attr,
                verbatim = false;

            if (Array.isArray(attr) && attr.length === 2) {
              if (attr[0]._isSequelizeMethod) {
                if (attr[0] instanceof Utils.literal ||
                  attr[0] instanceof Utils.cast ||
                  attr[0] instanceof Utils.fn
                ) {
                  verbatim = true;
                }
              }

              attr = attr.map(function($attr) {
                return $attr._isSequelizeMethod ? self.handleSequelizeMethod($attr) : $attr;
              });

              attrAs = attr[1];
              attr = attr[0];
            } else if (attr instanceof Utils.literal) {
              return attr.val; // We trust the user to rename the field correctly
            } else if (attr instanceof Utils.cast ||
              attr instanceof Utils.fn
            ) {
              throw new Error(
                'Tried to select attributes using Sequelize.cast or Sequelize.fn without specifying an alias for the result, during eager loading. ' +
                'This means the attribute will not be added to the returned instance'
              );
            }

            var prefix;

            if (verbatim === true) {
              prefix = attr;
            } else {
              prefix = self.quoteIdentifier(as) + '.' + self.quoteIdentifier(attr);
            }

            return prefix + ' AS ' + self.quoteIdentifier(as + '.' + attrAs, true);
          });

          if (include.subQuery && subQuery) {
            subQueryAttributes = subQueryAttributes.concat(attributes);
          } else {
            mainAttributes = mainAttributes.concat(attributes);
          }
        }

        if (through) {
          var throughTable = through.model.getTableName()
            , throughAs = as + '.' + through.as
            , throughAttributes = through.attributes.map(function(attr) {
              return self.quoteIdentifier(throughAs) + '.' + self.quoteIdentifier(Array.isArray(attr) ? attr[0] : attr) +
                     ' AS ' +
                     self.quoteIdentifier(throughAs + '.' + (Array.isArray(attr) ? attr[1] : attr));
            })
            , primaryKeysSource = association.source.primaryKeyAttributes
            , tableSource = parentTable
            , identSource = association.identifierField
            , attrSource = primaryKeysSource[0]
            , primaryKeysTarget = association.target.primaryKeyAttributes
            , tableTarget = as
            , identTarget = association.foreignIdentifierField
            , attrTarget = association.target.rawAttributes[primaryKeysTarget[0]].field || primaryKeysTarget[0]

            , sourceJoinOn
            , targetJoinOn

            , throughWhere;

          if (options.includeIgnoreAttributes !== false) {
            // Through includes are always hasMany, so we need to add the attributes to the mainAttributes no matter what (Real join will never be executed in subquery)
            mainAttributes = mainAttributes.concat(throughAttributes);
          }

          // Figure out if we need to use field or attribute
          if (!subQuery) {
            attrSource = association.source.rawAttributes[primaryKeysSource[0]].field;
          }
          if (subQuery && !include.subQuery && !include.parent.subQuery && include.parent.model !== mainModel) {
            attrSource = association.source.rawAttributes[primaryKeysSource[0]].field;
          }

          // Filter statement for left side of through
          // Used by both join and subquery where

          // If parent include was in a subquery need to join on the aliased attribute

          if (subQuery && !include.subQuery && include.parent.subQuery && !parentIsTop) {
            sourceJoinOn = self.quoteIdentifier(tableSource + '.' + attrSource) + ' = ';
          } else {
            sourceJoinOn = self.quoteTable(tableSource) + '.' + self.quoteIdentifier(attrSource) + ' = ';
          }
          sourceJoinOn += self.quoteIdentifier(throughAs) + '.' + self.quoteIdentifier(identSource);

          // Filter statement for right side of through
          // Used by both join and subquery where
          targetJoinOn = self.quoteIdentifier(tableTarget) + '.' + self.quoteIdentifier(attrTarget) + ' = ';
          targetJoinOn += self.quoteIdentifier(throughAs) + '.' + self.quoteIdentifier(identTarget);

          if (include.through.where) {
            throughWhere = self.getWhereConditions(include.through.where, self.sequelize.literal(self.quoteIdentifier(throughAs)), include.through.model);
          }

          if (self._dialect.supports.joinTableDependent) {
            // Generate a wrapped join so that the through table join can be dependent on the target join
            joinQueryItem += joinType + '(';
            joinQueryItem += self.quoteTable(throughTable, throughAs);
            joinQueryItem += ' INNER JOIN ' + self.quoteTable(table, as) + ' ON ';
            joinQueryItem += targetJoinOn;

            if (throughWhere) {
              joinQueryItem += ' AND ' + throughWhere;
            }

            joinQueryItem += ') ON '+sourceJoinOn;
          } else {
            // Generate join SQL for left side of through
            joinQueryItem += joinType + self.quoteTable(throughTable, throughAs)  + ' ON ';
            joinQueryItem += sourceJoinOn;

            // Generate join SQL for right side of through
            joinQueryItem += joinType + self.quoteTable(table, as) + ' ON ';
            joinQueryItem += targetJoinOn;

            if (throughWhere) {
              joinQueryItem += ' AND ' + throughWhere;
            }

          }

          if (include.where || include.through.where) {
            if (include.where) {
              targetWhere = self.getWhereConditions(include.where, self.sequelize.literal(self.quoteIdentifier(as)), include.model, whereOptions);
              if (targetWhere) {
                joinQueryItem += ' AND ' + targetWhere;
              }
            }
            if (subQuery && include.required) {
              if (!options.where) options.where = {};
              (function (include) {
                // Closure to use sane local variables

                var parent = include
                  , child = include
                  , nestedIncludes = []
                  , topParent
                  , topInclude
                  , $query;

                while (parent = parent.parent) {
                  nestedIncludes = [_.extend({}, child, {include: nestedIncludes})];
                  child = parent;
                }

                topInclude = nestedIncludes[0];
                topParent = topInclude.parent;

                if (topInclude.through && Object(topInclude.through.model) === topInclude.through.model) {
                  $query = self.selectQuery(topInclude.through.model.getTableName(), {
                    attributes: [topInclude.through.model.primaryKeyField],
                    include: Model.$validateIncludedElements({
                      model: topInclude.through.model,
                      include: [{
                        association: topInclude.association.toTarget,
                        required: true
                      }]
                    }).include,
                    model: topInclude.through.model,
                    where: { $and: [
                      self.sequelize.asIs([
                        self.quoteTable(topParent.model.name) + '.' + self.quoteIdentifier(topParent.model.primaryKeyField),
                        self.quoteIdentifier(topInclude.through.model.name) + '.' + self.quoteIdentifier(topInclude.association.identifierField)
                      ].join(' = ')),
                      topInclude.through.where
                    ]},
                    limit: 1,
                    includeIgnoreAttributes: false
                  }, topInclude.through.model);
                } else {
                  var isBelongsTo = topInclude.association.associationType === 'BelongsTo';
                  var join = [
                    self.quoteTable(topParent.model.name) + '.' + self.quoteIdentifier(isBelongsTo ? topInclude.association.identifierField : topParent.model.primaryKeyAttributes[0]),
                    self.quoteIdentifier(topInclude.model.name) + '.' + self.quoteIdentifier(isBelongsTo ? topInclude.model.primaryKeyAttributes[0] : topInclude.association.identifierField)
                  ].join(' = ');
                  $query = self.selectQuery(topInclude.model.tableName, {
                    attributes: [topInclude.model.primaryKeyAttributes[0]],
                    include: topInclude.include,
                    where: {
                      $join: self.sequelize.asIs(join)
                    },
                    limit: 1,
                    includeIgnoreAttributes: false
                  }, topInclude.model);
                }

                options.where['__' + throughAs] = self.sequelize.asIs([
                  '(',
                    $query.replace(/\;$/, ''),
                  ')',
                  'IS NOT NULL'
                ].join(' '));
              })(include);
            }
          }
        } else {
          if (subQuery && include.subQueryFilter) {
            var associationWhere = {}
              , $query
              , subQueryWhere;

            associationWhere[association.identifierField] = {
              $raw: self.quoteTable(parentTable) + '.' + self.quoteIdentifier(association.sourceKeyField || association.source.primaryKeyField)
            };

            if (!options.where) options.where = {};

            // Creating the as-is where for the subQuery, checks that the required association exists
            $query = self.selectQuery(include.model.getTableName(), {
              attributes: [association.identifierField],
              where: {
                $and: [
                  associationWhere,
                  include.where || {}
                ]
              },
              limit: 1
            }, include.model);

            subQueryWhere = self.sequelize.asIs([
              '(',
                $query.replace(/\;$/, ''),
              ')',
              'IS NOT NULL'
            ].join(' '));

            if (Utils._.isPlainObject(options.where)) {
              options.where['__' + as] = subQueryWhere;
            } else {
              options.where = { $and: [options.where, subQueryWhere] };
            }
          }

          joinQueryItem = ' ' + self.joinIncludeQuery({
            model: mainModel,
            subQuery: options.subQuery,
            include: include,
            groupedLimit: options.groupedLimit
          });
        }

        if (include.subQuery && subQuery) {
          joinQueries.subQuery.push(joinQueryItem);
        } else {
          joinQueries.mainQuery.push(joinQueryItem);
        }

        if (include.include) {
          include.include.filter(function (include) {
            return !include.separate;
          }).forEach(function(childInclude) {
            if (childInclude._pseudo) return;
            var childJoinQueries = generateJoinQueries(childInclude, as);

            if (childInclude.subQuery && subQuery) {
              joinQueries.subQuery = joinQueries.subQuery.concat(childJoinQueries.subQuery);
            }
            if (childJoinQueries.mainQuery) {
              joinQueries.mainQuery = joinQueries.mainQuery.concat(childJoinQueries.mainQuery);
            }

          }.bind(this));
        }

        return joinQueries;
      };

      // Loop through includes and generate subqueries
      options.include.filter(function (include) {
        return !include.separate;
      }).forEach(function(include) {
        var joinQueries = generateJoinQueries(include, mainTableAs);

        subJoinQueries = subJoinQueries.concat(joinQueries.subQuery);
        mainJoinQueries = mainJoinQueries.concat(joinQueries.mainQuery);

      }.bind(this));
    }

    // If using subQuery select defined subQuery attributes and join subJoinQueries
    if (subQuery) {
      subQueryItems.push(this.selectFromTableFragment(options, model, subQueryAttributes, table, mainTableAs));
      subQueryItems.push(subJoinQueries.join(''));

    // Else do it the reguar way
    } else {
      if (options.groupedLimit) {
        if (!mainTableAs) {
          mainTableAs = table;
        }

        var groupedLimitOrder
          , where = _.assign({}, options.where)
          , whereKey
          , include
          , groupedTableName = mainTableAs;

        if (typeof options.groupedLimit.on === 'string') {
          whereKey = options.groupedLimit.on;
        } else if (options.groupedLimit.on instanceof HasMany) {
          whereKey = options.groupedLimit.on.foreignKeyField;
        }

        if (options.groupedLimit.on instanceof BelongsToMany) {
          // BTM includes needs to join the through table on to check ID
          groupedTableName = options.groupedLimit.on.manyFromSource.as;
          var groupedLimitOptions = Model.$validateIncludedElements({
            include: [{
              association: options.groupedLimit.on.manyFromSource,
              duplicating: false, // The UNION'ed query may contain duplicates, but each sub-query cannot
              required: true,
              where: _.assign({
                '$$PLACEHOLDER$$': true
              }, options.groupedLimit.through && options.groupedLimit.through.where)
            }],
            model: model
          });
          // Make sure attributes from the join table are mapped back to models
          options.hasJoin = true;
          options.hasMultiAssociation = true;
          options.includeMap = _.assign(groupedLimitOptions.includeMap, options.includeMap);
          options.includeNames = groupedLimitOptions.includeNames.concat(options.includeNames || []);
          include = groupedLimitOptions.include;

          if (Array.isArray(options.order)) {
            // We need to make sure the order by attributes are available to the parent query
            options.order.forEach(function(order, i) {
              if (Array.isArray(order)) {
                order = order[0];
              }

              var alias = 'subquery_order_' +i;
              options.attributes.push([order, alias]);

              // We don't want to prepend model name when we alias the attributes, so quote them here
              alias = this.sequelize.literal(this.quote(alias));

              if (Array.isArray(options.order[i])) {
                options.order[i][0] = alias;
              } else {
                options.order[i] = alias;
              }
            }, this);
            groupedLimitOrder = options.order;
          }
        } else {
          // Ordering is handled by the subqueries, so ordering the UNION'ed result is not needed
          groupedLimitOrder = options.order;
          delete options.order;
          where.$$PLACEHOLDER$$ = true;
        }

        // Caching the base query and splicing the where part into it is consistently > twice
        // as fast than generating from scratch each time for values.length >= 5
        var baseQuery = '('+this.selectQuery(
          tableName,
          {
            attributes: options.attributes,
            limit: options.groupedLimit.limit,
            order: groupedLimitOrder,
            where: where,
            include: include,
            model: model
          },
          model
        ).replace(/;$/, '')+')';
        var placeHolder = this.whereItemQuery('$$PLACEHOLDER$$', true, { model: model })
          , splicePos = baseQuery.indexOf(placeHolder);

        mainQueryItems.push(this.selectFromTableFragment(options, model, mainAttributes, '('+
          options.groupedLimit.values.map(function (value) {
            var groupWhere = {};
            if (whereKey) {
              groupWhere[whereKey] = value;
            }
            if (include) {
              groupWhere[options.groupedLimit.on.foreignIdentifierField] = value;
            }

            return Utils.spliceStr(baseQuery, splicePos, placeHolder.length, this.getWhereConditions(groupWhere, groupedTableName));
          }, this).join(
            self._dialect.supports['UNION ALL'] ?' UNION ALL ' : ' UNION '
          )
        +')', mainTableAs));
      } else {
        mainQueryItems.push(this.selectFromTableFragment(options, model, mainAttributes, table, mainTableAs));
      }
      mainQueryItems.push(mainJoinQueries.join(''));
    }

    // Add WHERE to sub or main query
    if (options.hasOwnProperty('where') && !options.groupedLimit) {
      options.where = this.getWhereConditions(options.where, mainTableAs || tableName, model, options);
      if (options.where) {
        if (subQuery) {
          subQueryItems.push(' WHERE ' + options.where);
        } else {
          mainQueryItems.push(' WHERE ' + options.where);
          // Walk the main query to update all selects
          _.each(mainQueryItems, function(value, key) {
            if(value.match(/^SELECT/)) {
              mainQueryItems[key] = this.selectFromTableFragment(options, model, mainAttributes, table, mainTableAs, options.where);
            }
          }.bind(this));
        }
      }
    }

    // Add GROUP BY to sub or main query
    if (options.group) {
      options.group = Array.isArray(options.group) ? options.group.map(function(t) { return this.quote(t, model); }.bind(this)).join(', ') : options.group;
      if (subQuery) {
        subQueryItems.push(' GROUP BY ' + options.group);
      } else {
        mainQueryItems.push(' GROUP BY ' + options.group);
      }
    }

    // Add HAVING to sub or main query
    if (options.hasOwnProperty('having')) {
      options.having = this.getWhereConditions(options.having, tableName, model, options, false);
      if (subQuery) {
        subQueryItems.push(' HAVING ' + options.having);
      } else {
        mainQueryItems.push(' HAVING ' + options.having);
      }
    }
    // Add ORDER to sub or main query
    if (options.order) {
      var orders = this.getQueryOrders(options, model, subQuery);

      if (orders.mainQueryOrder.length) {
        mainQueryItems.push(' ORDER BY ' + orders.mainQueryOrder.join(', '));
      }
      if (orders.subQueryOrder.length) {
        subQueryItems.push(' ORDER BY ' + orders.subQueryOrder.join(', '));
      }
    }

    // Add LIMIT, OFFSET to sub or main query
    var limitOrder = this.addLimitAndOffset(options, model);
    if (limitOrder && !options.groupedLimit) {
      if (subQuery) {
        subQueryItems.push(limitOrder);
      } else {
        mainQueryItems.push(limitOrder);
      }
    }

    // If using subQuery, select attributes from wrapped subQuery and join out join tables
    if (subQuery) {
      query = 'SELECT ' + mainAttributes.join(', ') + ' FROM (';
      query += subQueryItems.join('');
      query += ') AS ' + mainTableAs;
      query += mainJoinQueries.join('');
      query += mainQueryItems.join('');
    } else {
      query = mainQueryItems.join('');
    }

    if (options.lock && this._dialect.supports.lock) {
      var lock = options.lock;
      if (typeof options.lock === 'object') {
        lock = options.lock.level;
      }
      if (this._dialect.supports.lockKey && (lock === 'KEY SHARE' || lock === 'NO KEY UPDATE')) {
        query += ' FOR ' + lock;
      } else if (lock === 'SHARE') {
        query += ' ' + this._dialect.supports.forShare;
      } else {
        query += ' FOR UPDATE';
      }
      if (this._dialect.supports.lockOf && options.lock.of instanceof Model) {
        query += ' OF ' + this.quoteTable(options.lock.of.name);
      }
    }

    query += ';';

    return query;
  },

  getQueryOrders: function(options, model, subQuery) {
    var mainQueryOrder = [];
    var subQueryOrder = [];

    var validateOrder = function(order) {
      if (order instanceof Utils.literal) return;

      if (!_.includes([
        'ASC',
        'DESC',
        'ASC NULLS LAST',
        'DESC NULLS LAST',
        'ASC NULLS FIRST',
        'DESC NULLS FIRST',
        'NULLS FIRST',
        'NULLS LAST'
      ], order.toUpperCase())) {
        throw new Error(util.format('Order must be \'ASC\' or \'DESC\', \'%s\' given', order));
      }
    };

    if (Array.isArray(options.order)) {
      options.order.forEach(function(t) {
        if (Array.isArray(t) && _.size(t) > 1) {
          if (t[0] instanceof Model || t[0].model instanceof Model) {
            if (typeof t[t.length - 2] === 'string') {
              validateOrder(_.last(t));
            }
          } else {
            validateOrder(_.last(t));
          }
        }

        var hadSubquery = false;

        if (subQuery && (Array.isArray(t) && !(t[0] instanceof Model) && !(t[0].model instanceof Model))) {
          subQueryOrder.push(this.quote(t, model));
          hadSubquery = true;
        }

        if (hadSubquery) {
          for (var name in model.attributes) {
            var attribute = model.attributes[name];
            if (attribute.field && attribute.field === t[0]) {
              t[0] = attribute.fieldName;
            }
          }
        }

        mainQueryOrder.push(this.quote(t, model));
      }.bind(this));
    } else {
      var sql = this.quote(typeof options.order === 'string' ? new Utils.literal(options.order) : options.order, model);
      if (subQuery) {
        subQueryOrder.push(sql);
      }
      mainQueryOrder.push(sql);
    }

    return {
      mainQueryOrder: mainQueryOrder,
      subQueryOrder: subQueryOrder
    };
  },

  selectFromTableFragment: function(options, model, attributes, tables, mainTableAs, whereClause) {
    var fragment = 'SELECT ' + attributes.join(', ') + ' FROM ' + tables;

    if(mainTableAs) {
      fragment += ' AS ' + mainTableAs;
    }

    return fragment;
  },

  joinIncludeQuery: function(options) {
    var subQuery = options.subQuery
      , include = options.include
      , association = include.association
      , parent = include.parent
      , parentIsTop = !include.parent.association && include.parent.model.name === options.model.name
      , $parent
      , joinType = include.required ? 'INNER JOIN ' : 'LEFT OUTER JOIN '
      , joinOn
      , joinWhere

      /* Attributes for the left side */
      , left = association.source
      , asLeft
      , attrLeft = association instanceof BelongsTo ?
                   association.identifier :
                   association.sourceKeyAttribute || left.primaryKeyAttribute
      , fieldLeft = association instanceof BelongsTo ?
                   association.identifierField :
                   left.rawAttributes[association.sourceKeyAttribute || left.primaryKeyAttribute].field

      /* Attributes for the right side */
      , right = include.model
      , asRight = include.as
      , tableRight = right.getTableName()
      , fieldRight = association instanceof BelongsTo ?
                     right.rawAttributes[association.targetIdentifier || right.primaryKeyAttribute].field :
                     association.identifierField;

    while (($parent = ($parent && $parent.parent || include.parent)) && $parent.association) {
      if (asLeft) {
        asLeft = [$parent.as, asLeft].join('.');
      } else {
        asLeft = $parent.as;
      }
    }

    if (!asLeft) asLeft = parent.as || parent.model.name;
    else asRight = [asLeft, asRight].join('.');

    joinOn = [
      this.quoteTable(asLeft),
      this.quoteIdentifier(fieldLeft)
    ].join('.');

    if ((options.groupedLimit && parentIsTop) || (subQuery && include.parent.subQuery && !include.subQuery)) {
      if (parentIsTop) {
        // The main model attributes is not aliased to a prefix
        joinOn = [
          this.quoteTable(parent.as || parent.model.name),
          this.quoteIdentifier(attrLeft)
        ].join('.');
      } else {
        joinOn = this.quoteIdentifier(asLeft + '.' + attrLeft);
      }
    }

    joinOn += ' = ' + this.quoteIdentifier(asRight) + '.' + this.quoteIdentifier(fieldRight);

    if (include.on) {
      joinOn = this.whereItemsQuery(include.on, {
        prefix: this.sequelize.literal(this.quoteIdentifier(asRight)),
        model: include.model
      });
    }

    if (include.where) {
      joinWhere = this.whereItemsQuery(include.where, {
        prefix: this.sequelize.literal(this.quoteIdentifier(asRight)),
        model: include.model
      });
      if (joinWhere) {
        if (include.or) {
          joinOn += ' OR ' + joinWhere;
        } else {
          joinOn += ' AND ' + joinWhere;
        }
      }
    }

    return joinType + this.quoteTable(tableRight, asRight) + ' ON ' + joinOn;
  },

  /**
   * Returns a query that starts a transaction.
   *
   * @param  {Boolean} value   A boolean that states whether autocommit shall be done or not.
   * @param  {Object}  options An object with options.
   * @return {String}          The generated sql query.
   */
  setAutocommitQuery: function(value, options) {
    if (options.parent) {
      return;
    }

    return 'SET autocommit = ' + (!!value ? 1 : 0) + ';';
  },

  /**
   * Returns a query that sets the transaction isolation level.
   *
   * @param  {String} value   The isolation level.
   * @param  {Object} options An object with options.
   * @return {String}         The generated sql query.
   */
  setIsolationLevelQuery: function(value, options) {
    if (options.parent) {
      return;
    }

    return 'SET SESSION TRANSACTION ISOLATION LEVEL ' + value + ';';
  },

  generateTransactionId: function() {
    return uuid.v4();
  },

  /**
   * Returns a query that starts a transaction.
   *
   * @param  {Transaction} transaction
   * @param  {Object} options An object with options.
   * @return {String}         The generated sql query.
   */
  startTransactionQuery: function(transaction) {
    if (transaction.parent) {
      // force quoting of savepoint identifiers for postgres
      return 'SAVEPOINT ' + this.quoteIdentifier(transaction.name, true) + ';';
    }

    return 'START TRANSACTION;';
  },

  /**
   * Returns a query that defers the constraints. Only works for postgres.
   *
   * @param  {Transaction} transaction
   * @param  {Object} options An object with options.
   * @return {String}         The generated sql query.
   */
  deferConstraintsQuery: function () {},

  setConstraintQuery: function () {},
  setDeferredQuery: function () {},
  setImmediateQuery: function () {},

  /**
   * Returns a query that commits a transaction.
   *
   * @param  {Object} options An object with options.
   * @return {String}         The generated sql query.
   */
  commitTransactionQuery: function(transaction) {
    if (transaction.parent) {
      return;
    }

    return 'COMMIT;';
  },

  /**
   * Returns a query that rollbacks a transaction.
   *
   * @param  {Transaction} transaction
   * @param  {Object} options An object with options.
   * @return {String}         The generated sql query.
   */
  rollbackTransactionQuery: function(transaction) {
    if (transaction.parent) {
      // force quoting of savepoint identifiers for postgres
      return 'ROLLBACK TO SAVEPOINT ' + this.quoteIdentifier(transaction.name, true) + ';';
    }

    return 'ROLLBACK;';
  },

  /**
   * Returns an SQL fragment for adding result constraints
   *
   * @param  {Object} options An object with selectQuery options.
   * @param  {Object} options The model passed to the selectQuery.
   * @return {String}         The generated sql query.
   */
  addLimitAndOffset: function(options, model) {
    var fragment = '';

    /*jshint eqeqeq:false*/
    if (options.offset != null && options.limit == null) {
      fragment += ' LIMIT ' + this.escape(options.offset) + ', ' + 10000000000000;
    } else if (options.limit != null) {
      if (options.offset != null) {
        fragment += ' LIMIT ' + this.escape(options.offset) + ', ' + this.escape(options.limit);
      } else {
        fragment += ' LIMIT ' + this.escape(options.limit);
      }
    }

    return fragment;
  },

  handleSequelizeMethod: function (smth, tableName, factory, options, prepend) {
    var self = this
      , result;

    if (smth instanceof Utils.where) {
      var value = smth.logic
        , key;

      if (smth.attribute._isSequelizeMethod) {
        key = this.getWhereConditions(smth.attribute, tableName, factory, options, prepend);
      } else {
        key = this.quoteTable(smth.attribute.Model.name) + '.' + this.quoteIdentifier(smth.attribute.field || smth.attribute.fieldName);
      }

      if (value && value._isSequelizeMethod) {
        value = this.getWhereConditions(value, tableName, factory, options, prepend);

        result = (value === 'NULL') ? key + ' IS NULL' : [key, value].join(smth.comparator);
      } else if (_.isPlainObject(value)) {
        result = this.whereItemQuery(smth.attribute, value, {
          model: factory
        });
      } else {
        if (typeof value === 'boolean') {
          value = this.booleanValue(value);
        } else {
          value = this.escape(value);
        }

        result = (value === 'NULL') ? key + ' IS NULL' : [key, value].join(' ' + smth.comparator + ' ');
      }
    } else if (smth instanceof Utils.literal) {
      result = smth.val;
    } else if (smth instanceof Utils.cast) {
      if (smth.val._isSequelizeMethod) {
        result = this.handleSequelizeMethod(smth.val, tableName, factory, options, prepend);
      } else if (_.isPlainObject(smth.val)) {
        result = this.whereItemsQuery(smth.val);
      } else {
        result = this.escape(smth.val);
      }

      result = 'CAST(' + result + ' AS ' + smth.type.toUpperCase() + ')';
    } else if (smth instanceof Utils.fn) {
      result = smth.fn + '(' + smth.args.map(function(arg) {
        if (arg._isSequelizeMethod) {
          return self.handleSequelizeMethod(arg, tableName, factory, options, prepend);
        } else if (_.isPlainObject(arg)) {
          return self.whereItemsQuery(arg);
        } else {
          return self.escape(arg);
        }
      }).join(', ') + ')';
    } else if (smth instanceof Utils.col) {
      if (Array.isArray(smth.col)) {
        if (!factory) {
          throw new Error('Cannot call Sequelize.col() with array outside of order / group clause');
        }
      } else if (smth.col.indexOf('*') === 0) {
        return '*';
      }
      return this.quote(smth.col, factory);
    } else {
      result = smth.toString(this, factory);
    }

    return result;
  },

  whereQuery: function(where, options) {
    var query = this.whereItemsQuery(where, options);
    if (query && query.length) {
      return 'WHERE '+query;
    }
    return '';
  },
  whereItemsQuery: function(where, options, binding) {
    if (
      (Array.isArray(where) && where.length === 0) ||
      (_.isPlainObject(where) && _.isEmpty(where)) ||
      where === null ||
      where === undefined
    ) {
      // NO OP
      return '';
    }

    if (_.isString(where)) {
      throw new Error('where: ""raw query"" has been removed, please use where [""raw query"", [replacements]]');
    }

    var self = this
      , items = [];

    binding = binding || 'AND';
    if (binding.substr(0, 1) !== ' ') binding = ' '+binding+' ';

    if (_.isPlainObject(where)) {
      _.forOwn(where, function (value, key) {
        items.push(self.whereItemQuery(key, value, options));
      });
    } else {
      items.push(self.whereItemQuery(undefined, where, options));
    }

    return items.length && items.filter(function (item) {
      return item && item.length;
    }).join(binding) || '';
  },
  whereItemQuery: function(key, value, options) {
    options = options || {};

    var self = this
      , binding
      , outerBinding
      , comparatorMap
      , aliasMap
      , comparator = '='
      , field = options.field || options.model && options.model.rawAttributes && options.model.rawAttributes[key] || options.model && options.model.fieldRawAttributesMap && options.model.fieldRawAttributesMap[key]
      , fieldType = options.type || (field && field.type)
      , tmp;

    if (key && typeof key === 'string' && key.indexOf('.') !== -1 && options.model) {
      if (options.model.rawAttributes[key.split('.')[0]] && options.model.rawAttributes[key.split('.')[0]].type instanceof DataTypes.JSON) {
        field = options.model.rawAttributes[key.split('.')[0]];
        fieldType = field.type;
        tmp = value;
        value = {};

        Dottie.set(value, key.split('.').slice(1), tmp);
        key = field.field || key.split('.')[0];
      }
    }

    comparatorMap = {
      $eq: '=',
      $ne: '!=',
      $gte: '>=',
      $gt: '>',
      $lte: '<=',
      $lt: '<',
      $not: 'IS NOT',
      $is: 'IS',
      $like: 'LIKE',
      $notLike: 'NOT LIKE',
      $iLike: 'ILIKE',
      $notILike: 'NOT ILIKE',
      $between: 'BETWEEN',
      $notBetween: 'NOT BETWEEN',
      $overlap: '&&',
      $contains: '@>',
      $contained: '<@'
    };

    // Maintain BC
    aliasMap = {
      'ne': '$ne',
      'in': '$in',
      'not': '$not',
      'notIn': '$notIn',
      'gte': '$gte',
      'gt': '$gt',
      'lte': '$lte',
      'lt': '$lt',
      'like': '$like',
      'ilike': '$iLike',
      '$ilike': '$iLike',
      'nlike': '$notLike',
      '$notlike': '$notLike',
      'notilike': '$notILike',
      '..': '$between',
      'between': '$between',
      '!..': '$notBetween',
      'notbetween': '$notBetween',
      'nbetween': '$notBetween',
      'overlap': '$overlap',
      '&&': '$overlap',
      '@>': '$contains',
      '<@': '$contained'
    };

    key = aliasMap[key] || key;
    if (_.isPlainObject(value)) {
      _.forOwn(value, function (item, key) {
        if (aliasMap[key]) {
          value[aliasMap[key]] = item;
          delete value[key];
        }
      });
    }

    if (key === undefined) {
      if (typeof value === 'string') {
        return value;
      }

      if (_.isPlainObject(value) && _.size(value) === 1) {
        key = Object.keys(value)[0];
        value = _.values(value)[0];
      }
    }

    if (value && value._isSequelizeMethod && !(key !== undefined && value instanceof Utils.fn)) {
      return this.handleSequelizeMethod(value);
    }

    // Convert where: [] to $and if possible, else treat as literal/replacements
    if (key === undefined && Array.isArray(value)) {
      if (Utils.canTreatArrayAsAnd(value)) {
        key = '$and';
      } else {
        return Utils.format(value, this.dialect);
      }
    }
    // OR/AND/NOT grouping logic
    if (key === '$or' || key === '$and' || key === '$not') {
      binding = (key === '$or') ?' OR ' : ' AND ';
      outerBinding = '';
      if (key === '$not') outerBinding = 'NOT ';

      if (Array.isArray(value)) {
        value = value.map(function (item) {
          var itemQuery = self.whereItemsQuery(item, options, ' AND ');
          if ((Array.isArray(item) || _.isPlainObject(item)) && _.size(item) > 1) {
            itemQuery = '('+itemQuery+')';
          }
          return itemQuery;
        }).filter(function (item) {
          return item && item.length;
        });

        // $or: [] should return no data.
        // $not of no restriction should also return no data
        if ((key === '$or' || key === '$not') && value.length === 0) {
          return '0 = 1';
        }

        return value.length ? outerBinding + '('+value.join(binding)+')' : undefined;
      } else {
        value = self.whereItemsQuery(value, options, binding);

        if ((key === '$or' || key === '$not') && !value) {
          return '0 = 1';
        }

        return value ? outerBinding + '('+value+')' : undefined;
      }
    }

    if (value && (value.$or || value.$and)) {
      binding = value.$or ? ' OR ' : ' AND ';
      value = value.$or || value.$and;

      if (_.isPlainObject(value)) {
        value = _.reduce(value, function (result, _value, key) {
          result.push(_.zipObject([key], [_value]));
          return result;
        }, []);
      }

      value = value.map(function (_value) {
        return self.whereItemQuery(key, _value, options);
      }).filter(function (item) {
        return item && item.length;
      });

      return value.length ? '('+value.join(binding)+')' : undefined;
    }

    if (_.isPlainObject(value) && fieldType instanceof DataTypes.JSON && options.json !== false) {
      return (function () {
        var $items = []
          , result
          , traverse;

        traverse = function (prop, item, path) {
          var $where = {}
            , $key
            , $cast
            , $baseKey
            , $tmp
            , castKey;

          if (path[path.length - 1].indexOf('::') > -1) {
            $tmp = path[path.length - 1].split('::');
            $cast = $tmp[1];
            path[path.length - 1] = $tmp[0];
          }

          $baseKey = self.quoteIdentifier(key)+'#>>\'{'+path.join(', ')+'}\'';

          if (options.prefix) {
            if (options.prefix instanceof Utils.literal) {
              $baseKey = self.handleSequelizeMethod(options.prefix)+'.'+$baseKey;
            } else {
              $baseKey = self.quoteTable(options.prefix)+'.'+$baseKey;
            }
          }

          $baseKey = '('+$baseKey+')';

          castKey = function ($item) {
            var key = $baseKey;

            if (!$cast) {
              if (typeof $item === 'number') {
                $cast = 'double precision';
              } else if ($item instanceof Date) {
                $cast = 'timestamptz';
              } else if (typeof $item === 'boolean') {
                $cast = 'boolean';
              }
            }

            if ($cast) {
              key += '::'+$cast;
            }

            return key;
          };

          if (_.isPlainObject(item)) {
            _.forOwn(item, function ($item, $prop) {
              if ($prop.indexOf('$') === 0) {
                $where[$prop] = $item;
                $key = castKey($item);

                $items.push(self.whereItemQuery(new Utils.literal($key), $where/*, _.pick(options, 'prefix')*/));
              } else {
                traverse($prop, $item, path.concat([$prop]));
              }
            });
          } else {
            $where.$eq = item;
            $key = castKey(item);

            $items.push(self.whereItemQuery(new Utils.literal($key), $where/*, _.pick(options, 'prefix')*/));
          }
        };

        _.forOwn(value, function (item, prop) {
          if (prop.indexOf('$') === 0) {
            var $where = {};
            $where[prop] = item;
            $items.push(self.whereItemQuery(key, $where, _.assign({}, options, {json: false})));
            return;
          }

          traverse(prop, item, [prop]);
        });

        result = $items.join(' AND ');
        return $items.length > 1 ? '('+result+')' : result;
      })();
    }

    // If multiple keys we combine the different logic conditions
    if (_.isPlainObject(value) && Object.keys(value).length > 1) {
      return (function () {
        var $items = [];
        _.forOwn(value, function (item, logic) {
          var $where = {};
          $where[logic] = item;
          $items.push(self.whereItemQuery(key, $where, options));
        });

        return '('+$items.join(' AND ')+')';
      })();
    }

    // Do [] to $in/$notIn normalization
    if (value && (!fieldType || !(fieldType instanceof DataTypes.ARRAY))) {
      if (Array.isArray(value)) {
        value = {
          $in: value
        };
      } else if (value && Array.isArray(value.$not)) {
        value.$notIn = value.$not;
        delete value.$not;
      }
    }

    // normalize $not: non-bool|non-null to $ne
    if (value && typeof value.$not !== 'undefined' && [null, true, false].indexOf(value.$not) < 0) {
      value.$ne = value.$not;
      delete value.$not;
    }

    // Setup keys and comparators
    if (Array.isArray(value) && fieldType instanceof DataTypes.ARRAY) {
      value = this.escape(value, field);
    } else if (value && (value.$in || value.$notIn)) {
      comparator = 'IN';
      if (value.$notIn) comparator = 'NOT IN';

      if ((value.$in || value.$notIn) instanceof Utils.literal) {
        value = (value.$in || value.$notIn).val;
      } else if ((value.$in || value.$notIn).length) {
        value = '('+(value.$in || value.$notIn).map(function (item) {
          return self.escape(item);
        }).join(', ')+')';
      } else {
        value = '(NULL)';
      }
    } else if (value && (value.$any || value.$all)) {
      comparator = value.$any ? '= ANY' : '= ALL';
      if (value.$any && value.$any.$values || value.$all && value.$all.$values) {
        value = '(VALUES '+(value.$any && value.$any.$values || value.$all && value.$all.$values).map(function (value) {
          return '('+this.escape(value)+')';
        }.bind(this)).join(', ')+')';
      } else {
        value = '('+this.escape(value.$any || value.$all, field)+')';
      }
    } else if (value && (value.$between || value.$notBetween)) {
      comparator = 'BETWEEN';
      if (value.$notBetween) comparator = 'NOT BETWEEN';

      value = (value.$between || value.$notBetween).map(function (item) {
        return self.escape(item);
      }).join(' AND ');
    } else if (value && value.$raw) {
      value = value.$raw;
    } else if (value && value.$col) {
      value = value.$col.split('.');

      if (value.length > 2) {
        value = [
          value.slice(0, -1).join('.'),
          value[value.length - 1]
        ];
      }

      value = value.map(this.quoteIdentifier.bind(this)).join('.');
    } else {
      var escapeValue = true;
      var escapeOptions = {};

      if (_.isPlainObject(value)) {
        _.forOwn(value, function (item, key) {
          if (comparatorMap[key]) {
            comparator = comparatorMap[key];
            value = item;

            if (_.isPlainObject(value) && value.$any) {
              comparator += ' ANY';
              escapeOptions.isList = true;
              value = value.$any;
            } else if (_.isPlainObject(value) && value.$all) {
              comparator += ' ALL';
              escapeOptions.isList = true;
              value = value.$all;
            } else if (value && value.$col) {
              escapeValue = false;
              value = this.whereItemQuery(null, value);
            }
          }
        }.bind(this));
      }

      if (comparator === '=' && value === null) {
        comparator = 'IS';
      } else if (comparator === '!=' && value === null) {
        comparator = 'IS NOT';
      }

      escapeOptions.acceptStrings = comparator.indexOf('LIKE') !== -1;

      if (escapeValue) {
        value = this.escape(value, field, escapeOptions);

        //if ANY is used with like, add parentheses to generate correct query
        if (escapeOptions.acceptStrings && (comparator.indexOf('ANY') > comparator.indexOf('LIKE'))) {
         value = '(' + value + ')';
        }
      }
    }

    if (key) {
      var prefix = true;
      if (key._isSequelizeMethod) {
        key = this.handleSequelizeMethod(key);
      } else if (Utils.isColString(key)) {
        key = key.substr(1, key.length - 2).split('.');

        if (key.length > 2) {
          key = [
            key.slice(0, -1).join('.'),
            key[key.length - 1]
          ];
        }

        key = key.map(this.quoteIdentifier.bind(this)).join('.');
        prefix = false;
      } else {
        key = this.quoteIdentifier(key);
      }

      if (options.prefix && prefix) {
        if (options.prefix instanceof Utils.literal) {
          key = [this.handleSequelizeMethod(options.prefix), key].join('.');
        } else {
          key = [this.quoteTable(options.prefix), key].join('.');
        }
      }
      return [key, value].join(' '+comparator+' ');
    }
    return value;
  },

  /*
    Takes something and transforms it into values of a where condition.
  */
  getWhereConditions: function(smth, tableName, factory, options, prepend) {
    var result = null
      , where = {}
      , self = this;

    if (Array.isArray(tableName)) {
      tableName = tableName[0];
      if (Array.isArray(tableName)) {
        tableName = tableName[1];
      }
    }

    options = options || {};

    if (typeof prepend === 'undefined') {
      prepend = true;
    }

    if (smth && smth._isSequelizeMethod === true) { // Checking a property is cheaper than a lot of instanceof calls
      result = this.handleSequelizeMethod(smth, tableName, factory, options, prepend);
    } else if (Utils._.isPlainObject(smth)) {
      return self.whereItemsQuery(smth, {
        model: factory,
        prefix: prepend && tableName
      });
    } else if (typeof smth === 'number') {
      var primaryKeys = !!factory ? Object.keys(factory.primaryKeys) : [];

      if (primaryKeys.length > 0) {
        // Since we're just a number, assume only the first key
        primaryKeys = primaryKeys[0];
      } else {
        primaryKeys = 'id';
      }

      where[primaryKeys] = smth;

      return self.whereItemsQuery(where, {
        model: factory,
        prefix: prepend && tableName
      });
    } else if (typeof smth === 'string') {
      return self.whereItemsQuery(smth, {
        model: factory,
        prefix: prepend && tableName
      });
    } else if (Buffer.isBuffer(smth)) {
      result = this.escape(smth);
    } else if (Array.isArray(smth)) {
      if (smth.length === 0) return '1=1';
      if (Utils.canTreatArrayAsAnd(smth)) {
        var _smth = { $and: smth };
        result = self.getWhereConditions(_smth, tableName, factory, options, prepend);
      } else {
        result = Utils.format(smth, this.dialect);
      }
    } else if (smth === null) {
      return self.whereItemsQuery(smth, {
        model: factory,
        prefix: prepend && tableName
      });
    }

    return result ? result : '1=1';
  },

  booleanValue: function(value) {
    return value;
  }
};

module.exports = QueryGenerator;
","  'use strict';

var Utils = require('../../utils')
  , SqlString = require('../../sql-string')
  , Model = require('../../model')
  , DataTypes = require('../../data-types')
  , _ = require('lodash')
  , util = require('util')
  , Dottie = require('dottie')
  , BelongsTo = require('../../associations/belongs-to')
  , BelongsToMany = require('../../associations/belongs-to-many')
  , HasMany = require('../../associations/has-many')
  , uuid = require('uuid')
  , semver = require('semver')
  , deprecate = require('depd')('sequelize');

/* istanbul ignore next */
var throwMethodUndefined = function(methodName) {
  throw new Error('The method ""' + methodName + '"" is not defined! Please add it to your sql dialect.');
};

var QueryGenerator = {
  options: {},

  extractTableDetails: function(tableName, options) {
    options = options || {};
    tableName = tableName || {};
    return {
      schema: tableName.schema || options.schema || 'public',
      tableName: _.isPlainObject(tableName) ? tableName.tableName : tableName,
      delimiter: tableName.delimiter || options.delimiter || '.'
    };
  },

  addSchema: function(param) {
    var self = this;

    if (!param.$schema) return param.tableName || param;

    return {
      tableName: param.tableName || param,
      table: param.tableName || param,
      name: param.name || param,
      schema: param.$schema,
      delimiter: param.$schemaDelimiter || '.',
      toString: function() {
        return self.quoteTable(this);
      }
    };
  },

  /*
    Returns a query for dropping a schema
  */
  dropSchema: function(tableName, options) {
    return this.dropTableQuery(tableName, options);
  },

  /*
    Returns a query for creating a table.
    Parameters:
      - tableName: Name of the new table.
      - attributes: An object with containing attribute-attributeType-pairs.
                    Attributes should have the format:
                    {attributeName: type, attr2: type2}
                    --> e.g. {title: 'VARCHAR(255)'}
      - options: An object with options.
                 Defaults: { engine: 'InnoDB', charset: null }
  */
  /* istanbul ignore next */
  createTableQuery: function(tableName, attributes, options) {
    throwMethodUndefined('createTableQuery');
  },

  versionQuery: function(tableName, attributes, options) {
    throwMethodUndefined('versionQuery');
  },

  describeTableQuery: function(tableName, schema, schemaDelimiter) {
    var table = this.quoteTable(
      this.addSchema({
        tableName: tableName,
        $schema: schema,
        $schemaDelimiter: schemaDelimiter
      })
    );

    return 'DESCRIBE ' + table + ';';
  },

  /*
    Returns a query for dropping a table.
  */
  dropTableQuery: function(tableName, options) {
    options = options || {};

    var query = 'DROP TABLE IF EXISTS <%= table %>;';

    return Utils._.template(query)({
      table: this.quoteTable(tableName)
    });
  },

  /*
    Returns a rename table query.
    Parameters:
      - originalTableName: Name of the table before execution.
      - futureTableName: Name of the table after execution.
  */
  renameTableQuery: function(before, after) {
    var query = 'ALTER TABLE <%= before %> RENAME TO <%= after %>;';
    return Utils._.template(query)({
      before: this.quoteTable(before),
      after: this.quoteTable(after)
    });
  },

  /*
    Returns a query, which gets all available table names in the database.
  */
  /* istanbul ignore next */
  showTablesQuery: function() {
    throwMethodUndefined('showTablesQuery');
  },

  /*
    Returns a query, which adds an attribute to an existing table.
    Parameters:
      - tableName: Name of the existing table.
      - attributes: A hash with attribute-attributeOptions-pairs.
        - key: attributeName
        - value: A hash with attribute specific options:
          - type: DataType
          - defaultValue: A String with the default value
          - allowNull: Boolean
  */
  /* istanbul ignore next */
  addColumnQuery: function(tableName, attributes) {
    throwMethodUndefined('addColumnQuery');
  },

  /*
    Returns a query, which removes an attribute from an existing table.
    Parameters:
      - tableName: Name of the existing table
      - attributeName: Name of the obsolete attribute.
  */
  /* istanbul ignore next */
  removeColumnQuery: function(tableName, attributeName) {
    throwMethodUndefined('removeColumnQuery');
  },

  /*
    Returns a query, which modifies an existing attribute from a table.
    Parameters:
      - tableName: Name of the existing table.
      - attributes: A hash with attribute-attributeOptions-pairs.
        - key: attributeName
        - value: A hash with attribute specific options:
          - type: DataType
          - defaultValue: A String with the default value
          - allowNull: Boolean
  */
  /* istanbul ignore next */
  changeColumnQuery: function(tableName, attributes) {
    throwMethodUndefined('changeColumnQuery');
  },

  /*
    Returns a query, which renames an existing attribute.
    Parameters:
      - tableName: Name of an existing table.
      - attrNameBefore: The name of the attribute, which shall be renamed.
      - attrNameAfter: The name of the attribute, after renaming.
  */
  /* istanbul ignore next */
  renameColumnQuery: function(tableName, attrNameBefore, attrNameAfter) {
    throwMethodUndefined('renameColumnQuery');
  },

  /*
    Returns an insert into command. Parameters: table name + hash of attribute-value-pairs.
  */
  insertQuery: function(table, valueHash, modelAttributes, options) {
    options = options || {};
    _.defaults(options, this.options);

    var query
      , valueQuery = '<%= tmpTable %>INSERT<%= ignore %> INTO <%= table %> (<%= attributes %>)<%= output %> VALUES (<%= values %>)'
      , emptyQuery = '<%= tmpTable %>INSERT<%= ignore %> INTO <%= table %><%= output %>'
      , outputFragment
      , fields = []
      , values = []
      , key
      , value
      , identityWrapperRequired = false
      , modelAttributeMap = {}
      , tmpTable = ''         //tmpTable declaration for trigger
      , selectFromTmp = ''    //Select statement for trigger
      , tmpColumns = ''       //Columns for temp table for trigger
      , outputColumns = ''    //Columns to capture into temp table for trigger
      , attribute             //Model attribute holder
      , modelKey;             //key for model

    if (modelAttributes) {
      Utils._.each(modelAttributes, function(attribute, key) {
        modelAttributeMap[key] = attribute;
        if (attribute.field) {
          modelAttributeMap[attribute.field] = attribute;
        }
      });
    }

    if (this._dialect.supports['DEFAULT VALUES']) {
      emptyQuery += ' DEFAULT VALUES';
    } else if (this._dialect.supports['VALUES ()']) {
      emptyQuery += ' VALUES ()';
    }

    if (this._dialect.supports.returnValues && options.returning) {
      if (!!this._dialect.supports.returnValues.returning) {
        valueQuery += ' RETURNING *';
        emptyQuery += ' RETURNING *';
      } else if (!!this._dialect.supports.returnValues.output) {
        outputFragment = ' OUTPUT INSERTED.*';

        //To capture output rows when there is a trigger on MSSQL DB
        if (modelAttributes && options.hasTrigger && this._dialect.supports.tmpTableTrigger) {
            tmpTable = 'declare @tmp table (<%= columns %>); ';

            for (modelKey in modelAttributes){
              attribute = modelAttributes[modelKey];
              if(!(attribute.type instanceof DataTypes.VIRTUAL)){
                if (tmpColumns.length > 0){
                  tmpColumns += ',';
                  outputColumns += ',';
                }

                tmpColumns += this.quoteIdentifier(attribute.field) + ' ' + attribute.type.toSql();
                outputColumns += 'INSERTED.' + this.quoteIdentifier(attribute.field);
              }
            }

            var replacement ={
              columns : tmpColumns
            };

            tmpTable = Utils._.template(tmpTable)(replacement).trim();
            outputFragment = ' OUTPUT ' + outputColumns + ' into @tmp';
            selectFromTmp = ';select * from @tmp';

            valueQuery += selectFromTmp;
            emptyQuery += selectFromTmp;
        }
      }
    }

    if (this._dialect.supports.EXCEPTION && options.exception) {
      // Mostly for internal use, so we expect the user to know what he's doing!
      // pg_temp functions are private per connection, so we never risk this function interfering with another one.
      if (semver.gte(this.sequelize.options.databaseVersion, '9.2.0')) {
        // >= 9.2 - Use a UUID but prefix with 'func_' (numbers first not allowed)
        var delimiter = '$func_' + uuid.v4().replace(/-/g, '') + '$';

        options.exception = 'WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL;';
        valueQuery = 'CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response <%= table %>, OUT sequelize_caught_exception text) RETURNS RECORD AS ' + delimiter +
          ' BEGIN ' + valueQuery + ' INTO response; EXCEPTION ' + options.exception + ' END ' + delimiter +
          ' LANGUAGE plpgsql; SELECT (testfunc.response).*, testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc()';
      } else {
        options.exception = 'WHEN unique_violation THEN NULL;';
        valueQuery = 'CREATE OR REPLACE FUNCTION pg_temp.testfunc() RETURNS SETOF <%= table %> AS $body$ BEGIN RETURN QUERY ' + valueQuery + '; EXCEPTION ' + options.exception + ' END; $body$ LANGUAGE plpgsql; SELECT * FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc();';
      }
    }

    if (this._dialect.supports['ON DUPLICATE KEY'] && options.onDuplicate) {
      valueQuery += ' ON DUPLICATE KEY ' + options.onDuplicate;
      emptyQuery += ' ON DUPLICATE KEY ' + options.onDuplicate;
    }

    valueHash = Utils.removeNullValuesFromHash(valueHash, this.options.omitNull);
    for (key in valueHash) {
      if (valueHash.hasOwnProperty(key)) {
        value = valueHash[key];
        fields.push(this.quoteIdentifier(key));

        // SERIALS' can't be NULL in postgresql, use DEFAULT where supported
        if (modelAttributeMap && modelAttributeMap[key] && modelAttributeMap[key].autoIncrement === true && !value) {
          if (!this._dialect.supports.autoIncrement.defaultValue) {
            fields.splice(-1,1);
          } else if (this._dialect.supports.DEFAULT) {
            values.push('DEFAULT');
          } else {
            values.push(this.escape(null));
          }
        } else {
          if (modelAttributeMap && modelAttributeMap[key] && modelAttributeMap[key].autoIncrement === true) {
            identityWrapperRequired = true;
          }

          values.push(this.escape(value, (modelAttributeMap && modelAttributeMap[key]) || undefined, { context: 'INSERT' }));
        }
      }
    }

    var replacements = {
      ignore: options.ignore ? this._dialect.supports.IGNORE : '',
      table: this.quoteTable(table),
      attributes: fields.join(','),
      output: outputFragment,
      values: values.join(','),
      tmpTable: tmpTable
    };

    query = (replacements.attributes.length ? valueQuery : emptyQuery) + ';';
    if (identityWrapperRequired && this._dialect.supports.autoIncrement.identityInsert) {
      query = [
        'SET IDENTITY_INSERT', this.quoteTable(table), 'ON;',
        query,
        'SET IDENTITY_INSERT', this.quoteTable(table), 'OFF;',
      ].join(' ');
    }

    return Utils._.template(query)(replacements);
  },

  /*
    Returns an insert into command for multiple values.
    Parameters: table name + list of hashes of attribute-value-pairs.
  */
  bulkInsertQuery: function(tableName, attrValueHashes, options, rawAttributes) {
    options = options || {};
    rawAttributes = rawAttributes || {};

    var query = 'INSERT<%= ignoreDuplicates %> INTO <%= table %> (<%= attributes %>) VALUES <%= tuples %><%= onDuplicateKeyUpdate %><%= returning %>;'
      , tuples = []
      , serials = []
      , allAttributes = []
      , onDuplicateKeyUpdate = '';

    attrValueHashes.forEach(function(attrValueHash) {
      _.forOwn(attrValueHash, function(value, key) {
        if (allAttributes.indexOf(key) === -1) {
          allAttributes.push(key);
        }

        if (rawAttributes[key] && rawAttributes[key].autoIncrement === true) {
          serials.push(key);
        }
      });
    });

    attrValueHashes.forEach(function(attrValueHash) {
      tuples.push('(' +
        allAttributes.map(function(key) {
          if (this._dialect.supports.bulkDefault && serials.indexOf(key) !== -1) {
            return attrValueHash[key] || 'DEFAULT';
          }
          return this.escape(attrValueHash[key], rawAttributes[key], { context: 'INSERT' });
        }, this).join(',') +
        ')');
    }, this);

    if (this._dialect.supports.updateOnDuplicate && options.updateOnDuplicate) {
      onDuplicateKeyUpdate += ' ON DUPLICATE KEY UPDATE ' + options.updateOnDuplicate.map(function(attr) {
        var field = rawAttributes && rawAttributes[attr] && rawAttributes[attr].field || attr;
        var key = this.quoteIdentifier(field);
        return key + '=VALUES(' + key + ')';
      }, this).join(',');
    }

    var replacements = {
      ignoreDuplicates: options.ignoreDuplicates ? this._dialect.supports.ignoreDuplicates : '',
      table: this.quoteTable(tableName),
      attributes: allAttributes.map(function(attr) {
        return this.quoteIdentifier(attr);
      }, this).join(','),
      tuples: tuples.join(','),
      onDuplicateKeyUpdate: onDuplicateKeyUpdate,
      returning: this._dialect.supports.returnValues && options.returning ? ' RETURNING *' : ''
    };

    return _.template(query)(replacements);
  },

  /*
    Returns an update query.
    Parameters:
      - tableName -> Name of the table
      - values -> A hash with attribute-value-pairs
      - where -> A hash with conditions (e.g. {name: 'foo'})
                 OR an ID as integer
                 OR a string with conditions (e.g. 'name=""foo""').
                 If you use a string, you have to escape it on your own.
  */
  updateQuery: function(tableName, attrValueHash, where, options, attributes) {
    options = options || {};
    _.defaults(options, this.options);

    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);

    var query
      , values = []
      , outputFragment
      , modelAttributeMap = {}
      , tmpTable = ''         //tmpTable declaration for trigger
      , selectFromTmp = ''    //Select statement for trigger
      , tmpColumns = ''       //Columns for temp table for trigger
      , outputColumns = ''    //Columns to capture into temp table for trigger
      , attribute             //Model attribute holder
      , modelKey;             //key for model

    query = '<%= tmpTable %>UPDATE <%= table %> SET <%= values %><%= output %> <%= where %>';

    if (this._dialect.supports['LIMIT ON UPDATE'] && options.limit) {
      query += ' LIMIT ' + this.escape(options.limit) + ' ';
    }

    if (this._dialect.supports.returnValues) {
      if (!!this._dialect.supports.returnValues.output) {
        // we always need this for mssql
        outputFragment = ' OUTPUT INSERTED.*';

        //To capture output rows when there is a trigger on MSSQL DB
        if (attributes && options.hasTrigger && this._dialect.supports.tmpTableTrigger) {
            tmpTable = 'declare @tmp table (<%= columns %>); ';

            for (modelKey in attributes){
              attribute = attributes[modelKey];
              if(!(attribute.type instanceof DataTypes.VIRTUAL)){
                if (tmpColumns.length > 0){
                  tmpColumns += ',';
                  outputColumns += ',';
                }

                tmpColumns += this.quoteIdentifier(attribute.field) + ' ' + attribute.type.toSql();
                outputColumns += 'INSERTED.' + this.quoteIdentifier(attribute.field);
              }
            }

            var replacement ={
              columns : tmpColumns
            };

            tmpTable = Utils._.template(tmpTable)(replacement).trim();
            outputFragment = ' OUTPUT ' + outputColumns + ' into @tmp';
            selectFromTmp = ';select * from @tmp';

            query += selectFromTmp;
        }
      } else if (this._dialect.supports.returnValues && options.returning) {
        // ensure that the return output is properly mapped to model fields.
        options.mapToModel = true;
        query += ' RETURNING *';
      }
    }

    if (attributes) {
      Utils._.each(attributes, function(attribute, key) {
        modelAttributeMap[key] = attribute;
        if (attribute.field) {
          modelAttributeMap[attribute.field] = attribute;
        }
      });
    }

    for (var key in attrValueHash) {
      if (modelAttributeMap && modelAttributeMap[key] &&
          modelAttributeMap[key].autoIncrement === true &&
          !this._dialect.supports.autoIncrement.update) {
        // not allowed to update identity column
        continue;
      }

      var value = attrValueHash[key];
      values.push(this.quoteIdentifier(key) + '=' + this.escape(value, (modelAttributeMap && modelAttributeMap[key] || undefined), { context: 'UPDATE' }));
    }

    var replacements = {
      table: this.quoteTable(tableName),
      values: values.join(','),
      output: outputFragment,
      where: this.whereQuery(where),
      tmpTable: tmpTable
    };

    if (values.length === 0) {
      return '';
    }

    return Utils._.template(query)(replacements).trim();
  },

  /*
    Returns an upsert query.
  */
  upsertQuery: function (tableName, insertValues, updateValues, where, rawAttributes, options) {
    throwMethodUndefined('upsertQuery');
  },

  /*
    Returns a deletion query.
    Parameters:
      - tableName -> Name of the table
      - where -> A hash with conditions (e.g. {name: 'foo'})
                 OR an ID as integer
                 OR a string with conditions (e.g. 'name=""foo""').
                 If you use a string, you have to escape it on your own.
    Options:
      - limit -> Maximaum count of lines to delete
      - truncate -> boolean - whether to use an 'optimized' mechanism (i.e. TRUNCATE) if available,
                              note that this should not be the default behaviour because TRUNCATE does not
                              always play nicely (e.g. InnoDB tables with FK constraints)
                              (@see http://dev.mysql.com/doc/refman/5.6/en/truncate-table.html).
                              Note that truncate must ignore limit and where
  */
  /* istanbul ignore next */
  deleteQuery: function(tableName, where, options) {
    throwMethodUndefined('deleteQuery');
  },

  /*
    Returns an update query.
    Parameters:
      - tableName -> Name of the table
      - values -> A hash with attribute-value-pairs
      - where -> A hash with conditions (e.g. {name: 'foo'})
                 OR an ID as integer
                 OR a string with conditions (e.g. 'name=""foo""').
                 If you use a string, you have to escape it on your own.
  */
  incrementQuery: function(tableName, attrValueHash, where, options) {
    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, this.options.omitNull);

    var query
      , key
      , value
      , values = []
      , outputFragment;

    query = 'UPDATE <%= table %> SET <%= values %><%= output %> <%= where %>';
    if (this._dialect.supports.returnValues) {
      if (!!this._dialect.supports.returnValues.returning) {
        query += ' RETURNING *';
      } else if (!!this._dialect.supports.returnValues.output) {
        outputFragment = ' OUTPUT INSERTED.*';
      }
    }

    for (key in attrValueHash) {
      value = attrValueHash[key];
      values.push(this.quoteIdentifier(key) + '=' + this.quoteIdentifier(key) + ' + ' + this.escape(value));
    }

    options = options || {};
    for (key in options) {
      value = options[key];
      values.push(this.quoteIdentifier(key) + '=' + this.escape(value));
    }

    var replacements = {
      table: this.quoteTable(tableName),
      values: values.join(','),
      output: outputFragment,
      where: this.whereQuery(where)
    };

    return Utils._.template(query)(replacements);
  },

  nameIndexes: function (indexes, rawTablename) {
    return Utils._.map(indexes, function (index) {
      if (!index.hasOwnProperty('name')) {
        var onlyAttributeNames = index.fields.map(function(field) {
          return (typeof field === 'string') ? field : (field.name || field.attribute);
        }.bind(this));

        index.name = Utils.inflection.underscore(rawTablename + '_' + onlyAttributeNames.join('_'));
      }

      return index;
    });
  },

  /*
    Returns an add index query.
    Parameters:
      - tableName -> Name of an existing table, possibly with schema.
      - options:
        - type: UNIQUE|FULLTEXT|SPATIAL
        - name: The name of the index. Default is <table>_<attr1>_<attr2>
        - fields: An array of attributes as string or as hash.
                  If the attribute is a hash, it must have the following content:
                  - name: The name of the attribute/column
                  - length: An integer. Optional
                  - order: 'ASC' or 'DESC'. Optional
        - parser
      - rawTablename, the name of the table, without schema. Used to create the name of the index
  */
  addIndexQuery: function(tableName, attributes, options, rawTablename) {
    var fieldsSql;
    options = options || {};

    if (!Array.isArray(attributes)) {
      options = attributes;
      attributes = undefined;
    } else {
      options.fields = attributes;
    }

    // Backwards compatability
    if (options.indexName) {
      options.name = options.indexName;
    }
    if (options.indicesType) {
      options.type = options.indicesType;
    }
    if (options.indexType || options.method) {
      options.using = options.indexType || options.method;
    }

    options.prefix = options.prefix || rawTablename || tableName;
    if (options.prefix && _.isString(options.prefix)) {
      options.prefix = options.prefix.replace(/\./g, '_');
      options.prefix = options.prefix.replace(/(\""|\')/g, '');
    }

    fieldsSql = options.fields.map(function(field) {
      if (typeof field === 'string') {
        return this.quoteIdentifier(field);
      } else if (field._isSequelizeMethod) {
        return this.handleSequelizeMethod(field);
      } else {
        var result = '';

        if (field.attribute) {
          field.name = field.attribute;
        }

        if (!field.name) {
          throw new Error('The following index field has no name: ' + util.inspect(field));
        }

        result += this.quoteIdentifier(field.name);

        if (this._dialect.supports.index.collate && field.collate) {
          result += ' COLLATE ' + this.quoteIdentifier(field.collate);
        }

        if (this._dialect.supports.index.length && field.length) {
          result += '(' + field.length + ')';
        }

        if (field.order) {
          result += ' ' + field.order;
        }

        return result;
      }
    }.bind(this));

    if (!options.name) {
      // Mostly for cases where addIndex is called directly by the user without an options object (for example in migrations)
      // All calls that go through sequelize should already have a name
      options = this.nameIndexes([options], options.prefix)[0];
    }

    options = Model.prototype.$conformIndex(options);

    if (!this._dialect.supports.index.type) {
      delete options.type;
    }

    if (options.where) {
      options.where = this.whereQuery(options.where);
    }

    if (_.isString(tableName)) {
      tableName = this.quoteIdentifiers(tableName);
    } else {
      tableName = this.quoteTable(tableName);
    }

    var concurrently = this._dialect.supports.index.concurrently && options.concurrently ? 'CONCURRENTLY' : undefined
      , ind;
    if (this._dialect.supports.indexViaAlter) {
      ind = [
        'ALTER TABLE',
        tableName,
        concurrently,
        'ADD'
      ];
    } else {
      ind = ['CREATE'];
    }

    ind = ind.concat(
      options.unique ? 'UNIQUE' : '',
      options.type, 'INDEX',
      !this._dialect.supports.indexViaAlter ? concurrently : undefined,
      this.quoteIdentifiers(options.name),
      this._dialect.supports.index.using === 1 && options.using ? 'USING ' + options.using : '',
      !this._dialect.supports.indexViaAlter ? 'ON ' + tableName : undefined,
      this._dialect.supports.index.using === 2 && options.using ? 'USING ' + options.using : '',
      '(' + fieldsSql.join(', ') + (options.operator ? ' '+options.operator : '') + ')',
      (this._dialect.supports.index.parser && options.parser ? 'WITH PARSER ' + options.parser : undefined),
      (this._dialect.supports.index.where && options.where ? options.where : undefined)
    );

    return Utils._.compact(ind).join(' ');
  },

  /*
    Returns a query listing indexes for a given table.
    Parameters:
      - tableName: Name of an existing table.
      - options:
        - database: Name of the database.
  */
  /* istanbul ignore next */
  showIndexesQuery: function(tableName, options) {
    throwMethodUndefined('showIndexesQuery');
  },

  /*
    Returns a remove index query.
    Parameters:
      - tableName: Name of an existing table.
      - indexNameOrAttributes: The name of the index as string or an array of attribute names.
  */
  /* istanbul ignore next */
  removeIndexQuery: function(tableName, indexNameOrAttributes) {
    throwMethodUndefined('removeIndexQuery');
  },

  /*
    This method transforms an array of attribute hashes into equivalent
    sql attribute definition.
  */
  /* istanbul ignore next */
  attributesToSQL: function(attributes) {
    throwMethodUndefined('attributesToSQL');
  },

  /*
    Returns all auto increment fields of a factory.
  */
  /* istanbul ignore next */
  findAutoIncrementField: function(factory) {
    throwMethodUndefined('findAutoIncrementField');
  },


  quoteTable: function(param, as) {
    var table = '';

    if (as === true) {
      as = param.as || param.name || param;
    }

    if (_.isObject(param)) {
      if (this._dialect.supports.schemas) {
        if (param.schema) {
          table += this.quoteIdentifier(param.schema) + '.';
        }

        table += this.quoteIdentifier(param.tableName);
      } else {
        if (param.schema) {
          table += param.schema + (param.delimiter || '.');
        }

        table += param.tableName;
        table = this.quoteIdentifier(table);
      }


    } else {
      table = this.quoteIdentifier(param);
    }

    if (as) {
      table += ' AS ' + this.quoteIdentifier(as);
    }
    return table;
  },

  /*
    Quote an object based on its type. This is a more general version of quoteIdentifiers
    Strings: should proxy to quoteIdentifiers
    Arrays:
      * Expects array in the form: [<model> (optional), <model> (optional),... String, String (optional)]
        Each <model> can be a model or an object {model: Model, as: String}, matching include
      * Zero or more models can be included in the array and are used to trace a path through the tree of
        included nested associations. This produces the correct table name for the ORDER BY/GROUP BY SQL
        and quotes it.
      * If a single string is appended to end of array, it is quoted.
        If two strings appended, the 1st string is quoted, the 2nd string unquoted.
    Objects:
      * If raw is set, that value should be returned verbatim, without quoting
      * If fn is set, the string should start with the value of fn, starting paren, followed by
        the values of cols (which is assumed to be an array), quoted and joined with ', ',
        unless they are themselves objects
      * If direction is set, should be prepended

    Currently this function is only used for ordering / grouping columns and Sequelize.col(), but it could
    potentially also be used for other places where we want to be able to call SQL functions (e.g. as default values)
  */
  quote: function(obj, parent, force) {
    if (Utils._.isString(obj)) {
      return this.quoteIdentifiers(obj, force);
    } else if (Array.isArray(obj)) {
      // loop through array, adding table names of models to quoted
      // (checking associations to see if names should be singularised or not)
      var tableNames = []
        , parentAssociation
        , len = obj.length
        , item
        , model
        , as
        , association;

      for (var i = 0; i < len - 1; i++) {
        item = obj[i];
        if (item._modelAttribute || Utils._.isString(item) || item._isSequelizeMethod || 'raw' in item) {
          break;
        }

        if (item instanceof Model) {
          model = item;
          as = undefined;
        } else {
          model = item.model;
          as = item.as;
        }

        // check if model provided is through table
        if (!as && parentAssociation && parentAssociation.through && parentAssociation.through.model === model) {
          association = {as: model.name};
        } else {
          // find applicable association for linking parent to this model
          association = parent.getAssociation(model, as);
        }

        if (association) {
          tableNames[i] = association.as;
          parent = model;
          parentAssociation = association;
        } else {
          tableNames[i] = model.tableName;
          throw new Error('\'' + tableNames.join('.') + '\' in order / group clause is not valid association');
        }
      }

      // add 1st string as quoted, 2nd as unquoted raw
      var sql = (i > 0 ? this.quoteIdentifier(tableNames.join('.')) + '.' : (Utils._.isString(obj[0]) && parent ? this.quoteIdentifier(parent.name) + '.' : '')) + this.quote(obj[i], parent, force);
      if (i < len - 1) {
        if (obj[i + 1]._isSequelizeMethod) {
          sql += this.handleSequelizeMethod(obj[i + 1]);
        } else {
          sql += ' ' + obj[i + 1];
        }
      }
      return sql;
    } else if (obj._modelAttribute) {
      return this.quoteTable(obj.Model.name) + '.' + obj.fieldName;
    } else if (obj._isSequelizeMethod) {
      return this.handleSequelizeMethod(obj);
    } else if (Utils._.isObject(obj) && 'raw' in obj) {
      return obj.raw;
    } else {
      throw new Error('Unknown structure passed to order / group: ' + JSON.stringify(obj));
    }
  },

  /*
   Create a trigger
   */
  /* istanbul ignore next */
  createTrigger: function(tableName, triggerName, timingType, fireOnArray, functionName, functionParams, optionsArray) {
    throwMethodUndefined('createTrigger');
  },

  /*
   Drop a trigger
   */
  /* istanbul ignore next */
  dropTrigger: function(tableName, triggerName) {
    throwMethodUndefined('dropTrigger');
  },

  /*
   Rename a trigger
  */
  /* istanbul ignore next */
  renameTrigger: function(tableName, oldTriggerName, newTriggerName) {
    throwMethodUndefined('renameTrigger');
  },

  /*
   Create a function
   */
  /* istanbul ignore next */
  createFunction: function(functionName, params, returnType, language, body, options) {
    throwMethodUndefined('createFunction');
  },

  /*
   Drop a function
   */
  /* istanbul ignore next */
  dropFunction: function(functionName, params) {
    throwMethodUndefined('dropFunction');
  },

  /*
   Rename a function
   */
  /* istanbul ignore next */
  renameFunction: function(oldFunctionName, params, newFunctionName) {
    throwMethodUndefined('renameFunction');
  },

  /*
    Escape an identifier (e.g. a table or attribute name)
  */
  /* istanbul ignore next */
  quoteIdentifier: function(identifier, force) {
    throwMethodUndefined('quoteIdentifier');
  },

  /*
    Split an identifier into .-separated tokens and quote each part
  */
  quoteIdentifiers: function(identifiers, force) {
    if (identifiers.indexOf('.') !== -1) {
      identifiers = identifiers.split('.');
      return this.quoteIdentifier(identifiers.slice(0, identifiers.length - 1).join('.')) + '.' + this.quoteIdentifier(identifiers[identifiers.length - 1]);
    } else {
      return this.quoteIdentifier(identifiers);
    }
  },

  /*
    Escape a value (e.g. a string, number or date)
  */
  escape: function(value, field, options) {
    options = options || {};

    if (value !== null && value !== undefined) {
      if (value._isSequelizeMethod) {
        return this.handleSequelizeMethod(value);
      } else {
        if (field && field.type) {
          if (this.typeValidation && field.type.validate && value) {
            if (options.isList && Array.isArray(value)) {
              _.forEach(value, function(item) {
                field.type.validate(item, options);
              });
            } else {
              field.type.validate(value, options);
            }
          }

          if (field.type.stringify) {
            // Users shouldn't have to worry about these args - just give them a function that takes a single arg
            var simpleEscape = _.partialRight(SqlString.escape, this.options.timezone, this.dialect);

            value = field.type.stringify(value, { escape: simpleEscape, field: field, timezone: this.options.timezone });

            if (field.type.escape === false) {
              // The data-type already did the required escaping
              return value;
            }
          }
        }
      }
    }

    return SqlString.escape(value, this.options.timezone, this.dialect);
  },

  /**
   * Generates an SQL query that returns all foreign keys of a table.
   *
   * @param  {String} tableName  The name of the table.
   * @param  {String} schemaName The name of the schema.
   * @return {String}            The generated sql query.
   */
  /* istanbul ignore next */
  getForeignKeysQuery: function(tableName, schemaName) {
    throwMethodUndefined('getForeignKeysQuery');
  },

  /**
   * Generates an SQL query that removes a foreign key from a table.
   *
   * @param  {String} tableName  The name of the table.
   * @param  {String} foreignKey The name of the foreign key constraint.
   * @return {String}            The generated sql query.
   */
  /* istanbul ignore next */
  dropForeignKeyQuery: function(tableName, foreignKey) {
    throwMethodUndefined('dropForeignKeyQuery');
  },


  /*
    Returns a query for selecting elements in the table <tableName>.
    Options:
      - attributes -> An array of attributes (e.g. ['name', 'birthday']). Default: *
      - where -> A hash with conditions (e.g. {name: 'foo'})
                 OR an ID as integer
                 OR a string with conditions (e.g. 'name=""foo""').
                 If you use a string, you have to escape it on your own.
      - order -> e.g. 'id DESC'
      - group
      - limit -> The maximum count you want to get.
      - offset -> An offset value to start from. Only useable with limit!
  */

  selectQuery: function(tableName, options, model) {
    // Enter and change at your own peril -- Mick Hansen

    options = options || {};

    var table = null
      , self = this
      , query
      , limit = options.limit
      , mainModel = model
      , mainQueryItems = []
      , mainAttributes = options.attributes && options.attributes.slice()
      , mainJoinQueries = []
      // We'll use a subquery if we have a hasMany association and a limit
      , subQuery = options.subQuery === undefined ?
                   limit && options.hasMultiAssociation :
                   options.subQuery
      , subQueryItems = []
      , subQueryAttributes = null
      , subJoinQueries = []
      , mainTableAs = null;

    if (options.tableAs) {
      mainTableAs = this.quoteTable(options.tableAs);
    } else if (!Array.isArray(tableName) && model) {
      mainTableAs = this.quoteTable(model.name);
    }

    table = !Array.isArray(tableName) ? this.quoteTable(tableName) : tableName.map(function(t) {
      if (Array.isArray(t)) {
        return this.quoteTable(t[0], t[1]);
      }
      return this.quoteTable(t, true);
    }.bind(this)).join(', ');

    if (subQuery && mainAttributes) {
      model.primaryKeyAttributes.forEach(function(keyAtt) {
        // Check if mainAttributes contain the primary key of the model either as a field or an aliased field
        if (!_.find(mainAttributes, function (attr) {
          return keyAtt === attr || keyAtt === attr[0] || keyAtt === attr[1];
        })) {
          mainAttributes.push(model.rawAttributes[keyAtt].field ? [keyAtt, model.rawAttributes[keyAtt].field] : keyAtt);
        }
      });
    }

    // Escape attributes
    mainAttributes = mainAttributes && mainAttributes.map(function(attr) {
      var addTable = true;

      if (attr._isSequelizeMethod) {
        return self.handleSequelizeMethod(attr);
      }

      if (Array.isArray(attr) && attr.length === 2) {
        attr = attr.slice();

        if (attr[0]._isSequelizeMethod) {
          attr[0] = self.handleSequelizeMethod(attr[0]);
          addTable = false;
        } else if (
          attr[0].indexOf('(') === -1 &&
          attr[0].indexOf(')') === -1
        ) {
          attr[0] = self.quoteIdentifier(attr[0]);
        } else {
          deprecate('Use sequelize.fn / sequelize.literal to construct attributes');
        }

        attr = [attr[0], self.quoteIdentifier(attr[1])].join(' AS ');
      } else {
        if (
          attr.indexOf(Utils.TICK_CHAR) < 0 &&
          attr.indexOf('""') < 0
        ) {
          attr = self.quoteIdentifiers(attr);
        } else {
          attr = self.escape(attr);
        }
      }

      if (options.include && attr.indexOf('.') === -1 && addTable) {
        attr = mainTableAs + '.' + attr;
      }

      return attr;
    });

    // If no attributes specified, use *
    mainAttributes = mainAttributes || (options.include ? [mainTableAs + '.*'] : ['*']);

    // If subquery, we ad the mainAttributes to the subQuery and set the mainAttributes to select * from subquery
    if (subQuery || options.groupedLimit) {
      // We need primary keys
      subQueryAttributes = mainAttributes;
      mainAttributes = [(mainTableAs || table) + '.*'];
    }

    if (options.include) {
      var generateJoinQueries = function(include, parentTable) {
        var table = include.model.getTableName()
          , as = include.as
          , joinQueryItem = ''
          , joinQueries = {
            mainQuery: [],
            subQuery: []
          }
          , attributes
          , association = include.association
          , through = include.through
          , joinType = include.required ? ' INNER JOIN ' : ' LEFT OUTER JOIN '
          , parentIsTop = !include.parent.association && include.parent.model.name === options.model.name
          , whereOptions = Utils._.clone(options)
          , targetWhere;

        whereOptions.keysEscaped = true;

        if (tableName !== parentTable && mainTableAs !== parentTable) {
          as = parentTable + '.' + include.as;
        }

        // includeIgnoreAttributes is used by aggregate functions
        if (options.includeIgnoreAttributes !== false) {
          attributes = include.attributes.map(function(attr) {
            var attrAs = attr,
                verbatim = false;

            if (Array.isArray(attr) && attr.length === 2) {
              if (attr[0]._isSequelizeMethod) {
                if (attr[0] instanceof Utils.literal ||
                  attr[0] instanceof Utils.cast ||
                  attr[0] instanceof Utils.fn
                ) {
                  verbatim = true;
                }
              }

              attr = attr.map(function($attr) {
                return $attr._isSequelizeMethod ? self.handleSequelizeMethod($attr) : $attr;
              });

              attrAs = attr[1];
              attr = attr[0];
            } else if (attr instanceof Utils.literal) {
              return attr.val; // We trust the user to rename the field correctly
            } else if (attr instanceof Utils.cast ||
              attr instanceof Utils.fn
            ) {
              throw new Error(
                'Tried to select attributes using Sequelize.cast or Sequelize.fn without specifying an alias for the result, during eager loading. ' +
                'This means the attribute will not be added to the returned instance'
              );
            }

            var prefix;

            if (verbatim === true) {
              prefix = attr;
            } else {
              prefix = self.quoteIdentifier(as) + '.' + self.quoteIdentifier(attr);
            }

            return prefix + ' AS ' + self.quoteIdentifier(as + '.' + attrAs, true);
          });

          if (include.subQuery && subQuery) {
            subQueryAttributes = subQueryAttributes.concat(attributes);
          } else {
            mainAttributes = mainAttributes.concat(attributes);
          }
        }

        if (through) {
          var throughTable = through.model.getTableName()
            , throughAs = as + '.' + through.as
            , throughAttributes = through.attributes.map(function(attr) {
              return self.quoteIdentifier(throughAs) + '.' + self.quoteIdentifier(Array.isArray(attr) ? attr[0] : attr) +
                     ' AS ' +
                     self.quoteIdentifier(throughAs + '.' + (Array.isArray(attr) ? attr[1] : attr));
            })
            , primaryKeysSource = association.source.primaryKeyAttributes
            , tableSource = parentTable
            , identSource = association.identifierField
            , attrSource = primaryKeysSource[0]
            , primaryKeysTarget = association.target.primaryKeyAttributes
            , tableTarget = as
            , identTarget = association.foreignIdentifierField
            , attrTarget = association.target.rawAttributes[primaryKeysTarget[0]].field || primaryKeysTarget[0]

            , sourceJoinOn
            , targetJoinOn

            , throughWhere;

          if (options.includeIgnoreAttributes !== false) {
            // Through includes are always hasMany, so we need to add the attributes to the mainAttributes no matter what (Real join will never be executed in subquery)
            mainAttributes = mainAttributes.concat(throughAttributes);
          }

          // Figure out if we need to use field or attribute
          if (!subQuery) {
            attrSource = association.source.rawAttributes[primaryKeysSource[0]].field;
          }
          if (subQuery && !include.subQuery && !include.parent.subQuery && include.parent.model !== mainModel) {
            attrSource = association.source.rawAttributes[primaryKeysSource[0]].field;
          }

          // Filter statement for left side of through
          // Used by both join and subquery where

          // If parent include was in a subquery need to join on the aliased attribute

          if (subQuery && !include.subQuery && include.parent.subQuery && !parentIsTop) {
            sourceJoinOn = self.quoteIdentifier(tableSource + '.' + attrSource) + ' = ';
          } else {
            sourceJoinOn = self.quoteTable(tableSource) + '.' + self.quoteIdentifier(attrSource) + ' = ';
          }
          sourceJoinOn += self.quoteIdentifier(throughAs) + '.' + self.quoteIdentifier(identSource);

          // Filter statement for right side of through
          // Used by both join and subquery where
          targetJoinOn = self.quoteIdentifier(tableTarget) + '.' + self.quoteIdentifier(attrTarget) + ' = ';
          targetJoinOn += self.quoteIdentifier(throughAs) + '.' + self.quoteIdentifier(identTarget);

          if (include.through.where) {
            throughWhere = self.getWhereConditions(include.through.where, self.sequelize.literal(self.quoteIdentifier(throughAs)), include.through.model);
          }

          if (self._dialect.supports.joinTableDependent) {
            // Generate a wrapped join so that the through table join can be dependent on the target join
            joinQueryItem += joinType + '(';
            joinQueryItem += self.quoteTable(throughTable, throughAs);
            joinQueryItem += ' INNER JOIN ' + self.quoteTable(table, as) + ' ON ';
            joinQueryItem += targetJoinOn;

            if (throughWhere) {
              joinQueryItem += ' AND ' + throughWhere;
            }

            joinQueryItem += ') ON '+sourceJoinOn;
          } else {
            // Generate join SQL for left side of through
            joinQueryItem += joinType + self.quoteTable(throughTable, throughAs)  + ' ON ';
            joinQueryItem += sourceJoinOn;

            // Generate join SQL for right side of through
            joinQueryItem += joinType + self.quoteTable(table, as) + ' ON ';
            joinQueryItem += targetJoinOn;

            if (throughWhere) {
              joinQueryItem += ' AND ' + throughWhere;
            }

          }

          if (include.where || include.through.where) {
            if (include.where) {
              targetWhere = self.getWhereConditions(include.where, self.sequelize.literal(self.quoteIdentifier(as)), include.model, whereOptions);
              if (targetWhere) {
                joinQueryItem += ' AND ' + targetWhere;
              }
            }
            if (subQuery && include.required) {
              if (!options.where) options.where = {};
              (function (include) {
                // Closure to use sane local variables

                var parent = include
                  , child = include
                  , nestedIncludes = []
                  , topParent
                  , topInclude
                  , $query;

                while (parent = parent.parent) {
                  nestedIncludes = [_.extend({}, child, {include: nestedIncludes})];
                  child = parent;
                }

                topInclude = nestedIncludes[0];
                topParent = topInclude.parent;

                if (topInclude.through && Object(topInclude.through.model) === topInclude.through.model) {
                  $query = self.selectQuery(topInclude.through.model.getTableName(), {
                    attributes: [topInclude.through.model.primaryKeyField],
                    include: Model.$validateIncludedElements({
                      model: topInclude.through.model,
                      include: [{
                        association: topInclude.association.toTarget,
                        required: true
                      }]
                    }).include,
                    model: topInclude.through.model,
                    where: { $and: [
                      self.sequelize.asIs([
                        self.quoteTable(topParent.model.name) + '.' + self.quoteIdentifier(topParent.model.primaryKeyField),
                        self.quoteIdentifier(topInclude.through.model.name) + '.' + self.quoteIdentifier(topInclude.association.identifierField)
                      ].join(' = ')),
                      topInclude.through.where
                    ]},
                    limit: 1,
                    includeIgnoreAttributes: false
                  }, topInclude.through.model);
                } else {
                  var isBelongsTo = topInclude.association.associationType === 'BelongsTo';
                  var join = [
                    self.quoteTable(topParent.model.name) + '.' + self.quoteIdentifier(isBelongsTo ? topInclude.association.identifierField : topParent.model.primaryKeyAttributes[0]),
                    self.quoteIdentifier(topInclude.model.name) + '.' + self.quoteIdentifier(isBelongsTo ? topInclude.model.primaryKeyAttributes[0] : topInclude.association.identifierField)
                  ].join(' = ');
                  $query = self.selectQuery(topInclude.model.tableName, {
                    attributes: [topInclude.model.primaryKeyAttributes[0]],
                    include: topInclude.include,
                    where: {
                      $join: self.sequelize.asIs(join)
                    },
                    limit: 1,
                    includeIgnoreAttributes: false
                  }, topInclude.model);
                }

                options.where['__' + throughAs] = self.sequelize.asIs([
                  '(',
                    $query.replace(/\;$/, ''),
                  ')',
                  'IS NOT NULL'
                ].join(' '));
              })(include);
            }
          }
        } else {
          if (subQuery && include.subQueryFilter) {
            var associationWhere = {}
              , $query
              , subQueryWhere;

            associationWhere[association.identifierField] = {
              $raw: self.quoteTable(parentTable) + '.' + self.quoteIdentifier(association.sourceKeyField || association.source.primaryKeyField)
            };

            if (!options.where) options.where = {};

            // Creating the as-is where for the subQuery, checks that the required association exists
            $query = self.selectQuery(include.model.getTableName(), {
              attributes: [association.identifierField],
              where: {
                $and: [
                  associationWhere,
                  include.where || {}
                ]
              },
              limit: 1
            }, include.model);

            subQueryWhere = self.sequelize.asIs([
              '(',
                $query.replace(/\;$/, ''),
              ')',
              'IS NOT NULL'
            ].join(' '));

            if (Utils._.isPlainObject(options.where)) {
              options.where['__' + as] = subQueryWhere;
            } else {
              options.where = { $and: [options.where, subQueryWhere] };
            }
          }

          joinQueryItem = ' ' + self.joinIncludeQuery({
            model: mainModel,
            subQuery: options.subQuery,
            include: include,
            groupedLimit: options.groupedLimit
          });
        }

        if (include.subQuery && subQuery) {
          joinQueries.subQuery.push(joinQueryItem);
        } else {
          joinQueries.mainQuery.push(joinQueryItem);
        }

        if (include.include) {
          include.include.filter(function (include) {
            return !include.separate;
          }).forEach(function(childInclude) {
            if (childInclude._pseudo) return;
            var childJoinQueries = generateJoinQueries(childInclude, as);

            if (childInclude.subQuery && subQuery) {
              joinQueries.subQuery = joinQueries.subQuery.concat(childJoinQueries.subQuery);
            }
            if (childJoinQueries.mainQuery) {
              joinQueries.mainQuery = joinQueries.mainQuery.concat(childJoinQueries.mainQuery);
            }

          }.bind(this));
        }

        return joinQueries;
      };

      // Loop through includes and generate subqueries
      options.include.filter(function (include) {
        return !include.separate;
      }).forEach(function(include) {
        var joinQueries = generateJoinQueries(include, mainTableAs);

        subJoinQueries = subJoinQueries.concat(joinQueries.subQuery);
        mainJoinQueries = mainJoinQueries.concat(joinQueries.mainQuery);

      }.bind(this));
    }

    // If using subQuery select defined subQuery attributes and join subJoinQueries
    if (subQuery) {
      subQueryItems.push(this.selectFromTableFragment(options, model, subQueryAttributes, table, mainTableAs));
      subQueryItems.push(subJoinQueries.join(''));

    // Else do it the reguar way
    } else {
      if (options.groupedLimit) {
        if (!mainTableAs) {
          mainTableAs = table;
        }

        var groupedLimitOrder
          , where = _.assign({}, options.where)
          , whereKey
          , include
          , groupedTableName = mainTableAs;

        if (typeof options.groupedLimit.on === 'string') {
          whereKey = options.groupedLimit.on;
        } else if (options.groupedLimit.on instanceof HasMany) {
          whereKey = options.groupedLimit.on.foreignKeyField;
        }

        if (options.groupedLimit.on instanceof BelongsToMany) {
          // BTM includes needs to join the through table on to check ID
          groupedTableName = options.groupedLimit.on.manyFromSource.as;
          var groupedLimitOptions = Model.$validateIncludedElements({
            include: [{
              association: options.groupedLimit.on.manyFromSource,
              duplicating: false, // The UNION'ed query may contain duplicates, but each sub-query cannot
              required: true,
              where: _.assign({
                '$$PLACEHOLDER$$': true
              }, options.groupedLimit.through && options.groupedLimit.through.where)
            }],
            model: model
          });
          // Make sure attributes from the join table are mapped back to models
          options.hasJoin = true;
          options.hasMultiAssociation = true;
          options.includeMap = _.assign(groupedLimitOptions.includeMap, options.includeMap);
          options.includeNames = groupedLimitOptions.includeNames.concat(options.includeNames || []);
          include = groupedLimitOptions.include;

          if (Array.isArray(options.order)) {
            // We need to make sure the order by attributes are available to the parent query
            options.order.forEach(function(order, i) {
              if (Array.isArray(order)) {
                order = order[0];
              }

              var alias = 'subquery_order_' +i;
              options.attributes.push([order, alias]);

              // We don't want to prepend model name when we alias the attributes, so quote them here
              alias = this.sequelize.literal(this.quote(alias));

              if (Array.isArray(options.order[i])) {
                options.order[i][0] = alias;
              } else {
                options.order[i] = alias;
              }
            }, this);
            groupedLimitOrder = options.order;
          }
        } else {
          // Ordering is handled by the subqueries, so ordering the UNION'ed result is not needed
          groupedLimitOrder = options.order;
          delete options.order;
          where.$$PLACEHOLDER$$ = true;
        }

        // Caching the base query and splicing the where part into it is consistently > twice
        // as fast than generating from scratch each time for values.length >= 5
        var baseQuery = '('+this.selectQuery(
          tableName,
          {
            attributes: options.attributes,
            limit: options.groupedLimit.limit,
            order: groupedLimitOrder,
            where: where,
            include: include,
            model: model
          },
          model
        ).replace(/;$/, '')+')';
        var placeHolder = this.whereItemQuery('$$PLACEHOLDER$$', true, { model: model })
          , splicePos = baseQuery.indexOf(placeHolder);

        mainQueryItems.push(this.selectFromTableFragment(options, model, mainAttributes, '('+
          options.groupedLimit.values.map(function (value) {
            var groupWhere = {};
            if (whereKey) {
              groupWhere[whereKey] = value;
            }
            if (include) {
              groupWhere[options.groupedLimit.on.foreignIdentifierField] = value;
            }

            return Utils.spliceStr(baseQuery, splicePos, placeHolder.length, this.getWhereConditions(groupWhere, groupedTableName));
          }, this).join(
            self._dialect.supports['UNION ALL'] ?' UNION ALL ' : ' UNION '
          )
        +')', mainTableAs));
      } else {
        mainQueryItems.push(this.selectFromTableFragment(options, model, mainAttributes, table, mainTableAs));
      }
      mainQueryItems.push(mainJoinQueries.join(''));
    }

    // Add WHERE to sub or main query
    if (options.hasOwnProperty('where') && !options.groupedLimit) {
      options.where = this.getWhereConditions(options.where, mainTableAs || tableName, model, options);
      if (options.where) {
        if (subQuery) {
          subQueryItems.push(' WHERE ' + options.where);
        } else {
          mainQueryItems.push(' WHERE ' + options.where);
          // Walk the main query to update all selects
          _.each(mainQueryItems, function(value, key) {
            if(value.match(/^SELECT/)) {
              mainQueryItems[key] = this.selectFromTableFragment(options, model, mainAttributes, table, mainTableAs, options.where);
            }
          }.bind(this));
        }
      }
    }

    // Add GROUP BY to sub or main query
    if (options.group) {
      options.group = Array.isArray(options.group) ? options.group.map(function(t) { return this.quote(t, model); }.bind(this)).join(', ') : options.group;
      if (subQuery) {
        subQueryItems.push(' GROUP BY ' + options.group);
      } else {
        mainQueryItems.push(' GROUP BY ' + options.group);
      }
    }

    // Add HAVING to sub or main query
    if (options.hasOwnProperty('having')) {
      options.having = this.getWhereConditions(options.having, tableName, model, options, false);
      if (subQuery) {
        subQueryItems.push(' HAVING ' + options.having);
      } else {
        mainQueryItems.push(' HAVING ' + options.having);
      }
    }
    // Add ORDER to sub or main query
    if (options.order) {
      var orders = this.getQueryOrders(options, model, subQuery);

      if (orders.mainQueryOrder.length) {
        mainQueryItems.push(' ORDER BY ' + orders.mainQueryOrder.join(', '));
      }
      if (orders.subQueryOrder.length) {
        subQueryItems.push(' ORDER BY ' + orders.subQueryOrder.join(', '));
      }
    }

    // Add LIMIT, OFFSET to sub or main query
    var limitOrder = this.addLimitAndOffset(options, model);
    if (limitOrder && !options.groupedLimit) {
      if (subQuery) {
        subQueryItems.push(limitOrder);
      } else {
        mainQueryItems.push(limitOrder);
      }
    }

    // If using subQuery, select attributes from wrapped subQuery and join out join tables
    if (subQuery) {
      query = 'SELECT ' + mainAttributes.join(', ') + ' FROM (';
      query += subQueryItems.join('');
      query += ') AS ' + mainTableAs;
      query += mainJoinQueries.join('');
      query += mainQueryItems.join('');
    } else {
      query = mainQueryItems.join('');
    }

    if (options.lock && this._dialect.supports.lock) {
      var lock = options.lock;
      if (typeof options.lock === 'object') {
        lock = options.lock.level;
      }
      if (this._dialect.supports.lockKey && (lock === 'KEY SHARE' || lock === 'NO KEY UPDATE')) {
        query += ' FOR ' + lock;
      } else if (lock === 'SHARE') {
        query += ' ' + this._dialect.supports.forShare;
      } else {
        query += ' FOR UPDATE';
      }
      if (this._dialect.supports.lockOf && options.lock.of instanceof Model) {
        query += ' OF ' + this.quoteTable(options.lock.of.name);
      }
    }

    query += ';';

    return query;
  },

  getQueryOrders: function(options, model, subQuery) {
    var mainQueryOrder = [];
    var subQueryOrder = [];

    var validateOrder = function(order) {
      if (order instanceof Utils.literal) return;

      if (!_.includes([
        'ASC',
        'DESC',
        'ASC NULLS LAST',
        'DESC NULLS LAST',
        'ASC NULLS FIRST',
        'DESC NULLS FIRST',
        'NULLS FIRST',
        'NULLS LAST'
      ], order.toUpperCase())) {
        throw new Error(util.format('Order must be \'ASC\' or \'DESC\', \'%s\' given', order));
      }
    };

    if (Array.isArray(options.order)) {
      options.order.forEach(function(t) {
        if (Array.isArray(t) && _.size(t) > 1) {
          if (t[0] instanceof Model || t[0].model instanceof Model) {
            if (typeof t[t.length - 2] === 'string') {
              validateOrder(_.last(t));
            }
          } else {
            validateOrder(_.last(t));
          }
        }

        var hadSubquery = false;

        if (subQuery && (Array.isArray(t) && !(t[0] instanceof Model) && !(t[0].model instanceof Model))) {
          subQueryOrder.push(this.quote(t, model));
          hadSubquery = true;
        }

        if (hadSubquery) {
          for (var name in model.attributes) {
            var attribute = model.attributes[name];
            if (attribute.field && attribute.field === t[0]) {
              t[0] = attribute.fieldName;
            }
          }
        }

        mainQueryOrder.push(this.quote(t, model));
      }.bind(this));
    } else {
      var sql = this.quote(typeof options.order === 'string' ? new Utils.literal(options.order) : options.order, model);
      if (subQuery) {
        subQueryOrder.push(sql);
      }
      mainQueryOrder.push(sql);
    }

    return {
      mainQueryOrder: mainQueryOrder,
      subQueryOrder: subQueryOrder
    };
  },

  selectFromTableFragment: function(options, model, attributes, tables, mainTableAs, whereClause) {
    var fragment = 'SELECT ' + attributes.join(', ') + ' FROM ' + tables;

    if(mainTableAs) {
      fragment += ' AS ' + mainTableAs;
    }

    return fragment;
  },

  joinIncludeQuery: function(options) {
    var subQuery = options.subQuery
      , include = options.include
      , association = include.association
      , parent = include.parent
      , parentIsTop = !include.parent.association && include.parent.model.name === options.model.name
      , $parent
      , joinType = include.required ? 'INNER JOIN ' : 'LEFT OUTER JOIN '
      , joinOn
      , joinWhere

      /* Attributes for the left side */
      , left = association.source
      , asLeft
      , attrLeft = association instanceof BelongsTo ?
                   association.identifier :
                   association.sourceKeyAttribute || left.primaryKeyAttribute
      , fieldLeft = association instanceof BelongsTo ?
                   association.identifierField :
                   left.rawAttributes[association.sourceKeyAttribute || left.primaryKeyAttribute].field

      /* Attributes for the right side */
      , right = include.model
      , asRight = include.as
      , tableRight = right.getTableName()
      , fieldRight = association instanceof BelongsTo ?
                     right.rawAttributes[association.targetIdentifier || right.primaryKeyAttribute].field :
                     association.identifierField;

    while (($parent = ($parent && $parent.parent || include.parent)) && $parent.association) {
      if (asLeft) {
        asLeft = [$parent.as, asLeft].join('.');
      } else {
        asLeft = $parent.as;
      }
    }

    if (!asLeft) asLeft = parent.as || parent.model.name;
    else asRight = [asLeft, asRight].join('.');

    joinOn = [
      this.quoteTable(asLeft),
      this.quoteIdentifier(fieldLeft)
    ].join('.');

    if ((options.groupedLimit && parentIsTop) || (subQuery && include.parent.subQuery && !include.subQuery)) {
      if (parentIsTop) {
        // The main model attributes is not aliased to a prefix
        joinOn = [
          this.quoteTable(parent.as || parent.model.name),
          this.quoteIdentifier(attrLeft)
        ].join('.');
      } else {
        joinOn = this.quoteIdentifier(asLeft + '.' + attrLeft);
      }
    }

    joinOn += ' = ' + this.quoteIdentifier(asRight) + '.' + this.quoteIdentifier(fieldRight);

    if (include.on) {
      joinOn = this.whereItemsQuery(include.on, {
        prefix: this.sequelize.literal(this.quoteIdentifier(asRight)),
        model: include.model
      });
    }

    if (include.where) {
      joinWhere = this.whereItemsQuery(include.where, {
        prefix: this.sequelize.literal(this.quoteIdentifier(asRight)),
        model: include.model
      });
      if (joinWhere) {
        if (include.or) {
          joinOn += ' OR ' + joinWhere;
        } else {
          joinOn += ' AND ' + joinWhere;
        }
      }
    }

    return joinType + this.quoteTable(tableRight, asRight) + ' ON ' + joinOn;
  },

  /**
   * Returns a query that starts a transaction.
   *
   * @param  {Boolean} value   A boolean that states whether autocommit shall be done or not.
   * @param  {Object}  options An object with options.
   * @return {String}          The generated sql query.
   */
  setAutocommitQuery: function(value, options) {
    if (options.parent) {
      return;
    }

    return 'SET autocommit = ' + (!!value ? 1 : 0) + ';';
  },

  /**
   * Returns a query that sets the transaction isolation level.
   *
   * @param  {String} value   The isolation level.
   * @param  {Object} options An object with options.
   * @return {String}         The generated sql query.
   */
  setIsolationLevelQuery: function(value, options) {
    if (options.parent) {
      return;
    }

    return 'SET SESSION TRANSACTION ISOLATION LEVEL ' + value + ';';
  },

  generateTransactionId: function() {
    return uuid.v4();
  },

  /**
   * Returns a query that starts a transaction.
   *
   * @param  {Transaction} transaction
   * @param  {Object} options An object with options.
   * @return {String}         The generated sql query.
   */
  startTransactionQuery: function(transaction) {
    if (transaction.parent) {
      // force quoting of savepoint identifiers for postgres
      return 'SAVEPOINT ' + this.quoteIdentifier(transaction.name, true) + ';';
    }

    return 'START TRANSACTION;';
  },

  /**
   * Returns a query that defers the constraints. Only works for postgres.
   *
   * @param  {Transaction} transaction
   * @param  {Object} options An object with options.
   * @return {String}         The generated sql query.
   */
  deferConstraintsQuery: function () {},

  setConstraintQuery: function () {},
  setDeferredQuery: function () {},
  setImmediateQuery: function () {},

  /**
   * Returns a query that commits a transaction.
   *
   * @param  {Object} options An object with options.
   * @return {String}         The generated sql query.
   */
  commitTransactionQuery: function(transaction) {
    if (transaction.parent) {
      return;
    }

    return 'COMMIT;';
  },

  /**
   * Returns a query that rollbacks a transaction.
   *
   * @param  {Transaction} transaction
   * @param  {Object} options An object with options.
   * @return {String}         The generated sql query.
   */
  rollbackTransactionQuery: function(transaction) {
    if (transaction.parent) {
      // force quoting of savepoint identifiers for postgres
      return 'ROLLBACK TO SAVEPOINT ' + this.quoteIdentifier(transaction.name, true) + ';';
    }

    return 'ROLLBACK;';
  },

  /**
   * Returns an SQL fragment for adding result constraints
   *
   * @param  {Object} options An object with selectQuery options.
   * @param  {Object} options The model passed to the selectQuery.
   * @return {String}         The generated sql query.
   */
  addLimitAndOffset: function(options, model) {
    var fragment = '';

    /*jshint eqeqeq:false*/
    if (options.offset != null && options.limit == null) {
      fragment += ' LIMIT ' + this.escape(options.offset) + ', ' + 10000000000000;
    } else if (options.limit != null) {
      if (options.offset != null) {
        fragment += ' LIMIT ' + this.escape(options.offset) + ', ' + this.escape(options.limit);
      } else {
        fragment += ' LIMIT ' + this.escape(options.limit);
      }
    }

    return fragment;
  },

  handleSequelizeMethod: function (smth, tableName, factory, options, prepend) {
    var self = this
      , result;

    if (smth instanceof Utils.where) {
      var value = smth.logic
        , key;

      if (smth.attribute._isSequelizeMethod) {
        key = this.getWhereConditions(smth.attribute, tableName, factory, options, prepend);
      } else {
        key = this.quoteTable(smth.attribute.Model.name) + '.' + this.quoteIdentifier(smth.attribute.field || smth.attribute.fieldName);
      }

      if (value && value._isSequelizeMethod) {
        value = this.getWhereConditions(value, tableName, factory, options, prepend);

        result = (value === 'NULL') ? key + ' IS NULL' : [key, value].join(smth.comparator);
      } else if (_.isPlainObject(value)) {
        result = this.whereItemQuery(smth.attribute, value, {
          model: factory
        });
      } else {
        if (typeof value === 'boolean') {
          value = this.booleanValue(value);
        } else {
          value = this.escape(value);
        }

        result = (value === 'NULL') ? key + ' IS NULL' : [key, value].join(' ' + smth.comparator + ' ');
      }
    } else if (smth instanceof Utils.literal) {
      result = smth.val;
    } else if (smth instanceof Utils.cast) {
      if (smth.val._isSequelizeMethod) {
        result = this.handleSequelizeMethod(smth.val, tableName, factory, options, prepend);
      } else if (_.isPlainObject(smth.val)) {
        result = this.whereItemsQuery(smth.val);
      } else {
        result = this.escape(smth.val);
      }

      result = 'CAST(' + result + ' AS ' + smth.type.toUpperCase() + ')';
    } else if (smth instanceof Utils.fn) {
      result = smth.fn + '(' + smth.args.map(function(arg) {
        if (arg._isSequelizeMethod) {
          return self.handleSequelizeMethod(arg, tableName, factory, options, prepend);
        } else if (_.isPlainObject(arg)) {
          return self.whereItemsQuery(arg);
        } else {
          return self.escape(arg);
        }
      }).join(', ') + ')';
    } else if (smth instanceof Utils.col) {
      if (Array.isArray(smth.col)) {
        if (!factory) {
          throw new Error('Cannot call Sequelize.col() with array outside of order / group clause');
        }
      } else if (smth.col.indexOf('*') === 0) {
        return '*';
      }
      return this.quote(smth.col, factory);
    } else {
      result = smth.toString(this, factory);
    }

    return result;
  },

  whereQuery: function(where, options) {
    var query = this.whereItemsQuery(where, options);
    if (query && query.length) {
      return 'WHERE '+query;
    }
    return '';
  },
  whereItemsQuery: function(where, options, binding) {
    if (
      (Array.isArray(where) && where.length === 0) ||
      (_.isPlainObject(where) && _.isEmpty(where)) ||
      where === null ||
      where === undefined
    ) {
      // NO OP
      return '';
    }

    if (_.isString(where)) {
      throw new Error('where: ""raw query"" has been removed, please use where [""raw query"", [replacements]]');
    }

    var self = this
      , items = [];

    binding = binding || 'AND';
    if (binding.substr(0, 1) !== ' ') binding = ' '+binding+' ';

    if (_.isPlainObject(where)) {
      _.forOwn(where, function (value, key) {
        items.push(self.whereItemQuery(key, value, options));
      });
    } else {
      items.push(self.whereItemQuery(undefined, where, options));
    }

    return items.length && items.filter(function (item) {
      return item && item.length;
    }).join(binding) || '';
  },
  whereItemQuery: function(key, value, options) {
    options = options || {};

    var self = this
      , binding
      , outerBinding
      , comparatorMap
      , aliasMap
      , comparator = '='
      , field = options.field || options.model && options.model.rawAttributes && options.model.rawAttributes[key] || options.model && options.model.fieldRawAttributesMap && options.model.fieldRawAttributesMap[key]
      , fieldType = options.type || (field && field.type)
      , tmp;

    if (key && typeof key === 'string' && key.indexOf('.') !== -1 && options.model) {
      if (options.model.rawAttributes[key.split('.')[0]] && options.model.rawAttributes[key.split('.')[0]].type instanceof DataTypes.JSON) {
        field = options.model.rawAttributes[key.split('.')[0]];
        fieldType = field.type;
        tmp = value;
        value = {};

        Dottie.set(value, key.split('.').slice(1), tmp);
        key = field.field || key.split('.')[0];
      }
    }

    comparatorMap = {
      $eq: '=',
      $ne: '!=',
      $gte: '>=',
      $gt: '>',
      $lte: '<=',
      $lt: '<',
      $not: 'IS NOT',
      $is: 'IS',
      $like: 'LIKE',
      $notLike: 'NOT LIKE',
      $iLike: 'ILIKE',
      $notILike: 'NOT ILIKE',
      $between: 'BETWEEN',
      $notBetween: 'NOT BETWEEN',
      $overlap: '&&',
      $contains: '@>',
      $contained: '<@'
    };

    // Maintain BC
    aliasMap = {
      'ne': '$ne',
      'in': '$in',
      'not': '$not',
      'notIn': '$notIn',
      'gte': '$gte',
      'gt': '$gt',
      'lte': '$lte',
      'lt': '$lt',
      'like': '$like',
      'ilike': '$iLike',
      '$ilike': '$iLike',
      'nlike': '$notLike',
      '$notlike': '$notLike',
      'notilike': '$notILike',
      '..': '$between',
      'between': '$between',
      '!..': '$notBetween',
      'notbetween': '$notBetween',
      'nbetween': '$notBetween',
      'overlap': '$overlap',
      '&&': '$overlap',
      '@>': '$contains',
      '<@': '$contained'
    };

    key = aliasMap[key] || key;
    if (_.isPlainObject(value)) {
      _.forOwn(value, function (item, key) {
        if (aliasMap[key]) {
          value[aliasMap[key]] = item;
          delete value[key];
        }
      });
    }

    if (key === undefined) {
      if (typeof value === 'string') {
        return value;
      }

      if (_.isPlainObject(value) && _.size(value) === 1) {
        key = Object.keys(value)[0];
        value = _.values(value)[0];
      }
    }

    if (value && value._isSequelizeMethod && !(key !== undefined && value instanceof Utils.fn)) {
      return this.handleSequelizeMethod(value);
    }

    // Convert where: [] to $and if possible, else treat as literal/replacements
    if (key === undefined && Array.isArray(value)) {
      if (Utils.canTreatArrayAsAnd(value)) {
        key = '$and';
      } else {
        return Utils.format(value, this.dialect);
      }
    }
    // OR/AND/NOT grouping logic
    if (key === '$or' || key === '$and' || key === '$not') {
      binding = (key === '$or') ?' OR ' : ' AND ';
      outerBinding = '';
      if (key === '$not') outerBinding = 'NOT ';

      if (Array.isArray(value)) {
        value = value.map(function (item) {
          var itemQuery = self.whereItemsQuery(item, options, ' AND ');
          if ((Array.isArray(item) || _.isPlainObject(item)) && _.size(item) > 1) {
            itemQuery = '('+itemQuery+')';
          }
          return itemQuery;
        }).filter(function (item) {
          return item && item.length;
        });

        // $or: [] should return no data.
        // $not of no restriction should also return no data
        if ((key === '$or' || key === '$not') && value.length === 0) {
          return '0 = 1';
        }

        return value.length ? outerBinding + '('+value.join(binding)+')' : undefined;
      } else {
        value = self.whereItemsQuery(value, options, binding);

        if ((key === '$or' || key === '$not') && !value) {
          return '0 = 1';
        }

        return value ? outerBinding + '('+value+')' : undefined;
      }
    }

    if (value && (value.$or || value.$and)) {
      binding = value.$or ? ' OR ' : ' AND ';
      value = value.$or || value.$and;

      if (_.isPlainObject(value)) {
        value = _.reduce(value, function (result, _value, key) {
          result.push(_.zipObject([key], [_value]));
          return result;
        }, []);
      }

      value = value.map(function (_value) {
        return self.whereItemQuery(key, _value, options);
      }).filter(function (item) {
        return item && item.length;
      });

      return value.length ? '('+value.join(binding)+')' : undefined;
    }

    if (_.isPlainObject(value) && fieldType instanceof DataTypes.JSON && options.json !== false) {
      return (function () {
        var $items = []
          , result
          , traverse;

        traverse = function (prop, item, path) {
          var $where = {}
            , $key
            , $cast
            , $baseKey
            , $tmp
            , castKey;

          if (path[path.length - 1].indexOf('::') > -1) {
            $tmp = path[path.length - 1].split('::');
            $cast = $tmp[1];
            path[path.length - 1] = $tmp[0];
          }

          var pathKey = self.escape('{' + path.join(', ') + '}');
          $baseKey = self.quoteIdentifier(key)+'#>>'+pathKey;

          if (options.prefix) {
            if (options.prefix instanceof Utils.literal) {
              $baseKey = self.handleSequelizeMethod(options.prefix)+'.'+$baseKey;
            } else {
              $baseKey = self.quoteTable(options.prefix)+'.'+$baseKey;
            }
          }

          $baseKey = '('+$baseKey+')';

          castKey = function ($item) {
            var key = $baseKey;

            if (!$cast) {
              if (typeof $item === 'number') {
                $cast = 'double precision';
              } else if ($item instanceof Date) {
                $cast = 'timestamptz';
              } else if (typeof $item === 'boolean') {
                $cast = 'boolean';
              }
            }

            if ($cast) {
              key += '::'+$cast;
            }

            return key;
          };

          if (_.isPlainObject(item)) {
            _.forOwn(item, function ($item, $prop) {
              if ($prop.indexOf('$') === 0) {
                $where[$prop] = $item;
                $key = castKey($item);

                $items.push(self.whereItemQuery(new Utils.literal($key), $where/*, _.pick(options, 'prefix')*/));
              } else {
                traverse($prop, $item, path.concat([$prop]));
              }
            });
          } else {
            $where.$eq = item;
            $key = castKey(item);

            $items.push(self.whereItemQuery(new Utils.literal($key), $where/*, _.pick(options, 'prefix')*/));
          }
        };

        _.forOwn(value, function (item, prop) {
          if (prop.indexOf('$') === 0) {
            var $where = {};
            $where[prop] = item;
            $items.push(self.whereItemQuery(key, $where, _.assign({}, options, {json: false})));
            return;
          }

          traverse(prop, item, [prop]);
        });

        result = $items.join(' AND ');
        return $items.length > 1 ? '('+result+')' : result;
      })();
    }

    // If multiple keys we combine the different logic conditions
    if (_.isPlainObject(value) && Object.keys(value).length > 1) {
      return (function () {
        var $items = [];
        _.forOwn(value, function (item, logic) {
          var $where = {};
          $where[logic] = item;
          $items.push(self.whereItemQuery(key, $where, options));
        });

        return '('+$items.join(' AND ')+')';
      })();
    }

    // Do [] to $in/$notIn normalization
    if (value && (!fieldType || !(fieldType instanceof DataTypes.ARRAY))) {
      if (Array.isArray(value)) {
        value = {
          $in: value
        };
      } else if (value && Array.isArray(value.$not)) {
        value.$notIn = value.$not;
        delete value.$not;
      }
    }

    // normalize $not: non-bool|non-null to $ne
    if (value && typeof value.$not !== 'undefined' && [null, true, false].indexOf(value.$not) < 0) {
      value.$ne = value.$not;
      delete value.$not;
    }

    // Setup keys and comparators
    if (Array.isArray(value) && fieldType instanceof DataTypes.ARRAY) {
      value = this.escape(value, field);
    } else if (value && (value.$in || value.$notIn)) {
      comparator = 'IN';
      if (value.$notIn) comparator = 'NOT IN';

      if ((value.$in || value.$notIn) instanceof Utils.literal) {
        value = (value.$in || value.$notIn).val;
      } else if ((value.$in || value.$notIn).length) {
        value = '('+(value.$in || value.$notIn).map(function (item) {
          return self.escape(item);
        }).join(', ')+')';
      } else {
        value = '(NULL)';
      }
    } else if (value && (value.$any || value.$all)) {
      comparator = value.$any ? '= ANY' : '= ALL';
      if (value.$any && value.$any.$values || value.$all && value.$all.$values) {
        value = '(VALUES '+(value.$any && value.$any.$values || value.$all && value.$all.$values).map(function (value) {
          return '('+this.escape(value)+')';
        }.bind(this)).join(', ')+')';
      } else {
        value = '('+this.escape(value.$any || value.$all, field)+')';
      }
    } else if (value && (value.$between || value.$notBetween)) {
      comparator = 'BETWEEN';
      if (value.$notBetween) comparator = 'NOT BETWEEN';

      value = (value.$between || value.$notBetween).map(function (item) {
        return self.escape(item);
      }).join(' AND ');
    } else if (value && value.$raw) {
      value = value.$raw;
    } else if (value && value.$col) {
      value = value.$col.split('.');

      if (value.length > 2) {
        value = [
          value.slice(0, -1).join('.'),
          value[value.length - 1]
        ];
      }

      value = value.map(this.quoteIdentifier.bind(this)).join('.');
    } else {
      var escapeValue = true;
      var escapeOptions = {};

      if (_.isPlainObject(value)) {
        _.forOwn(value, function (item, key) {
          if (comparatorMap[key]) {
            comparator = comparatorMap[key];
            value = item;

            if (_.isPlainObject(value) && value.$any) {
              comparator += ' ANY';
              escapeOptions.isList = true;
              value = value.$any;
            } else if (_.isPlainObject(value) && value.$all) {
              comparator += ' ALL';
              escapeOptions.isList = true;
              value = value.$all;
            } else if (value && value.$col) {
              escapeValue = false;
              value = this.whereItemQuery(null, value);
            }
          }
        }.bind(this));
      }

      if (comparator === '=' && value === null) {
        comparator = 'IS';
      } else if (comparator === '!=' && value === null) {
        comparator = 'IS NOT';
      }

      escapeOptions.acceptStrings = comparator.indexOf('LIKE') !== -1;

      if (escapeValue) {
        value = this.escape(value, field, escapeOptions);

        //if ANY is used with like, add parentheses to generate correct query
        if (escapeOptions.acceptStrings && (comparator.indexOf('ANY') > comparator.indexOf('LIKE'))) {
         value = '(' + value + ')';
        }
      }
    }

    if (key) {
      var prefix = true;
      if (key._isSequelizeMethod) {
        key = this.handleSequelizeMethod(key);
      } else if (Utils.isColString(key)) {
        key = key.substr(1, key.length - 2).split('.');

        if (key.length > 2) {
          key = [
            key.slice(0, -1).join('.'),
            key[key.length - 1]
          ];
        }

        key = key.map(this.quoteIdentifier.bind(this)).join('.');
        prefix = false;
      } else {
        key = this.quoteIdentifier(key);
      }

      if (options.prefix && prefix) {
        if (options.prefix instanceof Utils.literal) {
          key = [this.handleSequelizeMethod(options.prefix), key].join('.');
        } else {
          key = [this.quoteTable(options.prefix), key].join('.');
        }
      }
      return [key, value].join(' '+comparator+' ');
    }
    return value;
  },

  /*
    Takes something and transforms it into values of a where condition.
  */
  getWhereConditions: function(smth, tableName, factory, options, prepend) {
    var result = null
      , where = {}
      , self = this;

    if (Array.isArray(tableName)) {
      tableName = tableName[0];
      if (Array.isArray(tableName)) {
        tableName = tableName[1];
      }
    }

    options = options || {};

    if (typeof prepend === 'undefined') {
      prepend = true;
    }

    if (smth && smth._isSequelizeMethod === true) { // Checking a property is cheaper than a lot of instanceof calls
      result = this.handleSequelizeMethod(smth, tableName, factory, options, prepend);
    } else if (Utils._.isPlainObject(smth)) {
      return self.whereItemsQuery(smth, {
        model: factory,
        prefix: prepend && tableName
      });
    } else if (typeof smth === 'number') {
      var primaryKeys = !!factory ? Object.keys(factory.primaryKeys) : [];

      if (primaryKeys.length > 0) {
        // Since we're just a number, assume only the first key
        primaryKeys = primaryKeys[0];
      } else {
        primaryKeys = 'id';
      }

      where[primaryKeys] = smth;

      return self.whereItemsQuery(where, {
        model: factory,
        prefix: prepend && tableName
      });
    } else if (typeof smth === 'string') {
      return self.whereItemsQuery(smth, {
        model: factory,
        prefix: prepend && tableName
      });
    } else if (Buffer.isBuffer(smth)) {
      result = this.escape(smth);
    } else if (Array.isArray(smth)) {
      if (smth.length === 0) return '1=1';
      if (Utils.canTreatArrayAsAnd(smth)) {
        var _smth = { $and: smth };
        result = self.getWhereConditions(_smth, tableName, factory, options, prepend);
      } else {
        result = Utils.format(smth, this.dialect);
      }
    } else if (smth === null) {
      return self.whereItemsQuery(smth, {
        model: factory,
        prefix: prepend && tableName
      });
    }

    return result ? result : '1=1';
  },

  booleanValue: function(value) {
    return value;
  }
};

module.exports = QueryGenerator;
"
"(function(module) {
	""use strict"";

	var Comments = {};

	var db = require.main.require('./src/database');
	var meta = require.main.require('./src/meta');
	var posts = require.main.require('./src/posts');
	var topics = require.main.require('./src/topics');
	var user = require.main.require('./src/user');
	var groups = require.main.require('./src/groups');
	var fs = module.parent.require('fs');
	var path = module.parent.require('path');
	var async = module.parent.require('async');
	var winston = module.parent.require('winston');
	var nconf = module.parent.require('nconf');
	var relativePath = nconf.get('relative_path');

	module.exports = Comments;

	Comments.getTopicIDByCommentID = function(commentID, callback) {
		db.getObjectField('blog-comments', commentID, function(err, tid) {
			callback(err, tid);
		});
	};

	Comments.getCommentData = function(req, res, callback) {
		var commentID = req.params.id,
			pagination = req.params.pagination ? req.params.pagination : 0,
			uid = req.user ? req.user.uid : 0;

		Comments.getTopicIDByCommentID(commentID, function(err, tid) {
			var disabled = false;

			async.parallel({
				posts: function(next) {
					if (disabled) {
						next(err, []);
					} else {
						topics.getTopicPosts(tid, 'tid:' + tid + ':posts', 0 + req.params.pagination * 10, 9 + req.params.pagination * 9, uid, true, next);
					}
				},
				postCount: function(next) {
					topics.getTopicField(tid, 'postcount', next);
				},
				user: function(next) {
					user.getUserData(uid, next);
				},
				isAdministrator: function(next) {
					user.isAdministrator(uid, next);
				},
				isPublisher: function(next) {
					groups.isMember(uid, 'publishers', next);
				},
				category: function(next) {
					topics.getCategoryData(tid, next);
				},
				mainPost: function(next) {
					topics.getMainPost(tid, uid, next);
				}
			}, function(err, data) {
				var hostUrls = (meta.config['blog-comments:url'] || '').split(','),
					url;

				hostUrls.forEach(function(hostUrl) {
					hostUrl = hostUrl.trim();
					if (hostUrl[hostUrl.length - 1] === '/') {
						hostUrl = hostUrl.substring(0, hostUrl.length - 1);
					}

					if (hostUrl === req.get('origin')) {
						url = req.get('origin');
					}
				});

				if (!url) {
					winston.warn('[nodebb-plugin-blog-comments] Origin (' + req.get('origin') + ') does not match hostUrls: ' + hostUrls.join(', '));
				}

				res.header(""Access-Control-Allow-Origin"", url);
				res.header('Access-Control-Allow-Headers', 'X-Requested-With, X-HTTP-Method-Override, Content-Type, Accept');
				res.header(""Access-Control-Allow-Credentials"", ""true"");

				var posts = data.posts.filter(function(post) {
					if (post.user.picture) {
						post.user.picture = post.user.picture.replace(relativePath, '');
					}
					return !post.deleted;
				});

				if (data.user.picture) {
					data.user.picture = data.user.picture.replace(relativePath, '');
				}

				var top = true;
				var bottom = false;
				var compose_location = meta.config['blog-comments:compose-location'];
				if (compose_location == ""bottom""){ bottom = true; top = false;}

				res.json({
					posts: posts,
					postCount: data.postCount,
					user: data.user,
					template: Comments.template,
					token: req.csrfToken && req.csrfToken(),
					isAdmin: !data.isAdministrator ? data.isPublisher : data.isAdministrator,
					isLoggedIn: !!uid,
					tid: tid,
					category: data.category,
					mainPost: data.mainPost ? data.mainPost[0] : null,
					atBottom: bottom,
					atTop: top
				});
			});
		});
	};

	Comments.replyToComment = function(req, res, callback) {
		var content = req.body.content,
			tid = req.body.tid,
			url = req.body.url,
			uid = req.user ? req.user.uid : 0;

		topics.reply({
			tid: tid,
			uid: uid,
			content: content,
			req: req,
		}, function(err, postData) {
			if(err) {
				return res.redirect(url + '?error=' + err.message + '#nodebb-comments');
			}

			res.redirect(url + '#nodebb-comments');
		});
	};

	Comments.publishArticle = function(req, res, callback) {
		var markdown = req.body.markdown,
			title = req.body.title,
			url = req.body.url,
			commentID = req.body.id,
			tags = req.body.tags,
			uid = req.user ? req.user.uid : 0,
			cid = JSON.parse(req.body.cid);

		if (cid === -1) {
			var hostUrls = (meta.config['blog-comments:url'] || '').split(','),
				position = 0;

			hostUrls.forEach(function(hostUrl, i) {
				hostUrl = hostUrl.trim();
				if (hostUrl[hostUrl.length - 1] === '/') {
					hostUrl = hostUrl.substring(0, hostUrl.length - 1);
				}

				if (hostUrl === req.get('origin')) {
					position = i;
				}
			});

			cid = meta.config['blog-comments:cid'].toString() || '';
			cid = parseInt(cid.split(',')[position], 10) || parseInt(cid.split(',')[0], 10) || 1;
		}

		async.parallel({
			isAdministrator: function(next) {
				user.isAdministrator(uid, next);
			},
			isPublisher: function(next) {
				groups.isMember(uid, 'publishers', next);
			}
		}, function(err, userStatus) {
			if (!userStatus.isAdministrator && !userStatus.isPublisher) {
				return res.json({error: ""Only Administrators or members of the publishers group can publish articles""});
			}

			topics.post({
				uid: uid,
				title: title,
				content: markdown,
				tags: tags ? JSON.parse(tags) : [],
				req: req,
				cid: cid
			}, function(err, result) {
				if (!err && result && result.postData && result.postData.tid) {
					posts.setPostField(result.postData.pid, 'blog-comments:url', url, function(err) {
						if (err) {
							return res.json({error: ""Unable to post topic"", result: result});		
						}
						
						db.setObjectField('blog-comments', commentID, result.postData.tid);
						res.redirect((req.header('Referer') || '/') + '#nodebb-comments');
					});
				} else {
					res.json({error: ""Unable to post topic"", result: result});
				}
			});
		});

	};

	Comments.addLinkbackToArticle = function(post, callback) {
		var hostUrls = (meta.config['blog-comments:url'] || '').split(','),
			position;

		posts.getPostField(post.pid, 'blog-comments:url', function(err, url) {
			if (url) {
				hostUrls.forEach(function(hostUrl, i) {
					if (url.indexOf(hostUrl.trim().replace(/^https?:\/\//, '')) !== -1) {
						position = i;
					}
				});

				var blogName = (meta.config['blog-comments:name'] || '');
				blogName = parseInt(blogName.split(',')[position], 10) || parseInt(blogName.split(',')[0], 10) || 1;

				post.profile.push({
					content: ""Posted from <strong><a href=""+ url +"" target='blank'>"" + blogName + ""</a></strong>""
				});
			}

			callback(err, post);
		});
	};

	Comments.addAdminLink = function(custom_header, callback) {
		custom_header.plugins.push({
			""route"": ""/blog-comments"",
			""icon"": ""fa-book"",
			""name"": ""Blog Comments""
		});

		callback(null, custom_header);
	};

	function renderAdmin(req, res, callback) {
		res.render('comments/admin', {});
	}

	Comments.init = function(params, callback) {
		var app = params.router,
			middleware = params.middleware,
			controllers = params.controllers;
			
		fs.readFile(path.resolve(__dirname, './public/templates/comments/comments.tpl'), function (err, data) {
			Comments.template = data.toString();
		});

		app.get('/comments/get/:id/:pagination?', middleware.applyCSRF, Comments.getCommentData);
		app.post('/comments/reply', Comments.replyToComment);
		app.post('/comments/publish', Comments.publishArticle);

		app.get('/admin/blog-comments', middleware.admin.buildHeader, renderAdmin);
		app.get('/api/admin/blog-comments', renderAdmin);

		callback();
	};

}(module));
","(function(module) {
	""use strict"";

	var Comments = {};

	var db = require.main.require('./src/database');
	var meta = require.main.require('./src/meta');
	var posts = require.main.require('./src/posts');
	var topics = require.main.require('./src/topics');
	var user = require.main.require('./src/user');
	var groups = require.main.require('./src/groups');
	var fs = module.parent.require('fs');
	var path = module.parent.require('path');
	var async = module.parent.require('async');
	var winston = module.parent.require('winston');
	var nconf = module.parent.require('nconf');
	var relativePath = nconf.get('relative_path');

	module.exports = Comments;

	Comments.getTopicIDByCommentID = function(commentID, callback) {
		db.getObjectField('blog-comments', commentID, function(err, tid) {
			callback(err, tid);
		});
	};

	Comments.getCommentData = function(req, res, callback) {
		var commentID = req.params.id,
			pagination = req.params.pagination ? req.params.pagination : 0,
			uid = req.user ? req.user.uid : 0;

		Comments.getTopicIDByCommentID(commentID, function(err, tid) {
			var disabled = false;

			async.parallel({
				posts: function(next) {
					if (disabled) {
						next(err, []);
					} else {
						topics.getTopicPosts(tid, 'tid:' + tid + ':posts', 0 + req.params.pagination * 10, 9 + req.params.pagination * 9, uid, true, next);
					}
				},
				postCount: function(next) {
					topics.getTopicField(tid, 'postcount', next);
				},
				user: function(next) {
					user.getUserData(uid, next);
				},
				isAdministrator: function(next) {
					user.isAdministrator(uid, next);
				},
				isPublisher: function(next) {
					groups.isMember(uid, 'publishers', next);
				},
				category: function(next) {
					topics.getCategoryData(tid, next);
				},
				mainPost: function(next) {
					topics.getMainPost(tid, uid, next);
				}
			}, function(err, data) {
				var hostUrls = (meta.config['blog-comments:url'] || '').split(','),
					url;

				hostUrls.forEach(function(hostUrl) {
					hostUrl = hostUrl.trim();
					if (hostUrl[hostUrl.length - 1] === '/') {
						hostUrl = hostUrl.substring(0, hostUrl.length - 1);
					}

					if (hostUrl === req.get('origin')) {
						url = req.get('origin');
					}
				});

				if (!url) {
					winston.warn('[nodebb-plugin-blog-comments] Origin (' + req.get('origin') + ') does not match hostUrls: ' + hostUrls.join(', '));
				}

				res.header(""Access-Control-Allow-Origin"", url);
				res.header('Access-Control-Allow-Headers', 'X-Requested-With, X-HTTP-Method-Override, Content-Type, Accept');
				res.header(""Access-Control-Allow-Credentials"", ""true"");

				var posts = data.posts.filter(function(post) {
					if (post.user.picture) {
						post.user.picture = post.user.picture.replace(relativePath, '');
					}
					return !post.deleted;
				});

				if (data.user.picture) {
					data.user.picture = data.user.picture.replace(relativePath, '');
				}

				var top = true;
				var bottom = false;
				var compose_location = meta.config['blog-comments:compose-location'];
				if (compose_location == ""bottom""){ bottom = true; top = false;}

				res.json({
					posts: posts,
					postCount: data.postCount,
					user: data.user,
					template: Comments.template,
					token: req.csrfToken && req.csrfToken(),
					isAdmin: !data.isAdministrator ? data.isPublisher : data.isAdministrator,
					isLoggedIn: !!uid,
					tid: tid,
					category: data.category,
					mainPost: data.mainPost ? data.mainPost[0] : null,
					atBottom: bottom,
					atTop: top
				});
			});
		});
	};

	Comments.replyToComment = function(req, res, callback) {
		var content = req.body.content,
			tid = req.body.tid,
			url = req.body.url,
			uid = req.user ? req.user.uid : 0;

		topics.reply({
			tid: tid,
			uid: uid,
			content: content,
			req: req,
		}, function(err, postData) {
			if(err) {
				return res.redirect(url + '?error=' + err.message + '#nodebb-comments');
			}

			res.redirect(url + '#nodebb-comments');
		});
	};

	Comments.publishArticle = function(req, res, callback) {
		var markdown = req.body.markdown,
			title = req.body.title,
			url = req.body.url,
			commentID = req.body.id,
			tags = req.body.tags,
			uid = req.user ? req.user.uid : 0,
			cid = JSON.parse(req.body.cid);

		if (cid === -1) {
			var hostUrls = (meta.config['blog-comments:url'] || '').split(','),
				position = 0;

			hostUrls.forEach(function(hostUrl, i) {
				hostUrl = hostUrl.trim();
				if (hostUrl[hostUrl.length - 1] === '/') {
					hostUrl = hostUrl.substring(0, hostUrl.length - 1);
				}

				if (hostUrl === req.get('origin')) {
					position = i;
				}
			});

			cid = meta.config['blog-comments:cid'].toString() || '';
			cid = parseInt(cid.split(',')[position], 10) || parseInt(cid.split(',')[0], 10) || 1;
		}

		async.parallel({
			isAdministrator: function(next) {
				user.isAdministrator(uid, next);
			},
			isPublisher: function(next) {
				groups.isMember(uid, 'publishers', next);
			}
		}, function(err, userStatus) {
			if (!userStatus.isAdministrator && !userStatus.isPublisher) {
				return res.json({error: ""Only Administrators or members of the publishers group can publish articles""});
			}

			topics.post({
				uid: uid,
				title: title,
				content: markdown,
				tags: tags ? JSON.parse(tags) : [],
				req: req,
				cid: cid
			}, function(err, result) {
				if (!err && result && result.postData && result.postData.tid) {
					posts.setPostField(result.postData.pid, 'blog-comments:url', url, function(err) {
						if (err) {
							return res.json({error: ""Unable to post topic"", result: result});		
						}
						
						db.setObjectField('blog-comments', commentID, result.postData.tid);
						res.redirect((req.header('Referer') || '/') + '#nodebb-comments');
					});
				} else {
					res.json({error: ""Unable to post topic"", result: result});
				}
			});
		});

	};

	Comments.addLinkbackToArticle = function(post, callback) {
		var hostUrls = (meta.config['blog-comments:url'] || '').split(','),
			position;

		posts.getPostField(post.pid, 'blog-comments:url', function(err, url) {
			if (url) {
				hostUrls.forEach(function(hostUrl, i) {
					if (url.indexOf(hostUrl.trim().replace(/^https?:\/\//, '')) !== -1) {
						position = i;
					}
				});

				var blogName = (meta.config['blog-comments:name'] || '');
				blogName = parseInt(blogName.split(',')[position], 10) || parseInt(blogName.split(',')[0], 10) || 1;

				post.profile.push({
					content: ""Posted from <strong><a href=""+ url +"" target='blank'>"" + blogName + ""</a></strong>""
				});
			}

			callback(err, post);
		});
	};

	Comments.addAdminLink = function(custom_header, callback) {
		custom_header.plugins.push({
			""route"": ""/blog-comments"",
			""icon"": ""fa-book"",
			""name"": ""Blog Comments""
		});

		callback(null, custom_header);
	};

	function renderAdmin(req, res, callback) {
		res.render('comments/admin', {});
	}

	Comments.init = function(params, callback) {
		var app = params.router,
			middleware = params.middleware,
			controllers = params.controllers;
			
		fs.readFile(path.resolve(__dirname, './public/templates/comments/comments.tpl'), function (err, data) {
			Comments.template = data.toString();
		});

		app.get('/comments/get/:id/:pagination?', middleware.applyCSRF, Comments.getCommentData);
		app.post('/comments/reply', middleware.applyCSRF, Comments.replyToComment);
		app.post('/comments/publish', middleware.applyCSRF, Comments.publishArticle);

		app.get('/admin/blog-comments', middleware.admin.buildHeader, renderAdmin);
		app.get('/api/admin/blog-comments', renderAdmin);

		callback();
	};

}(module));
"
"// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-

const Lang = imports.lang;
const Signals = imports.signals;

const GLib = imports.gi.GLib;
const Gio = imports.gi.Gio;
const St = imports.gi.St;

const ExtensionUtils = imports.misc.extensionUtils;
const Main = imports.ui.main;

const ExtensionState = {
    ENABLED: 1,
    DISABLED: 2,
    ERROR: 3,
    OUT_OF_DATE: 4,
    DOWNLOADING: 5,
    INITIALIZED: 6,

    // Used as an error state for operations on unknown extensions,
    // should never be in a real extensionMeta object.
    UNINSTALLED: 99
};

// Arrays of uuids
var enabledExtensions;
// Contains the order that extensions were enabled in.
const extensionOrder = [];

// We don't really have a class to add signals on. So, create
// a simple dummy object, add the signal methods, and export those
// publically.
var _signals = {};
Signals.addSignalMethods(_signals);

const connect = Lang.bind(_signals, _signals.connect);
const disconnect = Lang.bind(_signals, _signals.disconnect);

const ENABLED_EXTENSIONS_KEY = 'enabled-extensions';
const DISABLE_USER_EXTENSIONS_KEY = 'disable-user-extensions';
const EXTENSION_DISABLE_VERSION_CHECK_KEY = 'disable-extension-version-validation';

var initted = false;
var enabled;

function disableExtension(uuid) {
    let extension = ExtensionUtils.extensions[uuid];
    if (!extension)
        return;

    if (extension.state != ExtensionState.ENABLED)
        return;

    // ""Rebase"" the extension order by disabling and then enabling extensions
    // in order to help prevent conflicts.

    // Example:
    //   order = [A, B, C, D, E]
    //   user disables C
    //   this should: disable E, disable D, disable C, enable D, enable E

    let orderIdx = extensionOrder.indexOf(uuid);
    let order = extensionOrder.slice(orderIdx + 1);
    let orderReversed = order.slice().reverse();

    for (let i = 0; i < orderReversed.length; i++) {
        let uuid = orderReversed[i];
        try {
            ExtensionUtils.extensions[uuid].stateObj.disable();
        } catch(e) {
            logExtensionError(uuid, e);
        }
    }

    if (extension.stylesheet) {
        let theme = St.ThemeContext.get_for_stage(global.stage).get_theme();
        theme.unload_stylesheet(extension.stylesheet);
    }

    try {
        extension.stateObj.disable();
    } catch(e) {
        logExtensionError(uuid, e);
    }

    for (let i = 0; i < order.length; i++) {
        let uuid = order[i];
        try {
            ExtensionUtils.extensions[uuid].stateObj.enable();
        } catch(e) {
            logExtensionError(uuid, e);
        }
    }

    extensionOrder.splice(orderIdx, 1);

    if ( extension.state != ExtensionState.ERROR ) {
        extension.state = ExtensionState.DISABLED;
        _signals.emit('extension-state-changed', extension);
    }
}

function enableExtension(uuid) {
    let extension = ExtensionUtils.extensions[uuid];
    if (!extension)
        return;

    if (extension.state == ExtensionState.INITIALIZED)
        initExtension(uuid);

    if (extension.state != ExtensionState.DISABLED)
        return;

    extensionOrder.push(uuid);

    let stylesheetNames = [global.session_mode + '.css', 'stylesheet.css'];
    for (let i = 0; i < stylesheetNames.length; i++) {
        let stylesheetFile = extension.dir.get_child(stylesheetNames[i]);
        if (stylesheetFile.query_exists(null)) {
            let theme = St.ThemeContext.get_for_stage(global.stage).get_theme();
            theme.load_stylesheet(stylesheetFile);
            extension.stylesheet = stylesheetFile;
            break;
        }
    }

    try {
        extension.stateObj.enable();
        extension.state = ExtensionState.ENABLED;
        _signals.emit('extension-state-changed', extension);
        return;
    } catch(e) {
        logExtensionError(uuid, e);
        return;
    }
}

function logExtensionError(uuid, error) {
    let extension = ExtensionUtils.extensions[uuid];
    if (!extension)
        return;

    let message = '' + error;

    extension.state = ExtensionState.ERROR;
    if (!extension.errors)
        extension.errors = [];
    extension.errors.push(message);

    log('Extension ""%s"" had error: %s'.format(uuid, message));
    _signals.emit('extension-state-changed', { uuid: uuid,
                                               error: message,
                                               state: extension.state });
}

function loadExtension(extension) {
    // Default to error, we set success as the last step
    extension.state = ExtensionState.ERROR;

    let checkVersion = !global.settings.get_boolean(EXTENSION_DISABLE_VERSION_CHECK_KEY);

    if (checkVersion && ExtensionUtils.isOutOfDate(extension)) {
        extension.state = ExtensionState.OUT_OF_DATE;
    } else {
        let enabled = enabledExtensions.indexOf(extension.uuid) != -1;
        if (enabled) {
            if (!initExtension(extension.uuid))
                return;
            if (extension.state == ExtensionState.DISABLED)
                enableExtension(extension.uuid);
        } else {
            extension.state = ExtensionState.INITIALIZED;
        }
    }

    _signals.emit('extension-state-changed', extension);
}

function unloadExtension(extension) {
    // Try to disable it -- if it's ERROR'd, we can't guarantee that,
    // but it will be removed on next reboot, and hopefully nothing
    // broke too much.
    disableExtension(extension.uuid);

    extension.state = ExtensionState.UNINSTALLED;
    _signals.emit('extension-state-changed', extension);

    delete ExtensionUtils.extensions[extension.uuid];
    return true;
}

function reloadExtension(oldExtension) {
    // Grab the things we'll need to pass to createExtensionObject
    // to reload it.
    let { uuid: uuid, dir: dir, type: type } = oldExtension;

    // Then unload the old extension.
    unloadExtension(oldExtension);

    // Now, recreate the extension and load it.
    let newExtension = ExtensionUtils.createExtensionObject(uuid, dir, type);
    loadExtension(newExtension);
}

function initExtension(uuid) {
    let extension = ExtensionUtils.extensions[uuid];
    let dir = extension.dir;

    if (!extension)
        throw new Error(""Extension was not properly created. Call loadExtension first"");

    let extensionJs = dir.get_child('extension.js');
    if (!extensionJs.query_exists(null))
        throw new Error('Missing extension.js');

    let extensionModule;
    let extensionState = null;

    ExtensionUtils.installImporter(extension);
    extensionModule = extension.imports.extension;

    if (extensionModule.init) {
        try {
            extensionState = extensionModule.init(extension);
        } catch(e) {
            logExtensionError(uuid, e);
            return false;
        }
    }

    if (!extensionState)
        extensionState = extensionModule;
    extension.stateObj = extensionState;

    extension.state = ExtensionState.DISABLED;
    _signals.emit('extension-loaded', uuid);
    return true;
}

function getEnabledExtensions() {
    let extensions;
    if (Array.isArray(Main.sessionMode.enabledExtensions))
        extensions = Main.sessionMode.enabledExtensions;
    else
        extensions = [];

    if (global.settings.get_boolean(DISABLE_USER_EXTENSIONS_KEY))
        return extensions;

    return extensions.concat(global.settings.get_strv(ENABLED_EXTENSIONS_KEY));
}

function onEnabledExtensionsChanged() {
    let newEnabledExtensions = getEnabledExtensions();

    if (!enabled)
        return;

    // Find and enable all the newly enabled extensions: UUIDs found in the
    // new setting, but not in the old one.
    newEnabledExtensions.filter(function(uuid) {
        return enabledExtensions.indexOf(uuid) == -1;
    }).forEach(function(uuid) {
        enableExtension(uuid);
    });

    // Find and disable all the newly disabled extensions: UUIDs found in the
    // old setting, but not in the new one.
    enabledExtensions.filter(function(item) {
        return newEnabledExtensions.indexOf(item) == -1;
    }).forEach(function(uuid) {
        disableExtension(uuid);
    });

    enabledExtensions = newEnabledExtensions;
}

function _onVersionValidationChanged() {
    // we want to reload all extensions, but only enable
    // extensions when allowed by the sessionMode, so
    // temporarily disable them all
    enabledExtensions = [];
    for (let uuid in ExtensionUtils.extensions)
        reloadExtension(ExtensionUtils.extensions[uuid]);
    enabledExtensions = getEnabledExtensions();

    if (Main.sessionMode.allowExtensions) {
        enabledExtensions.forEach(function(uuid) {
            enableExtension(uuid);
        });
    }
}

function _loadExtensions() {
    global.settings.connect('changed::' + ENABLED_EXTENSIONS_KEY, onEnabledExtensionsChanged);
    global.settings.connect('changed::' + DISABLE_USER_EXTENSIONS_KEY, onEnabledExtensionsChanged);
    global.settings.connect('changed::' + EXTENSION_DISABLE_VERSION_CHECK_KEY, _onVersionValidationChanged);

    enabledExtensions = getEnabledExtensions();

    let finder = new ExtensionUtils.ExtensionFinder();
    finder.connect('extension-found', function(finder, extension) {
        loadExtension(extension);
    });
    finder.scanExtensions();
}

function enableAllExtensions() {
    if (enabled)
        return;

    if (!initted) {
        _loadExtensions();
        initted = true;
    } else {
        enabledExtensions.forEach(function(uuid) {
            enableExtension(uuid);
        });
    }
    enabled = true;
}

function disableAllExtensions() {
    if (!enabled)
        return;

    if (initted) {
        extensionOrder.slice().reverse().forEach(function(uuid) {
            disableExtension(uuid);
        });
    }

    enabled = false;
}

function _sessionUpdated() {
    // For now sessionMode.allowExtensions controls extensions from both the
    // 'enabled-extensions' preference and the sessionMode.enabledExtensions
    // property; it might make sense to make enabledExtensions independent
    // from allowExtensions in the future
    if (Main.sessionMode.allowExtensions) {
        if (initted)
            enabledExtensions = getEnabledExtensions();
        enableAllExtensions();
    } else {
        disableAllExtensions();
    }
}

function init() {
    Main.sessionMode.connect('updated', _sessionUpdated);
    _sessionUpdated();
}
","// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-

const Lang = imports.lang;
const Signals = imports.signals;

const GLib = imports.gi.GLib;
const Gio = imports.gi.Gio;
const St = imports.gi.St;

const ExtensionUtils = imports.misc.extensionUtils;
const Main = imports.ui.main;

const ExtensionState = {
    ENABLED: 1,
    DISABLED: 2,
    ERROR: 3,
    OUT_OF_DATE: 4,
    DOWNLOADING: 5,
    INITIALIZED: 6,

    // Used as an error state for operations on unknown extensions,
    // should never be in a real extensionMeta object.
    UNINSTALLED: 99
};

// Arrays of uuids
var enabledExtensions;
// Contains the order that extensions were enabled in.
const extensionOrder = [];

// We don't really have a class to add signals on. So, create
// a simple dummy object, add the signal methods, and export those
// publically.
var _signals = {};
Signals.addSignalMethods(_signals);

const connect = Lang.bind(_signals, _signals.connect);
const disconnect = Lang.bind(_signals, _signals.disconnect);

const ENABLED_EXTENSIONS_KEY = 'enabled-extensions';
const DISABLE_USER_EXTENSIONS_KEY = 'disable-user-extensions';
const EXTENSION_DISABLE_VERSION_CHECK_KEY = 'disable-extension-version-validation';

var initted = false;
var enabled;

function disableExtension(uuid) {
    let extension = ExtensionUtils.extensions[uuid];
    if (!extension)
        return;

    if (extension.state != ExtensionState.ENABLED)
        return;

    // ""Rebase"" the extension order by disabling and then enabling extensions
    // in order to help prevent conflicts.

    // Example:
    //   order = [A, B, C, D, E]
    //   user disables C
    //   this should: disable E, disable D, disable C, enable D, enable E

    let orderIdx = extensionOrder.indexOf(uuid);
    let order = extensionOrder.slice(orderIdx + 1);
    let orderReversed = order.slice().reverse();

    for (let i = 0; i < orderReversed.length; i++) {
        let uuid = orderReversed[i];
        try {
            ExtensionUtils.extensions[uuid].stateObj.disable();
        } catch(e) {
            logExtensionError(uuid, e);
        }
    }

    if (extension.stylesheet) {
        let theme = St.ThemeContext.get_for_stage(global.stage).get_theme();
        theme.unload_stylesheet(extension.stylesheet);
    }

    try {
        extension.stateObj.disable();
    } catch(e) {
        logExtensionError(uuid, e);
    }

    for (let i = 0; i < order.length; i++) {
        let uuid = order[i];
        try {
            ExtensionUtils.extensions[uuid].stateObj.enable();
        } catch(e) {
            logExtensionError(uuid, e);
        }
    }

    extensionOrder.splice(orderIdx, 1);

    if ( extension.state != ExtensionState.ERROR ) {
        extension.state = ExtensionState.DISABLED;
        _signals.emit('extension-state-changed', extension);
    }
}

function enableExtension(uuid) {
    let extension = ExtensionUtils.extensions[uuid];
    if (!extension)
        return;

    if (extension.state == ExtensionState.INITIALIZED)
        initExtension(uuid);

    if (extension.state != ExtensionState.DISABLED)
        return;

    extensionOrder.push(uuid);

    let stylesheetNames = [global.session_mode + '.css', 'stylesheet.css'];
    for (let i = 0; i < stylesheetNames.length; i++) {
        let stylesheetFile = extension.dir.get_child(stylesheetNames[i]);
        if (stylesheetFile.query_exists(null)) {
            let theme = St.ThemeContext.get_for_stage(global.stage).get_theme();
            theme.load_stylesheet(stylesheetFile);
            extension.stylesheet = stylesheetFile;
            break;
        }
    }

    try {
        extension.stateObj.enable();
        extension.state = ExtensionState.ENABLED;
        _signals.emit('extension-state-changed', extension);
        return;
    } catch(e) {
        logExtensionError(uuid, e);
        return;
    }
}

function logExtensionError(uuid, error) {
    let extension = ExtensionUtils.extensions[uuid];
    if (!extension)
        return;

    let message = '' + error;

    extension.state = ExtensionState.ERROR;
    if (!extension.errors)
        extension.errors = [];
    extension.errors.push(message);

    log('Extension ""%s"" had error: %s'.format(uuid, message));
    _signals.emit('extension-state-changed', { uuid: uuid,
                                               error: message,
                                               state: extension.state });
}

function loadExtension(extension) {
    // Default to error, we set success as the last step
    extension.state = ExtensionState.ERROR;

    let checkVersion = !global.settings.get_boolean(EXTENSION_DISABLE_VERSION_CHECK_KEY);

    if (checkVersion && ExtensionUtils.isOutOfDate(extension)) {
        extension.state = ExtensionState.OUT_OF_DATE;
    } else {
        let enabled = enabledExtensions.indexOf(extension.uuid) != -1;
        if (enabled) {
            if (!initExtension(extension.uuid))
                return;
            if (extension.state == ExtensionState.DISABLED)
                enableExtension(extension.uuid);
        } else {
            extension.state = ExtensionState.INITIALIZED;
        }
    }

    _signals.emit('extension-state-changed', extension);
}

function unloadExtension(extension) {
    // Try to disable it -- if it's ERROR'd, we can't guarantee that,
    // but it will be removed on next reboot, and hopefully nothing
    // broke too much.
    disableExtension(extension.uuid);

    extension.state = ExtensionState.UNINSTALLED;
    _signals.emit('extension-state-changed', extension);

    delete ExtensionUtils.extensions[extension.uuid];
    return true;
}

function reloadExtension(oldExtension) {
    // Grab the things we'll need to pass to createExtensionObject
    // to reload it.
    let { uuid: uuid, dir: dir, type: type } = oldExtension;

    // Then unload the old extension.
    unloadExtension(oldExtension);

    // Now, recreate the extension and load it.
    let newExtension = ExtensionUtils.createExtensionObject(uuid, dir, type);
    loadExtension(newExtension);
}

function initExtension(uuid) {
    let extension = ExtensionUtils.extensions[uuid];
    let dir = extension.dir;

    if (!extension)
        throw new Error(""Extension was not properly created. Call loadExtension first"");

    let extensionJs = dir.get_child('extension.js');
    if (!extensionJs.query_exists(null))
        throw new Error('Missing extension.js');

    let extensionModule;
    let extensionState = null;

    ExtensionUtils.installImporter(extension);
    extensionModule = extension.imports.extension;

    if (extensionModule.init) {
        try {
            extensionState = extensionModule.init(extension);
        } catch(e) {
            logExtensionError(uuid, e);
            return false;
        }
    }

    if (!extensionState)
        extensionState = extensionModule;
    extension.stateObj = extensionState;

    extension.state = ExtensionState.DISABLED;
    _signals.emit('extension-loaded', uuid);
    return true;
}

function getEnabledExtensions() {
    let extensions;
    if (Array.isArray(Main.sessionMode.enabledExtensions))
        extensions = Main.sessionMode.enabledExtensions;
    else
        extensions = [];

    if (global.settings.get_boolean(DISABLE_USER_EXTENSIONS_KEY))
        return extensions;

    return extensions.concat(global.settings.get_strv(ENABLED_EXTENSIONS_KEY));
}

function onEnabledExtensionsChanged() {
    let newEnabledExtensions = getEnabledExtensions();

    if (!enabled)
        return;

    // Find and enable all the newly enabled extensions: UUIDs found in the
    // new setting, but not in the old one.
    newEnabledExtensions.filter(function(uuid) {
        return enabledExtensions.indexOf(uuid) == -1;
    }).forEach(function(uuid) {
        enableExtension(uuid);
    });

    // Find and disable all the newly disabled extensions: UUIDs found in the
    // old setting, but not in the new one.
    enabledExtensions.filter(function(item) {
        return newEnabledExtensions.indexOf(item) == -1;
    }).forEach(function(uuid) {
        disableExtension(uuid);
    });

    enabledExtensions = newEnabledExtensions;
}

function _onVersionValidationChanged() {
    // we want to reload all extensions, but only enable
    // extensions when allowed by the sessionMode, so
    // temporarily disable them all
    enabledExtensions = [];
    for (let uuid in ExtensionUtils.extensions)
        try {
            reloadExtension(ExtensionUtils.extensions[uuid]);
        } catch(e) {
            logExtensionError(uuid, e);
        }
    enabledExtensions = getEnabledExtensions();

    if (Main.sessionMode.allowExtensions) {
        enabledExtensions.forEach(function(uuid) {
            try {
                enableExtension(uuid);
            } catch(e) {
                logExtensionError(uuid, e);
            }
        });
    }
}

function _loadExtensions() {
    global.settings.connect('changed::' + ENABLED_EXTENSIONS_KEY, onEnabledExtensionsChanged);
    global.settings.connect('changed::' + DISABLE_USER_EXTENSIONS_KEY, onEnabledExtensionsChanged);
    global.settings.connect('changed::' + EXTENSION_DISABLE_VERSION_CHECK_KEY, _onVersionValidationChanged);

    enabledExtensions = getEnabledExtensions();

    let finder = new ExtensionUtils.ExtensionFinder();
    finder.connect('extension-found', function(finder, extension) {
        loadExtension(extension);
    });
    finder.scanExtensions();
}

function enableAllExtensions() {
    if (enabled)
        return;

    if (!initted) {
        _loadExtensions();
        initted = true;
    } else {
        enabledExtensions.forEach(function(uuid) {
            enableExtension(uuid);
        });
    }
    enabled = true;
}

function disableAllExtensions() {
    if (!enabled)
        return;

    if (initted) {
        extensionOrder.slice().reverse().forEach(function(uuid) {
            disableExtension(uuid);
        });
    }

    enabled = false;
}

function _sessionUpdated() {
    // For now sessionMode.allowExtensions controls extensions from both the
    // 'enabled-extensions' preference and the sessionMode.enabledExtensions
    // property; it might make sense to make enabledExtensions independent
    // from allowExtensions in the future
    if (Main.sessionMode.allowExtensions) {
        if (initted)
            enabledExtensions = getEnabledExtensions();
        enableAllExtensions();
    } else {
        disableAllExtensions();
    }
}

function init() {
    Main.sessionMode.connect('updated', _sessionUpdated);
    _sessionUpdated();
}
"
"'use strict';

const socketUser = require('./user');
const socketGroup = require('./groups');
const image = require('../image');
const meta = require('../meta');

const inProgress = {};

const uploads = module.exports;

uploads.upload = async function (socket, data) {
	const methodToFunc = {
		'user.uploadCroppedPicture': socketUser.uploadCroppedPicture,
		'user.updateCover': socketUser.updateCover,
		'groups.cover.update': socketGroup.cover.update,
	};
	if (!socket.uid || !data || !data.chunk || !data.params || !data.params.method || !methodToFunc[data.params.method]) {
		throw new Error('[[error:invalid-data]]');
	}

	inProgress[socket.id] = inProgress[socket.id] || {};
	const socketUploads = inProgress[socket.id];
	const { method } = data.params;

	socketUploads[method] = socketUploads[method] || { imageData: '' };
	socketUploads[method].imageData += data.chunk;

	try {
		const maxSize = data.params.method === 'user.uploadCroppedPicture' ?
			meta.config.maximumProfileImageSize : meta.config.maximumCoverImageSize;
		const size = image.sizeFromBase64(socketUploads[method].imageData);

		if (size > maxSize * 1024) {
			throw new Error(`[[error:file-too-big, ${maxSize}]]`);
		}
		if (socketUploads[method].imageData.length < data.params.size) {
			return;
		}
		data.params.imageData = socketUploads[method].imageData;
		const result = await methodToFunc[data.params.method](socket, data.params);
		delete socketUploads[method];
		return result;
	} catch (err) {
		delete inProgress[socket.id];
		throw err;
	}
};

uploads.clear = function (sid) {
	delete inProgress[sid];
};
","'use strict';

const socketUser = require('./user');
const socketGroup = require('./groups');
const image = require('../image');
const meta = require('../meta');

const inProgress = {};

const uploads = module.exports;

uploads.upload = async function (socket, data) {
	const methodToFunc = {
		'user.uploadCroppedPicture': socketUser.uploadCroppedPicture,
		'user.updateCover': socketUser.updateCover,
		'groups.cover.update': socketGroup.cover.update,
	};
	if (!socket.uid || !data || !data.chunk ||
		!data.params || !data.params.method || !methodToFunc.hasOwnProperty(data.params.method)) {
		throw new Error('[[error:invalid-data]]');
	}

	inProgress[socket.id] = inProgress[socket.id] || Object.create(null);
	const socketUploads = inProgress[socket.id];
	const { method } = data.params;

	socketUploads[method] = socketUploads[method] || { imageData: '' };
	socketUploads[method].imageData += data.chunk;

	try {
		const maxSize = data.params.method === 'user.uploadCroppedPicture' ?
			meta.config.maximumProfileImageSize : meta.config.maximumCoverImageSize;
		const size = image.sizeFromBase64(socketUploads[method].imageData);

		if (size > maxSize * 1024) {
			throw new Error(`[[error:file-too-big, ${maxSize}]]`);
		}
		if (socketUploads[method].imageData.length < data.params.size) {
			return;
		}
		data.params.imageData = socketUploads[method].imageData;
		const result = await methodToFunc[data.params.method](socket, data.params);
		delete socketUploads[method];
		return result;
	} catch (err) {
		delete inProgress[socket.id];
		throw err;
	}
};

uploads.clear = function (sid) {
	delete inProgress[sid];
};
"
"/**
 * @hello.js
 *
 * HelloJS is a client side Javascript SDK for making OAuth2 logins and subsequent REST calls.
 *
 * @author Andrew Dodson
 * @website https://adodson.com/hello.js/
 *
 * @copyright Andrew Dodson, 2012 - 2015
 * @license MIT: You are free to use and modify this code for any use, on the condition that this copyright notice remains.
 */

var hello = function(name) {
	return hello.use(name);
};

hello.utils = {

	// Extend the first object with the properties and methods of the second
	extend: function(r /*, a[, b[, ...]] */) {

		// Get the arguments as an array but ommit the initial item
		Array.prototype.slice.call(arguments, 1).forEach(function(a) {
			if (Array.isArray(r) && Array.isArray(a)) {
				Array.prototype.push.apply(r, a);
			}
			else if (r && (r instanceof Object || typeof r === 'object') && a && (a instanceof Object || typeof a === 'object') && r !== a) {
				for (var x in a) {
					r[x] = hello.utils.extend(r[x], a[x]);
				}
			}
			else {

				if (Array.isArray(a)) {
					// Clone it
					a = a.slice(0);
				}

				r = a;
			}
		});

		return r;
	}
};

// Core library
hello.utils.extend(hello, {

	settings: {

		// OAuth2 authentication defaults
		redirect_uri: window.location.href.split('#')[0],
		response_type: 'token',
		display: 'popup',
		state: '',

		// OAuth1 shim
		// The path to the OAuth1 server for signing user requests
		// Want to recreate your own? Checkout https://github.com/MrSwitch/node-oauth-shim
		oauth_proxy: 'https://auth-server.herokuapp.com/proxy',

		// API timeout in milliseconds
		timeout: 20000,

		// Popup Options
		popup: {
			resizable: 1,
			scrollbars: 1,
			width: 500,
			height: 550
		},

		// Default scope
		// Many services require atleast a profile scope,
		// HelloJS automatially includes the value of provider.scope_map.basic
		// If that's not required it can be removed via hello.settings.scope.length = 0;
		scope: ['basic'],

		// Scope Maps
		// This is the default module scope, these are the defaults which each service is mapped too.
		// By including them here it prevents the scope from being applied accidentally
		scope_map: {
			basic: ''
		},

		// Default service / network
		default_service: null,

		// Force authentication
		// When hello.login is fired.
		// (null): ignore current session expiry and continue with login
		// (true): ignore current session expiry and continue with login, ask for user to reauthenticate
		// (false): if the current session looks good for the request scopes return the current session.
		force: null,

		// Page URL
		// When 'display=page' this property defines where the users page should end up after redirect_uri
		// Ths could be problematic if the redirect_uri is indeed the final place,
		// Typically this circumvents the problem of the redirect_url being a dumb relay page.
		page_uri: window.location.href
	},

	// Service configuration objects
	services: {},

	// Use
	// Define a new instance of the HelloJS library with a default service
	use: function(service) {

		// Create self, which inherits from its parent
		var self = Object.create(this);

		// Inherit the prototype from its parent
		self.settings = Object.create(this.settings);

		// Define the default service
		if (service) {
			self.settings.default_service = service;
		}

		// Create an instance of Events
		self.utils.Event.call(self);

		return self;
	},

	// Initialize
	// Define the client_ids for the endpoint services
	// @param object o, contains a key value pair, service => clientId
	// @param object opts, contains a key value pair of options used for defining the authentication defaults
	// @param number timeout, timeout in seconds
	init: function(services, options) {

		var utils = this.utils;

		if (!services) {
			return this.services;
		}

		// Define provider credentials
		// Reformat the ID field
		for (var x in services) {if (services.hasOwnProperty(x)) {
			if (typeof (services[x]) !== 'object') {
				services[x] = {id: services[x]};
			}
		}}

		// Merge services if there already exists some
		utils.extend(this.services, services);

		// Update the default settings with this one.
		if (options) {
			utils.extend(this.settings, options);

			// Do this immediatly incase the browser changes the current path.
			if ('redirect_uri' in options) {
				this.settings.redirect_uri = utils.url(options.redirect_uri).href;
			}
		}

		return this;
	},

	// Login
	// Using the endpoint
	// @param network stringify       name to connect to
	// @param options object    (optional)  {display mode, is either none|popup(default)|page, scope: email,birthday,publish, .. }
	// @param callback  function  (optional)  fired on signin
	login: function() {

		// Create an object which inherits its parent as the prototype and constructs a new event chain.
		var _this = this;
		var utils = _this.utils;
		var error = utils.error;
		var promise = utils.Promise();

		// Get parameters
		var p = utils.args({network: 's', options: 'o', callback: 'f'}, arguments);

		// Local vars
		var url;

		// Get all the custom options and store to be appended to the querystring
		var qs = utils.diffKey(p.options, _this.settings);

		// Merge/override options with app defaults
		var opts = p.options = utils.merge(_this.settings, p.options || {});

		// Merge/override options with app defaults
		opts.popup = utils.merge(_this.settings.popup, p.options.popup || {});

		// Network
		p.network = p.network || _this.settings.default_service;

		// Bind callback to both reject and fulfill states
		promise.proxy.then(p.callback, p.callback);

		// Trigger an event on the global listener
		function emit(s, value) {
			hello.emit(s, value);
		}

		promise.proxy.then(emit.bind(this, 'auth.login auth'), emit.bind(this, 'auth.failed auth'));

		// Is our service valid?
		if (typeof (p.network) !== 'string' || !(p.network in _this.services)) {
			// Trigger the default login.
			// Ahh we dont have one.
			return promise.reject(error('invalid_network', 'The provided network was not recognized'));
		}

		var provider = _this.services[p.network];

		// Create a global listener to capture events triggered out of scope
		var callbackId = utils.globalEvent(function(obj) {

			// The responseHandler returns a string, lets save this locally
			if (obj) {
				if (typeof (obj) == 'string') {
					obj = JSON.parse(obj);
				}
			}
			else {
				obj = error('cancelled', 'The authentication was not completed');
			}

			// Handle these response using the local
			// Trigger on the parent
			if (!obj.error) {

				// Save on the parent window the new credentials
				// This fixes an IE10 bug i think... atleast it does for me.
				utils.store(obj.network, obj);

				// Fulfill a successful login
				promise.fulfill({
					network: obj.network,
					authResponse: obj
				});
			}
			else {
				// Reject a successful login
				promise.reject(obj);
			}
		});

		var redirectUri = utils.url(opts.redirect_uri).href;

		// May be a space-delimited list of multiple, complementary types
		var responseType = provider.oauth.response_type || opts.response_type;

		// Fallback to token if the module hasn't defined a grant url
		if (/\bcode\b/.test(responseType) && !provider.oauth.grant) {
			responseType = responseType.replace(/\bcode\b/, 'token');
		}

		// Query string parameters, we may pass our own arguments to form the querystring
		p.qs = utils.merge(qs, {
			client_id: encodeURIComponent(provider.id),
			response_type: encodeURIComponent(responseType),
			redirect_uri: encodeURIComponent(redirectUri),
			state: {
				client_id: provider.id,
				network: p.network,
				display: opts.display,
				callback: callbackId,
				state: opts.state,
				redirect_uri: redirectUri
			}
		});

		// Get current session for merging scopes, and for quick auth response
		var session = utils.store(p.network);

		// Scopes (authentication permisions)
		// Ensure this is a string - IE has a problem moving Arrays between windows
		// Append the setup scope
		var SCOPE_SPLIT = /[,\s]+/;

		// Include default scope settings (cloned).
		var scope = _this.settings.scope ? [_this.settings.scope.toString()] : [];

		// Extend the providers scope list with the default
		var scopeMap = utils.merge(_this.settings.scope_map, provider.scope || {});

		// Add user defined scopes...
		if (opts.scope) {
			scope.push(opts.scope.toString());
		}

		// Append scopes from a previous session.
		// This helps keep app credentials constant,
		// Avoiding having to keep tabs on what scopes are authorized
		if (session && 'scope' in session && session.scope instanceof String) {
			scope.push(session.scope);
		}

		// Join and Split again
		scope = scope.join(',').split(SCOPE_SPLIT);

		// Format remove duplicates and empty values
		scope = utils.unique(scope).filter(filterEmpty);

		// Save the the scopes to the state with the names that they were requested with.
		p.qs.state.scope = scope.join(',');

		// Map scopes to the providers naming convention
		scope = scope.map(function(item) {
			// Does this have a mapping?
			return (item in scopeMap) ? scopeMap[item] : item;
		});

		// Stringify and Arrayify so that double mapped scopes are given the chance to be formatted
		scope = scope.join(',').split(SCOPE_SPLIT);

		// Again...
		// Format remove duplicates and empty values
		scope = utils.unique(scope).filter(filterEmpty);

		// Join with the expected scope delimiter into a string
		p.qs.scope = scope.join(provider.scope_delim || ',');

		// Is the user already signed in with the appropriate scopes, valid access_token?
		if (opts.force === false) {

			if (session && 'access_token' in session && session.access_token && 'expires' in session && session.expires > ((new Date()).getTime() / 1e3)) {
				// What is different about the scopes in the session vs the scopes in the new login?
				var diff = utils.diff((session.scope || '').split(SCOPE_SPLIT), (p.qs.state.scope || '').split(SCOPE_SPLIT));
				if (diff.length === 0) {

					// OK trigger the callback
					promise.fulfill({
						unchanged: true,
						network: p.network,
						authResponse: session
					});

					// Nothing has changed
					return promise;
				}
			}
		}

		// Page URL
		if (opts.display === 'page' && opts.page_uri) {
			// Add a page location, place to endup after session has authenticated
			p.qs.state.page_uri = utils.url(opts.page_uri).href;
		}

		// Bespoke
		// Override login querystrings from auth_options
		if ('login' in provider && typeof (provider.login) === 'function') {
			// Format the paramaters according to the providers formatting function
			provider.login(p);
		}

		// Add OAuth to state
		// Where the service is going to take advantage of the oauth_proxy
		if (!/\btoken\b/.test(responseType) ||
		parseInt(provider.oauth.version, 10) < 2 ||
		(opts.display === 'none' && provider.oauth.grant && session && session.refresh_token)) {

			// Add the oauth endpoints
			p.qs.state.oauth = provider.oauth;

			// Add the proxy url
			p.qs.state.oauth_proxy = opts.oauth_proxy;

		}

		// Convert state to a string
		p.qs.state = encodeURIComponent(JSON.stringify(p.qs.state));

		// URL
		if (parseInt(provider.oauth.version, 10) === 1) {

			// Turn the request to the OAuth Proxy for 3-legged auth
			url = utils.qs(opts.oauth_proxy, p.qs, encodeFunction);
		}

		// Refresh token
		else if (opts.display === 'none' && provider.oauth.grant && session && session.refresh_token) {

			// Add the refresh_token to the request
			p.qs.refresh_token = session.refresh_token;

			// Define the request path
			url = utils.qs(opts.oauth_proxy, p.qs, encodeFunction);
		}
		else {
			url = utils.qs(provider.oauth.auth, p.qs, encodeFunction);
		}

		// Broadcast this event as an auth:init
		emit('auth.init', p);

		// Execute
		// Trigger how we want self displayed
		if (opts.display === 'none') {
			// Sign-in in the background, iframe
			utils.iframe(url, redirectUri);
		}

		// Triggering popup?
		else if (opts.display === 'popup') {

			var popup = utils.popup(url, redirectUri, opts.popup);

			var timer = setInterval(function() {
				if (!popup || popup.closed) {
					clearInterval(timer);
					if (!promise.state) {

						var response = error('cancelled', 'Login has been cancelled');

						if (!popup) {
							response = error('blocked', 'Popup was blocked');
						}

						response.network = p.network;

						promise.reject(response);
					}
				}
			}, 100);
		}

		else {
			window.location = url;
		}

		return promise.proxy;

		function encodeFunction(s) {return s;}

		function filterEmpty(s) {return !!s;}
	},

	// Remove any data associated with a given service
	// @param string name of the service
	// @param function callback
	logout: function() {

		var _this = this;
		var utils = _this.utils;
		var error = utils.error;

		// Create a new promise
		var promise = utils.Promise();

		var p = utils.args({name:'s', options: 'o', callback: 'f'}, arguments);

		p.options = p.options || {};

		// Add callback to events
		promise.proxy.then(p.callback, p.callback);

		// Trigger an event on the global listener
		function emit(s, value) {
			hello.emit(s, value);
		}

		promise.proxy.then(emit.bind(this, 'auth.logout auth'), emit.bind(this, 'error'));

		// Network
		p.name = p.name || this.settings.default_service;
		p.authResponse = utils.store(p.name);

		if (p.name && !(p.name in _this.services)) {

			promise.reject(error('invalid_network', 'The network was unrecognized'));

		}
		else if (p.name && p.authResponse) {

			// Define the callback
			var callback = function(opts) {

				// Remove from the store
				utils.store(p.name, null);

				// Emit events by default
				promise.fulfill(hello.utils.merge({network:p.name}, opts || {}));
			};

			// Run an async operation to remove the users session
			var _opts = {};
			if (p.options.force) {
				var logout = _this.services[p.name].logout;
				if (logout) {
					// Convert logout to URL string,
					// If no string is returned, then this function will handle the logout async style
					if (typeof (logout) === 'function') {
						logout = logout(callback, p);
					}

					// If logout is a string then assume URL and open in iframe.
					if (typeof (logout) === 'string') {
						utils.iframe(logout);
						_opts.force = null;
						_opts.message = 'Logout success on providers site was indeterminate';
					}
					else if (logout === undefined) {
						// The callback function will handle the response.
						return promise.proxy;
					}
				}
			}

			// Remove local credentials
			callback(_opts);
		}
		else {
			promise.reject(error('invalid_session', 'There was no session to remove'));
		}

		return promise.proxy;
	},

	// Returns all the sessions that are subscribed too
	// @param string optional, name of the service to get information about.
	getAuthResponse: function(service) {

		// If the service doesn't exist
		service = service || this.settings.default_service;

		if (!service || !(service in this.services)) {
			return null;
		}

		return this.utils.store(service) || null;
	},

	// Events: placeholder for the events
	events: {}
});

// Core utilities
hello.utils.extend(hello.utils, {

	// Error
	error: function(code, message) {
		return {
			error: {
				code: code,
				message: message
			}
		};
	},

	// Append the querystring to a url
	// @param string url
	// @param object parameters
	qs: function(url, params, formatFunction) {

		if (params) {

			// Set default formatting function
			formatFunction = formatFunction || encodeURIComponent;

			// Override the items in the URL which already exist
			for (var x in params) {
				var str = '([\\?\\&])' + x + '=[^\\&]*';
				var reg = new RegExp(str);
				if (url.match(reg)) {
					url = url.replace(reg, '$1' + x + '=' + formatFunction(params[x]));
					delete params[x];
				}
			}
		}

		if (!this.isEmpty(params)) {
			return url + (url.indexOf('?') > -1 ? '&' : '?') + this.param(params, formatFunction);
		}

		return url;
	},

	// Param
	// Explode/encode the parameters of an URL string/object
	// @param string s, string to decode
	param: function(s, formatFunction) {
		var b;
		var a = {};
		var m;

		if (typeof (s) === 'string') {

			formatFunction = formatFunction || decodeURIComponent;

			m = s.replace(/^[\#\?]/, '').match(/([^=\/\&]+)=([^\&]+)/g);
			if (m) {
				for (var i = 0; i < m.length; i++) {
					b = m[i].match(/([^=]+)=(.*)/);
					a[b[1]] = formatFunction(b[2]);
				}
			}

			return a;
		}
		else {

			formatFunction = formatFunction || encodeURIComponent;

			var o = s;

			a = [];

			for (var x in o) {if (o.hasOwnProperty(x)) {
				if (o.hasOwnProperty(x)) {
					a.push([x, o[x] === '?' ? '?' : formatFunction(o[x])].join('='));
				}
			}}

			return a.join('&');
		}
	},

	// Local storage facade
	store: (function() {

		var a = ['localStorage', 'sessionStorage'];
		var i = -1;
		var prefix = 'test';

		// Set LocalStorage
		var localStorage;

		while (a[++i]) {
			try {
				// In Chrome with cookies blocked, calling localStorage throws an error
				localStorage = window[a[i]];
				localStorage.setItem(prefix + i, i);
				localStorage.removeItem(prefix + i);
				break;
			}
			catch (e) {
				localStorage = null;
			}
		}

		if (!localStorage) {

			var cache = null;

			localStorage = {
				getItem: function(prop) {
					prop = prop + '=';
					var m = document.cookie.split(';');
					for (var i = 0; i < m.length; i++) {
						var _m = m[i].replace(/(^\s+|\s+$)/, '');
						if (_m && _m.indexOf(prop) === 0) {
							return _m.substr(prop.length);
						}
					}

					return cache;
				},

				setItem: function(prop, value) {
					cache = value;
					document.cookie = prop + '=' + value;
				}
			};

			// Fill the cache up
			cache = localStorage.getItem('hello');
		}

		function get() {
			var json = {};
			try {
				json = JSON.parse(localStorage.getItem('hello')) || {};
			}
			catch (e) {}

			return json;
		}

		function set(json) {
			localStorage.setItem('hello', JSON.stringify(json));
		}

		// Check if the browser support local storage
		return function(name, value, days) {

			// Local storage
			var json = get();

			if (name && value === undefined) {
				return json[name] || null;
			}
			else if (name && value === null) {
				try {
					delete json[name];
				}
				catch (e) {
					json[name] = null;
				}
			}
			else if (name) {
				json[name] = value;
			}
			else {
				return json;
			}

			set(json);

			return json || null;
		};

	})(),

	// Create and Append new DOM elements
	// @param node string
	// @param attr object literal
	// @param dom/string
	append: function(node, attr, target) {

		var n = typeof (node) === 'string' ? document.createElement(node) : node;

		if (typeof (attr) === 'object') {
			if ('tagName' in attr) {
				target = attr;
			}
			else {
				for (var x in attr) {if (attr.hasOwnProperty(x)) {
					if (typeof (attr[x]) === 'object') {
						for (var y in attr[x]) {if (attr[x].hasOwnProperty(y)) {
							n[x][y] = attr[x][y];
						}}
					}
					else if (x === 'html') {
						n.innerHTML = attr[x];
					}

					// IE doesn't like us setting methods with setAttribute
					else if (!/^on/.test(x)) {
						n.setAttribute(x, attr[x]);
					}
					else {
						n[x] = attr[x];
					}
				}}
			}
		}

		if (target === 'body') {
			(function self() {
				if (document.body) {
					document.body.appendChild(n);
				}
				else {
					setTimeout(self, 16);
				}
			})();
		}
		else if (typeof (target) === 'object') {
			target.appendChild(n);
		}
		else if (typeof (target) === 'string') {
			document.getElementsByTagName(target)[0].appendChild(n);
		}

		return n;
	},

	// An easy way to create a hidden iframe
	// @param string src
	iframe: function(src) {
		this.append('iframe', {src: src, style: {position:'absolute', left: '-1000px', bottom: 0, height: '1px', width: '1px'}}, 'body');
	},

	// Recursive merge two objects into one, second parameter overides the first
	// @param a array
	merge: function(/* Args: a, b, c, .. n */) {
		var args = Array.prototype.slice.call(arguments);
		args.unshift({});
		return this.extend.apply(null, args);
	},

	// Makes it easier to assign parameters, where some are optional
	// @param o object
	// @param a arguments
	args: function(o, args) {

		var p = {};
		var i = 0;
		var t = null;
		var x = null;

		// 'x' is the first key in the list of object parameters
		for (x in o) {if (o.hasOwnProperty(x)) {
			break;
		}}

		// Passing in hash object of arguments?
		// Where the first argument can't be an object
		if ((args.length === 1) && (typeof (args[0]) === 'object') && o[x] != 'o!') {

			// Could this object still belong to a property?
			// Check the object keys if they match any of the property keys
			for (x in args[0]) {if (o.hasOwnProperty(x)) {
				// Does this key exist in the property list?
				if (x in o) {
					// Yes this key does exist so its most likely this function has been invoked with an object parameter
					// Return first argument as the hash of all arguments
					return args[0];
				}
			}}
		}

		// Else loop through and account for the missing ones.
		for (x in o) {if (o.hasOwnProperty(x)) {

			t = typeof (args[i]);

			if ((typeof (o[x]) === 'function' && o[x].test(args[i])) || (typeof (o[x]) === 'string' && (
			(o[x].indexOf('s') > -1 && t === 'string') ||
			(o[x].indexOf('o') > -1 && t === 'object') ||
			(o[x].indexOf('i') > -1 && t === 'number') ||
			(o[x].indexOf('a') > -1 && t === 'object') ||
			(o[x].indexOf('f') > -1 && t === 'function')
			))
			) {
				p[x] = args[i++];
			}

			else if (typeof (o[x]) === 'string' && o[x].indexOf('!') > -1) {
				return false;
			}
		}}

		return p;
	},

	// Returns a URL instance
	url: function(path) {

		// If the path is empty
		if (!path) {
			return window.location;
		}

		// Chrome and FireFox support new URL() to extract URL objects
		else if (window.URL && URL instanceof Function && URL.length !== 0) {
			return new URL(path, window.location);
		}

		// Ugly shim, it works!
		else {
			var a = document.createElement('a');
			a.href = path;
			return a.cloneNode(false);
		}
	},

	diff: function(a, b) {
		return b.filter(function(item) {
			return a.indexOf(item) === -1;
		});
	},

	// Get the different hash of properties unique to `a`, and not in `b`
	diffKey: function(a, b) {
		if (a || !b) {
			var r = {};
			for (var x in a) {
				// Does the property not exist?
				if (!(x in b)) {
					r[x] = a[x];
				}
			}

			return r;
		}

		return a;
	},

	// Unique
	// Remove duplicate and null values from an array
	// @param a array
	unique: function(a) {
		if (!Array.isArray(a)) { return []; }

		return a.filter(function(item, index) {
			// Is this the first location of item
			return a.indexOf(item) === index;
		});
	},

	isEmpty: function(obj) {

		// Scalar
		if (!obj)
			return true;

		// Array
		if (Array.isArray(obj)) {
			return !obj.length;
		}
		else if (typeof (obj) === 'object') {
			// Object
			for (var key in obj) {
				if (obj.hasOwnProperty(key)) {
					return false;
				}
			}
		}

		return true;
	},

	//jscs:disable

	/*!
	 **  Thenable -- Embeddable Minimum Strictly-Compliant Promises/A+ 1.1.1 Thenable
	 **  Copyright (c) 2013-2014 Ralf S. Engelschall <http://engelschall.com>
	 **  Licensed under The MIT License <http://opensource.org/licenses/MIT>
	 **  Source-Code distributed on <http://github.com/rse/thenable>
	 */
	Promise: (function(){
		/*  promise states [Promises/A+ 2.1]  */
		var STATE_PENDING   = 0;                                         /*  [Promises/A+ 2.1.1]  */
		var STATE_FULFILLED = 1;                                         /*  [Promises/A+ 2.1.2]  */
		var STATE_REJECTED  = 2;                                         /*  [Promises/A+ 2.1.3]  */

		/*  promise object constructor  */
		var api = function (executor) {
			/*  optionally support non-constructor/plain-function call  */
			if (!(this instanceof api))
				return new api(executor);

			/*  initialize object  */
			this.id           = ""Thenable/1.0.6"";
			this.state        = STATE_PENDING; /*  initial state  */
			this.fulfillValue = undefined;     /*  initial value  */     /*  [Promises/A+ 1.3, 2.1.2.2]  */
			this.rejectReason = undefined;     /*  initial reason */     /*  [Promises/A+ 1.5, 2.1.3.2]  */
			this.onFulfilled  = [];            /*  initial handlers  */
			this.onRejected   = [];            /*  initial handlers  */

			/*  provide optional information-hiding proxy  */
			this.proxy = {
				then: this.then.bind(this)
			};

			/*  support optional executor function  */
			if (typeof executor === ""function"")
				executor.call(this, this.fulfill.bind(this), this.reject.bind(this));
		};

		/*  promise API methods  */
		api.prototype = {
			/*  promise resolving methods  */
			fulfill: function (value) { return deliver(this, STATE_FULFILLED, ""fulfillValue"", value); },
			reject:  function (value) { return deliver(this, STATE_REJECTED,  ""rejectReason"", value); },

			/*  ""The then Method"" [Promises/A+ 1.1, 1.2, 2.2]  */
			then: function (onFulfilled, onRejected) {
				var curr = this;
				var next = new api();                                    /*  [Promises/A+ 2.2.7]  */
				curr.onFulfilled.push(
					resolver(onFulfilled, next, ""fulfill""));             /*  [Promises/A+ 2.2.2/2.2.6]  */
				curr.onRejected.push(
					resolver(onRejected,  next, ""reject"" ));             /*  [Promises/A+ 2.2.3/2.2.6]  */
				execute(curr);
				return next.proxy;                                       /*  [Promises/A+ 2.2.7, 3.3]  */
			}
		};

		/*  deliver an action  */
		var deliver = function (curr, state, name, value) {
			if (curr.state === STATE_PENDING) {
				curr.state = state;                                      /*  [Promises/A+ 2.1.2.1, 2.1.3.1]  */
				curr[name] = value;                                      /*  [Promises/A+ 2.1.2.2, 2.1.3.2]  */
				execute(curr);
			}
			return curr;
		};

		/*  execute all handlers  */
		var execute = function (curr) {
			if (curr.state === STATE_FULFILLED)
				execute_handlers(curr, ""onFulfilled"", curr.fulfillValue);
			else if (curr.state === STATE_REJECTED)
				execute_handlers(curr, ""onRejected"",  curr.rejectReason);
		};

		/*  execute particular set of handlers  */
		var execute_handlers = function (curr, name, value) {
			/* global process: true */
			/* global setImmediate: true */
			/* global setTimeout: true */

			/*  short-circuit processing  */
			if (curr[name].length === 0)
				return;

			/*  iterate over all handlers, exactly once  */
			var handlers = curr[name];
			curr[name] = [];                                             /*  [Promises/A+ 2.2.2.3, 2.2.3.3]  */
			var func = function () {
				for (var i = 0; i < handlers.length; i++)
					handlers[i](value);                                  /*  [Promises/A+ 2.2.5]  */
			};

			/*  execute procedure asynchronously  */                     /*  [Promises/A+ 2.2.4, 3.1]  */
			if (typeof process === ""object"" && typeof process.nextTick === ""function"")
				process.nextTick(func);
			else if (typeof setImmediate === ""function"")
				setImmediate(func);
			else
				setTimeout(func, 0);
		};

		/*  generate a resolver function  */
		var resolver = function (cb, next, method) {
			return function (value) {
				if (typeof cb !== ""function"")                            /*  [Promises/A+ 2.2.1, 2.2.7.3, 2.2.7.4]  */
					next[method].call(next, value);                      /*  [Promises/A+ 2.2.7.3, 2.2.7.4]  */
				else {
					var result;
					try { result = cb(value); }                          /*  [Promises/A+ 2.2.2.1, 2.2.3.1, 2.2.5, 3.2]  */
					catch (e) {
						next.reject(e);                                  /*  [Promises/A+ 2.2.7.2]  */
						return;
					}
					resolve(next, result);                               /*  [Promises/A+ 2.2.7.1]  */
				}
			};
		};

		/*  ""Promise Resolution Procedure""  */                           /*  [Promises/A+ 2.3]  */
		var resolve = function (promise, x) {
			/*  sanity check arguments  */                               /*  [Promises/A+ 2.3.1]  */
			if (promise === x || promise.proxy === x) {
				promise.reject(new TypeError(""cannot resolve promise with itself""));
				return;
			}

			/*  surgically check for a ""then"" method
				(mainly to just call the ""getter"" of ""then"" only once)  */
			var then;
			if ((typeof x === ""object"" && x !== null) || typeof x === ""function"") {
				try { then = x.then; }                                   /*  [Promises/A+ 2.3.3.1, 3.5]  */
				catch (e) {
					promise.reject(e);                                   /*  [Promises/A+ 2.3.3.2]  */
					return;
				}
			}

			/*  handle own Thenables    [Promises/A+ 2.3.2]
				and similar ""thenables"" [Promises/A+ 2.3.3]  */
			if (typeof then === ""function"") {
				var resolved = false;
				try {
					/*  call retrieved ""then"" method */                  /*  [Promises/A+ 2.3.3.3]  */
					then.call(x,
						/*  resolvePromise  */                           /*  [Promises/A+ 2.3.3.3.1]  */
						function (y) {
							if (resolved) return; resolved = true;       /*  [Promises/A+ 2.3.3.3.3]  */
							if (y === x)                                 /*  [Promises/A+ 3.6]  */
								promise.reject(new TypeError(""circular thenable chain""));
							else
								resolve(promise, y);
						},

						/*  rejectPromise  */                            /*  [Promises/A+ 2.3.3.3.2]  */
						function (r) {
							if (resolved) return; resolved = true;       /*  [Promises/A+ 2.3.3.3.3]  */
							promise.reject(r);
						}
					);
				}
				catch (e) {
					if (!resolved)                                       /*  [Promises/A+ 2.3.3.3.3]  */
						promise.reject(e);                               /*  [Promises/A+ 2.3.3.3.4]  */
				}
				return;
			}

			/*  handle other values  */
			promise.fulfill(x);                                          /*  [Promises/A+ 2.3.4, 2.3.3.4]  */
		};

		/*  export API  */
		return api;
	})(),

	//jscs:enable

	// Event
	// A contructor superclass for adding event menthods, on, off, emit.
	Event: function() {

		var separator = /[\s\,]+/;

		// If this doesn't support getPrototype then we can't get prototype.events of the parent
		// So lets get the current instance events, and add those to a parent property
		this.parent = {
			events: this.events,
			findEvents: this.findEvents,
			parent: this.parent,
			utils: this.utils
		};

		this.events = {};

		// On, subscribe to events
		// @param evt   string
		// @param callback  function
		this.on = function(evt, callback) {

			if (callback && typeof (callback) === 'function') {
				var a = evt.split(separator);
				for (var i = 0; i < a.length; i++) {

					// Has this event already been fired on this instance?
					this.events[a[i]] = [callback].concat(this.events[a[i]] || []);
				}
			}

			return this;
		};

		// Off, unsubscribe to events
		// @param evt   string
		// @param callback  function
		this.off = function(evt, callback) {

			this.findEvents(evt, function(name, index) {
				if (!callback || this.events[name][index] === callback) {
					this.events[name][index] = null;
				}
			});

			return this;
		};

		// Emit
		// Triggers any subscribed events
		this.emit = function(evt /*, data, ... */) {

			// Get arguments as an Array, knock off the first one
			var args = Array.prototype.slice.call(arguments, 1);
			args.push(evt);

			// Handler
			var handler = function(name, index) {

				// Replace the last property with the event name
				args[args.length - 1] = (name === '*' ? evt : name);

				// Trigger
				this.events[name][index].apply(this, args);
			};

			// Find the callbacks which match the condition and call
			var _this = this;
			while (_this && _this.findEvents) {

				// Find events which match
				_this.findEvents(evt + ',*', handler);
				_this = _this.parent;
			}

			return this;
		};

		//
		// Easy functions
		this.emitAfter = function() {
			var _this = this;
			var args = arguments;
			setTimeout(function() {
				_this.emit.apply(_this, args);
			}, 0);

			return this;
		};

		this.findEvents = function(evt, callback) {

			var a = evt.split(separator);

			for (var name in this.events) {if (this.events.hasOwnProperty(name)) {

				if (a.indexOf(name) > -1) {

					for (var i = 0; i < this.events[name].length; i++) {

						// Does the event handler exist?
						if (this.events[name][i]) {
							// Emit on the local instance of this
							callback.call(this, name, i);
						}
					}
				}
			}}
		};

		return this;
	},

	// Global Events
	// Attach the callback to the window object
	// Return its unique reference
	globalEvent: function(callback, guid) {
		// If the guid has not been supplied then create a new one.
		guid = guid || '_hellojs_' + parseInt(Math.random() * 1e12, 10).toString(36);

		// Define the callback function
		window[guid] = function() {
			// Trigger the callback
			try {
				if (callback.apply(this, arguments)) {
					delete window[guid];
				}
			}
			catch (e) {
				console.error(e);
			}
		};

		return guid;
	},

	// Trigger a clientside popup
	// This has been augmented to support PhoneGap
	popup: function(url, redirectUri, options) {

		var documentElement = document.documentElement;

		// Multi Screen Popup Positioning (http://stackoverflow.com/a/16861050)
		// Credit: http://www.xtf.dk/2011/08/center-new-popup-window-even-on.html
		// Fixes dual-screen position                         Most browsers      Firefox

		if (options.height && options.top === undefined) {
			var dualScreenTop = window.screenTop !== undefined ? window.screenTop : screen.top;
			var height = screen.height || window.innerHeight || documentElement.clientHeight;
			options.top = parseInt((height - options.height) / 2, 10) + dualScreenTop;
		}

		if (options.width && options.left === undefined) {
			var dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : screen.left;
			var width = screen.width || window.innerWidth || documentElement.clientWidth;
			options.left = parseInt((width - options.width) / 2, 10) + dualScreenLeft;
		}

		// Convert options into an array
		var optionsArray = [];
		Object.keys(options).forEach(function(name) {
			var value = options[name];
			optionsArray.push(name + (value !== null ? '=' + value : ''));
		});

		// Call the open() function with the initial path
		//
		// OAuth redirect, fixes URI fragments from being lost in Safari
		// (URI Fragments within 302 Location URI are lost over HTTPS)
		// Loading the redirect.html before triggering the OAuth Flow seems to fix it.
		//
		// Firefox  decodes URL fragments when calling location.hash.
		//  - This is bad if the value contains break points which are escaped
		//  - Hence the url must be encoded twice as it contains breakpoints.
		if (navigator.userAgent.indexOf('Safari') !== -1 && navigator.userAgent.indexOf('Chrome') === -1) {
			url = redirectUri + '#oauth_redirect=' + encodeURIComponent(encodeURIComponent(url));
		}

		var popup = window.open(
			url,
			'_blank',
			optionsArray.join(',')
		);

		if (popup && popup.focus) {
			popup.focus();
		}

		return popup;
	},

	// OAuth and API response handler
	responseHandler: function(window, parent) {

		var _this = this;
		var p;
		var location = window.location;

		// Is this an auth relay message which needs to call the proxy?
		p = _this.param(location.search);

		// OAuth2 or OAuth1 server response?
		if (p && p.state && (p.code || p.oauth_token)) {

			var state = JSON.parse(p.state);

			// Add this path as the redirect_uri
			p.redirect_uri = state.redirect_uri || location.href.replace(/[\?\#].*$/, '');

			// Redirect to the host
			var path = _this.qs(state.oauth_proxy, p);

			location.assign(path);

			return;
		}

		// Save session, from redirected authentication
		// #access_token has come in?
		//
		// FACEBOOK is returning auth errors within as a query_string... thats a stickler for consistency.
		// SoundCloud is the state in the querystring and the token in the hashtag, so we'll mix the two together

		p = _this.merge(_this.param(location.search || ''), _this.param(location.hash || ''));

		// If p.state
		if (p && 'state' in p) {

			// Remove any addition information
			// E.g. p.state = 'facebook.page';
			try {
				var a = JSON.parse(p.state);
				_this.extend(p, a);
			}
			catch (e) {
				var stateDecoded = decodeURIComponent(p.state);
				try {
					var b = JSON.parse(stateDecoded);
					_this.extend(p, b);
				}
				catch (e) {
					console.error('Could not decode state parameter');
				}
			}

			// Access_token?
			if (('access_token' in p && p.access_token) && p.network) {

				if (!p.expires_in || parseInt(p.expires_in, 10) === 0) {
					// If p.expires_in is unset, set to 0
					p.expires_in = 0;
				}

				p.expires_in = parseInt(p.expires_in, 10);
				p.expires = ((new Date()).getTime() / 1e3) + (p.expires_in || (60 * 60 * 24 * 365));

				// Lets use the ""state"" to assign it to one of our networks
				authCallback(p, window, parent);
			}

			// Error=?
			// &error_description=?
			// &state=?
			else if (('error' in p && p.error) && p.network) {

				p.error = {
					code: p.error,
					message: p.error_message || p.error_description
				};

				// Let the state handler handle it
				authCallback(p, window, parent);
			}

			// API call, or a cancelled login
			// Result is serialized JSON string
			else if (p.callback && p.callback in parent) {

				// Trigger a function in the parent
				var res = 'result' in p && p.result ? JSON.parse(p.result) : false;

				// Trigger the callback on the parent
				callback(parent, p.callback)(res);
				closeWindow();
			}

			// If this page is still open
			if (p.page_uri && isValidUrl(p.page_uri)) {
				location.assign(p.page_uri);
			}
		}

		// OAuth redirect, fixes URI fragments from being lost in Safari
		// (URI Fragments within 302 Location URI are lost over HTTPS)
		// Loading the redirect.html before triggering the OAuth Flow seems to fix it.
		else if ('oauth_redirect' in p) {

			location.assign(decodeURIComponent(p.oauth_redirect));
			return;
		}

		function isValidUrl(url) {
			var regexp = /^https?:/;
			return regexp.test(url);
		}

		// Trigger a callback to authenticate
		function authCallback(obj, window, parent) {

			var cb = obj.callback;
			var network = obj.network;

			// Trigger the callback on the parent
			_this.store(network, obj);

			// If this is a page request it has no parent or opener window to handle callbacks
			if (('display' in obj) && obj.display === 'page') {
				return;
			}

			// Remove from session object
			if (parent && cb && cb in parent) {

				try {
					delete obj.callback;
				}
				catch (e) {}

				// Update store
				_this.store(network, obj);

				// Call the globalEvent function on the parent
				// It's safer to pass back a string to the parent,
				// Rather than an object/array (better for IE8)
				var str = JSON.stringify(obj);

				try {
					callback(parent, cb)(str);
				}
				catch (e) {
					// Error thrown whilst executing parent callback
				}
			}

			closeWindow();
		}

		function callback(parent, callbackID) {
			if (callbackID.indexOf('_hellojs_') !== 0) {
				return function() {
					throw 'Could not execute callback ' + callbackID;
				};
			}

			return parent[callbackID];
		}

		function closeWindow() {

			if (window.frameElement) {
				// Inside an iframe, remove from parent
				parent.document.body.removeChild(window.frameElement);
			}
			else {
				// Close this current window
				try {
					window.close();
				}
				catch (e) {}

				// IOS bug wont let us close a popup if still loading
				if (window.addEventListener) {
					window.addEventListener('load', function() {
						window.close();
					});
				}
			}

		}
	}
});

// Events
// Extend the hello object with its own event instance
hello.utils.Event.call(hello);

///////////////////////////////////
// Monitoring session state
// Check for session changes
///////////////////////////////////

(function(hello) {

	// Monitor for a change in state and fire
	var oldSessions = {};

	// Hash of expired tokens
	var expired = {};

	// Listen to other triggers to Auth events, use these to update this
	hello.on('auth.login, auth.logout', function(auth) {
		if (auth && typeof (auth) === 'object' && auth.network) {
			oldSessions[auth.network] = hello.utils.store(auth.network) || {};
		}
	});

	(function self() {

		var CURRENT_TIME = ((new Date()).getTime() / 1e3);
		var emit = function(eventName) {
			hello.emit('auth.' + eventName, {
				network: name,
				authResponse: session
			});
		};

		// Loop through the services
		for (var name in hello.services) {if (hello.services.hasOwnProperty(name)) {

			if (!hello.services[name].id) {
				// We haven't attached an ID so dont listen.
				continue;
			}

			// Get session
			var session = hello.utils.store(name) || {};
			var provider = hello.services[name];
			var oldSess = oldSessions[name] || {};

			// Listen for globalEvents that did not get triggered from the child
			if (session && 'callback' in session) {

				// To do remove from session object...
				var cb = session.callback;
				try {
					delete session.callback;
				}
				catch (e) {}

				// Update store
				// Removing the callback
				hello.utils.store(name, session);

				// Emit global events
				try {
					window[cb](session);
				}
				catch (e) {}
			}

			// Refresh token
			if (session && ('expires' in session) && session.expires < CURRENT_TIME) {

				// If auto refresh is possible
				// Either the browser supports
				var refresh = provider.refresh || session.refresh_token;

				// Has the refresh been run recently?
				if (refresh && (!(name in expired) || expired[name] < CURRENT_TIME)) {
					// Try to resignin
					hello.emit('notice', name + ' has expired trying to resignin');
					hello.login(name, {display: 'none', force: false});

					// Update expired, every 10 minutes
					expired[name] = CURRENT_TIME + 600;
				}

				// Does this provider not support refresh
				else if (!refresh && !(name in expired)) {
					// Label the event
					emit('expired');
					expired[name] = true;
				}

				// If session has expired then we dont want to store its value until it can be established that its been updated
				continue;
			}

			// Has session changed?
			else if (oldSess.access_token === session.access_token &&
			oldSess.expires === session.expires) {
				continue;
			}

			// Access_token has been removed
			else if (!session.access_token && oldSess.access_token) {
				emit('logout');
			}

			// Access_token has been created
			else if (session.access_token && !oldSess.access_token) {
				emit('login');
			}

			// Access_token has been updated
			else if (session.expires !== oldSess.expires) {
				emit('update');
			}

			// Updated stored session
			oldSessions[name] = session;

			// Remove the expired flags
			if (name in expired) {
				delete expired[name];
			}
		}}

		// Check error events
		setTimeout(self, 1000);
	})();

})(hello);

// EOF CORE lib
//////////////////////////////////

/////////////////////////////////////////
// API
// @param path    string
// @param query   object (optional)
// @param method  string (optional)
// @param data    object (optional)
// @param timeout integer (optional)
// @param callback  function (optional)

hello.api = function() {

	// Shorthand
	var _this = this;
	var utils = _this.utils;
	var error = utils.error;

	// Construct a new Promise object
	var promise = utils.Promise();

	// Arguments
	var p = utils.args({path: 's!', query: 'o', method: 's', data: 'o', timeout: 'i', callback: 'f'}, arguments);

	// Method
	p.method = (p.method || 'get').toLowerCase();

	// Headers
	p.headers = p.headers || {};

	// Query
	p.query = p.query || {};

	// If get, put all parameters into query
	if (p.method === 'get' || p.method === 'delete') {
		utils.extend(p.query, p.data);
		p.data = {};
	}

	var data = p.data = p.data || {};

	// Completed event callback
	promise.then(p.callback, p.callback);

	// Remove the network from path, e.g. facebook:/me/friends
	// Results in { network : facebook, path : me/friends }
	if (!p.path) {
		return promise.reject(error('invalid_path', 'Missing the path parameter from the request'));
	}

	p.path = p.path.replace(/^\/+/, '');
	var a = (p.path.split(/[\/\:]/, 2) || [])[0].toLowerCase();

	if (a in _this.services) {
		p.network = a;
		var reg = new RegExp('^' + a + ':?\/?');
		p.path = p.path.replace(reg, '');
	}

	// Network & Provider
	// Define the network that this request is made for
	p.network = _this.settings.default_service = p.network || _this.settings.default_service;
	var o = _this.services[p.network];

	// INVALID
	// Is there no service by the given network name?
	if (!o) {
		return promise.reject(error('invalid_network', 'Could not match the service requested: ' + p.network));
	}

	// PATH
	// As long as the path isn't flagged as unavaiable, e.g. path == false

	if (!(!(p.method in o) || !(p.path in o[p.method]) || o[p.method][p.path] !== false)) {
		return promise.reject(error('invalid_path', 'The provided path is not available on the selected network'));
	}

	// PROXY
	// OAuth1 calls always need a proxy

	if (!p.oauth_proxy) {
		p.oauth_proxy = _this.settings.oauth_proxy;
	}

	if (!('proxy' in p)) {
		p.proxy = p.oauth_proxy && o.oauth && parseInt(o.oauth.version, 10) === 1;
	}

	// TIMEOUT
	// Adopt timeout from global settings by default

	if (!('timeout' in p)) {
		p.timeout = _this.settings.timeout;
	}

	// Format response
	// Whether to run the raw response through post processing.
	if (!('formatResponse' in p)) {
		p.formatResponse = true;
	}

	// Get the current session
	// Append the access_token to the query
	p.authResponse = _this.getAuthResponse(p.network);
	if (p.authResponse && p.authResponse.access_token) {
		p.query.access_token = p.authResponse.access_token;
	}

	var url = p.path;
	var m;

	// Store the query as options
	// This is used to populate the request object before the data is augmented by the prewrap handlers.
	p.options = utils.clone(p.query);

	// Clone the data object
	// Prevent this script overwriting the data of the incoming object.
	// Ensure that everytime we run an iteration the callbacks haven't removed some data
	p.data = utils.clone(data);

	// URL Mapping
	// Is there a map for the given URL?
	var actions = o[{'delete': 'del'}[p.method] || p.method] || {};

	// Extrapolate the QueryString
	// Provide a clean path
	// Move the querystring into the data
	if (p.method === 'get') {

		var query = url.split(/[\?#]/)[1];
		if (query) {
			utils.extend(p.query, utils.param(query));

			// Remove the query part from the URL
			url = url.replace(/\?.*?(#|$)/, '$1');
		}
	}

	// Is the hash fragment defined
	if ((m = url.match(/#(.+)/, ''))) {
		url = url.split('#')[0];
		p.path = m[1];
	}
	else if (url in actions) {
		p.path = url;
		url = actions[url];
	}
	else if ('default' in actions) {
		url = actions['default'];
	}

	// Redirect Handler
	// This defines for the Form+Iframe+Hash hack where to return the results too.
	p.redirect_uri = _this.settings.redirect_uri;

	// Define FormatHandler
	// The request can be procesed in a multitude of ways
	// Here's the options - depending on the browser and endpoint
	p.xhr = o.xhr;
	p.jsonp = o.jsonp;
	p.form = o.form;

	// Make request
	if (typeof (url) === 'function') {
		// Does self have its own callback?
		url(p, getPath);
	}
	else {
		// Else the URL is a string
		getPath(url);
	}

	return promise.proxy;

	// If url needs a base
	// Wrap everything in
	function getPath(url) {

		// Format the string if it needs it
		url = url.replace(/\@\{([a-z\_\-]+)(\|.*?)?\}/gi, function(m, key, defaults) {
			var val = defaults ? defaults.replace(/^\|/, '') : '';
			if (key in p.query) {
				val = p.query[key];
				delete p.query[key];
			}
			else if (p.data && key in p.data) {
				val = p.data[key];
				delete p.data[key];
			}
			else if (!defaults) {
				promise.reject(error('missing_attribute', 'The attribute ' + key + ' is missing from the request'));
			}

			return val;
		});

		// Add base
		if (!url.match(/^https?:\/\//)) {
			url = o.base + url;
		}

		// Define the request URL
		p.url = url;

		// Make the HTTP request with the curated request object
		// CALLBACK HANDLER
		// @ response object
		// @ statusCode integer if available
		utils.request(p, function(r, headers) {

			// Is this a raw response?
			if (!p.formatResponse) {
				// Bad request? error statusCode or otherwise contains an error response vis JSONP?
				if (typeof headers === 'object' ? (headers.statusCode >= 400) : (typeof r === 'object' && 'error' in r)) {
					promise.reject(r);
				}
				else {
					promise.fulfill(r);
				}

				return;
			}

			// Should this be an object
			if (r === true) {
				r = {success:true};
			}
			else if (!r) {
				r = {};
			}

			// The delete callback needs a better response
			if (p.method === 'delete') {
				r = (!r || utils.isEmpty(r)) ? {success:true} : r;
			}

			// FORMAT RESPONSE?
			// Does self request have a corresponding formatter
			if (o.wrap && ((p.path in o.wrap) || ('default' in o.wrap))) {
				var wrap = (p.path in o.wrap ? p.path : 'default');
				var time = (new Date()).getTime();

				// FORMAT RESPONSE
				var b = o.wrap[wrap](r, headers, p);

				// Has the response been utterly overwritten?
				// Typically self augments the existing object.. but for those rare occassions
				if (b) {
					r = b;
				}
			}

			// Is there a next_page defined in the response?
			if (r && 'paging' in r && r.paging.next) {

				// Add the relative path if it is missing from the paging/next path
				if (r.paging.next[0] === '?') {
					r.paging.next = p.path + r.paging.next;
				}

				// The relative path has been defined, lets markup the handler in the HashFragment
				else {
					r.paging.next += '#' + p.path;
				}
			}

			// Dispatch to listeners
			// Emit events which pertain to the formatted response
			if (!r || 'error' in r) {
				promise.reject(r);
			}
			else {
				promise.fulfill(r);
			}
		});
	}
};

// API utilities
hello.utils.extend(hello.utils, {

	// Make an HTTP request
	request: function(p, callback) {

		var _this = this;
		var error = _this.error;

		// This has to go through a POST request
		if (!_this.isEmpty(p.data) && !('FileList' in window) && _this.hasBinary(p.data)) {

			// Disable XHR and JSONP
			p.xhr = false;
			p.jsonp = false;
		}

		// Check if the browser and service support CORS
		var cors = this.request_cors(function() {
			// If it does then run this...
			return ((p.xhr === undefined) || (p.xhr && (typeof (p.xhr) !== 'function' || p.xhr(p, p.query))));
		});

		if (cors) {

			formatUrl(p, function(url) {

				var x = _this.xhr(p.method, url, p.headers, p.data, callback);
				x.onprogress = p.onprogress || null;

				// Windows Phone does not support xhr.upload, see #74
				// Feature detect
				if (x.upload && p.onuploadprogress) {
					x.upload.onprogress = p.onuploadprogress;
				}

			});

			return;
		}

		// Clone the query object
		// Each request modifies the query object and needs to be tared after each one.
		var _query = p.query;

		p.query = _this.clone(p.query);

		// Assign a new callbackID
		p.callbackID = _this.globalEvent();

		// JSONP
		if (p.jsonp !== false) {

			// Clone the query object
			p.query.callback = p.callbackID;

			// If the JSONP is a function then run it
			if (typeof (p.jsonp) === 'function') {
				p.jsonp(p, p.query);
			}

			// Lets use JSONP if the method is 'get'
			if (p.method === 'get') {

				formatUrl(p, function(url) {
					_this.jsonp(url, callback, p.callbackID, p.timeout);
				});

				return;
			}
			else {
				// It's not compatible reset query
				p.query = _query;
			}

		}

		// Otherwise we're on to the old school, iframe hacks and JSONP
		if (p.form !== false) {

			// Add some additional query parameters to the URL
			// We're pretty stuffed if the endpoint doesn't like these
			p.query.redirect_uri = p.redirect_uri;
			p.query.state = JSON.stringify({callback:p.callbackID});

			var opts;

			if (typeof (p.form) === 'function') {

				// Format the request
				opts = p.form(p, p.query);
			}

			if (p.method === 'post' && opts !== false) {

				formatUrl(p, function(url) {
					_this.post(url, p.data, opts, callback, p.callbackID, p.timeout);
				});

				return;
			}
		}

		// None of the methods were successful throw an error
		callback(error('invalid_request', 'There was no mechanism for handling this request'));

		return;

		// Format URL
		// Constructs the request URL, optionally wraps the URL through a call to a proxy server
		// Returns the formatted URL
		function formatUrl(p, callback) {

			// Are we signing the request?
			var sign;

			// OAuth1
			// Remove the token from the query before signing
			if (p.authResponse && p.authResponse.oauth && parseInt(p.authResponse.oauth.version, 10) === 1) {

				// OAUTH SIGNING PROXY
				sign = p.query.access_token;

				// Remove the access_token
				delete p.query.access_token;

				// Enfore use of Proxy
				p.proxy = true;
			}

			// POST body to querystring
			if (p.data && (p.method === 'get' || p.method === 'delete')) {
				// Attach the p.data to the querystring.
				_this.extend(p.query, p.data);
				p.data = null;
			}

			// Construct the path
			var path = _this.qs(p.url, p.query);

			// Proxy the request through a server
			// Used for signing OAuth1
			// And circumventing services without Access-Control Headers
			if (p.proxy) {
				// Use the proxy as a path
				path = _this.qs(p.oauth_proxy, {
					path: path,
					access_token: sign || '',

					// This will prompt the request to be signed as though it is OAuth1
					then: p.proxy_response_type || (p.method.toLowerCase() === 'get' ? 'redirect' : 'proxy'),
					method: p.method.toLowerCase(),
					suppress_response_codes: p.suppress_response_codes || true
				});
			}

			callback(path);
		}
	},

	// Test whether the browser supports the CORS response
	request_cors: function(callback) {
		return 'withCredentials' in new XMLHttpRequest() && callback();
	},

	// Return the type of DOM object
	domInstance: function(type, data) {
		var test = 'HTML' + (type || '').replace(
			/^[a-z]/,
			function(m) {
				return m.toUpperCase();
			}

		) + 'Element';

		if (!data) {
			return false;
		}

		if (window[test]) {
			return data instanceof window[test];
		}
		else if (window.Element) {
			return data instanceof window.Element && (!type || (data.tagName && data.tagName.toLowerCase() === type));
		}
		else {
			return (!(data instanceof Object || data instanceof Array || data instanceof String || data instanceof Number) && data.tagName && data.tagName.toLowerCase() === type);
		}
	},

	// Create a clone of an object
	clone: function(obj) {
		// Does not clone DOM elements, nor Binary data, e.g. Blobs, Filelists
		if (obj === null || typeof (obj) !== 'object' || obj instanceof Date || 'nodeName' in obj || this.isBinary(obj) || (typeof FormData === 'function' && obj instanceof FormData)) {
			return obj;
		}

		if (Array.isArray(obj)) {
			// Clone each item in the array
			return obj.map(this.clone.bind(this));
		}

		// But does clone everything else.
		var clone = {};
		for (var x in obj) {
			clone[x] = this.clone(obj[x]);
		}

		return clone;
	},

	// XHR: uses CORS to make requests
	xhr: function(method, url, headers, data, callback) {

		var r = new XMLHttpRequest();
		var error = this.error;

		// Binary?
		var binary = false;
		if (method === 'blob') {
			binary = method;
			method = 'GET';
		}

		method = method.toUpperCase();

		// Xhr.responseType 'json' is not supported in any of the vendors yet.
		r.onload = function(e) {
			var json = r.response;
			try {
				json = JSON.parse(r.responseText);
			}
			catch (_e) {
				if (r.status === 401) {
					json = error('access_denied', r.statusText);
				}
			}

			var headers = headersToJSON(r.getAllResponseHeaders());
			headers.statusCode = r.status;

			callback(json || (method === 'GET' ? error('empty_response', 'Could not get resource') : {}), headers);
		};

		r.onerror = function(e) {
			var json = r.responseText;
			try {
				json = JSON.parse(r.responseText);
			}
			catch (_e) {}

			callback(json || error('access_denied', 'Could not get resource'));
		};

		var x;

		// Should we add the query to the URL?
		if (method === 'GET' || method === 'DELETE') {
			data = null;
		}
		else if (data && typeof (data) !== 'string' && !(data instanceof FormData) && !(data instanceof File) && !(data instanceof Blob)) {
			// Loop through and add formData
			var f = new FormData();
			for (x in data) if (data.hasOwnProperty(x)) {
				if (data[x] instanceof HTMLInputElement) {
					if ('files' in data[x] && data[x].files.length > 0) {
						f.append(x, data[x].files[0]);
					}
				}
				else if (data[x] instanceof Blob) {
					f.append(x, data[x], data.name);
				}
				else {
					f.append(x, data[x]);
				}
			}

			data = f;
		}

		// Open the path, async
		r.open(method, url, true);

		if (binary) {
			if ('responseType' in r) {
				r.responseType = binary;
			}
			else {
				r.overrideMimeType('text/plain; charset=x-user-defined');
			}
		}

		// Set any bespoke headers
		if (headers) {
			for (x in headers) {
				r.setRequestHeader(x, headers[x]);
			}
		}

		r.send(data);

		return r;

		// Headers are returned as a string
		function headersToJSON(s) {
			var r = {};
			var reg = /([a-z\-]+):\s?(.*);?/gi;
			var m;
			while ((m = reg.exec(s))) {
				r[m[1]] = m[2];
			}

			return r;
		}
	},

	// JSONP
	// Injects a script tag into the DOM to be executed and appends a callback function to the window object
	// @param string/function pathFunc either a string of the URL or a callback function pathFunc(querystringhash, continueFunc);
	// @param function callback a function to call on completion;
	jsonp: function(url, callback, callbackID, timeout) {

		var _this = this;
		var error = _this.error;

		// Change the name of the callback
		var bool = 0;
		var head = document.getElementsByTagName('head')[0];
		var operaFix;
		var result = error('server_error', 'server_error');
		var cb = function() {
			if (!(bool++)) {
				window.setTimeout(function() {
					callback(result);
					head.removeChild(script);
				}, 0);
			}

		};

		// Add callback to the window object
		callbackID = _this.globalEvent(function(json) {
			result = json;
			return true;

			// Mark callback as done
		}, callbackID);

		// The URL is a function for some cases and as such
		// Determine its value with a callback containing the new parameters of this function.
		url = url.replace(new RegExp('=\\?(&|$)'), '=' + callbackID + '$1');

		// Build script tag
		var script = _this.append('script', {
			id: callbackID,
			name: callbackID,
			src: url,
			async: true,
			onload: cb,
			onerror: cb,
			onreadystatechange: function() {
				if (/loaded|complete/i.test(this.readyState)) {
					cb();
				}
			}
		});

		// Opera fix error
		// Problem: If an error occurs with script loading Opera fails to trigger the script.onerror handler we specified
		//
		// Fix:
		// By setting the request to synchronous we can trigger the error handler when all else fails.
		// This action will be ignored if we've already called the callback handler ""cb"" with a successful onload event
		if (window.navigator.userAgent.toLowerCase().indexOf('opera') > -1) {
			operaFix = _this.append('script', {
				text: 'document.getElementById(\'' + callbackID + '\').onerror();'
			});
			script.async = false;
		}

		// Add timeout
		if (timeout) {
			window.setTimeout(function() {
				result = error('timeout', 'timeout');
				cb();
			}, timeout);
		}

		// TODO: add fix for IE,
		// However: unable recreate the bug of firing off the onreadystatechange before the script content has been executed and the value of ""result"" has been defined.
		// Inject script tag into the head element
		head.appendChild(script);

		// Append Opera Fix to run after our script
		if (operaFix) {
			head.appendChild(operaFix);
		}
	},

	// Post
	// Send information to a remote location using the post mechanism
	// @param string uri path
	// @param object data, key value data to send
	// @param function callback, function to execute in response
	post: function(url, data, options, callback, callbackID, timeout) {

		var _this = this;
		var error = _this.error;
		var doc = document;

		// This hack needs a form
		var form = null;
		var reenableAfterSubmit = [];
		var newform;
		var i = 0;
		var x = null;
		var bool = 0;
		var cb = function(r) {
			if (!(bool++)) {
				callback(r);
			}
		};

		// What is the name of the callback to contain
		// We'll also use this to name the iframe
		_this.globalEvent(cb, callbackID);

		// Build the iframe window
		var win;
		try {
			// IE7 hack, only lets us define the name here, not later.
			win = doc.createElement('<iframe name=""' + callbackID + '"">');
		}
		catch (e) {
			win = doc.createElement('iframe');
		}

		win.name = callbackID;
		win.id = callbackID;
		win.style.display = 'none';

		// Override callback mechanism. Triggger a response onload/onerror
		if (options && options.callbackonload) {
			// Onload is being fired twice
			win.onload = function() {
				cb({
					response: 'posted',
					message: 'Content was posted'
				});
			};
		}

		if (timeout) {
			setTimeout(function() {
				cb(error('timeout', 'The post operation timed out'));
			}, timeout);
		}

		doc.body.appendChild(win);

		// If we are just posting a single item
		if (_this.domInstance('form', data)) {
			// Get the parent form
			form = data.form;

			// Loop through and disable all of its siblings
			for (i = 0; i < form.elements.length; i++) {
				if (form.elements[i] !== data) {
					form.elements[i].setAttribute('disabled', true);
				}
			}

			// Move the focus to the form
			data = form;
		}

		// Posting a form
		if (_this.domInstance('form', data)) {
			// This is a form element
			form = data;

			// Does this form need to be a multipart form?
			for (i = 0; i < form.elements.length; i++) {
				if (!form.elements[i].disabled && form.elements[i].type === 'file') {
					form.encoding = form.enctype = 'multipart/form-data';
					form.elements[i].setAttribute('name', 'file');
				}
			}
		}
		else {
			// Its not a form element,
			// Therefore it must be a JSON object of Key=>Value or Key=>Element
			// If anyone of those values are a input type=file we shall shall insert its siblings into the form for which it belongs.
			for (x in data) if (data.hasOwnProperty(x)) {
				// Is this an input Element?
				if (_this.domInstance('input', data[x]) && data[x].type === 'file') {
					form = data[x].form;
					form.encoding = form.enctype = 'multipart/form-data';
				}
			}

			// Do If there is no defined form element, lets create one.
			if (!form) {
				// Build form
				form = doc.createElement('form');
				doc.body.appendChild(form);
				newform = form;
			}

			var input;

			// Add elements to the form if they dont exist
			for (x in data) if (data.hasOwnProperty(x)) {

				// Is this an element?
				var el = (_this.domInstance('input', data[x]) || _this.domInstance('textArea', data[x]) || _this.domInstance('select', data[x]));

				// Is this not an input element, or one that exists outside the form.
				if (!el || data[x].form !== form) {

					// Does an element have the same name?
					var inputs = form.elements[x];
					if (input) {
						// Remove it.
						if (!(inputs instanceof NodeList)) {
							inputs = [inputs];
						}

						for (i = 0; i < inputs.length; i++) {
							inputs[i].parentNode.removeChild(inputs[i]);
						}

					}

					// Create an input element
					input = doc.createElement('input');
					input.setAttribute('type', 'hidden');
					input.setAttribute('name', x);

					// Does it have a value attribute?
					if (el) {
						input.value = data[x].value;
					}
					else if (_this.domInstance(null, data[x])) {
						input.value = data[x].innerHTML || data[x].innerText;
					}
					else {
						input.value = data[x];
					}

					form.appendChild(input);
				}

				// It is an element, which exists within the form, but the name is wrong
				else if (el && data[x].name !== x) {
					data[x].setAttribute('name', x);
					data[x].name = x;
				}
			}

			// Disable elements from within the form if they weren't specified
			for (i = 0; i < form.elements.length; i++) {

				input = form.elements[i];

				// Does the same name and value exist in the parent
				if (!(input.name in data) && input.getAttribute('disabled') !== true) {
					// Disable
					input.setAttribute('disabled', true);

					// Add re-enable to callback
					reenableAfterSubmit.push(input);
				}
			}
		}

		// Set the target of the form
		form.setAttribute('method', 'POST');
		form.setAttribute('target', callbackID);
		form.target = callbackID;

		// Update the form URL
		form.setAttribute('action', url);

		// Submit the form
		// Some reason this needs to be offset from the current window execution
		setTimeout(function() {
			form.submit();

			setTimeout(function() {
				try {
					// Remove the iframe from the page.
					//win.parentNode.removeChild(win);
					// Remove the form
					if (newform) {
						newform.parentNode.removeChild(newform);
					}
				}
				catch (e) {
					try {
						console.error('HelloJS: could not remove iframe');
					}
					catch (ee) {}
				}

				// Reenable the disabled form
				for (var i = 0; i < reenableAfterSubmit.length; i++) {
					if (reenableAfterSubmit[i]) {
						reenableAfterSubmit[i].setAttribute('disabled', false);
						reenableAfterSubmit[i].disabled = false;
					}
				}
			}, 0);
		}, 100);
	},

	// Some of the providers require that only multipart is used with non-binary forms.
	// This function checks whether the form contains binary data
	hasBinary: function(data) {
		for (var x in data) if (data.hasOwnProperty(x)) {
			if (this.isBinary(data[x])) {
				return true;
			}
		}

		return false;
	},

	// Determines if a variable Either Is or like a FormInput has the value of a Blob

	isBinary: function(data) {

		return data instanceof Object && (
		(this.domInstance('input', data) && data.type === 'file') ||
		('FileList' in window && data instanceof window.FileList) ||
		('File' in window && data instanceof window.File) ||
		('Blob' in window && data instanceof window.Blob));

	},

	// Convert Data-URI to Blob string
	toBlob: function(dataURI) {
		var reg = /^data\:([^;,]+(\;charset=[^;,]+)?)(\;base64)?,/i;
		var m = dataURI.match(reg);
		if (!m) {
			return dataURI;
		}

		var binary = atob(dataURI.replace(reg, ''));
		var array = [];
		for (var i = 0; i < binary.length; i++) {
			array.push(binary.charCodeAt(i));
		}

		return new Blob([new Uint8Array(array)], {type: m[1]});
	}

});

// EXTRA: Convert FormElement to JSON for POSTing
// Wrappers to add additional functionality to existing functions
(function(hello) {

	// Copy original function
	var api = hello.api;
	var utils = hello.utils;

	utils.extend(utils, {

		// DataToJSON
		// This takes a FormElement|NodeList|InputElement|MixedObjects and convers the data object to JSON.
		dataToJSON: function(p) {

			var _this = this;
			var w = window;
			var data = p.data;

			// Is data a form object
			if (_this.domInstance('form', data)) {
				data = _this.nodeListToJSON(data.elements);
			}
			else if ('NodeList' in w && data instanceof NodeList) {
				data = _this.nodeListToJSON(data);
			}
			else if (_this.domInstance('input', data)) {
				data = _this.nodeListToJSON([data]);
			}

			// Is data a blob, File, FileList?
			if (('File' in w && data instanceof w.File) ||
				('Blob' in w && data instanceof w.Blob) ||
				('FileList' in w && data instanceof w.FileList)) {
				data = {file: data};
			}

			// Loop through data if it's not form data it must now be a JSON object
			if (!('FormData' in w && data instanceof w.FormData)) {

				for (var x in data) if (data.hasOwnProperty(x)) {

					if ('FileList' in w && data[x] instanceof w.FileList) {
						if (data[x].length === 1) {
							data[x] = data[x][0];
						}
					}
					else if (_this.domInstance('input', data[x]) && data[x].type === 'file') {
						continue;
					}
					else if (_this.domInstance('input', data[x]) ||
						_this.domInstance('select', data[x]) ||
						_this.domInstance('textArea', data[x])) {
						data[x] = data[x].value;
					}
					else if (_this.domInstance(null, data[x])) {
						data[x] = data[x].innerHTML || data[x].innerText;
					}
				}
			}

			p.data = data;
			return data;
		},

		// NodeListToJSON
		// Given a list of elements extrapolate their values and return as a json object
		nodeListToJSON: function(nodelist) {

			var json = {};

			// Create a data string
			for (var i = 0; i < nodelist.length; i++) {

				var input = nodelist[i];

				// If the name of the input is empty or diabled, dont add it.
				if (input.disabled || !input.name) {
					continue;
				}

				// Is this a file, does the browser not support 'files' and 'FormData'?
				if (input.type === 'file') {
					json[input.name] = input;
				}
				else {
					json[input.name] = input.value || input.innerHTML;
				}
			}

			return json;
		}
	});

	// Replace it
	hello.api = function() {

		// Get arguments
		var p = utils.args({path: 's!', method: 's', data:'o', timeout: 'i', callback: 'f'}, arguments);

		// Change for into a data object
		if (p.data) {
			utils.dataToJSON(p);
		}

		return api.call(this, p);
	};

})(hello);

/////////////////////////////////////
//
// Save any access token that is in the current page URL
// Handle any response solicited through iframe hash tag following an API request
//
/////////////////////////////////////

hello.utils.responseHandler(window, window.opener || window.parent);
","/**
 * @hello.js
 *
 * HelloJS is a client side Javascript SDK for making OAuth2 logins and subsequent REST calls.
 *
 * @author Andrew Dodson
 * @website https://adodson.com/hello.js/
 *
 * @copyright Andrew Dodson, 2012 - 2015
 * @license MIT: You are free to use and modify this code for any use, on the condition that this copyright notice remains.
 */

var hello = function(name) {
	return hello.use(name);
};

hello.utils = {

	// Extend the first object with the properties and methods of the second
	extend: function(r /*, a[, b[, ...]] */) {

		// Get the arguments as an array but ommit the initial item
		Array.prototype.slice.call(arguments, 1).forEach(function(a) {
			if (Array.isArray(r) && Array.isArray(a)) {
				Array.prototype.push.apply(r, a);
			}
			else if (r && (r instanceof Object || typeof r === 'object') && a && (a instanceof Object || typeof a === 'object') && r !== a) {
				for (var x in a) {
					r[x] = hello.utils.extend(r[x], a[x]);
				}
			}
			else {

				if (Array.isArray(a)) {
					// Clone it
					a = a.slice(0);
				}

				r = a;
			}
		});

		return r;
	}
};

// Core library
hello.utils.extend(hello, {

	settings: {

		// OAuth2 authentication defaults
		redirect_uri: window.location.href.split('#')[0],
		response_type: 'token',
		display: 'popup',
		state: '',

		// OAuth1 shim
		// The path to the OAuth1 server for signing user requests
		// Want to recreate your own? Checkout https://github.com/MrSwitch/node-oauth-shim
		oauth_proxy: 'https://auth-server.herokuapp.com/proxy',

		// API timeout in milliseconds
		timeout: 20000,

		// Popup Options
		popup: {
			resizable: 1,
			scrollbars: 1,
			width: 500,
			height: 550
		},

		// Default scope
		// Many services require atleast a profile scope,
		// HelloJS automatially includes the value of provider.scope_map.basic
		// If that's not required it can be removed via hello.settings.scope.length = 0;
		scope: ['basic'],

		// Scope Maps
		// This is the default module scope, these are the defaults which each service is mapped too.
		// By including them here it prevents the scope from being applied accidentally
		scope_map: {
			basic: ''
		},

		// Default service / network
		default_service: null,

		// Force authentication
		// When hello.login is fired.
		// (null): ignore current session expiry and continue with login
		// (true): ignore current session expiry and continue with login, ask for user to reauthenticate
		// (false): if the current session looks good for the request scopes return the current session.
		force: null,

		// Page URL
		// When 'display=page' this property defines where the users page should end up after redirect_uri
		// Ths could be problematic if the redirect_uri is indeed the final place,
		// Typically this circumvents the problem of the redirect_url being a dumb relay page.
		page_uri: window.location.href
	},

	// Service configuration objects
	services: {},

	// Use
	// Define a new instance of the HelloJS library with a default service
	use: function(service) {

		// Create self, which inherits from its parent
		var self = Object.create(this);

		// Inherit the prototype from its parent
		self.settings = Object.create(this.settings);

		// Define the default service
		if (service) {
			self.settings.default_service = service;
		}

		// Create an instance of Events
		self.utils.Event.call(self);

		return self;
	},

	// Initialize
	// Define the client_ids for the endpoint services
	// @param object o, contains a key value pair, service => clientId
	// @param object opts, contains a key value pair of options used for defining the authentication defaults
	// @param number timeout, timeout in seconds
	init: function(services, options) {

		var utils = this.utils;

		if (!services) {
			return this.services;
		}

		// Define provider credentials
		// Reformat the ID field
		for (var x in services) {if (services.hasOwnProperty(x)) {
			if (typeof (services[x]) !== 'object') {
				services[x] = {id: services[x]};
			}
		}}

		// Merge services if there already exists some
		utils.extend(this.services, services);

		// Update the default settings with this one.
		if (options) {
			utils.extend(this.settings, options);

			// Do this immediatly incase the browser changes the current path.
			if ('redirect_uri' in options) {
				this.settings.redirect_uri = utils.url(options.redirect_uri).href;
			}
		}

		return this;
	},

	// Login
	// Using the endpoint
	// @param network stringify       name to connect to
	// @param options object    (optional)  {display mode, is either none|popup(default)|page, scope: email,birthday,publish, .. }
	// @param callback  function  (optional)  fired on signin
	login: function() {

		// Create an object which inherits its parent as the prototype and constructs a new event chain.
		var _this = this;
		var utils = _this.utils;
		var error = utils.error;
		var promise = utils.Promise();

		// Get parameters
		var p = utils.args({network: 's', options: 'o', callback: 'f'}, arguments);

		// Local vars
		var url;

		// Get all the custom options and store to be appended to the querystring
		var qs = utils.diffKey(p.options, _this.settings);

		// Merge/override options with app defaults
		var opts = p.options = utils.merge(_this.settings, p.options || {});

		// Merge/override options with app defaults
		opts.popup = utils.merge(_this.settings.popup, p.options.popup || {});

		// Network
		p.network = p.network || _this.settings.default_service;

		// Bind callback to both reject and fulfill states
		promise.proxy.then(p.callback, p.callback);

		// Trigger an event on the global listener
		function emit(s, value) {
			hello.emit(s, value);
		}

		promise.proxy.then(emit.bind(this, 'auth.login auth'), emit.bind(this, 'auth.failed auth'));

		// Is our service valid?
		if (typeof (p.network) !== 'string' || !(p.network in _this.services)) {
			// Trigger the default login.
			// Ahh we dont have one.
			return promise.reject(error('invalid_network', 'The provided network was not recognized'));
		}

		var provider = _this.services[p.network];

		// Create a global listener to capture events triggered out of scope
		var callbackId = utils.globalEvent(function(obj) {

			// The responseHandler returns a string, lets save this locally
			if (obj) {
				if (typeof (obj) == 'string') {
					obj = JSON.parse(obj);
				}
			}
			else {
				obj = error('cancelled', 'The authentication was not completed');
			}

			// Handle these response using the local
			// Trigger on the parent
			if (!obj.error) {

				// Save on the parent window the new credentials
				// This fixes an IE10 bug i think... atleast it does for me.
				utils.store(obj.network, obj);

				// Fulfill a successful login
				promise.fulfill({
					network: obj.network,
					authResponse: obj
				});
			}
			else {
				// Reject a successful login
				promise.reject(obj);
			}
		});

		var redirectUri = utils.url(opts.redirect_uri).href;

		// May be a space-delimited list of multiple, complementary types
		var responseType = provider.oauth.response_type || opts.response_type;

		// Fallback to token if the module hasn't defined a grant url
		if (/\bcode\b/.test(responseType) && !provider.oauth.grant) {
			responseType = responseType.replace(/\bcode\b/, 'token');
		}

		// Query string parameters, we may pass our own arguments to form the querystring
		p.qs = utils.merge(qs, {
			client_id: encodeURIComponent(provider.id),
			response_type: encodeURIComponent(responseType),
			redirect_uri: encodeURIComponent(redirectUri),
			state: {
				client_id: provider.id,
				network: p.network,
				display: opts.display,
				callback: callbackId,
				state: opts.state,
				redirect_uri: redirectUri
			}
		});

		// Get current session for merging scopes, and for quick auth response
		var session = utils.store(p.network);

		// Scopes (authentication permisions)
		// Ensure this is a string - IE has a problem moving Arrays between windows
		// Append the setup scope
		var SCOPE_SPLIT = /[,\s]+/;

		// Include default scope settings (cloned).
		var scope = _this.settings.scope ? [_this.settings.scope.toString()] : [];

		// Extend the providers scope list with the default
		var scopeMap = utils.merge(_this.settings.scope_map, provider.scope || {});

		// Add user defined scopes...
		if (opts.scope) {
			scope.push(opts.scope.toString());
		}

		// Append scopes from a previous session.
		// This helps keep app credentials constant,
		// Avoiding having to keep tabs on what scopes are authorized
		if (session && 'scope' in session && session.scope instanceof String) {
			scope.push(session.scope);
		}

		// Join and Split again
		scope = scope.join(',').split(SCOPE_SPLIT);

		// Format remove duplicates and empty values
		scope = utils.unique(scope).filter(filterEmpty);

		// Save the the scopes to the state with the names that they were requested with.
		p.qs.state.scope = scope.join(',');

		// Map scopes to the providers naming convention
		scope = scope.map(function(item) {
			// Does this have a mapping?
			return (item in scopeMap) ? scopeMap[item] : item;
		});

		// Stringify and Arrayify so that double mapped scopes are given the chance to be formatted
		scope = scope.join(',').split(SCOPE_SPLIT);

		// Again...
		// Format remove duplicates and empty values
		scope = utils.unique(scope).filter(filterEmpty);

		// Join with the expected scope delimiter into a string
		p.qs.scope = scope.join(provider.scope_delim || ',');

		// Is the user already signed in with the appropriate scopes, valid access_token?
		if (opts.force === false) {

			if (session && 'access_token' in session && session.access_token && 'expires' in session && session.expires > ((new Date()).getTime() / 1e3)) {
				// What is different about the scopes in the session vs the scopes in the new login?
				var diff = utils.diff((session.scope || '').split(SCOPE_SPLIT), (p.qs.state.scope || '').split(SCOPE_SPLIT));
				if (diff.length === 0) {

					// OK trigger the callback
					promise.fulfill({
						unchanged: true,
						network: p.network,
						authResponse: session
					});

					// Nothing has changed
					return promise;
				}
			}
		}

		// Page URL
		if (opts.display === 'page' && opts.page_uri) {
			// Add a page location, place to endup after session has authenticated
			p.qs.state.page_uri = utils.url(opts.page_uri).href;
		}

		// Bespoke
		// Override login querystrings from auth_options
		if ('login' in provider && typeof (provider.login) === 'function') {
			// Format the paramaters according to the providers formatting function
			provider.login(p);
		}

		// Add OAuth to state
		// Where the service is going to take advantage of the oauth_proxy
		if (!/\btoken\b/.test(responseType) ||
		parseInt(provider.oauth.version, 10) < 2 ||
		(opts.display === 'none' && provider.oauth.grant && session && session.refresh_token)) {

			// Add the oauth endpoints
			p.qs.state.oauth = provider.oauth;

			// Add the proxy url
			p.qs.state.oauth_proxy = opts.oauth_proxy;

		}

		// Convert state to a string
		p.qs.state = encodeURIComponent(JSON.stringify(p.qs.state));

		// URL
		if (parseInt(provider.oauth.version, 10) === 1) {

			// Turn the request to the OAuth Proxy for 3-legged auth
			url = utils.qs(opts.oauth_proxy, p.qs, encodeFunction);
		}

		// Refresh token
		else if (opts.display === 'none' && provider.oauth.grant && session && session.refresh_token) {

			// Add the refresh_token to the request
			p.qs.refresh_token = session.refresh_token;

			// Define the request path
			url = utils.qs(opts.oauth_proxy, p.qs, encodeFunction);
		}
		else {
			url = utils.qs(provider.oauth.auth, p.qs, encodeFunction);
		}

		// Broadcast this event as an auth:init
		emit('auth.init', p);

		// Execute
		// Trigger how we want self displayed
		if (opts.display === 'none') {
			// Sign-in in the background, iframe
			utils.iframe(url, redirectUri);
		}

		// Triggering popup?
		else if (opts.display === 'popup') {

			var popup = utils.popup(url, redirectUri, opts.popup);

			var timer = setInterval(function() {
				if (!popup || popup.closed) {
					clearInterval(timer);
					if (!promise.state) {

						var response = error('cancelled', 'Login has been cancelled');

						if (!popup) {
							response = error('blocked', 'Popup was blocked');
						}

						response.network = p.network;

						promise.reject(response);
					}
				}
			}, 100);
		}

		else {
			window.location = url;
		}

		return promise.proxy;

		function encodeFunction(s) {return s;}

		function filterEmpty(s) {return !!s;}
	},

	// Remove any data associated with a given service
	// @param string name of the service
	// @param function callback
	logout: function() {

		var _this = this;
		var utils = _this.utils;
		var error = utils.error;

		// Create a new promise
		var promise = utils.Promise();

		var p = utils.args({name:'s', options: 'o', callback: 'f'}, arguments);

		p.options = p.options || {};

		// Add callback to events
		promise.proxy.then(p.callback, p.callback);

		// Trigger an event on the global listener
		function emit(s, value) {
			hello.emit(s, value);
		}

		promise.proxy.then(emit.bind(this, 'auth.logout auth'), emit.bind(this, 'error'));

		// Network
		p.name = p.name || this.settings.default_service;
		p.authResponse = utils.store(p.name);

		if (p.name && !(p.name in _this.services)) {

			promise.reject(error('invalid_network', 'The network was unrecognized'));

		}
		else if (p.name && p.authResponse) {

			// Define the callback
			var callback = function(opts) {

				// Remove from the store
				utils.store(p.name, null);

				// Emit events by default
				promise.fulfill(hello.utils.merge({network:p.name}, opts || {}));
			};

			// Run an async operation to remove the users session
			var _opts = {};
			if (p.options.force) {
				var logout = _this.services[p.name].logout;
				if (logout) {
					// Convert logout to URL string,
					// If no string is returned, then this function will handle the logout async style
					if (typeof (logout) === 'function') {
						logout = logout(callback, p);
					}

					// If logout is a string then assume URL and open in iframe.
					if (typeof (logout) === 'string') {
						utils.iframe(logout);
						_opts.force = null;
						_opts.message = 'Logout success on providers site was indeterminate';
					}
					else if (logout === undefined) {
						// The callback function will handle the response.
						return promise.proxy;
					}
				}
			}

			// Remove local credentials
			callback(_opts);
		}
		else {
			promise.reject(error('invalid_session', 'There was no session to remove'));
		}

		return promise.proxy;
	},

	// Returns all the sessions that are subscribed too
	// @param string optional, name of the service to get information about.
	getAuthResponse: function(service) {

		// If the service doesn't exist
		service = service || this.settings.default_service;

		if (!service || !(service in this.services)) {
			return null;
		}

		return this.utils.store(service) || null;
	},

	// Events: placeholder for the events
	events: {}
});

// Core utilities
hello.utils.extend(hello.utils, {

	// Error
	error: function(code, message) {
		return {
			error: {
				code: code,
				message: message
			}
		};
	},

	// Append the querystring to a url
	// @param string url
	// @param object parameters
	qs: function(url, params, formatFunction) {

		if (params) {

			// Set default formatting function
			formatFunction = formatFunction || encodeURIComponent;

			// Override the items in the URL which already exist
			for (var x in params) {
				var str = '([\\?\\&])' + x + '=[^\\&]*';
				var reg = new RegExp(str);
				if (url.match(reg)) {
					url = url.replace(reg, '$1' + x + '=' + formatFunction(params[x]));
					delete params[x];
				}
			}
		}

		if (!this.isEmpty(params)) {
			return url + (url.indexOf('?') > -1 ? '&' : '?') + this.param(params, formatFunction);
		}

		return url;
	},

	// Param
	// Explode/encode the parameters of an URL string/object
	// @param string s, string to decode
	param: function(s, formatFunction) {
		var b;
		var a = {};
		var m;

		if (typeof (s) === 'string') {

			formatFunction = formatFunction || decodeURIComponent;

			m = s.replace(/^[\#\?]/, '').match(/([^=\/\&]+)=([^\&]+)/g);
			if (m) {
				for (var i = 0; i < m.length; i++) {
					b = m[i].match(/([^=]+)=(.*)/);
					a[b[1]] = formatFunction(b[2]);
				}
			}

			return a;
		}
		else {

			formatFunction = formatFunction || encodeURIComponent;

			var o = s;

			a = [];

			for (var x in o) {if (o.hasOwnProperty(x)) {
				if (o.hasOwnProperty(x)) {
					a.push([x, o[x] === '?' ? '?' : formatFunction(o[x])].join('='));
				}
			}}

			return a.join('&');
		}
	},

	// Local storage facade
	store: (function() {

		var a = ['localStorage', 'sessionStorage'];
		var i = -1;
		var prefix = 'test';

		// Set LocalStorage
		var localStorage;

		while (a[++i]) {
			try {
				// In Chrome with cookies blocked, calling localStorage throws an error
				localStorage = window[a[i]];
				localStorage.setItem(prefix + i, i);
				localStorage.removeItem(prefix + i);
				break;
			}
			catch (e) {
				localStorage = null;
			}
		}

		if (!localStorage) {

			var cache = null;

			localStorage = {
				getItem: function(prop) {
					prop = prop + '=';
					var m = document.cookie.split(';');
					for (var i = 0; i < m.length; i++) {
						var _m = m[i].replace(/(^\s+|\s+$)/, '');
						if (_m && _m.indexOf(prop) === 0) {
							return _m.substr(prop.length);
						}
					}

					return cache;
				},

				setItem: function(prop, value) {
					cache = value;
					document.cookie = prop + '=' + value;
				}
			};

			// Fill the cache up
			cache = localStorage.getItem('hello');
		}

		function get() {
			var json = {};
			try {
				json = JSON.parse(localStorage.getItem('hello')) || {};
			}
			catch (e) {}

			return json;
		}

		function set(json) {
			localStorage.setItem('hello', JSON.stringify(json));
		}

		// Check if the browser support local storage
		return function(name, value, days) {

			// Local storage
			var json = get();

			if (name && value === undefined) {
				return json[name] || null;
			}
			else if (name && value === null) {
				try {
					delete json[name];
				}
				catch (e) {
					json[name] = null;
				}
			}
			else if (name) {
				json[name] = value;
			}
			else {
				return json;
			}

			set(json);

			return json || null;
		};

	})(),

	// Create and Append new DOM elements
	// @param node string
	// @param attr object literal
	// @param dom/string
	append: function(node, attr, target) {

		var n = typeof (node) === 'string' ? document.createElement(node) : node;

		if (typeof (attr) === 'object') {
			if ('tagName' in attr) {
				target = attr;
			}
			else {
				for (var x in attr) {if (attr.hasOwnProperty(x)) {
					if (typeof (attr[x]) === 'object') {
						for (var y in attr[x]) {if (attr[x].hasOwnProperty(y)) {
							n[x][y] = attr[x][y];
						}}
					}
					else if (x === 'html') {
						n.innerHTML = attr[x];
					}

					// IE doesn't like us setting methods with setAttribute
					else if (!/^on/.test(x)) {
						n.setAttribute(x, attr[x]);
					}
					else {
						n[x] = attr[x];
					}
				}}
			}
		}

		if (target === 'body') {
			(function self() {
				if (document.body) {
					document.body.appendChild(n);
				}
				else {
					setTimeout(self, 16);
				}
			})();
		}
		else if (typeof (target) === 'object') {
			target.appendChild(n);
		}
		else if (typeof (target) === 'string') {
			document.getElementsByTagName(target)[0].appendChild(n);
		}

		return n;
	},

	// An easy way to create a hidden iframe
	// @param string src
	iframe: function(src) {
		this.append('iframe', {src: src, style: {position:'absolute', left: '-1000px', bottom: 0, height: '1px', width: '1px'}}, 'body');
	},

	// Recursive merge two objects into one, second parameter overides the first
	// @param a array
	merge: function(/* Args: a, b, c, .. n */) {
		var args = Array.prototype.slice.call(arguments);
		args.unshift({});
		return this.extend.apply(null, args);
	},

	// Makes it easier to assign parameters, where some are optional
	// @param o object
	// @param a arguments
	args: function(o, args) {

		var p = {};
		var i = 0;
		var t = null;
		var x = null;

		// 'x' is the first key in the list of object parameters
		for (x in o) {if (o.hasOwnProperty(x)) {
			break;
		}}

		// Passing in hash object of arguments?
		// Where the first argument can't be an object
		if ((args.length === 1) && (typeof (args[0]) === 'object') && o[x] != 'o!') {

			// Could this object still belong to a property?
			// Check the object keys if they match any of the property keys
			for (x in args[0]) {if (o.hasOwnProperty(x)) {
				// Does this key exist in the property list?
				if (x in o) {
					// Yes this key does exist so its most likely this function has been invoked with an object parameter
					// Return first argument as the hash of all arguments
					return args[0];
				}
			}}
		}

		// Else loop through and account for the missing ones.
		for (x in o) {if (o.hasOwnProperty(x)) {

			t = typeof (args[i]);

			if ((typeof (o[x]) === 'function' && o[x].test(args[i])) || (typeof (o[x]) === 'string' && (
			(o[x].indexOf('s') > -1 && t === 'string') ||
			(o[x].indexOf('o') > -1 && t === 'object') ||
			(o[x].indexOf('i') > -1 && t === 'number') ||
			(o[x].indexOf('a') > -1 && t === 'object') ||
			(o[x].indexOf('f') > -1 && t === 'function')
			))
			) {
				p[x] = args[i++];
			}

			else if (typeof (o[x]) === 'string' && o[x].indexOf('!') > -1) {
				return false;
			}
		}}

		return p;
	},

	// Returns a URL instance
	url: function(path) {

		// If the path is empty
		if (!path) {
			return window.location;
		}

		// Chrome and FireFox support new URL() to extract URL objects
		else if (window.URL && URL instanceof Function && URL.length !== 0) {
			return new URL(path, window.location);
		}

		// Ugly shim, it works!
		else {
			var a = document.createElement('a');
			a.href = path;
			return a.cloneNode(false);
		}
	},

	diff: function(a, b) {
		return b.filter(function(item) {
			return a.indexOf(item) === -1;
		});
	},

	// Get the different hash of properties unique to `a`, and not in `b`
	diffKey: function(a, b) {
		if (a || !b) {
			var r = {};
			for (var x in a) {
				// Does the property not exist?
				if (!(x in b)) {
					r[x] = a[x];
				}
			}

			return r;
		}

		return a;
	},

	// Unique
	// Remove duplicate and null values from an array
	// @param a array
	unique: function(a) {
		if (!Array.isArray(a)) { return []; }

		return a.filter(function(item, index) {
			// Is this the first location of item
			return a.indexOf(item) === index;
		});
	},

	isEmpty: function(obj) {

		// Scalar
		if (!obj)
			return true;

		// Array
		if (Array.isArray(obj)) {
			return !obj.length;
		}
		else if (typeof (obj) === 'object') {
			// Object
			for (var key in obj) {
				if (obj.hasOwnProperty(key)) {
					return false;
				}
			}
		}

		return true;
	},

	//jscs:disable

	/*!
	 **  Thenable -- Embeddable Minimum Strictly-Compliant Promises/A+ 1.1.1 Thenable
	 **  Copyright (c) 2013-2014 Ralf S. Engelschall <http://engelschall.com>
	 **  Licensed under The MIT License <http://opensource.org/licenses/MIT>
	 **  Source-Code distributed on <http://github.com/rse/thenable>
	 */
	Promise: (function(){
		/*  promise states [Promises/A+ 2.1]  */
		var STATE_PENDING   = 0;                                         /*  [Promises/A+ 2.1.1]  */
		var STATE_FULFILLED = 1;                                         /*  [Promises/A+ 2.1.2]  */
		var STATE_REJECTED  = 2;                                         /*  [Promises/A+ 2.1.3]  */

		/*  promise object constructor  */
		var api = function (executor) {
			/*  optionally support non-constructor/plain-function call  */
			if (!(this instanceof api))
				return new api(executor);

			/*  initialize object  */
			this.id           = ""Thenable/1.0.6"";
			this.state        = STATE_PENDING; /*  initial state  */
			this.fulfillValue = undefined;     /*  initial value  */     /*  [Promises/A+ 1.3, 2.1.2.2]  */
			this.rejectReason = undefined;     /*  initial reason */     /*  [Promises/A+ 1.5, 2.1.3.2]  */
			this.onFulfilled  = [];            /*  initial handlers  */
			this.onRejected   = [];            /*  initial handlers  */

			/*  provide optional information-hiding proxy  */
			this.proxy = {
				then: this.then.bind(this)
			};

			/*  support optional executor function  */
			if (typeof executor === ""function"")
				executor.call(this, this.fulfill.bind(this), this.reject.bind(this));
		};

		/*  promise API methods  */
		api.prototype = {
			/*  promise resolving methods  */
			fulfill: function (value) { return deliver(this, STATE_FULFILLED, ""fulfillValue"", value); },
			reject:  function (value) { return deliver(this, STATE_REJECTED,  ""rejectReason"", value); },

			/*  ""The then Method"" [Promises/A+ 1.1, 1.2, 2.2]  */
			then: function (onFulfilled, onRejected) {
				var curr = this;
				var next = new api();                                    /*  [Promises/A+ 2.2.7]  */
				curr.onFulfilled.push(
					resolver(onFulfilled, next, ""fulfill""));             /*  [Promises/A+ 2.2.2/2.2.6]  */
				curr.onRejected.push(
					resolver(onRejected,  next, ""reject"" ));             /*  [Promises/A+ 2.2.3/2.2.6]  */
				execute(curr);
				return next.proxy;                                       /*  [Promises/A+ 2.2.7, 3.3]  */
			}
		};

		/*  deliver an action  */
		var deliver = function (curr, state, name, value) {
			if (curr.state === STATE_PENDING) {
				curr.state = state;                                      /*  [Promises/A+ 2.1.2.1, 2.1.3.1]  */
				curr[name] = value;                                      /*  [Promises/A+ 2.1.2.2, 2.1.3.2]  */
				execute(curr);
			}
			return curr;
		};

		/*  execute all handlers  */
		var execute = function (curr) {
			if (curr.state === STATE_FULFILLED)
				execute_handlers(curr, ""onFulfilled"", curr.fulfillValue);
			else if (curr.state === STATE_REJECTED)
				execute_handlers(curr, ""onRejected"",  curr.rejectReason);
		};

		/*  execute particular set of handlers  */
		var execute_handlers = function (curr, name, value) {
			/* global process: true */
			/* global setImmediate: true */
			/* global setTimeout: true */

			/*  short-circuit processing  */
			if (curr[name].length === 0)
				return;

			/*  iterate over all handlers, exactly once  */
			var handlers = curr[name];
			curr[name] = [];                                             /*  [Promises/A+ 2.2.2.3, 2.2.3.3]  */
			var func = function () {
				for (var i = 0; i < handlers.length; i++)
					handlers[i](value);                                  /*  [Promises/A+ 2.2.5]  */
			};

			/*  execute procedure asynchronously  */                     /*  [Promises/A+ 2.2.4, 3.1]  */
			if (typeof process === ""object"" && typeof process.nextTick === ""function"")
				process.nextTick(func);
			else if (typeof setImmediate === ""function"")
				setImmediate(func);
			else
				setTimeout(func, 0);
		};

		/*  generate a resolver function  */
		var resolver = function (cb, next, method) {
			return function (value) {
				if (typeof cb !== ""function"")                            /*  [Promises/A+ 2.2.1, 2.2.7.3, 2.2.7.4]  */
					next[method].call(next, value);                      /*  [Promises/A+ 2.2.7.3, 2.2.7.4]  */
				else {
					var result;
					try { result = cb(value); }                          /*  [Promises/A+ 2.2.2.1, 2.2.3.1, 2.2.5, 3.2]  */
					catch (e) {
						next.reject(e);                                  /*  [Promises/A+ 2.2.7.2]  */
						return;
					}
					resolve(next, result);                               /*  [Promises/A+ 2.2.7.1]  */
				}
			};
		};

		/*  ""Promise Resolution Procedure""  */                           /*  [Promises/A+ 2.3]  */
		var resolve = function (promise, x) {
			/*  sanity check arguments  */                               /*  [Promises/A+ 2.3.1]  */
			if (promise === x || promise.proxy === x) {
				promise.reject(new TypeError(""cannot resolve promise with itself""));
				return;
			}

			/*  surgically check for a ""then"" method
				(mainly to just call the ""getter"" of ""then"" only once)  */
			var then;
			if ((typeof x === ""object"" && x !== null) || typeof x === ""function"") {
				try { then = x.then; }                                   /*  [Promises/A+ 2.3.3.1, 3.5]  */
				catch (e) {
					promise.reject(e);                                   /*  [Promises/A+ 2.3.3.2]  */
					return;
				}
			}

			/*  handle own Thenables    [Promises/A+ 2.3.2]
				and similar ""thenables"" [Promises/A+ 2.3.3]  */
			if (typeof then === ""function"") {
				var resolved = false;
				try {
					/*  call retrieved ""then"" method */                  /*  [Promises/A+ 2.3.3.3]  */
					then.call(x,
						/*  resolvePromise  */                           /*  [Promises/A+ 2.3.3.3.1]  */
						function (y) {
							if (resolved) return; resolved = true;       /*  [Promises/A+ 2.3.3.3.3]  */
							if (y === x)                                 /*  [Promises/A+ 3.6]  */
								promise.reject(new TypeError(""circular thenable chain""));
							else
								resolve(promise, y);
						},

						/*  rejectPromise  */                            /*  [Promises/A+ 2.3.3.3.2]  */
						function (r) {
							if (resolved) return; resolved = true;       /*  [Promises/A+ 2.3.3.3.3]  */
							promise.reject(r);
						}
					);
				}
				catch (e) {
					if (!resolved)                                       /*  [Promises/A+ 2.3.3.3.3]  */
						promise.reject(e);                               /*  [Promises/A+ 2.3.3.3.4]  */
				}
				return;
			}

			/*  handle other values  */
			promise.fulfill(x);                                          /*  [Promises/A+ 2.3.4, 2.3.3.4]  */
		};

		/*  export API  */
		return api;
	})(),

	//jscs:enable

	// Event
	// A contructor superclass for adding event menthods, on, off, emit.
	Event: function() {

		var separator = /[\s\,]+/;

		// If this doesn't support getPrototype then we can't get prototype.events of the parent
		// So lets get the current instance events, and add those to a parent property
		this.parent = {
			events: this.events,
			findEvents: this.findEvents,
			parent: this.parent,
			utils: this.utils
		};

		this.events = {};

		// On, subscribe to events
		// @param evt   string
		// @param callback  function
		this.on = function(evt, callback) {

			if (callback && typeof (callback) === 'function') {
				var a = evt.split(separator);
				for (var i = 0; i < a.length; i++) {

					// Has this event already been fired on this instance?
					this.events[a[i]] = [callback].concat(this.events[a[i]] || []);
				}
			}

			return this;
		};

		// Off, unsubscribe to events
		// @param evt   string
		// @param callback  function
		this.off = function(evt, callback) {

			this.findEvents(evt, function(name, index) {
				if (!callback || this.events[name][index] === callback) {
					this.events[name][index] = null;
				}
			});

			return this;
		};

		// Emit
		// Triggers any subscribed events
		this.emit = function(evt /*, data, ... */) {

			// Get arguments as an Array, knock off the first one
			var args = Array.prototype.slice.call(arguments, 1);
			args.push(evt);

			// Handler
			var handler = function(name, index) {

				// Replace the last property with the event name
				args[args.length - 1] = (name === '*' ? evt : name);

				// Trigger
				this.events[name][index].apply(this, args);
			};

			// Find the callbacks which match the condition and call
			var _this = this;
			while (_this && _this.findEvents) {

				// Find events which match
				_this.findEvents(evt + ',*', handler);
				_this = _this.parent;
			}

			return this;
		};

		//
		// Easy functions
		this.emitAfter = function() {
			var _this = this;
			var args = arguments;
			setTimeout(function() {
				_this.emit.apply(_this, args);
			}, 0);

			return this;
		};

		this.findEvents = function(evt, callback) {

			var a = evt.split(separator);

			for (var name in this.events) {if (this.events.hasOwnProperty(name)) {

				if (a.indexOf(name) > -1) {

					for (var i = 0; i < this.events[name].length; i++) {

						// Does the event handler exist?
						if (this.events[name][i]) {
							// Emit on the local instance of this
							callback.call(this, name, i);
						}
					}
				}
			}}
		};

		return this;
	},

	// Global Events
	// Attach the callback to the window object
	// Return its unique reference
	globalEvent: function(callback, guid) {
		// If the guid has not been supplied then create a new one.
		guid = guid || '_hellojs_' + parseInt(Math.random() * 1e12, 10).toString(36);

		// Define the callback function
		window[guid] = function() {
			// Trigger the callback
			try {
				if (callback.apply(this, arguments)) {
					delete window[guid];
				}
			}
			catch (e) {
				console.error(e);
			}
		};

		return guid;
	},

	// Trigger a clientside popup
	// This has been augmented to support PhoneGap
	popup: function(url, redirectUri, options) {

		var documentElement = document.documentElement;

		// Multi Screen Popup Positioning (http://stackoverflow.com/a/16861050)
		// Credit: http://www.xtf.dk/2011/08/center-new-popup-window-even-on.html
		// Fixes dual-screen position                         Most browsers      Firefox

		if (options.height && options.top === undefined) {
			var dualScreenTop = window.screenTop !== undefined ? window.screenTop : screen.top;
			var height = screen.height || window.innerHeight || documentElement.clientHeight;
			options.top = parseInt((height - options.height) / 2, 10) + dualScreenTop;
		}

		if (options.width && options.left === undefined) {
			var dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : screen.left;
			var width = screen.width || window.innerWidth || documentElement.clientWidth;
			options.left = parseInt((width - options.width) / 2, 10) + dualScreenLeft;
		}

		// Convert options into an array
		var optionsArray = [];
		Object.keys(options).forEach(function(name) {
			var value = options[name];
			optionsArray.push(name + (value !== null ? '=' + value : ''));
		});

		// Call the open() function with the initial path
		//
		// OAuth redirect, fixes URI fragments from being lost in Safari
		// (URI Fragments within 302 Location URI are lost over HTTPS)
		// Loading the redirect.html before triggering the OAuth Flow seems to fix it.
		//
		// Firefox  decodes URL fragments when calling location.hash.
		//  - This is bad if the value contains break points which are escaped
		//  - Hence the url must be encoded twice as it contains breakpoints.
		if (navigator.userAgent.indexOf('Safari') !== -1 && navigator.userAgent.indexOf('Chrome') === -1) {
			url = redirectUri + '#oauth_redirect=' + encodeURIComponent(encodeURIComponent(url));
		}

		var popup = window.open(
			url,
			'_blank',
			optionsArray.join(',')
		);

		if (popup && popup.focus) {
			popup.focus();
		}

		return popup;
	},

	// OAuth and API response handler
	responseHandler: function(window, parent) {

		var _this = this;
		var p;
		var location = window.location;

		// Is this an auth relay message which needs to call the proxy?
		p = _this.param(location.search);

		// OAuth2 or OAuth1 server response?
		if (p && p.state && (p.code || p.oauth_token)) {

			var state = JSON.parse(p.state);

			// Add this path as the redirect_uri
			p.redirect_uri = state.redirect_uri || location.href.replace(/[\?\#].*$/, '');

			// Redirect to the host
			var path = _this.qs(state.oauth_proxy, p);

			location.assign(path);

			return;
		}

		// Save session, from redirected authentication
		// #access_token has come in?
		//
		// FACEBOOK is returning auth errors within as a query_string... thats a stickler for consistency.
		// SoundCloud is the state in the querystring and the token in the hashtag, so we'll mix the two together

		p = _this.merge(_this.param(location.search || ''), _this.param(location.hash || ''));

		// If p.state
		if (p && 'state' in p) {

			// Remove any addition information
			// E.g. p.state = 'facebook.page';
			try {
				var a = JSON.parse(p.state);
				_this.extend(p, a);
			}
			catch (e) {
				var stateDecoded = decodeURIComponent(p.state);
				try {
					var b = JSON.parse(stateDecoded);
					_this.extend(p, b);
				}
				catch (e) {
					console.error('Could not decode state parameter');
				}
			}

			// Access_token?
			if (('access_token' in p && p.access_token) && p.network) {

				if (!p.expires_in || parseInt(p.expires_in, 10) === 0) {
					// If p.expires_in is unset, set to 0
					p.expires_in = 0;
				}

				p.expires_in = parseInt(p.expires_in, 10);
				p.expires = ((new Date()).getTime() / 1e3) + (p.expires_in || (60 * 60 * 24 * 365));

				// Lets use the ""state"" to assign it to one of our networks
				authCallback(p, window, parent);
			}

			// Error=?
			// &error_description=?
			// &state=?
			else if (('error' in p && p.error) && p.network) {

				p.error = {
					code: p.error,
					message: p.error_message || p.error_description
				};

				// Let the state handler handle it
				authCallback(p, window, parent);
			}

			// API call, or a cancelled login
			// Result is serialized JSON string
			else if (p.callback && p.callback in parent) {

				// Trigger a function in the parent
				var res = 'result' in p && p.result ? JSON.parse(p.result) : false;

				// Trigger the callback on the parent
				callback(parent, p.callback)(res);
				closeWindow();
			}

			// If this page is still open
			if (p.page_uri && isValidUrl(p.page_uri)) {
				location.assign(p.page_uri);
			}
		}

		// OAuth redirect, fixes URI fragments from being lost in Safari
		// (URI Fragments within 302 Location URI are lost over HTTPS)
		// Loading the redirect.html before triggering the OAuth Flow seems to fix it.
		else if ('oauth_redirect' in p) {
			var url = decodeURIComponent(p.oauth_redirect);

			if (isValidUrl(url)) {
				location.assign(url);
			}

			return;
		}

		function isValidUrl(url) {
			var regexp = /^https?:/;
			return regexp.test(url);
		}

		// Trigger a callback to authenticate
		function authCallback(obj, window, parent) {

			var cb = obj.callback;
			var network = obj.network;

			// Trigger the callback on the parent
			_this.store(network, obj);

			// If this is a page request it has no parent or opener window to handle callbacks
			if (('display' in obj) && obj.display === 'page') {
				return;
			}

			// Remove from session object
			if (parent && cb && cb in parent) {

				try {
					delete obj.callback;
				}
				catch (e) {}

				// Update store
				_this.store(network, obj);

				// Call the globalEvent function on the parent
				// It's safer to pass back a string to the parent,
				// Rather than an object/array (better for IE8)
				var str = JSON.stringify(obj);

				try {
					callback(parent, cb)(str);
				}
				catch (e) {
					// Error thrown whilst executing parent callback
				}
			}

			closeWindow();
		}

		function callback(parent, callbackID) {
			if (callbackID.indexOf('_hellojs_') !== 0) {
				return function() {
					throw 'Could not execute callback ' + callbackID;
				};
			}

			return parent[callbackID];
		}

		function closeWindow() {

			if (window.frameElement) {
				// Inside an iframe, remove from parent
				parent.document.body.removeChild(window.frameElement);
			}
			else {
				// Close this current window
				try {
					window.close();
				}
				catch (e) {}

				// IOS bug wont let us close a popup if still loading
				if (window.addEventListener) {
					window.addEventListener('load', function() {
						window.close();
					});
				}
			}

		}
	}
});

// Events
// Extend the hello object with its own event instance
hello.utils.Event.call(hello);

///////////////////////////////////
// Monitoring session state
// Check for session changes
///////////////////////////////////

(function(hello) {

	// Monitor for a change in state and fire
	var oldSessions = {};

	// Hash of expired tokens
	var expired = {};

	// Listen to other triggers to Auth events, use these to update this
	hello.on('auth.login, auth.logout', function(auth) {
		if (auth && typeof (auth) === 'object' && auth.network) {
			oldSessions[auth.network] = hello.utils.store(auth.network) || {};
		}
	});

	(function self() {

		var CURRENT_TIME = ((new Date()).getTime() / 1e3);
		var emit = function(eventName) {
			hello.emit('auth.' + eventName, {
				network: name,
				authResponse: session
			});
		};

		// Loop through the services
		for (var name in hello.services) {if (hello.services.hasOwnProperty(name)) {

			if (!hello.services[name].id) {
				// We haven't attached an ID so dont listen.
				continue;
			}

			// Get session
			var session = hello.utils.store(name) || {};
			var provider = hello.services[name];
			var oldSess = oldSessions[name] || {};

			// Listen for globalEvents that did not get triggered from the child
			if (session && 'callback' in session) {

				// To do remove from session object...
				var cb = session.callback;
				try {
					delete session.callback;
				}
				catch (e) {}

				// Update store
				// Removing the callback
				hello.utils.store(name, session);

				// Emit global events
				try {
					window[cb](session);
				}
				catch (e) {}
			}

			// Refresh token
			if (session && ('expires' in session) && session.expires < CURRENT_TIME) {

				// If auto refresh is possible
				// Either the browser supports
				var refresh = provider.refresh || session.refresh_token;

				// Has the refresh been run recently?
				if (refresh && (!(name in expired) || expired[name] < CURRENT_TIME)) {
					// Try to resignin
					hello.emit('notice', name + ' has expired trying to resignin');
					hello.login(name, {display: 'none', force: false});

					// Update expired, every 10 minutes
					expired[name] = CURRENT_TIME + 600;
				}

				// Does this provider not support refresh
				else if (!refresh && !(name in expired)) {
					// Label the event
					emit('expired');
					expired[name] = true;
				}

				// If session has expired then we dont want to store its value until it can be established that its been updated
				continue;
			}

			// Has session changed?
			else if (oldSess.access_token === session.access_token &&
			oldSess.expires === session.expires) {
				continue;
			}

			// Access_token has been removed
			else if (!session.access_token && oldSess.access_token) {
				emit('logout');
			}

			// Access_token has been created
			else if (session.access_token && !oldSess.access_token) {
				emit('login');
			}

			// Access_token has been updated
			else if (session.expires !== oldSess.expires) {
				emit('update');
			}

			// Updated stored session
			oldSessions[name] = session;

			// Remove the expired flags
			if (name in expired) {
				delete expired[name];
			}
		}}

		// Check error events
		setTimeout(self, 1000);
	})();

})(hello);

// EOF CORE lib
//////////////////////////////////

/////////////////////////////////////////
// API
// @param path    string
// @param query   object (optional)
// @param method  string (optional)
// @param data    object (optional)
// @param timeout integer (optional)
// @param callback  function (optional)

hello.api = function() {

	// Shorthand
	var _this = this;
	var utils = _this.utils;
	var error = utils.error;

	// Construct a new Promise object
	var promise = utils.Promise();

	// Arguments
	var p = utils.args({path: 's!', query: 'o', method: 's', data: 'o', timeout: 'i', callback: 'f'}, arguments);

	// Method
	p.method = (p.method || 'get').toLowerCase();

	// Headers
	p.headers = p.headers || {};

	// Query
	p.query = p.query || {};

	// If get, put all parameters into query
	if (p.method === 'get' || p.method === 'delete') {
		utils.extend(p.query, p.data);
		p.data = {};
	}

	var data = p.data = p.data || {};

	// Completed event callback
	promise.then(p.callback, p.callback);

	// Remove the network from path, e.g. facebook:/me/friends
	// Results in { network : facebook, path : me/friends }
	if (!p.path) {
		return promise.reject(error('invalid_path', 'Missing the path parameter from the request'));
	}

	p.path = p.path.replace(/^\/+/, '');
	var a = (p.path.split(/[\/\:]/, 2) || [])[0].toLowerCase();

	if (a in _this.services) {
		p.network = a;
		var reg = new RegExp('^' + a + ':?\/?');
		p.path = p.path.replace(reg, '');
	}

	// Network & Provider
	// Define the network that this request is made for
	p.network = _this.settings.default_service = p.network || _this.settings.default_service;
	var o = _this.services[p.network];

	// INVALID
	// Is there no service by the given network name?
	if (!o) {
		return promise.reject(error('invalid_network', 'Could not match the service requested: ' + p.network));
	}

	// PATH
	// As long as the path isn't flagged as unavaiable, e.g. path == false

	if (!(!(p.method in o) || !(p.path in o[p.method]) || o[p.method][p.path] !== false)) {
		return promise.reject(error('invalid_path', 'The provided path is not available on the selected network'));
	}

	// PROXY
	// OAuth1 calls always need a proxy

	if (!p.oauth_proxy) {
		p.oauth_proxy = _this.settings.oauth_proxy;
	}

	if (!('proxy' in p)) {
		p.proxy = p.oauth_proxy && o.oauth && parseInt(o.oauth.version, 10) === 1;
	}

	// TIMEOUT
	// Adopt timeout from global settings by default

	if (!('timeout' in p)) {
		p.timeout = _this.settings.timeout;
	}

	// Format response
	// Whether to run the raw response through post processing.
	if (!('formatResponse' in p)) {
		p.formatResponse = true;
	}

	// Get the current session
	// Append the access_token to the query
	p.authResponse = _this.getAuthResponse(p.network);
	if (p.authResponse && p.authResponse.access_token) {
		p.query.access_token = p.authResponse.access_token;
	}

	var url = p.path;
	var m;

	// Store the query as options
	// This is used to populate the request object before the data is augmented by the prewrap handlers.
	p.options = utils.clone(p.query);

	// Clone the data object
	// Prevent this script overwriting the data of the incoming object.
	// Ensure that everytime we run an iteration the callbacks haven't removed some data
	p.data = utils.clone(data);

	// URL Mapping
	// Is there a map for the given URL?
	var actions = o[{'delete': 'del'}[p.method] || p.method] || {};

	// Extrapolate the QueryString
	// Provide a clean path
	// Move the querystring into the data
	if (p.method === 'get') {

		var query = url.split(/[\?#]/)[1];
		if (query) {
			utils.extend(p.query, utils.param(query));

			// Remove the query part from the URL
			url = url.replace(/\?.*?(#|$)/, '$1');
		}
	}

	// Is the hash fragment defined
	if ((m = url.match(/#(.+)/, ''))) {
		url = url.split('#')[0];
		p.path = m[1];
	}
	else if (url in actions) {
		p.path = url;
		url = actions[url];
	}
	else if ('default' in actions) {
		url = actions['default'];
	}

	// Redirect Handler
	// This defines for the Form+Iframe+Hash hack where to return the results too.
	p.redirect_uri = _this.settings.redirect_uri;

	// Define FormatHandler
	// The request can be procesed in a multitude of ways
	// Here's the options - depending on the browser and endpoint
	p.xhr = o.xhr;
	p.jsonp = o.jsonp;
	p.form = o.form;

	// Make request
	if (typeof (url) === 'function') {
		// Does self have its own callback?
		url(p, getPath);
	}
	else {
		// Else the URL is a string
		getPath(url);
	}

	return promise.proxy;

	// If url needs a base
	// Wrap everything in
	function getPath(url) {

		// Format the string if it needs it
		url = url.replace(/\@\{([a-z\_\-]+)(\|.*?)?\}/gi, function(m, key, defaults) {
			var val = defaults ? defaults.replace(/^\|/, '') : '';
			if (key in p.query) {
				val = p.query[key];
				delete p.query[key];
			}
			else if (p.data && key in p.data) {
				val = p.data[key];
				delete p.data[key];
			}
			else if (!defaults) {
				promise.reject(error('missing_attribute', 'The attribute ' + key + ' is missing from the request'));
			}

			return val;
		});

		// Add base
		if (!url.match(/^https?:\/\//)) {
			url = o.base + url;
		}

		// Define the request URL
		p.url = url;

		// Make the HTTP request with the curated request object
		// CALLBACK HANDLER
		// @ response object
		// @ statusCode integer if available
		utils.request(p, function(r, headers) {

			// Is this a raw response?
			if (!p.formatResponse) {
				// Bad request? error statusCode or otherwise contains an error response vis JSONP?
				if (typeof headers === 'object' ? (headers.statusCode >= 400) : (typeof r === 'object' && 'error' in r)) {
					promise.reject(r);
				}
				else {
					promise.fulfill(r);
				}

				return;
			}

			// Should this be an object
			if (r === true) {
				r = {success:true};
			}
			else if (!r) {
				r = {};
			}

			// The delete callback needs a better response
			if (p.method === 'delete') {
				r = (!r || utils.isEmpty(r)) ? {success:true} : r;
			}

			// FORMAT RESPONSE?
			// Does self request have a corresponding formatter
			if (o.wrap && ((p.path in o.wrap) || ('default' in o.wrap))) {
				var wrap = (p.path in o.wrap ? p.path : 'default');
				var time = (new Date()).getTime();

				// FORMAT RESPONSE
				var b = o.wrap[wrap](r, headers, p);

				// Has the response been utterly overwritten?
				// Typically self augments the existing object.. but for those rare occassions
				if (b) {
					r = b;
				}
			}

			// Is there a next_page defined in the response?
			if (r && 'paging' in r && r.paging.next) {

				// Add the relative path if it is missing from the paging/next path
				if (r.paging.next[0] === '?') {
					r.paging.next = p.path + r.paging.next;
				}

				// The relative path has been defined, lets markup the handler in the HashFragment
				else {
					r.paging.next += '#' + p.path;
				}
			}

			// Dispatch to listeners
			// Emit events which pertain to the formatted response
			if (!r || 'error' in r) {
				promise.reject(r);
			}
			else {
				promise.fulfill(r);
			}
		});
	}
};

// API utilities
hello.utils.extend(hello.utils, {

	// Make an HTTP request
	request: function(p, callback) {

		var _this = this;
		var error = _this.error;

		// This has to go through a POST request
		if (!_this.isEmpty(p.data) && !('FileList' in window) && _this.hasBinary(p.data)) {

			// Disable XHR and JSONP
			p.xhr = false;
			p.jsonp = false;
		}

		// Check if the browser and service support CORS
		var cors = this.request_cors(function() {
			// If it does then run this...
			return ((p.xhr === undefined) || (p.xhr && (typeof (p.xhr) !== 'function' || p.xhr(p, p.query))));
		});

		if (cors) {

			formatUrl(p, function(url) {

				var x = _this.xhr(p.method, url, p.headers, p.data, callback);
				x.onprogress = p.onprogress || null;

				// Windows Phone does not support xhr.upload, see #74
				// Feature detect
				if (x.upload && p.onuploadprogress) {
					x.upload.onprogress = p.onuploadprogress;
				}

			});

			return;
		}

		// Clone the query object
		// Each request modifies the query object and needs to be tared after each one.
		var _query = p.query;

		p.query = _this.clone(p.query);

		// Assign a new callbackID
		p.callbackID = _this.globalEvent();

		// JSONP
		if (p.jsonp !== false) {

			// Clone the query object
			p.query.callback = p.callbackID;

			// If the JSONP is a function then run it
			if (typeof (p.jsonp) === 'function') {
				p.jsonp(p, p.query);
			}

			// Lets use JSONP if the method is 'get'
			if (p.method === 'get') {

				formatUrl(p, function(url) {
					_this.jsonp(url, callback, p.callbackID, p.timeout);
				});

				return;
			}
			else {
				// It's not compatible reset query
				p.query = _query;
			}

		}

		// Otherwise we're on to the old school, iframe hacks and JSONP
		if (p.form !== false) {

			// Add some additional query parameters to the URL
			// We're pretty stuffed if the endpoint doesn't like these
			p.query.redirect_uri = p.redirect_uri;
			p.query.state = JSON.stringify({callback:p.callbackID});

			var opts;

			if (typeof (p.form) === 'function') {

				// Format the request
				opts = p.form(p, p.query);
			}

			if (p.method === 'post' && opts !== false) {

				formatUrl(p, function(url) {
					_this.post(url, p.data, opts, callback, p.callbackID, p.timeout);
				});

				return;
			}
		}

		// None of the methods were successful throw an error
		callback(error('invalid_request', 'There was no mechanism for handling this request'));

		return;

		// Format URL
		// Constructs the request URL, optionally wraps the URL through a call to a proxy server
		// Returns the formatted URL
		function formatUrl(p, callback) {

			// Are we signing the request?
			var sign;

			// OAuth1
			// Remove the token from the query before signing
			if (p.authResponse && p.authResponse.oauth && parseInt(p.authResponse.oauth.version, 10) === 1) {

				// OAUTH SIGNING PROXY
				sign = p.query.access_token;

				// Remove the access_token
				delete p.query.access_token;

				// Enfore use of Proxy
				p.proxy = true;
			}

			// POST body to querystring
			if (p.data && (p.method === 'get' || p.method === 'delete')) {
				// Attach the p.data to the querystring.
				_this.extend(p.query, p.data);
				p.data = null;
			}

			// Construct the path
			var path = _this.qs(p.url, p.query);

			// Proxy the request through a server
			// Used for signing OAuth1
			// And circumventing services without Access-Control Headers
			if (p.proxy) {
				// Use the proxy as a path
				path = _this.qs(p.oauth_proxy, {
					path: path,
					access_token: sign || '',

					// This will prompt the request to be signed as though it is OAuth1
					then: p.proxy_response_type || (p.method.toLowerCase() === 'get' ? 'redirect' : 'proxy'),
					method: p.method.toLowerCase(),
					suppress_response_codes: p.suppress_response_codes || true
				});
			}

			callback(path);
		}
	},

	// Test whether the browser supports the CORS response
	request_cors: function(callback) {
		return 'withCredentials' in new XMLHttpRequest() && callback();
	},

	// Return the type of DOM object
	domInstance: function(type, data) {
		var test = 'HTML' + (type || '').replace(
			/^[a-z]/,
			function(m) {
				return m.toUpperCase();
			}

		) + 'Element';

		if (!data) {
			return false;
		}

		if (window[test]) {
			return data instanceof window[test];
		}
		else if (window.Element) {
			return data instanceof window.Element && (!type || (data.tagName && data.tagName.toLowerCase() === type));
		}
		else {
			return (!(data instanceof Object || data instanceof Array || data instanceof String || data instanceof Number) && data.tagName && data.tagName.toLowerCase() === type);
		}
	},

	// Create a clone of an object
	clone: function(obj) {
		// Does not clone DOM elements, nor Binary data, e.g. Blobs, Filelists
		if (obj === null || typeof (obj) !== 'object' || obj instanceof Date || 'nodeName' in obj || this.isBinary(obj) || (typeof FormData === 'function' && obj instanceof FormData)) {
			return obj;
		}

		if (Array.isArray(obj)) {
			// Clone each item in the array
			return obj.map(this.clone.bind(this));
		}

		// But does clone everything else.
		var clone = {};
		for (var x in obj) {
			clone[x] = this.clone(obj[x]);
		}

		return clone;
	},

	// XHR: uses CORS to make requests
	xhr: function(method, url, headers, data, callback) {

		var r = new XMLHttpRequest();
		var error = this.error;

		// Binary?
		var binary = false;
		if (method === 'blob') {
			binary = method;
			method = 'GET';
		}

		method = method.toUpperCase();

		// Xhr.responseType 'json' is not supported in any of the vendors yet.
		r.onload = function(e) {
			var json = r.response;
			try {
				json = JSON.parse(r.responseText);
			}
			catch (_e) {
				if (r.status === 401) {
					json = error('access_denied', r.statusText);
				}
			}

			var headers = headersToJSON(r.getAllResponseHeaders());
			headers.statusCode = r.status;

			callback(json || (method === 'GET' ? error('empty_response', 'Could not get resource') : {}), headers);
		};

		r.onerror = function(e) {
			var json = r.responseText;
			try {
				json = JSON.parse(r.responseText);
			}
			catch (_e) {}

			callback(json || error('access_denied', 'Could not get resource'));
		};

		var x;

		// Should we add the query to the URL?
		if (method === 'GET' || method === 'DELETE') {
			data = null;
		}
		else if (data && typeof (data) !== 'string' && !(data instanceof FormData) && !(data instanceof File) && !(data instanceof Blob)) {
			// Loop through and add formData
			var f = new FormData();
			for (x in data) if (data.hasOwnProperty(x)) {
				if (data[x] instanceof HTMLInputElement) {
					if ('files' in data[x] && data[x].files.length > 0) {
						f.append(x, data[x].files[0]);
					}
				}
				else if (data[x] instanceof Blob) {
					f.append(x, data[x], data.name);
				}
				else {
					f.append(x, data[x]);
				}
			}

			data = f;
		}

		// Open the path, async
		r.open(method, url, true);

		if (binary) {
			if ('responseType' in r) {
				r.responseType = binary;
			}
			else {
				r.overrideMimeType('text/plain; charset=x-user-defined');
			}
		}

		// Set any bespoke headers
		if (headers) {
			for (x in headers) {
				r.setRequestHeader(x, headers[x]);
			}
		}

		r.send(data);

		return r;

		// Headers are returned as a string
		function headersToJSON(s) {
			var r = {};
			var reg = /([a-z\-]+):\s?(.*);?/gi;
			var m;
			while ((m = reg.exec(s))) {
				r[m[1]] = m[2];
			}

			return r;
		}
	},

	// JSONP
	// Injects a script tag into the DOM to be executed and appends a callback function to the window object
	// @param string/function pathFunc either a string of the URL or a callback function pathFunc(querystringhash, continueFunc);
	// @param function callback a function to call on completion;
	jsonp: function(url, callback, callbackID, timeout) {

		var _this = this;
		var error = _this.error;

		// Change the name of the callback
		var bool = 0;
		var head = document.getElementsByTagName('head')[0];
		var operaFix;
		var result = error('server_error', 'server_error');
		var cb = function() {
			if (!(bool++)) {
				window.setTimeout(function() {
					callback(result);
					head.removeChild(script);
				}, 0);
			}

		};

		// Add callback to the window object
		callbackID = _this.globalEvent(function(json) {
			result = json;
			return true;

			// Mark callback as done
		}, callbackID);

		// The URL is a function for some cases and as such
		// Determine its value with a callback containing the new parameters of this function.
		url = url.replace(new RegExp('=\\?(&|$)'), '=' + callbackID + '$1');

		// Build script tag
		var script = _this.append('script', {
			id: callbackID,
			name: callbackID,
			src: url,
			async: true,
			onload: cb,
			onerror: cb,
			onreadystatechange: function() {
				if (/loaded|complete/i.test(this.readyState)) {
					cb();
				}
			}
		});

		// Opera fix error
		// Problem: If an error occurs with script loading Opera fails to trigger the script.onerror handler we specified
		//
		// Fix:
		// By setting the request to synchronous we can trigger the error handler when all else fails.
		// This action will be ignored if we've already called the callback handler ""cb"" with a successful onload event
		if (window.navigator.userAgent.toLowerCase().indexOf('opera') > -1) {
			operaFix = _this.append('script', {
				text: 'document.getElementById(\'' + callbackID + '\').onerror();'
			});
			script.async = false;
		}

		// Add timeout
		if (timeout) {
			window.setTimeout(function() {
				result = error('timeout', 'timeout');
				cb();
			}, timeout);
		}

		// TODO: add fix for IE,
		// However: unable recreate the bug of firing off the onreadystatechange before the script content has been executed and the value of ""result"" has been defined.
		// Inject script tag into the head element
		head.appendChild(script);

		// Append Opera Fix to run after our script
		if (operaFix) {
			head.appendChild(operaFix);
		}
	},

	// Post
	// Send information to a remote location using the post mechanism
	// @param string uri path
	// @param object data, key value data to send
	// @param function callback, function to execute in response
	post: function(url, data, options, callback, callbackID, timeout) {

		var _this = this;
		var error = _this.error;
		var doc = document;

		// This hack needs a form
		var form = null;
		var reenableAfterSubmit = [];
		var newform;
		var i = 0;
		var x = null;
		var bool = 0;
		var cb = function(r) {
			if (!(bool++)) {
				callback(r);
			}
		};

		// What is the name of the callback to contain
		// We'll also use this to name the iframe
		_this.globalEvent(cb, callbackID);

		// Build the iframe window
		var win;
		try {
			// IE7 hack, only lets us define the name here, not later.
			win = doc.createElement('<iframe name=""' + callbackID + '"">');
		}
		catch (e) {
			win = doc.createElement('iframe');
		}

		win.name = callbackID;
		win.id = callbackID;
		win.style.display = 'none';

		// Override callback mechanism. Triggger a response onload/onerror
		if (options && options.callbackonload) {
			// Onload is being fired twice
			win.onload = function() {
				cb({
					response: 'posted',
					message: 'Content was posted'
				});
			};
		}

		if (timeout) {
			setTimeout(function() {
				cb(error('timeout', 'The post operation timed out'));
			}, timeout);
		}

		doc.body.appendChild(win);

		// If we are just posting a single item
		if (_this.domInstance('form', data)) {
			// Get the parent form
			form = data.form;

			// Loop through and disable all of its siblings
			for (i = 0; i < form.elements.length; i++) {
				if (form.elements[i] !== data) {
					form.elements[i].setAttribute('disabled', true);
				}
			}

			// Move the focus to the form
			data = form;
		}

		// Posting a form
		if (_this.domInstance('form', data)) {
			// This is a form element
			form = data;

			// Does this form need to be a multipart form?
			for (i = 0; i < form.elements.length; i++) {
				if (!form.elements[i].disabled && form.elements[i].type === 'file') {
					form.encoding = form.enctype = 'multipart/form-data';
					form.elements[i].setAttribute('name', 'file');
				}
			}
		}
		else {
			// Its not a form element,
			// Therefore it must be a JSON object of Key=>Value or Key=>Element
			// If anyone of those values are a input type=file we shall shall insert its siblings into the form for which it belongs.
			for (x in data) if (data.hasOwnProperty(x)) {
				// Is this an input Element?
				if (_this.domInstance('input', data[x]) && data[x].type === 'file') {
					form = data[x].form;
					form.encoding = form.enctype = 'multipart/form-data';
				}
			}

			// Do If there is no defined form element, lets create one.
			if (!form) {
				// Build form
				form = doc.createElement('form');
				doc.body.appendChild(form);
				newform = form;
			}

			var input;

			// Add elements to the form if they dont exist
			for (x in data) if (data.hasOwnProperty(x)) {

				// Is this an element?
				var el = (_this.domInstance('input', data[x]) || _this.domInstance('textArea', data[x]) || _this.domInstance('select', data[x]));

				// Is this not an input element, or one that exists outside the form.
				if (!el || data[x].form !== form) {

					// Does an element have the same name?
					var inputs = form.elements[x];
					if (input) {
						// Remove it.
						if (!(inputs instanceof NodeList)) {
							inputs = [inputs];
						}

						for (i = 0; i < inputs.length; i++) {
							inputs[i].parentNode.removeChild(inputs[i]);
						}

					}

					// Create an input element
					input = doc.createElement('input');
					input.setAttribute('type', 'hidden');
					input.setAttribute('name', x);

					// Does it have a value attribute?
					if (el) {
						input.value = data[x].value;
					}
					else if (_this.domInstance(null, data[x])) {
						input.value = data[x].innerHTML || data[x].innerText;
					}
					else {
						input.value = data[x];
					}

					form.appendChild(input);
				}

				// It is an element, which exists within the form, but the name is wrong
				else if (el && data[x].name !== x) {
					data[x].setAttribute('name', x);
					data[x].name = x;
				}
			}

			// Disable elements from within the form if they weren't specified
			for (i = 0; i < form.elements.length; i++) {

				input = form.elements[i];

				// Does the same name and value exist in the parent
				if (!(input.name in data) && input.getAttribute('disabled') !== true) {
					// Disable
					input.setAttribute('disabled', true);

					// Add re-enable to callback
					reenableAfterSubmit.push(input);
				}
			}
		}

		// Set the target of the form
		form.setAttribute('method', 'POST');
		form.setAttribute('target', callbackID);
		form.target = callbackID;

		// Update the form URL
		form.setAttribute('action', url);

		// Submit the form
		// Some reason this needs to be offset from the current window execution
		setTimeout(function() {
			form.submit();

			setTimeout(function() {
				try {
					// Remove the iframe from the page.
					//win.parentNode.removeChild(win);
					// Remove the form
					if (newform) {
						newform.parentNode.removeChild(newform);
					}
				}
				catch (e) {
					try {
						console.error('HelloJS: could not remove iframe');
					}
					catch (ee) {}
				}

				// Reenable the disabled form
				for (var i = 0; i < reenableAfterSubmit.length; i++) {
					if (reenableAfterSubmit[i]) {
						reenableAfterSubmit[i].setAttribute('disabled', false);
						reenableAfterSubmit[i].disabled = false;
					}
				}
			}, 0);
		}, 100);
	},

	// Some of the providers require that only multipart is used with non-binary forms.
	// This function checks whether the form contains binary data
	hasBinary: function(data) {
		for (var x in data) if (data.hasOwnProperty(x)) {
			if (this.isBinary(data[x])) {
				return true;
			}
		}

		return false;
	},

	// Determines if a variable Either Is or like a FormInput has the value of a Blob

	isBinary: function(data) {

		return data instanceof Object && (
		(this.domInstance('input', data) && data.type === 'file') ||
		('FileList' in window && data instanceof window.FileList) ||
		('File' in window && data instanceof window.File) ||
		('Blob' in window && data instanceof window.Blob));

	},

	// Convert Data-URI to Blob string
	toBlob: function(dataURI) {
		var reg = /^data\:([^;,]+(\;charset=[^;,]+)?)(\;base64)?,/i;
		var m = dataURI.match(reg);
		if (!m) {
			return dataURI;
		}

		var binary = atob(dataURI.replace(reg, ''));
		var array = [];
		for (var i = 0; i < binary.length; i++) {
			array.push(binary.charCodeAt(i));
		}

		return new Blob([new Uint8Array(array)], {type: m[1]});
	}

});

// EXTRA: Convert FormElement to JSON for POSTing
// Wrappers to add additional functionality to existing functions
(function(hello) {

	// Copy original function
	var api = hello.api;
	var utils = hello.utils;

	utils.extend(utils, {

		// DataToJSON
		// This takes a FormElement|NodeList|InputElement|MixedObjects and convers the data object to JSON.
		dataToJSON: function(p) {

			var _this = this;
			var w = window;
			var data = p.data;

			// Is data a form object
			if (_this.domInstance('form', data)) {
				data = _this.nodeListToJSON(data.elements);
			}
			else if ('NodeList' in w && data instanceof NodeList) {
				data = _this.nodeListToJSON(data);
			}
			else if (_this.domInstance('input', data)) {
				data = _this.nodeListToJSON([data]);
			}

			// Is data a blob, File, FileList?
			if (('File' in w && data instanceof w.File) ||
				('Blob' in w && data instanceof w.Blob) ||
				('FileList' in w && data instanceof w.FileList)) {
				data = {file: data};
			}

			// Loop through data if it's not form data it must now be a JSON object
			if (!('FormData' in w && data instanceof w.FormData)) {

				for (var x in data) if (data.hasOwnProperty(x)) {

					if ('FileList' in w && data[x] instanceof w.FileList) {
						if (data[x].length === 1) {
							data[x] = data[x][0];
						}
					}
					else if (_this.domInstance('input', data[x]) && data[x].type === 'file') {
						continue;
					}
					else if (_this.domInstance('input', data[x]) ||
						_this.domInstance('select', data[x]) ||
						_this.domInstance('textArea', data[x])) {
						data[x] = data[x].value;
					}
					else if (_this.domInstance(null, data[x])) {
						data[x] = data[x].innerHTML || data[x].innerText;
					}
				}
			}

			p.data = data;
			return data;
		},

		// NodeListToJSON
		// Given a list of elements extrapolate their values and return as a json object
		nodeListToJSON: function(nodelist) {

			var json = {};

			// Create a data string
			for (var i = 0; i < nodelist.length; i++) {

				var input = nodelist[i];

				// If the name of the input is empty or diabled, dont add it.
				if (input.disabled || !input.name) {
					continue;
				}

				// Is this a file, does the browser not support 'files' and 'FormData'?
				if (input.type === 'file') {
					json[input.name] = input;
				}
				else {
					json[input.name] = input.value || input.innerHTML;
				}
			}

			return json;
		}
	});

	// Replace it
	hello.api = function() {

		// Get arguments
		var p = utils.args({path: 's!', method: 's', data:'o', timeout: 'i', callback: 'f'}, arguments);

		// Change for into a data object
		if (p.data) {
			utils.dataToJSON(p);
		}

		return api.call(this, p);
	};

})(hello);

/////////////////////////////////////
//
// Save any access token that is in the current page URL
// Handle any response solicited through iframe hash tag following an API request
//
/////////////////////////////////////

hello.utils.responseHandler(window, window.opener || window.parent);
"
"// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-

const Lang = imports.lang;
const Signals = imports.signals;

const GLib = imports.gi.GLib;
const Gio = imports.gi.Gio;
const St = imports.gi.St;

const ExtensionUtils = imports.misc.extensionUtils;
const Main = imports.ui.main;

const ExtensionState = {
    ENABLED: 1,
    DISABLED: 2,
    ERROR: 3,
    OUT_OF_DATE: 4,
    DOWNLOADING: 5,
    INITIALIZED: 6,

    // Used as an error state for operations on unknown extensions,
    // should never be in a real extensionMeta object.
    UNINSTALLED: 99
};

// Arrays of uuids
var enabledExtensions;
// Contains the order that extensions were enabled in.
const extensionOrder = [];

// We don't really have a class to add signals on. So, create
// a simple dummy object, add the signal methods, and export those
// publically.
var _signals = {};
Signals.addSignalMethods(_signals);

const connect = Lang.bind(_signals, _signals.connect);
const disconnect = Lang.bind(_signals, _signals.disconnect);

const ENABLED_EXTENSIONS_KEY = 'enabled-extensions';
const DISABLE_USER_EXTENSIONS_KEY = 'disable-user-extensions';
const EXTENSION_DISABLE_VERSION_CHECK_KEY = 'disable-extension-version-validation';

var initted = false;
var enabled;

function disableExtension(uuid) {
    let extension = ExtensionUtils.extensions[uuid];
    if (!extension)
        return;

    if (extension.state != ExtensionState.ENABLED)
        return;

    // ""Rebase"" the extension order by disabling and then enabling extensions
    // in order to help prevent conflicts.

    // Example:
    //   order = [A, B, C, D, E]
    //   user disables C
    //   this should: disable E, disable D, disable C, enable D, enable E

    let orderIdx = extensionOrder.indexOf(uuid);
    let order = extensionOrder.slice(orderIdx + 1);
    let orderReversed = order.slice().reverse();

    for (let i = 0; i < orderReversed.length; i++) {
        let uuid = orderReversed[i];
        try {
            ExtensionUtils.extensions[uuid].stateObj.disable();
        } catch(e) {
            logExtensionError(uuid, e);
        }
    }

    if (extension.stylesheet) {
        let theme = St.ThemeContext.get_for_stage(global.stage).get_theme();
        theme.unload_stylesheet(extension.stylesheet);
    }

    try {
        extension.stateObj.disable();
    } catch(e) {
        logExtensionError(uuid, e);
    }

    for (let i = 0; i < order.length; i++) {
        let uuid = order[i];
        try {
            ExtensionUtils.extensions[uuid].stateObj.enable();
        } catch(e) {
            logExtensionError(uuid, e);
        }
    }

    extensionOrder.splice(orderIdx, 1);

    if ( extension.state != ExtensionState.ERROR ) {
        extension.state = ExtensionState.DISABLED;
        _signals.emit('extension-state-changed', extension);
    }
}

function enableExtension(uuid) {
    let extension = ExtensionUtils.extensions[uuid];
    if (!extension)
        return;

    if (extension.state == ExtensionState.INITIALIZED)
        initExtension(uuid);

    if (extension.state != ExtensionState.DISABLED)
        return;

    extensionOrder.push(uuid);

    let stylesheetNames = [global.session_mode + '.css', 'stylesheet.css'];
    for (let i = 0; i < stylesheetNames.length; i++) {
        let stylesheetFile = extension.dir.get_child(stylesheetNames[i]);
        if (stylesheetFile.query_exists(null)) {
            let theme = St.ThemeContext.get_for_stage(global.stage).get_theme();
            theme.load_stylesheet(stylesheetFile);
            extension.stylesheet = stylesheetFile;
            break;
        }
    }

    try {
        extension.stateObj.enable();
        extension.state = ExtensionState.ENABLED;
        _signals.emit('extension-state-changed', extension);
        return;
    } catch(e) {
        logExtensionError(uuid, e);
        return;
    }
}

function logExtensionError(uuid, error) {
    let extension = ExtensionUtils.extensions[uuid];
    if (!extension)
        return;

    let message = '' + error;

    extension.state = ExtensionState.ERROR;
    if (!extension.errors)
        extension.errors = [];
    extension.errors.push(message);

    log('Extension ""%s"" had error: %s'.format(uuid, message));
    _signals.emit('extension-state-changed', { uuid: uuid,
                                               error: message,
                                               state: extension.state });
}

function loadExtension(extension) {
    // Default to error, we set success as the last step
    extension.state = ExtensionState.ERROR;

    let checkVersion = !global.settings.get_boolean(EXTENSION_DISABLE_VERSION_CHECK_KEY);

    if (checkVersion && ExtensionUtils.isOutOfDate(extension)) {
        extension.state = ExtensionState.OUT_OF_DATE;
    } else {
        let enabled = enabledExtensions.indexOf(extension.uuid) != -1;
        if (enabled) {
            if (!initExtension(extension.uuid))
                return;
            if (extension.state == ExtensionState.DISABLED)
                enableExtension(extension.uuid);
        } else {
            extension.state = ExtensionState.INITIALIZED;
        }
    }

    _signals.emit('extension-state-changed', extension);
}

function unloadExtension(extension) {
    // Try to disable it -- if it's ERROR'd, we can't guarantee that,
    // but it will be removed on next reboot, and hopefully nothing
    // broke too much.
    disableExtension(extension.uuid);

    extension.state = ExtensionState.UNINSTALLED;
    _signals.emit('extension-state-changed', extension);

    delete ExtensionUtils.extensions[extension.uuid];
    return true;
}

function reloadExtension(oldExtension) {
    // Grab the things we'll need to pass to createExtensionObject
    // to reload it.
    let { uuid: uuid, dir: dir, type: type } = oldExtension;

    // Then unload the old extension.
    unloadExtension(oldExtension);

    // Now, recreate the extension and load it.
    let newExtension = ExtensionUtils.createExtensionObject(uuid, dir, type);
    loadExtension(newExtension);
}

function initExtension(uuid) {
    let extension = ExtensionUtils.extensions[uuid];
    let dir = extension.dir;

    if (!extension)
        throw new Error(""Extension was not properly created. Call loadExtension first"");

    let extensionJs = dir.get_child('extension.js');
    if (!extensionJs.query_exists(null))
        throw new Error('Missing extension.js');

    let extensionModule;
    let extensionState = null;

    ExtensionUtils.installImporter(extension);
    extensionModule = extension.imports.extension;

    if (extensionModule.init) {
        try {
            extensionState = extensionModule.init(extension);
        } catch(e) {
            logExtensionError(uuid, e);
            return false;
        }
    }

    if (!extensionState)
        extensionState = extensionModule;
    extension.stateObj = extensionState;

    extension.state = ExtensionState.DISABLED;
    _signals.emit('extension-loaded', uuid);
    return true;
}

function getEnabledExtensions() {
    let extensions;
    if (Array.isArray(Main.sessionMode.enabledExtensions))
        extensions = Main.sessionMode.enabledExtensions;
    else
        extensions = [];

    if (global.settings.get_boolean(DISABLE_USER_EXTENSIONS_KEY))
        return extensions;

    return extensions.concat(global.settings.get_strv(ENABLED_EXTENSIONS_KEY));
}

function onEnabledExtensionsChanged() {
    let newEnabledExtensions = getEnabledExtensions();

    if (!enabled)
        return;

    // Find and enable all the newly enabled extensions: UUIDs found in the
    // new setting, but not in the old one.
    newEnabledExtensions.filter(function(uuid) {
        return enabledExtensions.indexOf(uuid) == -1;
    }).forEach(function(uuid) {
        enableExtension(uuid);
    });

    // Find and disable all the newly disabled extensions: UUIDs found in the
    // old setting, but not in the new one.
    enabledExtensions.filter(function(item) {
        return newEnabledExtensions.indexOf(item) == -1;
    }).forEach(function(uuid) {
        disableExtension(uuid);
    });

    enabledExtensions = newEnabledExtensions;
}

function _onVersionValidationChanged() {
    // we want to reload all extensions, but only enable
    // extensions when allowed by the sessionMode, so
    // temporarily disable them all
    enabledExtensions = [];
    for (let uuid in ExtensionUtils.extensions)
        reloadExtension(ExtensionUtils.extensions[uuid]);
    enabledExtensions = getEnabledExtensions();

    if (Main.sessionMode.allowExtensions) {
        enabledExtensions.forEach(function(uuid) {
            enableExtension(uuid);
        });
    }
}

function _loadExtensions() {
    global.settings.connect('changed::' + ENABLED_EXTENSIONS_KEY, onEnabledExtensionsChanged);
    global.settings.connect('changed::' + DISABLE_USER_EXTENSIONS_KEY, onEnabledExtensionsChanged);
    global.settings.connect('changed::' + EXTENSION_DISABLE_VERSION_CHECK_KEY, _onVersionValidationChanged);

    enabledExtensions = getEnabledExtensions();

    let finder = new ExtensionUtils.ExtensionFinder();
    finder.connect('extension-found', function(finder, extension) {
        loadExtension(extension);
    });
    finder.scanExtensions();
}

function enableAllExtensions() {
    if (enabled)
        return;

    if (!initted) {
        _loadExtensions();
        initted = true;
    } else {
        enabledExtensions.forEach(function(uuid) {
            enableExtension(uuid);
        });
    }
    enabled = true;
}

function disableAllExtensions() {
    if (!enabled)
        return;

    if (initted) {
        extensionOrder.slice().reverse().forEach(function(uuid) {
            disableExtension(uuid);
        });
    }

    enabled = false;
}

function _sessionUpdated() {
    // For now sessionMode.allowExtensions controls extensions from both the
    // 'enabled-extensions' preference and the sessionMode.enabledExtensions
    // property; it might make sense to make enabledExtensions independent
    // from allowExtensions in the future
    if (Main.sessionMode.allowExtensions) {
        if (initted)
            enabledExtensions = getEnabledExtensions();
        enableAllExtensions();
    } else {
        disableAllExtensions();
    }
}

function init() {
    Main.sessionMode.connect('updated', _sessionUpdated);
    _sessionUpdated();
}
","// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-

const Lang = imports.lang;
const Signals = imports.signals;

const GLib = imports.gi.GLib;
const Gio = imports.gi.Gio;
const St = imports.gi.St;

const ExtensionUtils = imports.misc.extensionUtils;
const Main = imports.ui.main;

const ExtensionState = {
    ENABLED: 1,
    DISABLED: 2,
    ERROR: 3,
    OUT_OF_DATE: 4,
    DOWNLOADING: 5,
    INITIALIZED: 6,

    // Used as an error state for operations on unknown extensions,
    // should never be in a real extensionMeta object.
    UNINSTALLED: 99
};

// Arrays of uuids
var enabledExtensions;
// Contains the order that extensions were enabled in.
const extensionOrder = [];

// We don't really have a class to add signals on. So, create
// a simple dummy object, add the signal methods, and export those
// publically.
var _signals = {};
Signals.addSignalMethods(_signals);

const connect = Lang.bind(_signals, _signals.connect);
const disconnect = Lang.bind(_signals, _signals.disconnect);

const ENABLED_EXTENSIONS_KEY = 'enabled-extensions';
const DISABLE_USER_EXTENSIONS_KEY = 'disable-user-extensions';
const EXTENSION_DISABLE_VERSION_CHECK_KEY = 'disable-extension-version-validation';

var initted = false;
var enabled;

function disableExtension(uuid) {
    let extension = ExtensionUtils.extensions[uuid];
    if (!extension)
        return;

    if (extension.state != ExtensionState.ENABLED)
        return;

    // ""Rebase"" the extension order by disabling and then enabling extensions
    // in order to help prevent conflicts.

    // Example:
    //   order = [A, B, C, D, E]
    //   user disables C
    //   this should: disable E, disable D, disable C, enable D, enable E

    let orderIdx = extensionOrder.indexOf(uuid);
    let order = extensionOrder.slice(orderIdx + 1);
    let orderReversed = order.slice().reverse();

    for (let i = 0; i < orderReversed.length; i++) {
        let uuid = orderReversed[i];
        try {
            ExtensionUtils.extensions[uuid].stateObj.disable();
        } catch(e) {
            logExtensionError(uuid, e);
        }
    }

    if (extension.stylesheet) {
        let theme = St.ThemeContext.get_for_stage(global.stage).get_theme();
        theme.unload_stylesheet(extension.stylesheet);
    }

    try {
        extension.stateObj.disable();
    } catch(e) {
        logExtensionError(uuid, e);
    }

    for (let i = 0; i < order.length; i++) {
        let uuid = order[i];
        try {
            ExtensionUtils.extensions[uuid].stateObj.enable();
        } catch(e) {
            logExtensionError(uuid, e);
        }
    }

    extensionOrder.splice(orderIdx, 1);

    if ( extension.state != ExtensionState.ERROR ) {
        extension.state = ExtensionState.DISABLED;
        _signals.emit('extension-state-changed', extension);
    }
}

function enableExtension(uuid) {
    let extension = ExtensionUtils.extensions[uuid];
    if (!extension)
        return;

    if (extension.state == ExtensionState.INITIALIZED)
        initExtension(uuid);

    if (extension.state != ExtensionState.DISABLED)
        return;

    extensionOrder.push(uuid);

    let stylesheetNames = [global.session_mode + '.css', 'stylesheet.css'];
    for (let i = 0; i < stylesheetNames.length; i++) {
        let stylesheetFile = extension.dir.get_child(stylesheetNames[i]);
        if (stylesheetFile.query_exists(null)) {
            let theme = St.ThemeContext.get_for_stage(global.stage).get_theme();
            theme.load_stylesheet(stylesheetFile);
            extension.stylesheet = stylesheetFile;
            break;
        }
    }

    try {
        extension.stateObj.enable();
        extension.state = ExtensionState.ENABLED;
        _signals.emit('extension-state-changed', extension);
        return;
    } catch(e) {
        logExtensionError(uuid, e);
        return;
    }
}

function logExtensionError(uuid, error) {
    let extension = ExtensionUtils.extensions[uuid];
    if (!extension)
        return;

    let message = '' + error;

    extension.state = ExtensionState.ERROR;
    if (!extension.errors)
        extension.errors = [];
    extension.errors.push(message);

    log('Extension ""%s"" had error: %s'.format(uuid, message));
    _signals.emit('extension-state-changed', { uuid: uuid,
                                               error: message,
                                               state: extension.state });
}

function loadExtension(extension) {
    // Default to error, we set success as the last step
    extension.state = ExtensionState.ERROR;

    let checkVersion = !global.settings.get_boolean(EXTENSION_DISABLE_VERSION_CHECK_KEY);

    if (checkVersion && ExtensionUtils.isOutOfDate(extension)) {
        extension.state = ExtensionState.OUT_OF_DATE;
    } else {
        let enabled = enabledExtensions.indexOf(extension.uuid) != -1;
        if (enabled) {
            if (!initExtension(extension.uuid))
                return;
            if (extension.state == ExtensionState.DISABLED)
                enableExtension(extension.uuid);
        } else {
            extension.state = ExtensionState.INITIALIZED;
        }
    }

    _signals.emit('extension-state-changed', extension);
}

function unloadExtension(extension) {
    // Try to disable it -- if it's ERROR'd, we can't guarantee that,
    // but it will be removed on next reboot, and hopefully nothing
    // broke too much.
    disableExtension(extension.uuid);

    extension.state = ExtensionState.UNINSTALLED;
    _signals.emit('extension-state-changed', extension);

    delete ExtensionUtils.extensions[extension.uuid];
    return true;
}

function reloadExtension(oldExtension) {
    // Grab the things we'll need to pass to createExtensionObject
    // to reload it.
    let { uuid: uuid, dir: dir, type: type } = oldExtension;

    // Then unload the old extension.
    unloadExtension(oldExtension);

    // Now, recreate the extension and load it.
    let newExtension = ExtensionUtils.createExtensionObject(uuid, dir, type);
    loadExtension(newExtension);
}

function initExtension(uuid) {
    let extension = ExtensionUtils.extensions[uuid];
    let dir = extension.dir;

    if (!extension)
        throw new Error(""Extension was not properly created. Call loadExtension first"");

    let extensionJs = dir.get_child('extension.js');
    if (!extensionJs.query_exists(null))
        throw new Error('Missing extension.js');

    let extensionModule;
    let extensionState = null;

    ExtensionUtils.installImporter(extension);
    extensionModule = extension.imports.extension;

    if (extensionModule.init) {
        try {
            extensionState = extensionModule.init(extension);
        } catch(e) {
            logExtensionError(uuid, e);
            return false;
        }
    }

    if (!extensionState)
        extensionState = extensionModule;
    extension.stateObj = extensionState;

    extension.state = ExtensionState.DISABLED;
    _signals.emit('extension-loaded', uuid);
    return true;
}

function getEnabledExtensions() {
    let extensions;
    if (Array.isArray(Main.sessionMode.enabledExtensions))
        extensions = Main.sessionMode.enabledExtensions;
    else
        extensions = [];

    if (global.settings.get_boolean(DISABLE_USER_EXTENSIONS_KEY))
        return extensions;

    return extensions.concat(global.settings.get_strv(ENABLED_EXTENSIONS_KEY));
}

function onEnabledExtensionsChanged() {
    let newEnabledExtensions = getEnabledExtensions();

    if (!enabled)
        return;

    // Find and enable all the newly enabled extensions: UUIDs found in the
    // new setting, but not in the old one.
    newEnabledExtensions.filter(function(uuid) {
        return enabledExtensions.indexOf(uuid) == -1;
    }).forEach(function(uuid) {
        enableExtension(uuid);
    });

    // Find and disable all the newly disabled extensions: UUIDs found in the
    // old setting, but not in the new one.
    enabledExtensions.filter(function(item) {
        return newEnabledExtensions.indexOf(item) == -1;
    }).forEach(function(uuid) {
        disableExtension(uuid);
    });

    enabledExtensions = newEnabledExtensions;
}

function _onVersionValidationChanged() {
    // we want to reload all extensions, but only enable
    // extensions when allowed by the sessionMode, so
    // temporarily disable them all
    enabledExtensions = [];
    for (let uuid in ExtensionUtils.extensions)
        try {
            reloadExtension(ExtensionUtils.extensions[uuid]);
        } catch(e) {
            logExtensionError(uuid, e);
        }
    enabledExtensions = getEnabledExtensions();

    if (Main.sessionMode.allowExtensions) {
        enabledExtensions.forEach(function(uuid) {
            try {
                enableExtension(uuid);
            } catch(e) {
                logExtensionError(uuid, e);
            }
        });
    }
}

function _loadExtensions() {
    global.settings.connect('changed::' + ENABLED_EXTENSIONS_KEY, onEnabledExtensionsChanged);
    global.settings.connect('changed::' + DISABLE_USER_EXTENSIONS_KEY, onEnabledExtensionsChanged);
    global.settings.connect('changed::' + EXTENSION_DISABLE_VERSION_CHECK_KEY, _onVersionValidationChanged);

    enabledExtensions = getEnabledExtensions();

    let finder = new ExtensionUtils.ExtensionFinder();
    finder.connect('extension-found', function(finder, extension) {
        loadExtension(extension);
    });
    finder.scanExtensions();
}

function enableAllExtensions() {
    if (enabled)
        return;

    if (!initted) {
        _loadExtensions();
        initted = true;
    } else {
        enabledExtensions.forEach(function(uuid) {
            enableExtension(uuid);
        });
    }
    enabled = true;
}

function disableAllExtensions() {
    if (!enabled)
        return;

    if (initted) {
        extensionOrder.slice().reverse().forEach(function(uuid) {
            disableExtension(uuid);
        });
    }

    enabled = false;
}

function _sessionUpdated() {
    // For now sessionMode.allowExtensions controls extensions from both the
    // 'enabled-extensions' preference and the sessionMode.enabledExtensions
    // property; it might make sense to make enabledExtensions independent
    // from allowExtensions in the future
    if (Main.sessionMode.allowExtensions) {
        if (initted)
            enabledExtensions = getEnabledExtensions();
        enableAllExtensions();
    } else {
        disableAllExtensions();
    }
}

function init() {
    Main.sessionMode.connect('updated', _sessionUpdated);
    _sessionUpdated();
}
"
