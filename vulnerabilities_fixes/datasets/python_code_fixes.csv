vulnerable_code,fixed_code
"# -*- coding: utf-8 -*-
#
# fastecdsa documentation build configuration file, created by
# sphinx-quickstart on Thu Dec 15 20:02:52 2016.
#
# This file is execfile()d with the current directory set to its
# containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#
from datetime import datetime
import os
import sys
from unittest import mock

sys.path.insert(0, os.path.abspath('.'))
sys.path.insert(0, os.path.abspath('../'))

MOCK_MODULES = ['fastecdsa._ecdsa', 'fastecdsa.curvemath']
for mod_name in MOCK_MODULES:
    sys.modules[mod_name] = mock.Mock()


# -- General configuration ------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#
# needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
# ones.
extensions = ['sphinx.ext.mathjax', 'sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix(es) of source filenames.
# You can specify multiple suffix as a list of string:
#
# source_suffix = ['.rst', '.md']
source_suffix = ['.rst', '.md']

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = 'fastecdsa'
copyright = '{}, Anton Kueltz'.format(datetime.now().year)
author = 'Anton Kueltz'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '2.1'
# The full version, including alpha/beta/rc tags.
release = '2.1.1'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#
# This is also used if you do content translation via gettext catalogs.
# Usually you set ""language"" from the command line for these cases.
language = None

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
# This patterns also effect to html_static_path and html_extra_path
exclude_patterns = ['_build', 'Thumbs.db', '.DS_Store']

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# If true, `todo` and `todoList` produce output, else they produce nothing.
todo_include_todos = False


# -- Options for HTML output ----------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
#
# html_theme = 'alabaster'
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#
# html_theme_options = {}

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named ""default.css"" will overwrite the builtin ""default.css"".
html_static_path = ['_static']


# -- Options for HTMLHelp output ------------------------------------------

# Output file base name for HTML help builder.
htmlhelp_basename = 'fastecdsadoc'


# -- Options for LaTeX output ---------------------------------------------

latex_elements = {
    # The paper size ('letterpaper' or 'a4paper').
    #
    # 'papersize': 'letterpaper',

    # The font size ('10pt', '11pt' or '12pt').
    #
    # 'pointsize': '10pt',

    # Additional stuff for the LaTeX preamble.
    #
    # 'preamble': '',

    # Latex figure (float) alignment
    #
    # 'figure_align': 'htbp',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title,
#  author, documentclass [howto, manual, or own class]).
latex_documents = [
    (master_doc, 'fastecdsa.tex', 'fastecdsa Documentation',
     'Anton Kueltz', 'manual'),
]


# -- Options for manual page output ---------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    (master_doc, 'fastecdsa', 'fastecdsa Documentation',
     [author], 1)
]


# -- Options for Texinfo output -------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
    (master_doc, 'fastecdsa', 'fastecdsa Documentation',
     author, 'fastecdsa', 'One line description of project.',
     'Miscellaneous'),
]
","# -*- coding: utf-8 -*-
#
# fastecdsa documentation build configuration file, created by
# sphinx-quickstart on Thu Dec 15 20:02:52 2016.
#
# This file is execfile()d with the current directory set to its
# containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#
from datetime import datetime
import os
import sys
from unittest import mock

sys.path.insert(0, os.path.abspath('.'))
sys.path.insert(0, os.path.abspath('../'))

MOCK_MODULES = ['fastecdsa._ecdsa', 'fastecdsa.curvemath']
for mod_name in MOCK_MODULES:
    sys.modules[mod_name] = mock.Mock()


# -- General configuration ------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#
# needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
# ones.
extensions = ['sphinx.ext.mathjax', 'sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix(es) of source filenames.
# You can specify multiple suffix as a list of string:
#
# source_suffix = ['.rst', '.md']
source_suffix = ['.rst', '.md']

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = 'fastecdsa'
copyright = '{}, Anton Kueltz'.format(datetime.now().year)
author = 'Anton Kueltz'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '2.1'
# The full version, including alpha/beta/rc tags.
release = '2.1.2'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#
# This is also used if you do content translation via gettext catalogs.
# Usually you set ""language"" from the command line for these cases.
language = None

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
# This patterns also effect to html_static_path and html_extra_path
exclude_patterns = ['_build', 'Thumbs.db', '.DS_Store']

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# If true, `todo` and `todoList` produce output, else they produce nothing.
todo_include_todos = False


# -- Options for HTML output ----------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
#
# html_theme = 'alabaster'
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#
# html_theme_options = {}

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named ""default.css"" will overwrite the builtin ""default.css"".
html_static_path = ['_static']


# -- Options for HTMLHelp output ------------------------------------------

# Output file base name for HTML help builder.
htmlhelp_basename = 'fastecdsadoc'


# -- Options for LaTeX output ---------------------------------------------

latex_elements = {
    # The paper size ('letterpaper' or 'a4paper').
    #
    # 'papersize': 'letterpaper',

    # The font size ('10pt', '11pt' or '12pt').
    #
    # 'pointsize': '10pt',

    # Additional stuff for the LaTeX preamble.
    #
    # 'preamble': '',

    # Latex figure (float) alignment
    #
    # 'figure_align': 'htbp',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title,
#  author, documentclass [howto, manual, or own class]).
latex_documents = [
    (master_doc, 'fastecdsa.tex', 'fastecdsa Documentation',
     'Anton Kueltz', 'manual'),
]


# -- Options for manual page output ---------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    (master_doc, 'fastecdsa', 'fastecdsa Documentation',
     [author], 1)
]


# -- Options for Texinfo output -------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
    (master_doc, 'fastecdsa', 'fastecdsa Documentation',
     author, 'fastecdsa', 'One line description of project.',
     'Miscellaneous'),
]
"
"from __future__ import print_function

import argparse
import json
from oauthlib.oauth2 import LegacyApplicationClient
import logging
import logging.handlers
from requests_oauthlib import OAuth2Session
import os
import requests
import six
import sys
import traceback

from six.moves.urllib.parse import quote as urlquote
from six.moves.urllib.parse import urlparse


# ------------------------------------------------------------------------------

logger = None
prog_name = os.path.basename(sys.argv[0])
AUTH_ROLES = ['root-admin', 'realm-admin', 'anonymous']

LOG_FILE_ROTATION_COUNT = 3

TOKEN_URL_TEMPLATE = (
    '{server}/auth/realms/{realm}/protocol/openid-connect/token')
GET_SERVER_INFO_TEMPLATE = (
    '{server}/auth/admin/serverinfo/')
GET_REALMS_URL_TEMPLATE = (
    '{server}/auth/admin/realms')
CREATE_REALM_URL_TEMPLATE = (
    '{server}/auth/admin/realms')
DELETE_REALM_URL_TEMPLATE = (
    '{server}/auth/admin/realms/{realm}')
GET_REALM_METADATA_TEMPLATE = (
    '{server}/auth/realms/{realm}/protocol/saml/descriptor')

CLIENT_REPRESENTATION_TEMPLATE = (
    '{server}/auth/admin/realms/{realm}/clients/{id}')
GET_CLIENTS_URL_TEMPLATE = (
    '{server}/auth/admin/realms/{realm}/clients')
CLIENT_DESCRIPTOR_URL_TEMPLATE = (
    '{server}/auth/admin/realms/{realm}/client-description-converter')
CREATE_CLIENT_URL_TEMPLATE = (
    '{server}/auth/admin/realms/{realm}/clients')

GET_INITIAL_ACCESS_TOKEN_TEMPLATE = (
    '{server}/auth/admin/realms/{realm}/clients-initial-access')
SAML2_CLIENT_REGISTRATION_TEMPLATE = (
  '{server}/auth/realms/{realm}/clients-registrations/saml2-entity-descriptor')

GET_CLIENT_PROTOCOL_MAPPERS_TEMPLATE = (
    '{server}/auth/admin/realms/{realm}/clients/{id}/protocol-mappers/models')
GET_CLIENT_PROTOCOL_MAPPERS_BY_PROTOCOL_TEMPLATE = (
    '{server}/auth/admin/realms/{realm}/clients/{id}/protocol-mappers/protocol/{protocol}')

POST_CLIENT_PROTOCOL_MAPPER_TEMPLATE = (
    '{server}/auth/admin/realms/{realm}/clients/{id}/protocol-mappers/models')


ADMIN_CLIENT_ID = 'admin-cli'

# ------------------------------------------------------------------------------


class RESTError(Exception):
    def __init__(self, status_code, status_reason,
                 response_json, response_text, cmd):
        self.status_code = status_code
        self.status_reason = status_reason
        self.error_description = None
        self.error = None
        self.response_json = response_json
        self.response_text = response_text
        self.cmd = cmd

        self.message = '{status_reason}({status_code}): '.format(
            status_reason=self.status_reason,
            status_code=self.status_code)

        if response_json:
            self.error_description = response_json.get('error_description')
            if self.error_description is None:
                self.error_description = response_json.get('errorMessage')
            self.error = response_json.get('error')
            self.message += '""{error_description}"" [{error}]'.format(
                error_description=self.error_description,
                error=self.error)
        else:
            self.message += '""{response_text}""'.format(
                response_text=self.response_text)

        self.args = (self.message,)

    def __str__(self):
        return self.message

# ------------------------------------------------------------------------------


def configure_logging(options):
    global logger  # pylint: disable=W0603

    log_dir = os.path.dirname(options.log_file)
    if os.path.exists(log_dir):
        if not os.path.isdir(log_dir):
            raise ValueError('logging directory ""{log_dir}"" exists but is not '
                             'directory'.format(log_dir=log_dir))
    else:
        os.makedirs(log_dir)

    log_level = logging.ERROR
    if options.verbose:
        log_level = logging.INFO
    if options.debug:
        log_level = logging.DEBUG

        # These two lines enable debugging at httplib level
        # (requests->urllib3->http.client) You will see the REQUEST,
        # including HEADERS and DATA, and RESPONSE with HEADERS but
        # without DATA.  The only thing missing will be the
        # response.body which is not logged.
        try:
            import http.client as http_client  # Python 3
        except ImportError:
            import httplib as http_client      # Python 2

        http_client.HTTPConnection.debuglevel = 1

        # Turn on cookielib debugging
        if False:
            try:
                import http.cookiejar as cookiejar
            except ImportError:
                import cookielib as cookiejar  # Python 2
            cookiejar.debug = True

    logger = logging.getLogger(prog_name)

    try:
        file_handler = logging.handlers.RotatingFileHandler(
            options.log_file, backupCount=LOG_FILE_ROTATION_COUNT)
    except IOError as e:
        print('Unable to open log file %s (%s)' % (options.log_file, e),
              file=sys.stderr)

    else:
        formatter = logging.Formatter(
            '%(asctime)s %(name)s %(levelname)s: %(message)s')
        file_handler.setFormatter(formatter)
        file_handler.setLevel(logging.DEBUG)
        logger.addHandler(file_handler)

    console_handler = logging.StreamHandler(sys.stdout)
    formatter = logging.Formatter('%(message)s')
    console_handler.setFormatter(formatter)
    console_handler.setLevel(log_level)
    logger.addHandler(console_handler)

    # Set the log level on the logger to the lowest level
    # possible. This allows the message to be emitted from the logger
    # to it's handlers where the level will be filtered on a per
    # handler basis.
    logger.setLevel(1)

# ------------------------------------------------------------------------------


def json_pretty(text):
    return json.dumps(json.loads(text),
                      indent=4, sort_keys=True)


def py_json_pretty(py_json):
    return json_pretty(json.dumps(py_json))


def server_name_from_url(url):
    return urlparse(url).netloc


def get_realm_names_from_realms(realms):
    return [x['realm'] for x in realms]


def get_client_client_ids_from_clients(clients):
    return [x['clientId'] for x in clients]


def find_client_by_name(clients, client_id):
    for client in clients:
        if client.get('clientId') == client_id:
            return client
    raise KeyError('{item} not found'.format(item=client_id))


# ------------------------------------------------------------------------------

class KeycloakREST(object):

    def __init__(self, server, auth_role=None, session=None):
        self.server = server
        self.auth_role = auth_role
        self.session = session

    def get_initial_access_token(self, realm_name):
        cmd_name = ""get initial access token for realm '{realm}'"".format(
            realm=realm_name)
        url = GET_INITIAL_ACCESS_TOKEN_TEMPLATE.format(
            server=self.server, realm=urlquote(realm_name))

        logger.debug(""%s on server %s"", cmd_name, self.server)

        params = {""expiration"": 60,  # seconds
                  ""count"": 1}

        response = self.session.post(url, json=params)
        logger.debug(""%s response code: %s %s"",
                     cmd_name, response.status_code, response.reason)

        try:
            response_json = response.json()
        except ValueError as e:
            response_json = None

        if (not response_json or
            response.status_code != requests.codes.ok):
            logger.error(""%s error: status=%s (%s) text=%s"",
                         cmd_name, response.status_code, response.reason,
                         response.text)
            raise RESTError(response.status_code, response.reason,
                            response_json, response.text, cmd_name)

        logger.debug(""%s response = %s"", cmd_name, json_pretty(response.text))

        return response_json    # ClientInitialAccessPresentation

    def get_server_info(self):
        cmd_name = ""get server info""
        url = GET_SERVER_INFO_TEMPLATE.format(server=self.server)

        logger.debug(""%s on server %s"", cmd_name, self.server)
        response = self.session.get(url)
        logger.debug(""%s response code: %s %s"",
                     cmd_name, response.status_code, response.reason)

        try:
            response_json = response.json()
        except ValueError as e:
            response_json = None

        if (not response_json or
            response.status_code != requests.codes.ok):
            logger.error(""%s error: status=%s (%s) text=%s"",
                         cmd_name, response.status_code, response.reason,
                         response.text)
            raise RESTError(response.status_code, response.reason,
                            response_json, response.text, cmd_name)

        logger.debug(""%s response = %s"", cmd_name, json_pretty(response.text))

        return response_json

    def get_realms(self):
        cmd_name = ""get realms""
        url = GET_REALMS_URL_TEMPLATE.format(server=self.server)

        logger.debug(""%s on server %s"", cmd_name, self.server)
        response = self.session.get(url)
        logger.debug(""%s response code: %s %s"",
                     cmd_name, response.status_code, response.reason)

        try:
            response_json = response.json()
        except ValueError as e:
            response_json = None

        if (not response_json or
            response.status_code != requests.codes.ok):
            logger.error(""%s error: status=%s (%s) text=%s"",
                         cmd_name, response.status_code, response.reason,
                         response.text)
            raise RESTError(response.status_code, response.reason,
                            response_json, response.text, cmd_name)

        logger.debug(""%s response = %s"", cmd_name, json_pretty(response.text))

        return response_json

    def create_realm(self, realm_name):
        cmd_name = ""create realm '{realm}'"".format(realm=realm_name)
        url = CREATE_REALM_URL_TEMPLATE.format(server=self.server)

        logger.debug(""%s on server %s"", cmd_name, self.server)

        params = {""enabled"": True,
                  ""id"": realm_name,
                  ""realm"": realm_name,
                  }

        response = self.session.post(url, json=params)
        logger.debug(""%s response code: %s %s"",
                     cmd_name, response.status_code, response.reason)

        try:
            response_json = response.json()
        except ValueError as e:
            response_json = None

        if response.status_code != requests.codes.created:
            logger.error(""%s error: status=%s (%s) text=%s"",
                         cmd_name, response.status_code, response.reason,
                         response.text)
            raise RESTError(response.status_code, response.reason,
                            response_json, response.text, cmd_name)

        logger.debug(""%s response = %s"", cmd_name, response.text)

    def delete_realm(self, realm_name):
        cmd_name = ""delete realm '{realm}'"".format(realm=realm_name)
        url = DELETE_REALM_URL_TEMPLATE.format(
            server=self.server, realm=urlquote(realm_name))

        logger.debug(""%s on server %s"", cmd_name, self.server)
        response = self.session.delete(url)
        logger.debug(""%s response code: %s %s"",
                     cmd_name, response.status_code, response.reason)

        try:
            response_json = response.json()
        except ValueError as e:
            response_json = None

        if response.status_code != requests.codes.no_content:
            logger.error(""%s error: status=%s (%s) text=%s"",
                         cmd_name, response.status_code, response.reason,
                         response.text)
            raise RESTError(response.status_code, response.reason,
                            response_json, response.text, cmd_name)

        logger.debug(""%s response = %s"", cmd_name, response.text)

    def get_realm_metadata(self, realm_name):
        cmd_name = ""get metadata for realm '{realm}'"".format(realm=realm_name)
        url = GET_REALM_METADATA_TEMPLATE.format(
            server=self.server, realm=urlquote(realm_name))

        logger.debug(""%s on server %s"", cmd_name, self.server)
        response = self.session.get(url)
        logger.debug(""%s response code: %s %s"",
                     cmd_name, response.status_code, response.reason)

        try:
            response_json = response.json()
        except ValueError as e:
            response_json = None

        if response.status_code != requests.codes.ok:
            logger.error(""%s error: status=%s (%s) text=%s"",
                         cmd_name, response.status_code, response.reason,
                         response.text)
            raise RESTError(response.status_code, response.reason,
                            response_json, response.text, cmd_name)

        logger.debug(""%s response = %s"", cmd_name, response.text)
        return response.text

    def get_clients(self, realm_name):
        cmd_name = ""get clients in realm '{realm}'"".format(realm=realm_name)
        url = GET_CLIENTS_URL_TEMPLATE.format(
            server=self.server, realm=urlquote(realm_name))

        logger.debug(""%s on server %s"", cmd_name, self.server)
        response = self.session.get(url)
        logger.debug(""%s response code: %s %s"",
                     cmd_name, response.status_code, response.reason)

        try:
            response_json = response.json()
        except ValueError as e:
            response_json = None

        if (not response_json or
            response.status_code != requests.codes.ok):
            logger.error(""%s error: status=%s (%s) text=%s"",
                         cmd_name, response.status_code, response.reason,
                         response.text)
            raise RESTError(response.status_code, response.reason,
                            response_json, response.text, cmd_name)

        logger.debug(""%s response = %s"", cmd_name, json_pretty(response.text))

        return response_json


    def get_client_by_id(self, realm_name, id):
        cmd_name = ""get client id {id} in realm '{realm}'"".format(
            id=id, realm=realm_name)
        url = GET_CLIENTS_URL_TEMPLATE.format(
            server=self.server, realm=urlquote(realm_name))

        params = {'clientID': id}

        logger.debug(""%s on server %s"", cmd_name, self.server)
        response = self.session.get(url, params=params)
        logger.debug(""%s response code: %s %s"",
                     cmd_name, response.status_code, response.reason)

        try:
            response_json = response.json()
        except ValueError as e:
            response_json = None

        if (not response_json or
            response.status_code != requests.codes.ok):
            logger.error(""%s error: status=%s (%s) text=%s"",
                         cmd_name, response.status_code, response.reason,
                         response.text)
            raise RESTError(response.status_code, response.reason,
                            response_json, response.text, cmd_name)

        logger.debug(""%s response = %s"", cmd_name, json_pretty(response.text))

        return response_json


    def get_client_by_name(self, realm_name, client_name):
        clients = self.get_clients(realm_name)
        client = find_client_by_name(clients, client_name)
        id = client.get('id')
        logger.debug(""client name '%s' mapped to id '%s'"",
                     client_name, id)
        logger.debug(""client %s\n%s"", client_name, py_json_pretty(client))
        return client

    def get_client_id_by_name(self, realm_name, client_name):
        client = self.get_client_by_name(realm_name, client_name)
        id = client.get('id')
        return id

    def get_client_descriptor(self, realm_name, metadata):
        cmd_name = ""get client descriptor realm '{realm}'"".format(
            realm=realm_name)
        url = CLIENT_DESCRIPTOR_URL_TEMPLATE.format(
            server=self.server, realm=urlquote(realm_name))

        logger.debug(""%s on server %s"", cmd_name, self.server)

        headers = {'Content-Type': 'application/xml;charset=utf-8'}

        response = self.session.post(url, headers=headers, data=metadata)
        logger.debug(""%s response code: %s %s"",
                     cmd_name, response.status_code, response.reason)

        try:
            response_json = response.json()
        except ValueError as e:
            response_json = None

        if (not response_json or
            response.status_code != requests.codes.ok):
            logger.error(""%s error: status=%s (%s) text=%s"",
                         cmd_name, response.status_code, response.reason,
                         response.text)
            raise RESTError(response.status_code, response.reason,
                            response_json, response.text, cmd_name)

        logger.debug(""%s response = %s"", cmd_name, json_pretty(response.text))

        return response_json

    def create_client_from_descriptor(self, realm_name, descriptor):
        cmd_name = ""create client from descriptor ""
        ""'{client_id}'in realm '{realm}'"".format(
            client_id=descriptor['clientId'], realm=realm_name)
        url = CREATE_CLIENT_URL_TEMPLATE.format(
            server=self.server, realm=urlquote(realm_name))

        logger.debug(""%s on server %s"", cmd_name, self.server)

        response = self.session.post(url, json=descriptor)
        logger.debug(""%s response code: %s %s"",
                     cmd_name, response.status_code, response.reason)

        try:
            response_json = response.json()
        except ValueError as e:
            response_json = None

        if response.status_code != requests.codes.created:
            logger.error(""%s error: status=%s (%s) text=%s"",
                         cmd_name, response.status_code, response.reason,
                         response.text)
            raise RESTError(response.status_code, response.reason,
                            response_json, response.text, cmd_name)

        logger.debug(""%s response = %s"", cmd_name, response.text)

    def create_client(self, realm_name, metadata):
        logger.debug(""create client in realm %s on server %s"",
                     realm_name, self.server)
        descriptor = self.get_client_descriptor(realm_name, metadata)
        self.create_client_from_descriptor(realm_name, descriptor)
        return descriptor

    def register_client(self, initial_access_token, realm_name, metadata):
        cmd_name = ""register_client realm '{realm}'"".format(
            realm=realm_name)
        url = SAML2_CLIENT_REGISTRATION_TEMPLATE.format(
            server=self.server, realm=urlquote(realm_name))

        logger.debug(""%s on server %s"", cmd_name, self.server)

        headers = {'Content-Type': 'application/xml;charset=utf-8'}

        if initial_access_token:
            headers['Authorization'] = 'Bearer {token}'.format(
                token=initial_access_token)

        response = self.session.post(url, headers=headers, data=metadata)
        logger.debug(""%s response code: %s %s"",
                     cmd_name, response.status_code, response.reason)

        try:
            response_json = response.json()
        except ValueError as e:
            response_json = None

        if (not response_json or
            response.status_code != requests.codes.created):
            logger.error(""%s error: status=%s (%s) text=%s"",
                         cmd_name, response.status_code, response.reason,
                         response.text)
            raise RESTError(response.status_code, response.reason,
                            response_json, response.text, cmd_name)

        logger.debug(""%s response = %s"", cmd_name, json_pretty(response.text))

        return response_json    # ClientRepresentation

    def delete_client_by_name(self, realm_name, client_name):
        id = self.get_client_id_by_name(realm_name, client_name)
        self.delete_client_by_id(realm_name, id)


    def delete_client_by_id(self, realm_name, id):
        cmd_name = ""delete client id '{id}'in realm '{realm}'"".format(
            id=id, realm=realm_name)
        url = CLIENT_REPRESENTATION_TEMPLATE.format(
            server=self.server, realm=urlquote(realm_name),
            id=urlquote(id))

        logger.debug(""%s on server %s"", cmd_name, self.server)
        response = self.session.delete(url)
        logger.debug(""%s response code: %s %s"",
                     cmd_name, response.status_code, response.reason)

        try:
            response_json = response.json()
        except ValueError as e:
            response_json = None

        if response.status_code != requests.codes.no_content:
            logger.error(""%s error: status=%s (%s) text=%s"",
                         cmd_name, response.status_code, response.reason,
                         response.text)
            raise RESTError(response.status_code, response.reason,
                            response_json, response.text, cmd_name)

        logger.debug(""%s response = %s"", cmd_name, response.text)

    def update_client(self, realm_name, client):
        id = client['id']
        cmd_name = ""update client {id} in realm '{realm}'"".format(
            id=client['clientId'], realm=realm_name)
        url = CLIENT_REPRESENTATION_TEMPLATE.format(
            server=self.server, realm=urlquote(realm_name),
            id=urlquote(id))

        logger.debug(""%s on server %s"", cmd_name, self.server)

        response = self.session.put(url, json=client)
        logger.debug(""%s response code: %s %s"",
                     cmd_name, response.status_code, response.reason)

        try:
            response_json = response.json()
        except ValueError as e:
            response_json = None

        if response.status_code != requests.codes.no_content:
            logger.error(""%s error: status=%s (%s) text=%s"",
                         cmd_name, response.status_code, response.reason,
                         response.text)
            raise RESTError(response.status_code, response.reason,
                            response_json, response.text, cmd_name)

        logger.debug(""%s response = %s"", cmd_name, response.text)


    def update_client_attributes(self, realm_name, client, update_attrs):
        client_id = client['clientId']
        logger.debug(""update client attrs: client_id=%s ""
        ""current attrs=%s update=%s"" % (client_id, client['attributes'],
                                update_attrs))
        client['attributes'].update(update_attrs)
        logger.debug(""update client attrs: client_id=%s ""
        ""new attrs=%s"" % (client_id, client['attributes']))
        self.update_client(realm_name, client);


    def update_client_by_name_attributes(self, realm_name, client_name,
                                         update_attrs):
        client = self.get_client_by_name(realm_name, client_name)
        self.update_client_attributes(realm_name, client, update_attrs)

    def new_saml_group_protocol_mapper(self, mapper_name, attribute_name,
                                       friendly_name=None,
                                       single_attribute=True):
        mapper = {
            'protocol': 'saml',
            'name': mapper_name,
            'protocolMapper': 'saml-group-membership-mapper',
            'config': {
                'attribute.name': attribute_name,
                'attribute.nameformat': 'Basic',
                'single': single_attribute,
                'full.path': False,
            },
        }

        if friendly_name:
            mapper['config']['friendly.name'] = friendly_name

        return mapper

    def create_client_protocol_mapper(self, realm_name, client, mapper):
        id = client['id']
        cmd_name = (""create protocol-mapper '{mapper_name}' for client {id} ""
                    ""in realm '{realm}'"".format(
                        mapper_name=mapper['name'],id=client['clientId'], realm=realm_name))
        url = POST_CLIENT_PROTOCOL_MAPPER_TEMPLATE.format(
            server=self.server,
            realm=urlquote(realm_name),
            id=urlquote(id))

        logger.debug(""%s on server %s"", cmd_name, self.server)

        response = self.session.post(url, json=mapper)
        logger.debug(""%s response code: %s %s"",
                     cmd_name, response.status_code, response.reason)

        try:
            response_json = response.json()
        except ValueError as e:
            response_json = None

        if response.status_code != requests.codes.created:
            logger.error(""%s error: status=%s (%s) text=%s"",
                         cmd_name, response.status_code, response.reason,
                         response.text)
            raise RESTError(response.status_code, response.reason,
                            response_json, response.text, cmd_name)

        logger.debug(""%s response = %s"", cmd_name, response.text)


    def create_client_by_name_protocol_mapper(self, realm_name, client_name,
                                              mapper):
        client = self.get_client_by_name(realm_name, client_name)
        self.create_client_protocol_mapper(realm_name, client, mapper)



    def add_client_by_name_redirect_uris(self, realm_name, client_name, uris):
        client = self.get_client_by_name(realm_name, client_name)

        uris = set(uris)
        redirect_uris = set(client['redirectUris'])
        redirect_uris |= uris
        client['redirectUris'] = list(redirect_uris)
        self.update_client(realm_name, client);

    def remove_client_by_name_redirect_uris(self, realm_name, client_name, uris):
        client = self.get_client_by_name(realm_name, client_name)

        uris = set(uris)
        redirect_uris = set(client['redirectUris'])
        redirect_uris -= uris
        client['redirectUris'] = list(redirect_uris)

        self.update_client(realm_name, client);


# ------------------------------------------------------------------------------


class KeycloakAdminConnection(KeycloakREST):

    def __init__(self, server, auth_role, realm, client_id,
                 username, password, tls_verify):
        super(KeycloakAdminConnection, self).__init__(server, auth_role)

        self.realm = realm
        self.client_id = client_id
        self.username = username
        self.password = password

        self.session = self._create_session(tls_verify)

    def _create_session(self, tls_verify):
        token_url = TOKEN_URL_TEMPLATE.format(
            server=self.server, realm=urlquote(self.realm))
        refresh_url = token_url

        client = LegacyApplicationClient(client_id=self.client_id)
        session = OAuth2Session(client=client,
                                auto_refresh_url=refresh_url,
                                auto_refresh_kwargs={
                                    'client_id': self.client_id})

        session.verify = tls_verify
        token = session.fetch_token(token_url=token_url,
                                    username=self.username,
                                    password=self.password,
                                    client_id=self.client_id,
                                    verify=session.verify)

        return session


class KeycloakAnonymousConnection(KeycloakREST):

    def __init__(self, server, tls_verify):
        super(KeycloakAnonymousConnection, self).__init__(server, 'anonymous')
        self.session = self._create_session(tls_verify)


    def _create_session(self, tls_verify):
        session = requests.Session()
        session.verify = tls_verify

        return session

# ------------------------------------------------------------------------------


def do_server_info(options, conn):
    server_info = conn.get_server_info()
    print(json_pretty(server_info))


def do_list_realms(options, conn):
    realms = conn.get_realms()
    realm_names = get_realm_names_from_realms(realms)
    print('\n'.join(sorted(realm_names)))


def do_create_realm(options, conn):
    conn.create_realm(options.realm_name)


def do_delete_realm(options, conn):
    conn.delete_realm(options.realm_name)


def do_get_realm_metadata(options, conn):
    metadata = conn.get_realm_metadata(options.realm_name)
    print(metadata)


def do_list_clients(options, conn):
    clients = conn.get_clients(options.realm_name)
    client_ids = get_client_client_ids_from_clients(clients)
    print('\n'.join(sorted(client_ids)))


def do_create_client(options, conn):
    metadata = options.metadata.read()
    descriptor = conn.create_client(options.realm_name, metadata)


def do_register_client(options, conn):
    metadata = options.metadata.read()
    client_representation = conn.register_client(
        options.initial_access_token,
        options.realm_name, metadata)


def do_delete_client(options, conn):
    conn.delete_client_by_name(options.realm_name, options.client_name)

def do_client_test(options, conn):
    'experimental test code used during development'

    uri = 'https://openstack.jdennis.oslab.test:5000/v3/mellon/fooResponse'

    conn.remove_client_by_name_redirect_uri(options.realm_name,
                                            options.client_name,
                                            uri)

# ------------------------------------------------------------------------------

verbose_help = '''

The structure of the command line arguments is ""noun verb"" where noun
is one of Keycloak's data items (e.g. realm, client, etc.) and the
verb is an action to perform on the item. Each of the nouns and verbs
may have their own set of arguments which must follow the noun or
verb.

For example to delete the client XYZ in the realm ABC:

echo password | {prog_name} -s http://example.com:8080 -P - client delete -r ABC -c XYZ

where 'client' is the noun, 'delete' is the verb and -r ABC -c XYZ are
arguments to the delete action.

If the command completes successfully the exit status is 0. The exit
status is 1 if an authenticated connection with the server cannont be
successfully established. The exit status is 2 if the REST operation
fails.

The server should be a scheme://hostname:port URL.
'''


class TlsVerifyAction(argparse.Action):
    def __init__(self, option_strings, dest, nargs=None, **kwargs):
        if nargs is not None:
            raise ValueError(""nargs not allowed"")
        super(TlsVerifyAction, self).__init__(option_strings, dest, **kwargs)

    def __call__(self, parser, namespace, values, option_string=None):
        if values.lower() in ['true', 'yes', 'on']:
            verify = True
        elif values.lower() in ['false', 'no', 'off']:
            verify = False
        else:
            verify = values
            
        setattr(namespace, self.dest, verify)

def main():
    global logger
    result = 0

    parser = argparse.ArgumentParser(description='Keycloak REST client',
                    prog=prog_name,
                    epilog=verbose_help.format(prog_name=prog_name),
                    formatter_class=argparse.RawDescriptionHelpFormatter)

    parser.add_argument('-v', '--verbose', action='store_true',
                        help='be chatty')

    parser.add_argument('-d', '--debug', action='store_true',
                        help='turn on debug info')

    parser.add_argument('--show-traceback', action='store_true',
                        help='exceptions print traceback in addition to '
                             'error message')

    parser.add_argument('--log-file',
                        default='/tmp/{prog_name}.log'.format(
                            prog_name=prog_name),
                        help='log file pathname')

    parser.add_argument('--permit-insecure-transport',  action='store_true',
                        help='Normally secure transport such as TLS '
                        'is required, defeat this check')

    parser.add_argument('--tls-verify', action=TlsVerifyAction,
                        default=True,
                        help='TLS certificate verification for requests to'
                        ' the server. May be one of case insenstive '
                        '[true, yes, on] to enable,'
                        '[false, no, off] to disable.'
                        'Or the pathname to a OpenSSL CA bundle to use.'
                        ' Default is True.')

    group = parser.add_argument_group('Server')

    group.add_argument('-s', '--server',
                       required=True,
                       help='DNS name or IP address of Keycloak server')

    group.add_argument('-a', '--auth-role',
                       choices=AUTH_ROLES,
                       default='root-admin',
                       help='authenticating as what type of user (default: root-admin)')

    group.add_argument('-u', '--admin-username',
                       default='admin',
                       help='admin user name (default: admin)')

    group.add_argument('-P', '--admin-password-file',
                       type=argparse.FileType('rb'),
                       help=('file containing admin password '
                             '(or use a hyphen ""-"" to read the password '
                             'from stdin)'))

    group.add_argument('--admin-realm',
                       default='master',
                       help='realm admin belongs to')

    cmd_parsers = parser.add_subparsers(help='available commands')

    # --- realm commands ---
    realm_parser = cmd_parsers.add_parser('realm',
                                          help='realm operations')

    sub_parser = realm_parser.add_subparsers(help='realm commands')

    cmd_parser = sub_parser.add_parser('server_info',
                                       help='dump server info')
    cmd_parser.set_defaults(func=do_server_info)

    cmd_parser = sub_parser.add_parser('list',
                                       help='list realm names')
    cmd_parser.set_defaults(func=do_list_realms)

    cmd_parser = sub_parser.add_parser('create',
                                       help='create new realm')
    cmd_parser.add_argument('-r', '--realm-name', required=True,
                            help='realm name')
    cmd_parser.set_defaults(func=do_create_realm)

    cmd_parser = sub_parser.add_parser('delete',
                                       help='delete existing realm')
    cmd_parser.add_argument('-r', '--realm-name', required=True,
                            help='realm name')
    cmd_parser.set_defaults(func=do_delete_realm)

    cmd_parser = sub_parser.add_parser('metadata',
                                       help='retrieve realm metadata')
    cmd_parser.add_argument('-r', '--realm-name', required=True,
                            help='realm name')
    cmd_parser.set_defaults(func=do_get_realm_metadata)

    # --- client commands ---
    client_parser = cmd_parsers.add_parser('client',
                                           help='client operations')

    sub_parser = client_parser.add_subparsers(help='client commands')

    cmd_parser = sub_parser.add_parser('list',
                                       help='list client names')
    cmd_parser.add_argument('-r', '--realm-name', required=True,
                            help='realm name')

    cmd_parser.set_defaults(func=do_list_clients)

    cmd_parser = sub_parser.add_parser('create',
                                       help='create new client')
    cmd_parser.add_argument('-r', '--realm-name', required=True,
                            help='realm name')
    cmd_parser.add_argument('-m', '--metadata', type=argparse.FileType('rb'),
                            required=True,
                            help='SP metadata file or stdin')
    cmd_parser.set_defaults(func=do_create_client)

    cmd_parser = sub_parser.add_parser('register',
                                       help='register new client')
    cmd_parser.add_argument('-r', '--realm-name', required=True,
                            help='realm name')
    cmd_parser.add_argument('-m', '--metadata', type=argparse.FileType('rb'),
                            required=True,
                            help='SP metadata file or stdin')
    cmd_parser.add_argument('--initial-access-token', required=True,
                            help='realm initial access token for '
                            'client registeration')
    cmd_parser.set_defaults(func=do_register_client)

    cmd_parser = sub_parser.add_parser('delete',
                                       help='delete existing client')
    cmd_parser.add_argument('-r', '--realm-name', required=True,
                            help='realm name')
    cmd_parser.add_argument('-c', '--client-name', required=True,
                            help='client name')
    cmd_parser.set_defaults(func=do_delete_client)

    cmd_parser = sub_parser.add_parser('test',
                                       help='experimental test used during '
                                       'development')
    cmd_parser.add_argument('-r', '--realm-name', required=True,
                            help='realm name')
    cmd_parser.add_argument('-c', '--client-name', required=True,
                            help='client name')
    cmd_parser.set_defaults(func=do_client_test)

    # Process command line arguments
    options = parser.parse_args()
    configure_logging(options)

    if options.permit_insecure_transport:
        os.environ['OAUTHLIB_INSECURE_TRANSPORT'] = '1'

    # Get admin password
    options.admin_password = None

    # 1. Try password file
    if options.admin_password_file is not None:
        options.admin_password = options.keycloak_admin_password_file.readline().strip()
        options.keycloak_admin_password_file.close()

    # 2. Try KEYCLOAK_ADMIN_PASSWORD environment variable
    if options.admin_password is None:
        if (('KEYCLOAK_ADMIN_PASSWORD' in os.environ) and
            (os.environ['KEYCLOAK_ADMIN_PASSWORD'])):
            options.admin_password = os.environ['KEYCLOAK_ADMIN_PASSWORD']

    try:
        anonymous_conn = KeycloakAnonymousConnection(options.server,
                                                     options.tls_verify)

        admin_conn = KeycloakAdminConnection(options.server,
                                             options.auth_role,
                                             options.admin_realm,
                                             ADMIN_CLIENT_ID,
                                             options.admin_username,
                                             options.admin_password,
                                             options.tls_verify)
    except Exception as e:
        if options.show_traceback:
            traceback.print_exc()
        print(six.text_type(e), file=sys.stderr)
        result = 1
        return result

    try:
        if options.func == do_register_client:
            conn = admin_conn
        else:
            conn = admin_conn
        result = options.func(options, conn)
    except Exception as e:
        if options.show_traceback:
            traceback.print_exc()
        print(six.text_type(e), file=sys.stderr)
        result = 2
        return result

    return result

# ------------------------------------------------------------------------------

if __name__ == '__main__':
    sys.exit(main())
else:
    logger = logging.getLogger('keycloak-cli')
","from __future__ import print_function

import argparse
import json
from oauthlib.oauth2 import LegacyApplicationClient
import logging
import logging.handlers
from requests_oauthlib import OAuth2Session
import os
import requests
import six
import sys
import traceback

from six.moves.urllib.parse import quote as urlquote
from six.moves.urllib.parse import urlparse


# ------------------------------------------------------------------------------

logger = None
prog_name = os.path.basename(sys.argv[0])
AUTH_ROLES = ['root-admin', 'realm-admin', 'anonymous']

LOG_FILE_ROTATION_COUNT = 3

TOKEN_URL_TEMPLATE = (
    '{server}/auth/realms/{realm}/protocol/openid-connect/token')
GET_SERVER_INFO_TEMPLATE = (
    '{server}/auth/admin/serverinfo/')
GET_REALMS_URL_TEMPLATE = (
    '{server}/auth/admin/realms')
CREATE_REALM_URL_TEMPLATE = (
    '{server}/auth/admin/realms')
DELETE_REALM_URL_TEMPLATE = (
    '{server}/auth/admin/realms/{realm}')
GET_REALM_METADATA_TEMPLATE = (
    '{server}/auth/realms/{realm}/protocol/saml/descriptor')

CLIENT_REPRESENTATION_TEMPLATE = (
    '{server}/auth/admin/realms/{realm}/clients/{id}')
GET_CLIENTS_URL_TEMPLATE = (
    '{server}/auth/admin/realms/{realm}/clients')
CLIENT_DESCRIPTOR_URL_TEMPLATE = (
    '{server}/auth/admin/realms/{realm}/client-description-converter')
CREATE_CLIENT_URL_TEMPLATE = (
    '{server}/auth/admin/realms/{realm}/clients')

GET_INITIAL_ACCESS_TOKEN_TEMPLATE = (
    '{server}/auth/admin/realms/{realm}/clients-initial-access')
SAML2_CLIENT_REGISTRATION_TEMPLATE = (
  '{server}/auth/realms/{realm}/clients-registrations/saml2-entity-descriptor')

GET_CLIENT_PROTOCOL_MAPPERS_TEMPLATE = (
    '{server}/auth/admin/realms/{realm}/clients/{id}/protocol-mappers/models')
GET_CLIENT_PROTOCOL_MAPPERS_BY_PROTOCOL_TEMPLATE = (
    '{server}/auth/admin/realms/{realm}/clients/{id}/protocol-mappers/protocol/{protocol}')

POST_CLIENT_PROTOCOL_MAPPER_TEMPLATE = (
    '{server}/auth/admin/realms/{realm}/clients/{id}/protocol-mappers/models')


ADMIN_CLIENT_ID = 'admin-cli'

# ------------------------------------------------------------------------------


class RESTError(Exception):
    def __init__(self, status_code, status_reason,
                 response_json, response_text, cmd):
        self.status_code = status_code
        self.status_reason = status_reason
        self.error_description = None
        self.error = None
        self.response_json = response_json
        self.response_text = response_text
        self.cmd = cmd

        self.message = '{status_reason}({status_code}): '.format(
            status_reason=self.status_reason,
            status_code=self.status_code)

        if response_json:
            self.error_description = response_json.get('error_description')
            if self.error_description is None:
                self.error_description = response_json.get('errorMessage')
            self.error = response_json.get('error')
            self.message += '""{error_description}"" [{error}]'.format(
                error_description=self.error_description,
                error=self.error)
        else:
            self.message += '""{response_text}""'.format(
                response_text=self.response_text)

        self.args = (self.message,)

    def __str__(self):
        return self.message

# ------------------------------------------------------------------------------


def configure_logging(options):
    global logger  # pylint: disable=W0603

    log_dir = os.path.dirname(options.log_file)
    if os.path.exists(log_dir):
        if not os.path.isdir(log_dir):
            raise ValueError('logging directory ""{log_dir}"" exists but is not '
                             'directory'.format(log_dir=log_dir))
    else:
        os.makedirs(log_dir)

    log_level = logging.ERROR
    if options.verbose:
        log_level = logging.INFO
    if options.debug:
        log_level = logging.DEBUG

        # These two lines enable debugging at httplib level
        # (requests->urllib3->http.client) You will see the REQUEST,
        # including HEADERS and DATA, and RESPONSE with HEADERS but
        # without DATA.  The only thing missing will be the
        # response.body which is not logged.
        try:
            import http.client as http_client  # Python 3
        except ImportError:
            import httplib as http_client      # Python 2

        http_client.HTTPConnection.debuglevel = 1

        # Turn on cookielib debugging
        if False:
            try:
                import http.cookiejar as cookiejar
            except ImportError:
                import cookielib as cookiejar  # Python 2
            cookiejar.debug = True

    logger = logging.getLogger(prog_name)

    try:
        file_handler = logging.handlers.RotatingFileHandler(
            options.log_file, backupCount=LOG_FILE_ROTATION_COUNT)
    except IOError as e:
        print('Unable to open log file %s (%s)' % (options.log_file, e),
              file=sys.stderr)

    else:
        formatter = logging.Formatter(
            '%(asctime)s %(name)s %(levelname)s: %(message)s')
        file_handler.setFormatter(formatter)
        file_handler.setLevel(logging.DEBUG)
        logger.addHandler(file_handler)

    console_handler = logging.StreamHandler(sys.stdout)
    formatter = logging.Formatter('%(message)s')
    console_handler.setFormatter(formatter)
    console_handler.setLevel(log_level)
    logger.addHandler(console_handler)

    # Set the log level on the logger to the lowest level
    # possible. This allows the message to be emitted from the logger
    # to it's handlers where the level will be filtered on a per
    # handler basis.
    logger.setLevel(1)

# ------------------------------------------------------------------------------


def json_pretty(text):
    return json.dumps(json.loads(text),
                      indent=4, sort_keys=True)


def py_json_pretty(py_json):
    return json_pretty(json.dumps(py_json))


def server_name_from_url(url):
    return urlparse(url).netloc


def get_realm_names_from_realms(realms):
    return [x['realm'] for x in realms]


def get_client_client_ids_from_clients(clients):
    return [x['clientId'] for x in clients]


def find_client_by_name(clients, client_id):
    for client in clients:
        if client.get('clientId') == client_id:
            return client
    raise KeyError('{item} not found'.format(item=client_id))


# ------------------------------------------------------------------------------

class KeycloakREST(object):

    def __init__(self, server, auth_role=None, session=None):
        self.server = server
        self.auth_role = auth_role
        self.session = session

    def get_initial_access_token(self, realm_name):
        cmd_name = ""get initial access token for realm '{realm}'"".format(
            realm=realm_name)
        url = GET_INITIAL_ACCESS_TOKEN_TEMPLATE.format(
            server=self.server, realm=urlquote(realm_name))

        logger.debug(""%s on server %s"", cmd_name, self.server)

        params = {""expiration"": 60,  # seconds
                  ""count"": 1}

        response = self.session.post(url, json=params)
        logger.debug(""%s response code: %s %s"",
                     cmd_name, response.status_code, response.reason)

        try:
            response_json = response.json()
        except ValueError as e:
            response_json = None

        if (not response_json or
            response.status_code != requests.codes.ok):
            logger.error(""%s error: status=%s (%s) text=%s"",
                         cmd_name, response.status_code, response.reason,
                         response.text)
            raise RESTError(response.status_code, response.reason,
                            response_json, response.text, cmd_name)

        logger.debug(""%s response = %s"", cmd_name, json_pretty(response.text))

        return response_json    # ClientInitialAccessPresentation

    def get_server_info(self):
        cmd_name = ""get server info""
        url = GET_SERVER_INFO_TEMPLATE.format(server=self.server)

        logger.debug(""%s on server %s"", cmd_name, self.server)
        response = self.session.get(url)
        logger.debug(""%s response code: %s %s"",
                     cmd_name, response.status_code, response.reason)

        try:
            response_json = response.json()
        except ValueError as e:
            response_json = None

        if (not response_json or
            response.status_code != requests.codes.ok):
            logger.error(""%s error: status=%s (%s) text=%s"",
                         cmd_name, response.status_code, response.reason,
                         response.text)
            raise RESTError(response.status_code, response.reason,
                            response_json, response.text, cmd_name)

        logger.debug(""%s response = %s"", cmd_name, json_pretty(response.text))

        return response_json

    def get_realms(self):
        cmd_name = ""get realms""
        url = GET_REALMS_URL_TEMPLATE.format(server=self.server)

        logger.debug(""%s on server %s"", cmd_name, self.server)
        response = self.session.get(url)
        logger.debug(""%s response code: %s %s"",
                     cmd_name, response.status_code, response.reason)

        try:
            response_json = response.json()
        except ValueError as e:
            response_json = None

        if (not response_json or
            response.status_code != requests.codes.ok):
            logger.error(""%s error: status=%s (%s) text=%s"",
                         cmd_name, response.status_code, response.reason,
                         response.text)
            raise RESTError(response.status_code, response.reason,
                            response_json, response.text, cmd_name)

        logger.debug(""%s response = %s"", cmd_name, json_pretty(response.text))

        return response_json

    def create_realm(self, realm_name):
        cmd_name = ""create realm '{realm}'"".format(realm=realm_name)
        url = CREATE_REALM_URL_TEMPLATE.format(server=self.server)

        logger.debug(""%s on server %s"", cmd_name, self.server)

        params = {""enabled"": True,
                  ""id"": realm_name,
                  ""realm"": realm_name,
                  }

        response = self.session.post(url, json=params)
        logger.debug(""%s response code: %s %s"",
                     cmd_name, response.status_code, response.reason)

        try:
            response_json = response.json()
        except ValueError as e:
            response_json = None

        if response.status_code != requests.codes.created:
            logger.error(""%s error: status=%s (%s) text=%s"",
                         cmd_name, response.status_code, response.reason,
                         response.text)
            raise RESTError(response.status_code, response.reason,
                            response_json, response.text, cmd_name)

        logger.debug(""%s response = %s"", cmd_name, response.text)

    def delete_realm(self, realm_name):
        cmd_name = ""delete realm '{realm}'"".format(realm=realm_name)
        url = DELETE_REALM_URL_TEMPLATE.format(
            server=self.server, realm=urlquote(realm_name))

        logger.debug(""%s on server %s"", cmd_name, self.server)
        response = self.session.delete(url)
        logger.debug(""%s response code: %s %s"",
                     cmd_name, response.status_code, response.reason)

        try:
            response_json = response.json()
        except ValueError as e:
            response_json = None

        if response.status_code != requests.codes.no_content:
            logger.error(""%s error: status=%s (%s) text=%s"",
                         cmd_name, response.status_code, response.reason,
                         response.text)
            raise RESTError(response.status_code, response.reason,
                            response_json, response.text, cmd_name)

        logger.debug(""%s response = %s"", cmd_name, response.text)

    def get_realm_metadata(self, realm_name):
        cmd_name = ""get metadata for realm '{realm}'"".format(realm=realm_name)
        url = GET_REALM_METADATA_TEMPLATE.format(
            server=self.server, realm=urlquote(realm_name))

        logger.debug(""%s on server %s"", cmd_name, self.server)
        response = self.session.get(url)
        logger.debug(""%s response code: %s %s"",
                     cmd_name, response.status_code, response.reason)

        try:
            response_json = response.json()
        except ValueError as e:
            response_json = None

        if response.status_code != requests.codes.ok:
            logger.error(""%s error: status=%s (%s) text=%s"",
                         cmd_name, response.status_code, response.reason,
                         response.text)
            raise RESTError(response.status_code, response.reason,
                            response_json, response.text, cmd_name)

        logger.debug(""%s response = %s"", cmd_name, response.text)
        return response.text

    def get_clients(self, realm_name):
        cmd_name = ""get clients in realm '{realm}'"".format(realm=realm_name)
        url = GET_CLIENTS_URL_TEMPLATE.format(
            server=self.server, realm=urlquote(realm_name))

        logger.debug(""%s on server %s"", cmd_name, self.server)
        response = self.session.get(url)
        logger.debug(""%s response code: %s %s"",
                     cmd_name, response.status_code, response.reason)

        try:
            response_json = response.json()
        except ValueError as e:
            response_json = None

        if (not response_json or
            response.status_code != requests.codes.ok):
            logger.error(""%s error: status=%s (%s) text=%s"",
                         cmd_name, response.status_code, response.reason,
                         response.text)
            raise RESTError(response.status_code, response.reason,
                            response_json, response.text, cmd_name)

        logger.debug(""%s response = %s"", cmd_name, json_pretty(response.text))

        return response_json


    def get_client_by_id(self, realm_name, id):
        cmd_name = ""get client id {id} in realm '{realm}'"".format(
            id=id, realm=realm_name)
        url = GET_CLIENTS_URL_TEMPLATE.format(
            server=self.server, realm=urlquote(realm_name))

        params = {'clientID': id}

        logger.debug(""%s on server %s"", cmd_name, self.server)
        response = self.session.get(url, params=params)
        logger.debug(""%s response code: %s %s"",
                     cmd_name, response.status_code, response.reason)

        try:
            response_json = response.json()
        except ValueError as e:
            response_json = None

        if (not response_json or
            response.status_code != requests.codes.ok):
            logger.error(""%s error: status=%s (%s) text=%s"",
                         cmd_name, response.status_code, response.reason,
                         response.text)
            raise RESTError(response.status_code, response.reason,
                            response_json, response.text, cmd_name)

        logger.debug(""%s response = %s"", cmd_name, json_pretty(response.text))

        return response_json


    def get_client_by_name(self, realm_name, client_name):
        clients = self.get_clients(realm_name)
        client = find_client_by_name(clients, client_name)
        id = client.get('id')
        logger.debug(""client name '%s' mapped to id '%s'"",
                     client_name, id)
        logger.debug(""client %s\n%s"", client_name, py_json_pretty(client))
        return client

    def get_client_id_by_name(self, realm_name, client_name):
        client = self.get_client_by_name(realm_name, client_name)
        id = client.get('id')
        return id

    def get_client_descriptor(self, realm_name, metadata):
        cmd_name = ""get client descriptor realm '{realm}'"".format(
            realm=realm_name)
        url = CLIENT_DESCRIPTOR_URL_TEMPLATE.format(
            server=self.server, realm=urlquote(realm_name))

        logger.debug(""%s on server %s"", cmd_name, self.server)

        headers = {'Content-Type': 'application/xml;charset=utf-8'}

        response = self.session.post(url, headers=headers, data=metadata)
        logger.debug(""%s response code: %s %s"",
                     cmd_name, response.status_code, response.reason)

        try:
            response_json = response.json()
        except ValueError as e:
            response_json = None

        if (not response_json or
            response.status_code != requests.codes.ok):
            logger.error(""%s error: status=%s (%s) text=%s"",
                         cmd_name, response.status_code, response.reason,
                         response.text)
            raise RESTError(response.status_code, response.reason,
                            response_json, response.text, cmd_name)

        logger.debug(""%s response = %s"", cmd_name, json_pretty(response.text))

        return response_json

    def create_client_from_descriptor(self, realm_name, descriptor):
        cmd_name = ""create client from descriptor ""
        ""'{client_id}'in realm '{realm}'"".format(
            client_id=descriptor['clientId'], realm=realm_name)
        url = CREATE_CLIENT_URL_TEMPLATE.format(
            server=self.server, realm=urlquote(realm_name))

        logger.debug(""%s on server %s"", cmd_name, self.server)

        response = self.session.post(url, json=descriptor)
        logger.debug(""%s response code: %s %s"",
                     cmd_name, response.status_code, response.reason)

        try:
            response_json = response.json()
        except ValueError as e:
            response_json = None

        if response.status_code != requests.codes.created:
            logger.error(""%s error: status=%s (%s) text=%s"",
                         cmd_name, response.status_code, response.reason,
                         response.text)
            raise RESTError(response.status_code, response.reason,
                            response_json, response.text, cmd_name)

        logger.debug(""%s response = %s"", cmd_name, response.text)

    def create_client(self, realm_name, metadata):
        logger.debug(""create client in realm %s on server %s"",
                     realm_name, self.server)
        descriptor = self.get_client_descriptor(realm_name, metadata)
        self.create_client_from_descriptor(realm_name, descriptor)
        return descriptor

    def register_client(self, initial_access_token, realm_name, metadata):
        cmd_name = ""register_client realm '{realm}'"".format(
            realm=realm_name)
        url = SAML2_CLIENT_REGISTRATION_TEMPLATE.format(
            server=self.server, realm=urlquote(realm_name))

        logger.debug(""%s on server %s"", cmd_name, self.server)

        headers = {'Content-Type': 'application/xml;charset=utf-8'}

        if initial_access_token:
            headers['Authorization'] = 'Bearer {token}'.format(
                token=initial_access_token)

        response = self.session.post(url, headers=headers, data=metadata)
        logger.debug(""%s response code: %s %s"",
                     cmd_name, response.status_code, response.reason)

        try:
            response_json = response.json()
        except ValueError as e:
            response_json = None

        if (not response_json or
            response.status_code != requests.codes.created):
            logger.error(""%s error: status=%s (%s) text=%s"",
                         cmd_name, response.status_code, response.reason,
                         response.text)
            raise RESTError(response.status_code, response.reason,
                            response_json, response.text, cmd_name)

        logger.debug(""%s response = %s"", cmd_name, json_pretty(response.text))

        return response_json    # ClientRepresentation

    def delete_client_by_name(self, realm_name, client_name):
        id = self.get_client_id_by_name(realm_name, client_name)
        self.delete_client_by_id(realm_name, id)


    def delete_client_by_id(self, realm_name, id):
        cmd_name = ""delete client id '{id}'in realm '{realm}'"".format(
            id=id, realm=realm_name)
        url = CLIENT_REPRESENTATION_TEMPLATE.format(
            server=self.server, realm=urlquote(realm_name),
            id=urlquote(id))

        logger.debug(""%s on server %s"", cmd_name, self.server)
        response = self.session.delete(url)
        logger.debug(""%s response code: %s %s"",
                     cmd_name, response.status_code, response.reason)

        try:
            response_json = response.json()
        except ValueError as e:
            response_json = None

        if response.status_code != requests.codes.no_content:
            logger.error(""%s error: status=%s (%s) text=%s"",
                         cmd_name, response.status_code, response.reason,
                         response.text)
            raise RESTError(response.status_code, response.reason,
                            response_json, response.text, cmd_name)

        logger.debug(""%s response = %s"", cmd_name, response.text)

    def update_client(self, realm_name, client):
        id = client['id']
        cmd_name = ""update client {id} in realm '{realm}'"".format(
            id=client['clientId'], realm=realm_name)
        url = CLIENT_REPRESENTATION_TEMPLATE.format(
            server=self.server, realm=urlquote(realm_name),
            id=urlquote(id))

        logger.debug(""%s on server %s"", cmd_name, self.server)

        response = self.session.put(url, json=client)
        logger.debug(""%s response code: %s %s"",
                     cmd_name, response.status_code, response.reason)

        try:
            response_json = response.json()
        except ValueError as e:
            response_json = None

        if response.status_code != requests.codes.no_content:
            logger.error(""%s error: status=%s (%s) text=%s"",
                         cmd_name, response.status_code, response.reason,
                         response.text)
            raise RESTError(response.status_code, response.reason,
                            response_json, response.text, cmd_name)

        logger.debug(""%s response = %s"", cmd_name, response.text)


    def update_client_attributes(self, realm_name, client, update_attrs):
        client_id = client['clientId']
        logger.debug(""update client attrs: client_id=%s ""
        ""current attrs=%s update=%s"" % (client_id, client['attributes'],
                                update_attrs))
        client['attributes'].update(update_attrs)
        logger.debug(""update client attrs: client_id=%s ""
        ""new attrs=%s"" % (client_id, client['attributes']))
        self.update_client(realm_name, client);


    def update_client_by_name_attributes(self, realm_name, client_name,
                                         update_attrs):
        client = self.get_client_by_name(realm_name, client_name)
        self.update_client_attributes(realm_name, client, update_attrs)

    def new_saml_group_protocol_mapper(self, mapper_name, attribute_name,
                                       friendly_name=None,
                                       single_attribute=True):
        mapper = {
            'protocol': 'saml',
            'name': mapper_name,
            'protocolMapper': 'saml-group-membership-mapper',
            'config': {
                'attribute.name': attribute_name,
                'attribute.nameformat': 'Basic',
                'single': single_attribute,
                'full.path': False,
            },
        }

        if friendly_name:
            mapper['config']['friendly.name'] = friendly_name

        return mapper

    def create_client_protocol_mapper(self, realm_name, client, mapper):
        id = client['id']
        cmd_name = (""create protocol-mapper '{mapper_name}' for client {id} ""
                    ""in realm '{realm}'"".format(
                        mapper_name=mapper['name'],id=client['clientId'], realm=realm_name))
        url = POST_CLIENT_PROTOCOL_MAPPER_TEMPLATE.format(
            server=self.server,
            realm=urlquote(realm_name),
            id=urlquote(id))

        logger.debug(""%s on server %s"", cmd_name, self.server)

        response = self.session.post(url, json=mapper)
        logger.debug(""%s response code: %s %s"",
                     cmd_name, response.status_code, response.reason)

        try:
            response_json = response.json()
        except ValueError as e:
            response_json = None

        if response.status_code != requests.codes.created:
            logger.error(""%s error: status=%s (%s) text=%s"",
                         cmd_name, response.status_code, response.reason,
                         response.text)
            raise RESTError(response.status_code, response.reason,
                            response_json, response.text, cmd_name)

        logger.debug(""%s response = %s"", cmd_name, response.text)


    def create_client_by_name_protocol_mapper(self, realm_name, client_name,
                                              mapper):
        client = self.get_client_by_name(realm_name, client_name)
        self.create_client_protocol_mapper(realm_name, client, mapper)



    def add_client_by_name_redirect_uris(self, realm_name, client_name, uris):
        client = self.get_client_by_name(realm_name, client_name)

        uris = set(uris)
        redirect_uris = set(client['redirectUris'])
        redirect_uris |= uris
        client['redirectUris'] = list(redirect_uris)
        self.update_client(realm_name, client);

    def remove_client_by_name_redirect_uris(self, realm_name, client_name, uris):
        client = self.get_client_by_name(realm_name, client_name)

        uris = set(uris)
        redirect_uris = set(client['redirectUris'])
        redirect_uris -= uris
        client['redirectUris'] = list(redirect_uris)

        self.update_client(realm_name, client);


# ------------------------------------------------------------------------------


class KeycloakAdminConnection(KeycloakREST):

    def __init__(self, server, auth_role, realm, client_id,
                 username, password, tls_verify):
        super(KeycloakAdminConnection, self).__init__(server, auth_role)

        self.realm = realm
        self.client_id = client_id
        self.username = username
        self.password = password

        self.session = self._create_session(tls_verify)

    def _create_session(self, tls_verify):
        token_url = TOKEN_URL_TEMPLATE.format(
            server=self.server, realm=urlquote(self.realm))
        refresh_url = token_url

        client = LegacyApplicationClient(client_id=self.client_id)
        session = OAuth2Session(client=client,
                                auto_refresh_url=refresh_url,
                                auto_refresh_kwargs={
                                    'client_id': self.client_id})

        session.verify = tls_verify
        token = session.fetch_token(token_url=token_url,
                                    username=self.username,
                                    password=self.password,
                                    client_id=self.client_id,
                                    verify=session.verify)

        return session


class KeycloakAnonymousConnection(KeycloakREST):

    def __init__(self, server, tls_verify):
        super(KeycloakAnonymousConnection, self).__init__(server, 'anonymous')
        self.session = self._create_session(tls_verify)


    def _create_session(self, tls_verify):
        session = requests.Session()
        session.verify = tls_verify

        return session

# ------------------------------------------------------------------------------


def do_server_info(options, conn):
    server_info = conn.get_server_info()
    print(json_pretty(server_info))


def do_list_realms(options, conn):
    realms = conn.get_realms()
    realm_names = get_realm_names_from_realms(realms)
    print('\n'.join(sorted(realm_names)))


def do_create_realm(options, conn):
    conn.create_realm(options.realm_name)


def do_delete_realm(options, conn):
    conn.delete_realm(options.realm_name)


def do_get_realm_metadata(options, conn):
    metadata = conn.get_realm_metadata(options.realm_name)
    print(metadata)


def do_list_clients(options, conn):
    clients = conn.get_clients(options.realm_name)
    client_ids = get_client_client_ids_from_clients(clients)
    print('\n'.join(sorted(client_ids)))


def do_create_client(options, conn):
    metadata = options.metadata.read()
    descriptor = conn.create_client(options.realm_name, metadata)


def do_register_client(options, conn):
    metadata = options.metadata.read()
    client_representation = conn.register_client(
        options.initial_access_token,
        options.realm_name, metadata)


def do_delete_client(options, conn):
    conn.delete_client_by_name(options.realm_name, options.client_name)

def do_client_test(options, conn):
    'experimental test code used during development'

    uri = 'https://openstack.jdennis.oslab.test:5000/v3/mellon/fooResponse'

    conn.remove_client_by_name_redirect_uri(options.realm_name,
                                            options.client_name,
                                            uri)

# ------------------------------------------------------------------------------

verbose_help = '''

The structure of the command line arguments is ""noun verb"" where noun
is one of Keycloak's data items (e.g. realm, client, etc.) and the
verb is an action to perform on the item. Each of the nouns and verbs
may have their own set of arguments which must follow the noun or
verb.

For example to delete the client XYZ in the realm ABC:

echo password | {prog_name} -s http://example.com:8080 -P - client delete -r ABC -c XYZ

where 'client' is the noun, 'delete' is the verb and -r ABC -c XYZ are
arguments to the delete action.

If the command completes successfully the exit status is 0. The exit
status is 1 if an authenticated connection with the server cannont be
successfully established. The exit status is 2 if the REST operation
fails.

The server should be a scheme://hostname:port URL.
'''


class TlsVerifyAction(argparse.Action):
    def __init__(self, option_strings, dest, nargs=None, **kwargs):
        if nargs is not None:
            raise ValueError(""nargs not allowed"")
        super(TlsVerifyAction, self).__init__(option_strings, dest, **kwargs)

    def __call__(self, parser, namespace, values, option_string=None):
        if values.lower() in ['true', 'yes', 'on']:
            verify = True
        elif values.lower() in ['false', 'no', 'off']:
            verify = False
        else:
            verify = values
            
        setattr(namespace, self.dest, verify)

def main():
    global logger
    result = 0

    parser = argparse.ArgumentParser(description='Keycloak REST client',
                    prog=prog_name,
                    epilog=verbose_help.format(prog_name=prog_name),
                    formatter_class=argparse.RawDescriptionHelpFormatter)

    parser.add_argument('-v', '--verbose', action='store_true',
                        help='be chatty')

    parser.add_argument('-d', '--debug', action='store_true',
                        help='turn on debug info')

    parser.add_argument('--show-traceback', action='store_true',
                        help='exceptions print traceback in addition to '
                             'error message')

    parser.add_argument('--log-file',
                        default='{prog_name}.log'.format(
                            prog_name=prog_name),
                        help='log file pathname')

    parser.add_argument('--permit-insecure-transport',  action='store_true',
                        help='Normally secure transport such as TLS '
                        'is required, defeat this check')

    parser.add_argument('--tls-verify', action=TlsVerifyAction,
                        default=True,
                        help='TLS certificate verification for requests to'
                        ' the server. May be one of case insenstive '
                        '[true, yes, on] to enable,'
                        '[false, no, off] to disable.'
                        'Or the pathname to a OpenSSL CA bundle to use.'
                        ' Default is True.')

    group = parser.add_argument_group('Server')

    group.add_argument('-s', '--server',
                       required=True,
                       help='DNS name or IP address of Keycloak server')

    group.add_argument('-a', '--auth-role',
                       choices=AUTH_ROLES,
                       default='root-admin',
                       help='authenticating as what type of user (default: root-admin)')

    group.add_argument('-u', '--admin-username',
                       default='admin',
                       help='admin user name (default: admin)')

    group.add_argument('-P', '--admin-password-file',
                       type=argparse.FileType('rb'),
                       help=('file containing admin password '
                             '(or use a hyphen ""-"" to read the password '
                             'from stdin)'))

    group.add_argument('--admin-realm',
                       default='master',
                       help='realm admin belongs to')

    cmd_parsers = parser.add_subparsers(help='available commands')

    # --- realm commands ---
    realm_parser = cmd_parsers.add_parser('realm',
                                          help='realm operations')

    sub_parser = realm_parser.add_subparsers(help='realm commands')

    cmd_parser = sub_parser.add_parser('server_info',
                                       help='dump server info')
    cmd_parser.set_defaults(func=do_server_info)

    cmd_parser = sub_parser.add_parser('list',
                                       help='list realm names')
    cmd_parser.set_defaults(func=do_list_realms)

    cmd_parser = sub_parser.add_parser('create',
                                       help='create new realm')
    cmd_parser.add_argument('-r', '--realm-name', required=True,
                            help='realm name')
    cmd_parser.set_defaults(func=do_create_realm)

    cmd_parser = sub_parser.add_parser('delete',
                                       help='delete existing realm')
    cmd_parser.add_argument('-r', '--realm-name', required=True,
                            help='realm name')
    cmd_parser.set_defaults(func=do_delete_realm)

    cmd_parser = sub_parser.add_parser('metadata',
                                       help='retrieve realm metadata')
    cmd_parser.add_argument('-r', '--realm-name', required=True,
                            help='realm name')
    cmd_parser.set_defaults(func=do_get_realm_metadata)

    # --- client commands ---
    client_parser = cmd_parsers.add_parser('client',
                                           help='client operations')

    sub_parser = client_parser.add_subparsers(help='client commands')

    cmd_parser = sub_parser.add_parser('list',
                                       help='list client names')
    cmd_parser.add_argument('-r', '--realm-name', required=True,
                            help='realm name')

    cmd_parser.set_defaults(func=do_list_clients)

    cmd_parser = sub_parser.add_parser('create',
                                       help='create new client')
    cmd_parser.add_argument('-r', '--realm-name', required=True,
                            help='realm name')
    cmd_parser.add_argument('-m', '--metadata', type=argparse.FileType('rb'),
                            required=True,
                            help='SP metadata file or stdin')
    cmd_parser.set_defaults(func=do_create_client)

    cmd_parser = sub_parser.add_parser('register',
                                       help='register new client')
    cmd_parser.add_argument('-r', '--realm-name', required=True,
                            help='realm name')
    cmd_parser.add_argument('-m', '--metadata', type=argparse.FileType('rb'),
                            required=True,
                            help='SP metadata file or stdin')
    cmd_parser.add_argument('--initial-access-token', required=True,
                            help='realm initial access token for '
                            'client registeration')
    cmd_parser.set_defaults(func=do_register_client)

    cmd_parser = sub_parser.add_parser('delete',
                                       help='delete existing client')
    cmd_parser.add_argument('-r', '--realm-name', required=True,
                            help='realm name')
    cmd_parser.add_argument('-c', '--client-name', required=True,
                            help='client name')
    cmd_parser.set_defaults(func=do_delete_client)

    cmd_parser = sub_parser.add_parser('test',
                                       help='experimental test used during '
                                       'development')
    cmd_parser.add_argument('-r', '--realm-name', required=True,
                            help='realm name')
    cmd_parser.add_argument('-c', '--client-name', required=True,
                            help='client name')
    cmd_parser.set_defaults(func=do_client_test)

    # Process command line arguments
    options = parser.parse_args()
    configure_logging(options)

    if options.permit_insecure_transport:
        os.environ['OAUTHLIB_INSECURE_TRANSPORT'] = '1'

    # Get admin password
    options.admin_password = None

    # 1. Try password file
    if options.admin_password_file is not None:
        options.admin_password = options.keycloak_admin_password_file.readline().strip()
        options.keycloak_admin_password_file.close()

    # 2. Try KEYCLOAK_ADMIN_PASSWORD environment variable
    if options.admin_password is None:
        if (('KEYCLOAK_ADMIN_PASSWORD' in os.environ) and
            (os.environ['KEYCLOAK_ADMIN_PASSWORD'])):
            options.admin_password = os.environ['KEYCLOAK_ADMIN_PASSWORD']

    try:
        anonymous_conn = KeycloakAnonymousConnection(options.server,
                                                     options.tls_verify)

        admin_conn = KeycloakAdminConnection(options.server,
                                             options.auth_role,
                                             options.admin_realm,
                                             ADMIN_CLIENT_ID,
                                             options.admin_username,
                                             options.admin_password,
                                             options.tls_verify)
    except Exception as e:
        if options.show_traceback:
            traceback.print_exc()
        print(six.text_type(e), file=sys.stderr)
        result = 1
        return result

    try:
        if options.func == do_register_client:
            conn = admin_conn
        else:
            conn = admin_conn
        result = options.func(options, conn)
    except Exception as e:
        if options.show_traceback:
            traceback.print_exc()
        print(six.text_type(e), file=sys.stderr)
        result = 2
        return result

    return result

# ------------------------------------------------------------------------------

if __name__ == '__main__':
    sys.exit(main())
else:
    logger = logging.getLogger('keycloak-cli')
"
"#
# Copyright © 2012–2022 Michal Čihař <michal@cihar.com>
#
# This file is part of Weblate <https://weblate.org/>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
#

import copy
import json
import re
from datetime import date, datetime, timedelta
from typing import Dict, List

from crispy_forms.bootstrap import InlineCheckboxes, InlineRadios, Tab, TabHolder
from crispy_forms.helper import FormHelper
from crispy_forms.layout import Div, Field, Fieldset, Layout
from django import forms
from django.conf import settings
from django.core.exceptions import NON_FIELD_ERRORS, PermissionDenied, ValidationError
from django.core.validators import FileExtensionValidator
from django.db.models import Q
from django.forms import model_to_dict
from django.forms.models import ModelChoiceIterator
from django.forms.utils import from_current_timezone
from django.template.loader import render_to_string
from django.urls import reverse
from django.utils import timezone
from django.utils.http import urlencode
from django.utils.safestring import mark_safe
from django.utils.translation import gettext
from django.utils.translation import gettext_lazy as _
from translation_finder import DiscoveryResult, discover

from weblate.auth.models import Group, User
from weblate.checks.flags import Flags
from weblate.checks.models import CHECKS
from weblate.checks.utils import highlight_string
from weblate.formats.models import EXPORTERS, FILE_FORMATS
from weblate.glossary.forms import GlossaryAddMixin
from weblate.lang.data import BASIC_LANGUAGES
from weblate.lang.models import Language
from weblate.machinery import MACHINE_TRANSLATION_SERVICES
from weblate.trans.defines import COMPONENT_NAME_LENGTH, REPO_LENGTH
from weblate.trans.filter import FILTERS, get_filter_choice
from weblate.trans.models import (
    Announcement,
    Change,
    Component,
    Label,
    Project,
    ProjectToken,
    Unit,
)
from weblate.trans.specialchars import RTL_CHARS_DATA, get_special_chars
from weblate.trans.util import check_upload_method_permissions, is_repo_link
from weblate.trans.validators import validate_check_flags
from weblate.utils.antispam import is_spam
from weblate.utils.errors import report_error
from weblate.utils.forms import (
    ColorWidget,
    ContextDiv,
    EmailField,
    SearchField,
    SortedSelect,
    SortedSelectMultiple,
    UsernameField,
)
from weblate.utils.hash import checksum_to_hash, hash_to_checksum
from weblate.utils.search import parse_query
from weblate.utils.state import (
    STATE_APPROVED,
    STATE_CHOICES,
    STATE_EMPTY,
    STATE_FUZZY,
    STATE_READONLY,
    STATE_TRANSLATED,
)
from weblate.utils.validators import validate_file_extension
from weblate.vcs.models import VCS_REGISTRY

BUTTON_TEMPLATE = """"""
<button class=""btn btn-default {0}"" title=""{1}"" {2}>{3}</button>
""""""
RADIO_TEMPLATE = """"""
<label class=""btn btn-default {0}"" title=""{1}"">
<input type=""radio"" name=""{2}"" value=""{3}"" {4}/>
{5}
</label>
""""""
GROUP_TEMPLATE = """"""
<div class=""btn-group btn-group-xs"" {0}>{1}</div>
""""""
TOOLBAR_TEMPLATE = """"""
<div class=""btn-toolbar pull-right flip editor-toolbar"">{0}</div>
""""""


class MarkdownTextarea(forms.Textarea):
    def __init__(self, **kwargs):
        kwargs[""attrs""] = {
            ""dir"": ""auto"",
            ""class"": ""markdown-editor highlight-editor"",
            ""data-mode"": ""markdown"",
        }
        super().__init__(**kwargs)


class WeblateDateInput(forms.DateInput):
    def __init__(self, datepicker=True, **kwargs):
        attrs = {""type"": ""date""}
        if datepicker:
            attrs[""data-provide""] = ""datepicker""
            attrs[""data-date-format""] = ""yyyy-mm-dd""
        super().__init__(attrs=attrs, format=""%Y-%m-%d"", **kwargs)


class WeblateDateField(forms.DateField):
    def __init__(self, datepicker=True, **kwargs):
        if ""widget"" not in kwargs:
            kwargs[""widget""] = WeblateDateInput(datepicker=datepicker)
        super().__init__(**kwargs)

    def to_python(self, value):
        """"""Produce timezone aware datetime with 00:00:00 as time.""""""
        value = super().to_python(value)
        if isinstance(value, date):
            return from_current_timezone(
                datetime(value.year, value.month, value.day, 0, 0, 0)
            )
        return value


class ChecksumField(forms.CharField):
    """"""Field for handling checksum IDs for translation.""""""

    def __init__(self, *args, **kwargs):
        kwargs[""widget""] = forms.HiddenInput
        super().__init__(*args, **kwargs)

    def clean(self, value):
        super().clean(value)
        if not value:
            return None
        try:
            return checksum_to_hash(value)
        except ValueError:
            raise ValidationError(_(""Invalid checksum specified!""))


class UserField(forms.CharField):
    def clean(self, value):
        if not value:
            return None
        try:
            return User.objects.get(Q(username=value) | Q(email=value))
        except User.DoesNotExist:
            raise ValidationError(_(""Could not find any such user.""))
        except User.MultipleObjectsReturned:
            raise ValidationError(_(""More possible users were found.""))


class QueryField(forms.CharField):
    def __init__(self, **kwargs):
        if ""label"" not in kwargs:
            kwargs[""label""] = _(""Query"")
        if ""required"" not in kwargs:
            kwargs[""required""] = False
        super().__init__(**kwargs)

    def clean(self, value):
        if not value:
            if self.required:
                raise ValidationError(_(""Missing query string.""))
            return """"
        try:
            parse_query(value)
            return value
        except Exception as error:
            report_error()
            raise ValidationError(_(""Could not parse query string: {}"").format(error))


class FlagField(forms.CharField):
    default_validators = [validate_check_flags]


class PluralTextarea(forms.Textarea):
    """"""Text-area extension which possibly handles plurals.""""""

    def __init__(self, *args, **kwargs):
        self.profile = None
        super().__init__(*args, **kwargs)

    def get_rtl_toolbar(self, fieldname):
        groups = []

        # Special chars
        chars = []
        for name, char, value in RTL_CHARS_DATA:
            chars.append(
                BUTTON_TEMPLATE.format(
                    ""specialchar"",
                    name,
                    'data-value=""{}""'.format(
                        value.encode(""ascii"", ""xmlcharrefreplace"").decode(""ascii"")
                    ),
                    char,
                )
            )

        groups.append(GROUP_TEMPLATE.format("""", ""\n"".join(chars)))
        return TOOLBAR_TEMPLATE.format(""\n"".join(groups))

    def get_rtl_toggle(self, language, fieldname):
        if language.direction != ""rtl"":
            return """"

        # RTL/LTR switch
        rtl_name = f""rtl-{fieldname}""
        rtl_switch = [
            RADIO_TEMPLATE.format(
                ""direction-toggle active"",
                gettext(""Toggle text direction""),
                rtl_name,
                ""rtl"",
                'checked=""checked""',
                ""RTL"",
            ),
            RADIO_TEMPLATE.format(
                ""direction-toggle"",
                gettext(""Toggle text direction""),
                rtl_name,
                ""ltr"",
                """",
                ""LTR"",
            ),
        ]
        groups = [GROUP_TEMPLATE.format('data-toggle=""buttons""', ""\n"".join(rtl_switch))]
        return mark_safe(TOOLBAR_TEMPLATE.format(""\n"".join(groups)))

    def get_toolbar(self, language, fieldname, unit, idx, source):
        """"""Return toolbar HTML code.""""""
        profile = self.profile
        groups = []

        # Special chars
        chars = [
            BUTTON_TEMPLATE.format(
                ""specialchar"",
                name,
                'data-value=""{}""'.format(
                    value.encode(""ascii"", ""xmlcharrefreplace"").decode(""ascii"")
                ),
                char,
            )
            for name, char, value in get_special_chars(
                language, profile.special_chars, unit.source
            )
        ]

        groups.append(GROUP_TEMPLATE.format("""", ""\n"".join(chars)))

        result = TOOLBAR_TEMPLATE.format(""\n"".join(groups))

        if language.direction == ""rtl"":
            result = self.get_rtl_toolbar(fieldname) + result

        return mark_safe(result)

    def render(self, name, value, attrs=None, renderer=None, **kwargs):
        """"""Render all textareas with correct plural labels.""""""
        unit = value
        values = unit.get_target_plurals()
        lang = unit.translation.language
        plural = unit.translation.plural
        tabindex = self.attrs[""tabindex""]
        placeables = [hl[2] for hl in highlight_string(unit.source_string, unit)]

        # Need to add extra class
        attrs[""class""] = ""translation-editor form-control highlight-editor""
        attrs[""tabindex""] = tabindex
        attrs[""lang""] = lang.code
        attrs[""dir""] = lang.direction
        attrs[""rows""] = 3
        attrs[""data-max""] = unit.get_max_length()
        attrs[""data-mode""] = unit.edit_mode
        attrs[""data-placeables""] = ""|"".join(re.escape(pl) for pl in placeables if pl)
        if unit.readonly:
            attrs[""readonly""] = 1

        # Okay we have more strings
        ret = []
        plurals = unit.get_source_plurals()
        base_id = f""id_{unit.checksum}""
        for idx, val in enumerate(values):
            # Generate ID
            fieldname = f""{name}_{idx}""
            fieldid = f""{base_id}_{idx}""
            attrs[""id""] = fieldid
            attrs[""tabindex""] = tabindex + idx
            if idx and len(plurals) > 1:
                source = plurals[1]
            else:
                source = plurals[0]

            # Render textare
            textarea = super().render(fieldname, val, attrs, renderer, **kwargs)
            # Label for plural
            label = str(unit.translation.language)
            if len(values) != 1:
                label = f""{label}, {plural.get_plural_label(idx)}""
            ret.append(
                render_to_string(
                    ""snippets/editor.html"",
                    {
                        ""toolbar"": self.get_toolbar(lang, fieldid, unit, idx, source),
                        ""fieldid"": fieldid,
                        ""label"": mark_safe(label),
                        ""textarea"": textarea,
                        ""max_length"": attrs[""data-max""],
                        ""length"": len(val),
                        ""source_length"": len(source),
                        ""rtl_toggle"": self.get_rtl_toggle(lang, fieldid),
                    },
                )
            )

        # Show plural formula for more strings
        if len(values) > 1:
            ret.append(
                render_to_string(
                    ""snippets/plural-formula.html"",
                    {""plural"": plural, ""user"": self.profile.user},
                )
            )

        # Join output
        return mark_safe("""".join(ret))

    def value_from_datadict(self, data, files, name):
        """"""Return processed plurals as a list.""""""
        ret = []
        for idx in range(0, 10):
            fieldname = f""{name}_{idx:d}""
            if fieldname not in data:
                break
            ret.append(data.get(fieldname, """"))
        return [r.replace(""\r"", """") for r in ret]


class PluralField(forms.CharField):
    """"""Renderer for the plural field.

    The only difference from CharField is that it does not force value to be string.
    """"""

    def __init__(self, max_length=None, min_length=None, **kwargs):
        kwargs[""label""] = """"
        super().__init__(widget=PluralTextarea, **kwargs)

    def to_python(self, value):
        """"""Return list or string as returned by PluralTextarea.""""""
        return value

    def clean(self, value):
        value = super().clean(value)
        if not value or (self.required and not any(value)):
            raise ValidationError(_(""Missing translated string!""))
        return value


class FilterField(forms.ChoiceField):
    def __init__(self, *args, **kwargs):
        kwargs[""label""] = _(""Search filter"")
        if ""required"" not in kwargs:
            kwargs[""required""] = False
        kwargs[""choices""] = get_filter_choice()
        kwargs[""error_messages""] = {
            ""invalid_choice"": _(""Please choose a valid filter type."")
        }
        super().__init__(*args, **kwargs)

    def to_python(self, value):
        if value == ""untranslated"":
            return ""todo""
        return super().to_python(value)


class ChecksumForm(forms.Form):
    """"""Form for handling checksum IDs for translation.""""""

    checksum = ChecksumField(required=True)

    def __init__(self, unit_set, *args, **kwargs):
        self.unit_set = unit_set
        super().__init__(*args, **kwargs)

    def clean_checksum(self):
        """"""Validate whether checksum is valid and fetches unit for it.""""""
        if ""checksum"" not in self.cleaned_data:
            return

        unit_set = self.unit_set

        try:
            self.cleaned_data[""unit""] = unit_set.filter(
                id_hash=self.cleaned_data[""checksum""]
            )[0]
        except (Unit.DoesNotExist, IndexError):
            raise ValidationError(
                _(""The string you wanted to translate is no longer available."")
            )


class UnitForm(forms.Form):
    def __init__(self, unit: Unit, *args, **kwargs):
        self.unit = unit
        super().__init__(*args, **kwargs)


class FuzzyField(forms.BooleanField):
    help_as_icon = True

    def __init__(self, *args, **kwargs):
        kwargs[""label""] = _(""Needs editing"")
        kwargs[""help_text""] = _(
            'Strings are usually marked as ""Needs editing"" after the source '
            ""string is updated, or when marked as such manually.""
        )
        super().__init__(*args, **kwargs)
        self.widget.attrs[""class""] = ""fuzzy_checkbox""


class TranslationForm(UnitForm):
    """"""Form used for translation of single string.""""""

    contentsum = ChecksumField(required=True)
    translationsum = ChecksumField(required=True)
    target = PluralField(required=False)
    fuzzy = FuzzyField(required=False)
    review = forms.ChoiceField(
        label=_(""Review state""),
        choices=[
            (STATE_FUZZY, _(""Needs editing"")),
            (STATE_TRANSLATED, _(""Waiting for review"")),
            (STATE_APPROVED, _(""Approved"")),
        ],
        required=False,
        widget=forms.RadioSelect,
    )
    explanation = forms.CharField(
        widget=MarkdownTextarea,
        label=_(""Explanation""),
        help_text=_(
            ""Additional explanation to clarify meaning or usage of the string.""
        ),
        max_length=1000,
        required=False,
    )

    def __init__(self, user, unit: Unit, *args, **kwargs):
        if unit is not None:
            kwargs[""initial""] = {
                ""checksum"": unit.checksum,
                ""contentsum"": hash_to_checksum(unit.content_hash),
                ""translationsum"": hash_to_checksum(unit.get_target_hash()),
                ""target"": unit,
                ""fuzzy"": unit.fuzzy,
                ""review"": unit.state,
                ""explanation"": unit.explanation,
            }
            kwargs[""auto_id""] = f""id_{unit.checksum}_%s""
        tabindex = kwargs.pop(""tabindex"", 100)
        super().__init__(unit, *args, **kwargs)
        if unit.readonly:
            for field in [""target"", ""fuzzy"", ""review""]:
                self.fields[field].widget.attrs[""readonly""] = 1
            self.fields[""review""].choices = [
                (STATE_READONLY, _(""Read only"")),
            ]
        self.user = user
        self.fields[""target""].widget.attrs[""tabindex""] = tabindex
        self.fields[""target""].widget.profile = user.profile
        self.fields[""review""].widget.attrs[""class""] = ""review_radio""
        # Avoid failing validation on untranslated string
        if args:
            self.fields[""review""].choices.append((STATE_EMPTY, """"))
        self.helper = FormHelper()
        self.helper.form_method = ""post""
        self.helper.form_tag = False
        self.helper.disable_csrf = True
        self.helper.layout = Layout(
            Field(""target""),
            Field(""fuzzy""),
            Field(""contentsum""),
            Field(""translationsum""),
            InlineRadios(""review""),
            Field(""explanation""),
        )
        if unit and user.has_perm(""unit.review"", unit.translation):
            self.fields[""fuzzy""].widget = forms.HiddenInput()
        else:
            self.fields[""review""].widget = forms.HiddenInput()
        if not unit.translation.component.is_glossary:
            self.fields[""explanation""].widget = forms.HiddenInput()

    def clean(self):
        super().clean()

        # Check required fields
        required = {""target"", ""contentsum"", ""translationsum""}
        if not required.issubset(self.cleaned_data):
            return

        unit = self.unit

        if self.cleaned_data[""contentsum""] != unit.content_hash:
            raise ValidationError(
                _(
                    ""Source string has been changed meanwhile. ""
                    ""Please check your changes.""
                )
            )

        if self.cleaned_data[""translationsum""] != unit.get_target_hash():
            raise ValidationError(
                _(
                    ""Translation of the string has been changed meanwhile. ""
                    ""Please check your changes.""
                )
            )

        max_length = unit.get_max_length()
        for text in self.cleaned_data[""target""]:
            if len(text) > max_length:
                raise ValidationError(_(""Translation text too long!""))
        if self.user.has_perm(
            ""unit.review"", unit.translation
        ) and self.cleaned_data.get(""review""):
            self.cleaned_data[""state""] = int(self.cleaned_data[""review""])
        elif self.cleaned_data[""fuzzy""]:
            self.cleaned_data[""state""] = STATE_FUZZY
        else:
            self.cleaned_data[""state""] = STATE_TRANSLATED


class ZenTranslationForm(TranslationForm):
    checksum = ChecksumField(required=True)

    def __init__(self, user, unit, *args, **kwargs):
        super().__init__(user, unit, *args, **kwargs)
        self.helper.form_action = reverse(
            ""save_zen"", kwargs=unit.translation.get_reverse_url_kwargs()
        )
        self.helper.form_tag = True
        self.helper.disable_csrf = False
        self.helper.layout.append(Field(""checksum""))


class DownloadForm(forms.Form):
    q = QueryField()
    format = forms.ChoiceField(
        label=_(""File format""),
        choices=[(x.name, x.verbose) for x in EXPORTERS.values()],
        initial=""po"",
        required=True,
        widget=forms.RadioSelect,
    )

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.helper = FormHelper(self)
        self.helper.form_tag = False
        self.helper.layout = Layout(
            SearchField(""q""),
            InlineRadios(""format""),
        )


class SimpleUploadForm(forms.Form):
    """"""Base form for uploading a file.""""""

    file = forms.FileField(label=_(""File""), validators=[validate_file_extension])
    method = forms.ChoiceField(
        label=_(""File upload mode""),
        choices=(
            (""translate"", _(""Add as translation"")),
            (""approve"", _(""Add as approved translation"")),
            (""suggest"", _(""Add as suggestion"")),
            (""fuzzy"", _(""Add as translation needing edit"")),
            (""replace"", _(""Replace existing translation file"")),
            (""source"", _(""Update source strings"")),
            (""add"", _(""Add new strings"")),
        ),
        widget=forms.RadioSelect,
        required=True,
    )
    fuzzy = forms.ChoiceField(
        label=_(""Processing of strings needing edit""),
        choices=(
            ("""", _(""Do not import"")),
            (""process"", _(""Import as string needing edit"")),
            (""approve"", _(""Import as translated"")),
        ),
        required=False,
    )

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.helper = FormHelper(self)
        self.helper.form_tag = False

    @staticmethod
    def get_field_doc(field):
        return (""user/files"", f""upload-{field.name}"")

    def remove_translation_choice(self, value):
        """"""Remove add as translation choice.""""""
        choices = self.fields[""method""].choices
        self.fields[""method""].choices = [
            choice for choice in choices if choice[0] != value
        ]


class UploadForm(SimpleUploadForm):
    """"""Upload form with the option to overwrite current messages.""""""

    conflicts = forms.ChoiceField(
        label=_(""Conflict handling""),
        help_text=_(
            ""Whether to overwrite existing translations if the string is ""
            ""already translated.""
        ),
        choices=(
            ("""", _(""Update only untranslated strings"")),
            (""replace-translated"", _(""Update translated strings"")),
            (""replace-approved"", _(""Update translated and approved strings"")),
        ),
        required=False,
        initial=""replace-translated"",
    )


class ExtraUploadForm(UploadForm):
    """"""Advanced upload form for users who can override authorship.""""""

    author_name = forms.CharField(label=_(""Author name""))
    author_email = EmailField(label=_(""Author e-mail""))


def get_upload_form(user, translation, *args, **kwargs):
    """"""Return correct upload form based on user permissions.""""""
    if user.has_perm(""upload.authorship"", translation):
        form = ExtraUploadForm
        kwargs[""initial""] = {""author_name"": user.full_name, ""author_email"": user.email}
    elif user.has_perm(""upload.overwrite"", translation):
        form = UploadForm
    else:
        form = SimpleUploadForm
    result = form(*args, **kwargs)
    for method in [x[0] for x in result.fields[""method""].choices]:
        if not check_upload_method_permissions(user, translation, method):
            result.remove_translation_choice(method)
    # Remove approved choice for non review projects
    if not user.has_perm(""unit.review"", translation) and not form == SimpleUploadForm:
        result.fields[""conflicts""].choices = [
            choice
            for choice in result.fields[""conflicts""].choices
            if choice[0] != ""approved""
        ]
    return result


class SearchForm(forms.Form):
    """"""Text searching form.""""""

    # pylint: disable=invalid-name
    q = QueryField()
    sort_by = forms.CharField(required=False, widget=forms.HiddenInput)
    checksum = ChecksumField(required=False)
    offset = forms.IntegerField(min_value=-1, required=False, widget=forms.HiddenInput)
    offset_kwargs = {}

    def __init__(self, user, language=None, show_builder=True, **kwargs):
        """"""Generate choices for other component in same project.""""""
        self.user = user
        self.language = language
        super().__init__(**kwargs)

        self.helper = FormHelper(self)
        self.helper.disable_csrf = True
        self.helper.form_tag = False
        self.helper.layout = Layout(
            Div(
                Field(""offset"", **self.offset_kwargs),
                SearchField(""q""),
                Field(""sort_by"", template=""snippets/sort-field.html""),
                css_class=""btn-toolbar"",
                role=""toolbar"",
            ),
            ContextDiv(
                template=""snippets/query-builder.html"",
                context={
                    ""user"": self.user,
                    ""month_ago"": timezone.now() - timedelta(days=31),
                    ""show_builder"": show_builder,
                    ""language"": self.language,
                },
            ),
            Field(""checksum""),
        )

    def get_name(self):
        """"""Return verbose name for a search.""""""
        return FILTERS.get_search_name(self.cleaned_data.get(""q"", """"))

    def get_search_query(self):
        return self.cleaned_data[""q""]

    def clean_offset(self):
        if self.cleaned_data.get(""offset"") is None:
            self.cleaned_data[""offset""] = 1
        return self.cleaned_data[""offset""]

    def items(self):
        items = []
        # Skip checksum and offset as these change
        ignored = {""offset"", ""checksum""}
        for param in sorted(self.cleaned_data):
            value = self.cleaned_data[param]
            # We don't care about empty values or ignored
            if value is None or param in ignored:
                continue
            if isinstance(value, bool):
                # Only store true values
                if value:
                    items.append((param, ""1""))
            elif isinstance(value, int):
                # Avoid storing 0 values
                if value > 0:
                    items.append((param, str(value)))
            elif isinstance(value, datetime):
                # Convert date to string
                items.append((param, value.date().isoformat()))
            elif isinstance(value, list):
                for val in value:
                    items.append((param, val))
            elif isinstance(value, User):
                items.append((param, value.username))
            else:
                # It should be string here
                if value:
                    items.append((param, value))
        return items

    def urlencode(self):
        return urlencode(self.items())

    def reset_offset(self):
        """"""Reset offset to avoid using form as default for new search.""""""
        data = copy.copy(self.data)
        data[""offset""] = ""1""
        data[""checksum""] = """"
        self.data = data
        return self


class PositionSearchForm(SearchForm):
    offset = forms.IntegerField(min_value=-1, required=False)
    offset_kwargs = {""template"": ""snippets/position-field.html""}


class MergeForm(UnitForm):
    """"""Simple form for merging translation of two units.""""""

    merge = forms.IntegerField()

    def clean(self):
        super().clean()
        if ""merge"" not in self.cleaned_data:
            return None
        try:
            unit = self.unit
            translation = unit.translation
            project = translation.component.project
            self.cleaned_data[""merge_unit""] = merge_unit = Unit.objects.get(
                pk=self.cleaned_data[""merge""],
                translation__component__project=project,
                translation__language=translation.language,
            )
            # Compare in Python to ensure case sensitiveness on MySQL
            if not translation.is_source and unit.source != merge_unit.source:
                raise ValidationError(_(""Could not find merged string.""))
        except Unit.DoesNotExist:
            raise ValidationError(_(""Could not find merged string.""))
        return self.cleaned_data


class RevertForm(UnitForm):
    """"""Form for reverting edits.""""""

    revert = forms.IntegerField()

    def clean(self):
        super().clean()
        if ""revert"" not in self.cleaned_data:
            return None
        try:
            self.cleaned_data[""revert_change""] = Change.objects.get(
                pk=self.cleaned_data[""revert""], unit=self.unit
            )
        except Change.DoesNotExist:
            raise ValidationError(_(""Could not find reverted change.""))
        return self.cleaned_data


class AutoForm(forms.Form):
    """"""Automatic translation form.""""""

    mode = forms.ChoiceField(
        label=_(""Automatic translation mode""),
        choices=[
            (""suggest"", _(""Add as suggestion"")),
            (""translate"", _(""Add as translation"")),
            (""fuzzy"", _(""Add as needing edit"")),
        ],
        initial=""suggest"",
    )
    filter_type = FilterField(
        required=True,
        initial=""todo"",
        help_text=_(
            ""Please note that translating all strings will ""
            ""discard all existing translations.""
        ),
    )
    auto_source = forms.ChoiceField(
        label=_(""Automatic translation source""),
        choices=[
            (""others"", _(""Other translation components"")),
            (""mt"", _(""Machine translation"")),
        ],
        initial=""others"",
    )
    component = forms.ChoiceField(
        label=_(""Components""),
        required=False,
        help_text=_(
            ""Turn on contribution to shared translation memory for the project to ""
            ""get access to additional components.""
        ),
        initial="""",
    )
    engines = forms.MultipleChoiceField(
        label=_(""Machine translation engines""), choices=[], required=False
    )
    threshold = forms.IntegerField(
        label=_(""Score threshold""), initial=80, min_value=1, max_value=100
    )

    def __init__(self, obj, *args, **kwargs):
        """"""Generate choices for other component in same project.""""""
        super().__init__(*args, **kwargs)
        self.obj = obj

        # Add components from other projects with enabled shared TM
        self.components = obj.project.component_set.filter(
            source_language=obj.source_language
        ) | Component.objects.filter(
            source_language_id=obj.source_language_id,
            project__contribute_shared_tm=True,
        ).exclude(
            project=obj.project
        )

        # Fetching is faster than doing count on possibly thousands of components
        if len(self.components.values_list(""id"")[:30]) == 30:
            # Do not show choices when too many
            self.fields[""component""] = forms.CharField(
                required=False,
                label=_(""Components""),
                help_text=_(
                    ""Enter component to use as source, ""
                    ""keep blank to use all components in current project.""
                ),
            )
        else:
            choices = [
                (s.id, str(s))
                for s in self.components.order_project().prefetch_related(""project"")
            ]

            self.fields[""component""].choices = [
                ("""", _(""All components in current project""))
            ] + choices

        self.fields[""engines""].choices = [
            (key, mt.name) for key, mt in MACHINE_TRANSLATION_SERVICES.items()
        ]
        if ""weblate"" in MACHINE_TRANSLATION_SERVICES.keys():
            self.fields[""engines""].initial = ""weblate""

        use_types = {""all"", ""nottranslated"", ""todo"", ""fuzzy"", ""check:inconsistent""}

        self.fields[""filter_type""].choices = [
            x for x in self.fields[""filter_type""].choices if x[0] in use_types
        ]

        self.helper = FormHelper(self)
        self.helper.layout = Layout(
            Field(""mode""),
            Field(""filter_type""),
            InlineRadios(""auto_source"", id=""select_auto_source""),
            Div(""component"", css_id=""auto_source_others""),
            Div(""engines"", ""threshold"", css_id=""auto_source_mt""),
        )

    def clean_component(self):
        component = self.cleaned_data[""component""]
        if not component:
            return None
        if component.isdigit():
            try:
                result = self.components.get(pk=component)
            except Component.DoesNotExist:
                raise ValidationError(_(""Component not found!""))
        else:
            slashes = component.count(""/"")
            if slashes == 0:
                try:
                    result = self.components.get(
                        slug=component, project=self.obj.project
                    )
                except Component.DoesNotExist:
                    raise ValidationError(_(""Component not found!""))
            elif slashes == 1:
                project_slug, component_slug = component.split(""/"")
                try:
                    result = self.components.get(
                        slug=component_slug, project__slug=project_slug
                    )
                except Component.DoesNotExist:
                    raise ValidationError(_(""Component not found!""))
            else:
                raise ValidationError(_(""Please provide valid component slug!""))
        return result.pk


class CommentForm(forms.Form):
    """"""Simple commenting form.""""""

    scope = forms.ChoiceField(
        label=_(""Scope""),
        help_text=_(
            ""Is your comment specific to this ""
            ""translation or generic for all of them?""
        ),
        choices=(
            (
                ""report"",
                _(""Report issue with the source string""),
            ),
            (
                ""global"",
                _(""Source string comment, suggestions for changes to this string""),
            ),
            (
                ""translation"",
                _(""Translation comment, discussions with other translators""),
            ),
        ),
    )
    comment = forms.CharField(
        widget=MarkdownTextarea,
        label=_(""New comment""),
        help_text=_(""You can use Markdown and mention users by @username.""),
        max_length=1000,
    )

    def __init__(self, project, *args, **kwargs):
        super().__init__(*args, **kwargs)
        # Remove bug report in case source review is not enabled
        if not project.source_review:
            self.fields[""scope""].choices = self.fields[""scope""].choices[1:]


class EngageForm(forms.Form):
    """"""Form to choose language for engagement widgets.""""""

    lang = forms.ChoiceField(required=False, choices=[("""", _(""All languages""))])
    component = forms.ChoiceField(required=False, choices=[("""", _(""All components""))])

    def __init__(self, user, project, *args, **kwargs):
        """"""Dynamically generate choices for used languages in project.""""""
        super().__init__(*args, **kwargs)

        self.fields[""lang""].choices += project.languages.as_choices()
        self.fields[""component""].choices += (
            project.component_set.filter_access(user)
            .order()
            .values_list(""slug"", ""name"")
        )


class NewLanguageOwnerForm(forms.Form):
    """"""Form for requesting new language.""""""

    lang = forms.MultipleChoiceField(
        label=_(""Languages""), choices=[], widget=forms.SelectMultiple
    )

    def get_lang_objects(self):
        return Language.objects.exclude(
            Q(translation__component=self.component) | Q(component=self.component)
        )

    def __init__(self, component, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.component = component
        languages = self.get_lang_objects()
        self.fields[""lang""].choices = languages.as_choices()


class NewLanguageForm(NewLanguageOwnerForm):
    """"""Form for requesting new language.""""""

    lang = forms.ChoiceField(label=_(""Language""), choices=[], widget=forms.Select)

    def get_lang_objects(self):
        codes = BASIC_LANGUAGES
        if settings.BASIC_LANGUAGES is not None:
            codes = settings.BASIC_LANGUAGES
        return super().get_lang_objects().filter(code__in=codes)

    def __init__(self, component, *args, **kwargs):
        super().__init__(component, *args, **kwargs)
        self.fields[""lang""].choices = [("""", _(""Please choose""))] + self.fields[
            ""lang""
        ].choices

    def clean_lang(self):
        # Compatibility with NewLanguageOwnerForm
        return [self.cleaned_data[""lang""]]


def get_new_language_form(request, component):
    """"""Return new language form for user.""""""
    if not request.user.has_perm(""translation.add"", component):
        raise PermissionDenied()
    if request.user.has_perm(""translation.add_more"", component):
        return NewLanguageOwnerForm
    return NewLanguageForm


class ContextForm(forms.ModelForm):
    class Meta:
        model = Unit
        fields = (""explanation"", ""labels"", ""extra_flags"")
        widgets = {
            ""labels"": forms.CheckboxSelectMultiple(),
            ""explanation"": MarkdownTextarea,
        }

    doc_links = {
        ""explanation"": (""admin/translating"", ""additional-explanation""),
        ""labels"": (""devel/translations"", ""labels""),
        ""extra_flags"": (""admin/translating"", ""additional-flags""),
    }

    def get_field_doc(self, field):
        return self.doc_links[field.name]

    def __init__(self, data=None, instance=None, user=None, **kwargs):
        kwargs[""initial""] = {
            ""labels"": Label.objects.filter(
                Q(unit=instance) | Q(unit__source_unit=instance)
            )
        }
        super().__init__(data=data, instance=instance, **kwargs)
        project = instance.translation.component.project
        self.fields[""labels""].queryset = project.label_set.all()
        self.helper = FormHelper(self)
        self.helper.disable_csrf = True
        self.helper.form_tag = False
        self.helper.layout = Layout(
            Field(""explanation""),
            Field(""labels""),
            ContextDiv(
                template=""snippets/labels_description.html"",
                context={""project"": project, ""user"": user},
            ),
            Field(""extra_flags""),
        )

    def save(self, commit=True):
        if commit:
            self.instance.save(same_content=True)
            self._save_m2m()
            return self.instance
        return super().save(commit)


class UserManageForm(forms.Form):
    user = UserField(
        label=_(""User to add""),
        help_text=_(
            ""Please type in an existing Weblate account name or e-mail address.""
        ),
    )


class UserBlockForm(forms.Form):
    user = UserField(
        label=_(""User to block""),
        help_text=_(
            ""Please type in an existing Weblate account name or e-mail address.""
        ),
    )
    expiry = forms.ChoiceField(
        label=_(""Block duration""),
        choices=(
            ("""", _(""Block user until I unblock them"")),
            (""1"", _(""Block user for one day"")),
            (""7"", _(""Block user for one week"")),
            (""30"", _(""Block user for one month"")),
        ),
        required=False,
    )


class ReportsForm(forms.Form):
    style = forms.ChoiceField(
        label=_(""Report format""),
        help_text=_(""Choose file format for the report""),
        choices=(
            (""rst"", _(""reStructuredText"")),
            (""json"", _(""JSON"")),
            (""html"", _(""HTML"")),
        ),
    )
    period = forms.ChoiceField(
        label=_(""Report period""),
        choices=(
            (""30days"", _(""Last 30 days"")),
            (""this-month"", _(""This month"")),
            (""month"", _(""Last month"")),
            (""this-year"", _(""This year"")),
            (""year"", _(""Last year"")),
            ("""", _(""As specified"")),
        ),
        required=False,
    )
    start_date = WeblateDateField(
        label=_(""Starting date""), required=False, datepicker=False
    )
    end_date = WeblateDateField(
        label=_(""Ending date""), required=False, datepicker=False
    )

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.helper = FormHelper(self)
        self.helper.form_tag = False
        self.helper.layout = Layout(
            Field(""style""),
            Field(""period""),
            Div(
                ""start_date"",
                ""end_date"",
                css_class=""input-group input-daterange"",
                data_provide=""datepicker"",
                data_date_format=""yyyy-mm-dd"",
            ),
        )

    def clean(self):
        super().clean()
        # Invalid value, skip rest of the validation
        if ""period"" not in self.cleaned_data:
            return

        # Handle predefined periods
        if self.cleaned_data[""period""] == ""30days"":
            end = timezone.now()
            start = end - timedelta(days=30)
        elif self.cleaned_data[""period""] == ""month"":
            end = timezone.now().replace(day=1) - timedelta(days=1)
            start = end.replace(day=1)
        elif self.cleaned_data[""period""] == ""this-month"":
            end = timezone.now().replace(day=1) + timedelta(days=31)
            end = end.replace(day=1) - timedelta(days=1)
            start = end.replace(day=1)
        elif self.cleaned_data[""period""] == ""year"":
            year = timezone.now().year - 1
            end = timezone.make_aware(datetime(year, 12, 31))
            start = timezone.make_aware(datetime(year, 1, 1))
        elif self.cleaned_data[""period""] == ""this-year"":
            year = timezone.now().year
            end = timezone.make_aware(datetime(year, 12, 31))
            start = timezone.make_aware(datetime(year, 1, 1))
        else:
            # Validate custom period
            if not self.cleaned_data.get(""start_date""):
                raise ValidationError({""start_date"": _(""Missing date!"")})
            if not self.cleaned_data.get(""end_date""):
                raise ValidationError({""end_date"": _(""Missing date!"")})
            start = self.cleaned_data[""start_date""]
            end = self.cleaned_data[""end_date""]
        # Sanitize timestamps
        self.cleaned_data[""start_date""] = start.replace(
            hour=0, minute=0, second=0, microsecond=0
        )
        self.cleaned_data[""end_date""] = end.replace(
            hour=23, minute=59, second=59, microsecond=999999
        )
        # Final validation
        if self.cleaned_data[""start_date""] > self.cleaned_data[""end_date""]:
            msg = _(""Starting date has to be before ending date!"")
            raise ValidationError({""start_date"": msg, ""end_date"": msg})


class CleanRepoMixin:
    def clean_repo(self):
        repo = self.cleaned_data.get(""repo"")
        if not repo or not is_repo_link(repo) or ""/"" not in repo[10:]:
            return repo
        project, component = repo[10:].split(""/"", 1)
        try:
            obj = Component.objects.get(
                slug__iexact=component, project__slug__iexact=project
            )
        except Component.DoesNotExist:
            return repo
        if not self.request.user.has_perm(""component.edit"", obj):
            raise ValidationError(
                _(""You do not have permission to access this component!"")
            )
        return repo


class SettingsBaseForm(CleanRepoMixin, forms.ModelForm):
    """"""Component base form.""""""

    class Meta:
        model = Component
        fields = []

    def __init__(self, request, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.request = request
        self.helper = FormHelper()
        self.helper.form_tag = False


class SelectChecksWidget(SortedSelectMultiple):
    def __init__(self, attrs=None, choices=()):
        choices = CHECKS.get_choices()
        super().__init__(attrs=attrs, choices=choices)

    def value_from_datadict(self, data, files, name):
        value = super().value_from_datadict(data, files, name)
        if isinstance(value, str):
            return json.loads(value)
        return value

    def format_value(self, value):
        value = super().format_value(value)
        if isinstance(value, str):
            return value
        return json.dumps(value)


class SelectChecksField(forms.CharField):
    def to_python(self, value):
        return value


class ComponentDocsMixin:
    @staticmethod
    def get_field_doc(field):
        return (""admin/projects"", f""component-{field.name}"")


class ProjectDocsMixin:
    @staticmethod
    def get_field_doc(field):
        return (""admin/projects"", f""project-{field.name}"")


class SpamCheckMixin:
    def spam_check(self, value):
        if is_spam(value, self.request):
            raise ValidationError(_(""This field has been identified as spam!""))


class ComponentAntispamMixin(SpamCheckMixin):
    def clean_agreement(self):
        value = self.cleaned_data[""agreement""]
        self.spam_check(value)
        return value


class ProjectAntispamMixin(SpamCheckMixin):
    def clean_web(self):
        value = self.cleaned_data[""web""]
        self.spam_check(value)
        return value

    def clean_instructions(self):
        value = self.cleaned_data[""instructions""]
        self.spam_check(value)
        return value


class ComponentSettingsForm(
    SettingsBaseForm, ComponentDocsMixin, ComponentAntispamMixin
):
    """"""Component settings form.""""""

    class Meta:
        model = Component
        fields = (
            ""name"",
            ""report_source_bugs"",
            ""license"",
            ""agreement"",
            ""allow_translation_propagation"",
            ""enable_suggestions"",
            ""suggestion_voting"",
            ""suggestion_autoaccept"",
            ""priority"",
            ""check_flags"",
            ""enforced_checks"",
            ""commit_message"",
            ""add_message"",
            ""delete_message"",
            ""merge_message"",
            ""addon_message"",
            ""vcs"",
            ""repo"",
            ""branch"",
            ""push"",
            ""push_branch"",
            ""repoweb"",
            ""push_on_commit"",
            ""commit_pending_age"",
            ""merge_style"",
            ""file_format"",
            ""edit_template"",
            ""new_lang"",
            ""language_code_style"",
            ""source_language"",
            ""new_base"",
            ""filemask"",
            ""template"",
            ""intermediate"",
            ""language_regex"",
            ""variant_regex"",
            ""restricted"",
            ""auto_lock_error"",
            ""links"",
            ""manage_units"",
            ""is_glossary"",
            ""glossary_color"",
        )
        widgets = {
            ""enforced_checks"": SelectChecksWidget,
            ""source_language"": SortedSelect,
        }
        field_classes = {""enforced_checks"": SelectChecksField}

    def __init__(self, request, *args, **kwargs):
        super().__init__(request, *args, **kwargs)
        if self.hide_restricted:
            self.fields[""restricted""].widget = forms.HiddenInput()
        self.fields[""links""].queryset = request.user.managed_projects.exclude(
            pk=self.instance.pk
        )
        self.helper.layout = Layout(
            TabHolder(
                Tab(
                    _(""Basic""),
                    Fieldset(_(""Name""), ""name""),
                    Fieldset(_(""License""), ""license"", ""agreement""),
                    Fieldset(_(""Upstream links""), ""report_source_bugs""),
                    Fieldset(
                        _(""Listing and access""),
                        ""priority"",
                        ""restricted"",
                        ""links"",
                    ),
                    Fieldset(
                        _(""Glossary""),
                        ""is_glossary"",
                        ""glossary_color"",
                    ),
                    css_id=""basic"",
                ),
                Tab(
                    _(""Translation""),
                    Fieldset(
                        _(""Suggestions""),
                        ""enable_suggestions"",
                        ""suggestion_voting"",
                        ""suggestion_autoaccept"",
                    ),
                    Fieldset(
                        _(""Translation settings""),
                        ""allow_translation_propagation"",
                        ""manage_units"",
                        ""check_flags"",
                        ""variant_regex"",
                        ""enforced_checks"",
                    ),
                    css_id=""translation"",
                ),
                Tab(
                    _(""Version control""),
                    Fieldset(
                        _(""Locations""),
                        Div(template=""trans/repo_help.html""),
                        ""vcs"",
                        ""repo"",
                        ""branch"",
                        ""push"",
                        ""push_branch"",
                        ""repoweb"",
                    ),
                    Fieldset(
                        _(""Version control settings""),
                        ""push_on_commit"",
                        ""commit_pending_age"",
                        ""merge_style"",
                        ""auto_lock_error"",
                    ),
                    css_id=""vcs"",
                ),
                Tab(
                    _(""Commit messages""),
                    Fieldset(
                        _(""Commit messages""),
                        ContextDiv(
                            template=""trans/messages_help.html"",
                            context={""user"": request.user},
                        ),
                        ""commit_message"",
                        ""add_message"",
                        ""delete_message"",
                        ""merge_message"",
                        ""addon_message"",
                    ),
                    css_id=""messages"",
                ),
                Tab(
                    _(""Files""),
                    Fieldset(
                        _(""Translation files""),
                        ""file_format"",
                        ""filemask"",
                        ""language_regex"",
                        ""source_language"",
                    ),
                    Fieldset(
                        _(""Monolingual translations""),
                        ""template"",
                        ""edit_template"",
                        ""intermediate"",
                    ),
                    Fieldset(
                        _(""Adding new languages""),
                        ""new_base"",
                        ""new_lang"",
                        ""language_code_style"",
                    ),
                    css_id=""files"",
                ),
                template=""layout/pills.html"",
            )
        )
        vcses = (
            ""git"",
            ""gerrit"",
            ""github"",
            ""gitlab"",
            ""pagure"",
            ""local"",
            ""git-force-push"",
        )
        if self.instance.vcs not in vcses:
            vcses = (self.instance.vcs,)
        self.fields[""vcs""].choices = [
            c for c in self.fields[""vcs""].choices if c[0] in vcses
        ]

    @property
    def hide_restricted(self):
        user = self.request.user
        if user.is_superuser:
            return False
        if settings.OFFER_HOSTING:
            return True
        return not any(
            ""component.edit"" in permissions
            for permissions, _langs in user.component_permissions[self.instance.pk]
        )

    def clean(self):
        data = self.cleaned_data
        if self.hide_restricted:
            data[""restricted""] = self.instance.restricted


class ComponentCreateForm(SettingsBaseForm, ComponentDocsMixin, ComponentAntispamMixin):
    """"""Component creation form.""""""

    class Meta:
        model = Component
        fields = [
            ""project"",
            ""name"",
            ""slug"",
            ""vcs"",
            ""repo"",
            ""branch"",
            ""push"",
            ""push_branch"",
            ""repoweb"",
            ""file_format"",
            ""filemask"",
            ""template"",
            ""edit_template"",
            ""intermediate"",
            ""new_base"",
            ""license"",
            ""new_lang"",
            ""language_code_style"",
            ""language_regex"",
            ""source_language"",
            ""is_glossary"",
        ]
        widgets = {""source_language"": SortedSelect}


class ComponentNameForm(forms.Form, ComponentDocsMixin, ComponentAntispamMixin):
    name = forms.CharField(
        label=_(""Component name""),
        max_length=COMPONENT_NAME_LENGTH,
        help_text=_(""Display name""),
    )
    slug = forms.SlugField(
        label=_(""URL slug""),
        max_length=COMPONENT_NAME_LENGTH,
        help_text=_(""Name used in URLs and filenames.""),
    )
    is_glossary = forms.BooleanField(
        label=_(""Use as a glossary""),
        required=False,
    )

    def __init__(self, request, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.helper = FormHelper()
        self.helper.form_tag = False
        self.request = request


class ComponentSelectForm(ComponentNameForm):
    component = forms.ModelChoiceField(
        queryset=Component.objects.none(),
        label=_(""Component""),
        help_text=_(""Select existing component to copy configuration from.""),
    )

    def __init__(self, request, *args, **kwargs):
        if ""instance"" in kwargs:
            kwargs.pop(""instance"")
        if ""auto_id"" not in kwargs:
            kwargs[""auto_id""] = ""id_existing_%s""
        super().__init__(request, *args, **kwargs)


class ComponentBranchForm(ComponentSelectForm):
    branch = forms.ChoiceField(label=_(""Repository branch""))

    branch_data: Dict[int, List[str]] = {}
    instance = None

    def __init__(self, *args, **kwargs):
        kwargs[""auto_id""] = ""id_branch_%s""
        super().__init__(*args, **kwargs)

    def clean_component(self):
        component = self.cleaned_data[""component""]
        self.fields[""branch""].choices = [(x, x) for x in self.branch_data[component.pk]]
        return component

    def clean(self):
        form_fields = (""branch"", ""slug"", ""name"")
        data = self.cleaned_data
        component = data.get(""component"")
        if not component or any(field not in data for field in form_fields):
            return
        kwargs = model_to_dict(component, exclude=[""id"", ""links""])
        # We need a object, not integer here
        kwargs[""source_language""] = component.source_language
        kwargs[""project""] = component.project
        for field in form_fields:
            kwargs[field] = data[field]
        self.instance = Component(**kwargs)
        try:
            self.instance.full_clean()
        except ValidationError as error:
            # Can not raise directly as this will contain errors
            # from fields not present here
            result = {NON_FIELD_ERRORS: []}
            for key, value in error.message_dict.items():
                if key in self.fields:
                    result[key] = value
                else:
                    result[NON_FIELD_ERRORS].extend(value)
            raise ValidationError(error.messages)


class ComponentProjectForm(ComponentNameForm):
    project = forms.ModelChoiceField(
        queryset=Project.objects.none(), label=_(""Project"")
    )
    source_language = forms.ModelChoiceField(
        widget=SortedSelect,
        label=_(""Source language""),
        help_text=_(""Language used for source strings in all components""),
        queryset=Language.objects.all(),
    )

    def __init__(self, request, *args, **kwargs):
        if ""instance"" in kwargs:
            kwargs.pop(""instance"")
        super().__init__(request, *args, **kwargs)
        # It might be overriden based on preset project
        self.fields[""source_language""].initial = Language.objects.default_language
        self.request = request
        self.helper = FormHelper()
        self.helper.form_tag = False
        self.instance = None

    def clean(self):
        if ""project"" not in self.cleaned_data:
            return
        project = self.cleaned_data[""project""]
        name = self.cleaned_data.get(""name"")
        if name and project.component_set.filter(name__iexact=name).exists():
            raise ValidationError(
                {""name"": _(""Component with the same name already exists."")}
            )
        slug = self.cleaned_data.get(""slug"")
        if slug and project.component_set.filter(slug__iexact=slug).exists():
            raise ValidationError(
                {""slug"": _(""Component with the same name already exists."")}
            )


class ComponentScratchCreateForm(ComponentProjectForm):
    file_format = forms.ChoiceField(
        label=_(""File format""),
        initial=""po-mono"",
        choices=FILE_FORMATS.get_choices(
            cond=lambda x: bool(x.new_translation) or hasattr(x, ""update_bilingual"")
        ),
    )

    def __init__(self, *args, **kwargs):
        kwargs[""auto_id""] = ""id_scratchcreate_%s""
        super().__init__(*args, **kwargs)


class ComponentZipCreateForm(ComponentProjectForm):
    zipfile = forms.FileField(
        label=_(""ZIP file containing translations""),
        validators=[FileExtensionValidator(allowed_extensions=[""zip""])],
        widget=forms.FileInput(attrs={""accept"": "".zip,application/zip""}),
    )

    field_order = [""zipfile"", ""project"", ""name"", ""slug""]

    def __init__(self, *args, **kwargs):
        kwargs[""auto_id""] = ""id_zipcreate_%s""
        super().__init__(*args, **kwargs)


class ComponentDocCreateForm(ComponentProjectForm):
    docfile = forms.FileField(
        label=_(""Document to translate""),
        validators=[validate_file_extension],
    )

    field_order = [""docfile"", ""project"", ""name"", ""slug""]

    def __init__(self, *args, **kwargs):
        kwargs[""auto_id""] = ""id_doccreate_%s""
        super().__init__(*args, **kwargs)


class ComponentInitCreateForm(CleanRepoMixin, ComponentProjectForm):
    """"""Component creation form.

    This is mostly copy from Component model. Probably should be extracted to standalone
    Repository model...
    """"""

    project = forms.ModelChoiceField(
        queryset=Project.objects.none(), label=_(""Project"")
    )
    vcs = forms.ChoiceField(
        label=_(""Version control system""),
        help_text=_(
            ""Version control system to use to access your ""
            ""repository with translations.""
        ),
        choices=VCS_REGISTRY.get_choices(exclude={""local""}),
        initial=settings.DEFAULT_VCS,
    )
    repo = forms.CharField(
        label=_(""Source code repository""),
        max_length=REPO_LENGTH,
        help_text=_(
            ""URL of a repository, use weblate://project/component ""
            ""for sharing with other component.""
        ),
    )
    branch = forms.CharField(
        label=_(""Repository branch""),
        max_length=REPO_LENGTH,
        help_text=_(""Repository branch to translate""),
        required=False,
    )

    def clean_instance(self, data):
        params = copy.copy(data)
        if ""discovery"" in params:
            params.pop(""discovery"")

        instance = Component(**params)
        instance.clean_fields(exclude=(""filemask"", ""file_format"", ""license""))
        instance.validate_unique()
        instance.clean_repo()
        self.instance = instance

        # Create linked repos automatically
        repo = instance.suggest_repo_link()
        if repo:
            data[""repo""] = repo
            data[""branch""] = """"
            self.clean_instance(data)

    def clean(self):
        self.clean_instance(self.cleaned_data)


class ComponentDiscoverForm(ComponentInitCreateForm):
    discovery = forms.ChoiceField(
        label=_(""Choose translation files to import""),
        choices=[(""manual"", _(""Specify configuration manually""))],
        required=True,
        widget=forms.RadioSelect,
    )

    def render_choice(self, value):
        context = copy.copy(value)
        try:
            format_cls = FILE_FORMATS[value[""file_format""]]
            context[""file_format_name""] = format_cls.name
            context[""valid""] = True
        except KeyError:
            context[""file_format_name""] = value[""file_format""]
            context[""valid""] = False
        context[""origin""] = value.meta[""origin""]
        return render_to_string(""trans/discover-choice.html"", context)

    def __init__(self, request, *args, **kwargs):
        super().__init__(request, *args, **kwargs)
        for field, value in self.fields.items():
            if field == ""discovery"":
                continue
            value.widget = forms.HiddenInput()
        # Allow all VCS now (to handle zip file upload case)
        self.fields[""vcs""].choices = VCS_REGISTRY.get_choices()
        self.discovered = self.perform_discovery(request, kwargs)
        for i, value in enumerate(self.discovered):
            self.fields[""discovery""].choices.append((i, self.render_choice(value)))

    def perform_discovery(self, request, kwargs):
        if ""data"" in kwargs and ""create_discovery"" in request.session:
            discovered = []
            for i, data in enumerate(request.session[""create_discovery""]):
                item = DiscoveryResult(data)
                item.meta = request.session[""create_discovery_meta""][i]
                discovered.append(item)
            return discovered
        try:
            self.clean_instance(kwargs[""initial""])
            discovered = self.discover()
            if not discovered:
                discovered = self.discover(eager=True)
        except ValidationError:
            discovered = []
        request.session[""create_discovery""] = discovered
        request.session[""create_discovery_meta""] = [x.meta for x in discovered]
        return discovered

    def discover(self, eager: bool = False):
        return discover(
            self.instance.full_path,
            source_language=self.instance.source_language.code,
            eager=eager,
        )

    def clean(self):
        super().clean()
        discovery = self.cleaned_data.get(""discovery"")
        if discovery and discovery != ""manual"":
            self.cleaned_data.update(self.discovered[int(discovery)])


class ComponentRenameForm(SettingsBaseForm, ComponentDocsMixin):
    """"""Component rename form.""""""

    class Meta:
        model = Component
        fields = [""slug""]


class ComponentMoveForm(SettingsBaseForm, ComponentDocsMixin):
    """"""Component rename form.""""""

    class Meta:
        model = Component
        fields = [""project""]

    def __init__(self, request, *args, **kwargs):
        super().__init__(request, *args, **kwargs)
        self.fields[""project""].queryset = request.user.managed_projects


class ProjectSettingsForm(SettingsBaseForm, ProjectDocsMixin, ProjectAntispamMixin):
    """"""Project settings form.""""""

    class Meta:
        model = Project
        fields = (
            ""name"",
            ""web"",
            ""instructions"",
            ""set_language_team"",
            ""use_shared_tm"",
            ""contribute_shared_tm"",
            ""enable_hooks"",
            ""language_aliases"",
            ""access_control"",
            ""translation_review"",
            ""source_review"",
        )
        widgets = {
            ""access_control"": forms.RadioSelect,
            ""instructions"": MarkdownTextarea,
            ""language_aliases"": forms.TextInput,
        }

    def clean(self):
        data = self.cleaned_data
        if settings.OFFER_HOSTING:
            data[""contribute_shared_tm""] = data[""use_shared_tm""]
        if (
            ""access_control"" not in data
            or data[""access_control""] is None
            or data[""access_control""] == """"
        ):
            data[""access_control""] = self.instance.access_control
        access = data[""access_control""]

        self.changed_access = access != self.instance.access_control

        if self.changed_access and not self.user_can_change_access:
            raise ValidationError(
                {
                    ""access_control"": _(
                        ""You do not have permission to change project access control.""
                    )
                }
            )
        if self.changed_access and access in (
            Project.ACCESS_PUBLIC,
            Project.ACCESS_PROTECTED,
        ):
            unlicensed = self.instance.component_set.filter(license="""")
            if unlicensed:
                raise ValidationError(
                    {
                        ""access_control"": _(
                            ""You must specify a license for these components ""
                            ""to make them publicly accessible: %s""
                        )
                        % "", "".join(unlicensed.values_list(""name"", flat=True))
                    }
                )

    def save(self, commit: bool = True):
        super().save(commit=commit)
        if self.changed_access:
            Change.objects.create(
                project=self.instance,
                action=Change.ACTION_ACCESS_EDIT,
                user=self.user,
                details={""access_control"": self.instance.access_control},
            )

    def __init__(self, request, *args, **kwargs):
        super().__init__(request, *args, **kwargs)
        self.user = request.user
        self.user_can_change_access = request.user.has_perm(
            ""billing:project.permissions"", self.instance
        )
        self.changed_access = False
        self.helper.form_tag = False
        if not self.user_can_change_access:
            disabled = {""disabled"": True}
            self.fields[""access_control""].required = False
            self.fields[""access_control""].help_text = _(
                ""You do not have permission to change project access control.""
            )
        else:
            disabled = {}
        self.helper.layout = Layout(
            TabHolder(
                Tab(
                    _(""Basic""),
                    ""name"",
                    ""web"",
                    ""instructions"",
                    css_id=""basic"",
                ),
                Tab(
                    _(""Access""),
                    InlineRadios(
                        ""access_control"",
                        template=""%s/layout/radioselect_access.html"",
                        **disabled,
                    ),
                    css_id=""access"",
                ),
                Tab(
                    _(""Workflow""),
                    ""set_language_team"",
                    ""use_shared_tm"",
                    ""contribute_shared_tm"",
                    ""enable_hooks"",
                    ""language_aliases"",
                    ""translation_review"",
                    ""source_review"",
                    css_id=""workflow"",
                ),
                Tab(
                    _(""Components""),
                    ContextDiv(
                        template=""snippets/project-component-settings.html"",
                        context={""object"": self.instance, ""user"": request.user},
                    ),
                    css_id=""components"",
                ),
                template=""layout/pills.html"",
            )
        )

        if settings.OFFER_HOSTING:
            self.fields[""contribute_shared_tm""].widget = forms.HiddenInput()
            self.fields[""use_shared_tm""].help_text = _(
                ""Uses and contributes to the pool of shared translations ""
                ""between projects.""
            )
            self.fields[""access_control""].choices = [
                choice
                for choice in self.fields[""access_control""].choices
                if choice[0] != Project.ACCESS_CUSTOM
            ]


class ProjectRenameForm(SettingsBaseForm, ProjectDocsMixin):
    """"""Project rename form.""""""

    class Meta:
        model = Project
        fields = [""slug""]


class ProjectCreateForm(SettingsBaseForm, ProjectDocsMixin, ProjectAntispamMixin):
    """"""Project creation form.""""""

    # This is fake field with is either hidden or configured
    # in the view
    billing = forms.ModelChoiceField(
        label=_(""Billing""),
        queryset=User.objects.none(),
        required=True,
        empty_label=None,
    )

    class Meta:
        model = Project
        fields = (""name"", ""slug"", ""web"", ""instructions"")


class ReplaceForm(forms.Form):
    q = QueryField(
        required=False, help_text=_(""Optional additional filter on the strings"")
    )
    search = forms.CharField(
        label=_(""Search string""),
        min_length=1,
        required=True,
        strip=False,
        help_text=_(""Case sensitive string to search for and replace.""),
    )
    replacement = forms.CharField(
        label=_(""Replacement string""), min_length=1, required=True, strip=False
    )

    def __init__(self, *args, **kwargs):
        kwargs[""auto_id""] = ""id_replace_%s""
        super().__init__(*args, **kwargs)
        self.helper = FormHelper(self)
        self.helper.form_tag = False
        self.helper.layout = Layout(
            SearchField(""q""),
            Field(""search""),
            Field(""replacement""),
            Div(template=""snippets/replace-help.html""),
        )


class ReplaceConfirmForm(forms.Form):
    units = forms.ModelMultipleChoiceField(queryset=Unit.objects.none(), required=False)
    confirm = forms.BooleanField(required=True, initial=True, widget=forms.HiddenInput)

    def __init__(self, units, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.fields[""units""].queryset = units


class MatrixLanguageForm(forms.Form):
    """"""Form for requesting new language.""""""

    lang = forms.MultipleChoiceField(
        label=_(""Languages""), choices=[], widget=forms.SelectMultiple
    )

    def __init__(self, component, *args, **kwargs):
        super().__init__(*args, **kwargs)
        languages = Language.objects.filter(translation__component=component).exclude(
            pk=component.source_language_id
        )
        self.fields[""lang""].choices = languages.as_choices()


class NewUnitBaseForm(forms.Form):
    variant = forms.ModelChoiceField(
        Unit.objects.none(),
        widget=forms.HiddenInput,
        required=False,
    )

    def __init__(self, translation, user, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.translation = translation
        self.fields[""variant""].queryset = translation.unit_set.all()
        self.user = user

    def clean(self):
        try:
            data = self.as_kwargs()
        except KeyError:
            # Probably some fields validation has failed
            return
        self.translation.validate_new_unit_data(**data)

    def get_glossary_flags(self):
        return """"

    def as_kwargs(self):
        flags = Flags()
        flags.merge(self.get_glossary_flags())
        variant = self.cleaned_data.get(""variant"")
        if variant:
            flags.set_value(""variant"", variant.source)
        return {
            ""context"": self.cleaned_data.get(""context"", """"),
            ""source"": self.cleaned_data[""source""],
            ""target"": self.cleaned_data.get(""target""),
            ""extra_flags"": flags.format(),
            ""explanation"": self.cleaned_data.get(""explanation"", """"),
            ""auto_context"": self.cleaned_data.get(""auto_context"", False),
        }


class NewMonolingualUnitForm(NewUnitBaseForm):
    context = forms.CharField(
        label=_(""Translation key""),
        help_text=_(
            ""Key used to identify string in translation file. ""
            ""File format specific rules might apply.""
        ),
        required=True,
    )
    source = PluralField(
        label=_(""Source language text""),
        help_text=_(
            ""You can edit this later, as with any other string in ""
            ""the source language.""
        ),
        required=True,
    )

    def __init__(self, translation, user, *args, **kwargs):
        super().__init__(translation, user, *args, **kwargs)
        self.fields[""context""].widget.attrs[""tabindex""] = 99
        self.fields[""source""].widget.attrs[""tabindex""] = 100
        self.fields[""source""].widget.profile = user.profile
        self.fields[""source""].initial = Unit(translation=translation, id_hash=0)


class NewBilingualSourceUnitForm(NewUnitBaseForm):
    context = forms.CharField(
        label=_(""Context""),
        help_text=_(""Optional context to clarify the source strings.""),
        required=False,
    )
    auto_context = forms.BooleanField(
        required=False,
        initial=True,
        label=_(""Automatically adjust context when same string already exists.""),
    )
    source = PluralField(
        label=_(""Source string""),
        required=True,
    )

    def __init__(self, translation, user, *args, **kwargs):
        super().__init__(translation, user, *args, **kwargs)
        self.fields[""context""].widget.attrs[""tabindex""] = 99
        self.fields[""context""].label = translation.component.context_label
        self.fields[""source""].widget.attrs[""tabindex""] = 100
        self.fields[""source""].widget.profile = user.profile
        self.fields[""source""].initial = Unit(
            translation=translation.component.source_translation, id_hash=0
        )


class NewBilingualUnitForm(NewBilingualSourceUnitForm):
    target = PluralField(
        label=_(""Translated string""),
        help_text=_(
            ""You can edit this later, as with any other string in the translation.""
        ),
        required=True,
    )

    def __init__(self, translation, user, *args, **kwargs):
        super().__init__(translation, user, *args, **kwargs)
        self.fields[""target""].widget.attrs[""tabindex""] = 101
        self.fields[""target""].widget.profile = user.profile
        self.fields[""target""].initial = Unit(translation=translation, id_hash=0)


class NewBilingualGlossarySourceUnitForm(GlossaryAddMixin, NewBilingualSourceUnitForm):
    def __init__(self, translation, user, *args, **kwargs):
        if kwargs[""initial""] is None:
            kwargs[""initial""] = {}
        kwargs[""initial""][""terminology""] = True
        super().__init__(translation, user, *args, **kwargs)


class NewBilingualGlossaryUnitForm(GlossaryAddMixin, NewBilingualUnitForm):
    pass


def get_new_unit_form(translation, user, data=None, initial=None):
    if translation.component.has_template():
        return NewMonolingualUnitForm(translation, user, data=data, initial=initial)
    if translation.component.is_glossary:
        if translation.is_source:
            return NewBilingualGlossarySourceUnitForm(
                translation, user, data=data, initial=initial
            )
        return NewBilingualGlossaryUnitForm(
            translation, user, data=data, initial=initial
        )
    if translation.is_source:
        return NewBilingualSourceUnitForm(translation, user, data=data, initial=initial)
    return NewBilingualUnitForm(translation, user, data=data, initial=initial)


class CachedQueryIterator(ModelChoiceIterator):
    """"""
    Choice iterator for cached querysets.

    It assumes the queryset is reused and avoids using iterator or count queries.
    """"""

    def __iter__(self):
        if self.field.empty_label is not None:
            yield ("""", self.field.empty_label)
        for obj in self.queryset:
            yield self.choice(obj)

    def __len__(self):
        return len(self.queryset) + (1 if self.field.empty_label is not None else 0)

    def __bool__(self):
        return self.field.empty_label is not None or bool(self.queryset)


class CachedModelMultipleChoiceField(forms.ModelMultipleChoiceField):
    iterator = CachedQueryIterator

    def _get_queryset(self):
        return self._queryset

    def _set_queryset(self, queryset):
        self._queryset = queryset
        self.widget.choices = self.choices

    queryset = property(_get_queryset, _set_queryset)


class BulkEditForm(forms.Form):
    q = QueryField(required=True)
    state = forms.ChoiceField(
        label=_(""State to set""), choices=((-1, _(""Do not change"")),) + STATE_CHOICES
    )
    add_flags = FlagField(label=_(""Translation flags to add""), required=False)
    remove_flags = FlagField(label=_(""Translation flags to remove""), required=False)
    add_labels = CachedModelMultipleChoiceField(
        queryset=Label.objects.none(),
        label=_(""Labels to add""),
        widget=forms.CheckboxSelectMultiple(),
        required=False,
    )
    remove_labels = CachedModelMultipleChoiceField(
        queryset=Label.objects.none(),
        label=_(""Labels to remove""),
        widget=forms.CheckboxSelectMultiple(),
        required=False,
    )

    def __init__(self, user, obj, *args, **kwargs):
        project = kwargs.pop(""project"")
        kwargs[""auto_id""] = ""id_bulk_%s""
        super().__init__(*args, **kwargs)
        labels = project.label_set.all()
        if labels:
            self.fields[""remove_labels""].queryset = labels
            self.fields[""add_labels""].queryset = labels

        excluded = {STATE_EMPTY, STATE_READONLY}
        if user is not None and not user.has_perm(""unit.review"", obj):
            excluded.add(STATE_APPROVED)

        # Filter offered states
        self.fields[""state""].choices = [
            x for x in self.fields[""state""].choices if x[0] not in excluded
        ]

        self.helper = FormHelper(self)
        self.helper.form_tag = False
        self.helper.layout = Layout(
            Div(template=""snippets/bulk-help.html""),
            SearchField(""q""),
            Field(""state""),
            Field(""add_flags""),
            Field(""remove_flags""),
        )
        if labels:
            self.helper.layout.append(InlineCheckboxes(""add_labels""))
            self.helper.layout.append(InlineCheckboxes(""remove_labels""))


class ContributorAgreementForm(forms.Form):
    confirm = forms.BooleanField(
        label=_(""I accept the contributor agreement""), required=True
    )
    next = forms.CharField(required=False, widget=forms.HiddenInput)


class BaseDeleteForm(forms.Form):
    confirm = forms.CharField(required=True)
    warning_template = """"

    def __init__(self, obj, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.obj = obj
        self.helper = FormHelper(self)
        self.helper.layout = Layout(
            ContextDiv(
                template=self.warning_template,
                css_class=""form-group"",
                context={""object"": obj},
            ),
            Field(""confirm""),
        )
        self.helper.form_tag = False

    def clean(self):
        if self.cleaned_data.get(""confirm"") != self.obj.full_slug:
            raise ValidationError(
                _(""The slug does not match the one marked for deletion!"")
            )


class TranslationDeleteForm(BaseDeleteForm):
    confirm = forms.CharField(
        label=_(""Removal confirmation""),
        help_text=_(""Please type in the full slug of the translation to confirm.""),
        required=True,
    )
    warning_template = ""trans/delete-translation.html""


class ComponentDeleteForm(BaseDeleteForm):
    confirm = forms.CharField(
        label=_(""Removal confirmation""),
        help_text=_(""Please type in the full slug of the component to confirm.""),
        required=True,
    )
    warning_template = ""trans/delete-component.html""


class ProjectDeleteForm(BaseDeleteForm):
    confirm = forms.CharField(
        label=_(""Removal confirmation""),
        help_text=_(""Please type in the slug of the project to confirm.""),
        required=True,
    )
    warning_template = ""trans/delete-project.html""


class ProjectLanguageDeleteForm(BaseDeleteForm):
    confirm = forms.CharField(
        label=_(""Removal confirmation""),
        help_text=_(""Please type in the slug of the project and language to confirm.""),
        required=True,
    )
    warning_template = ""trans/delete-project-language.html""


class AnnouncementForm(forms.ModelForm):
    """"""Component base form.""""""

    class Meta:
        model = Announcement
        fields = [""message"", ""category"", ""expiry"", ""notify""]
        widgets = {
            ""expiry"": WeblateDateInput(),
            ""message"": MarkdownTextarea,
        }


class ChangesForm(forms.Form):
    project = forms.ChoiceField(label=_(""Project""), choices=[("""", """")], required=False)
    lang = forms.ChoiceField(label=_(""Language""), choices=[("""", """")], required=False)
    action = forms.MultipleChoiceField(
        label=_(""Action""),
        required=False,
        widget=SortedSelectMultiple,
        choices=Change.ACTION_CHOICES,
    )
    user = UsernameField(label=_(""Author username""), required=False, help_text=None)
    start_date = WeblateDateField(
        label=_(""Starting date""), required=False, datepicker=False
    )
    end_date = WeblateDateField(
        label=_(""Ending date""), required=False, datepicker=False
    )

    def __init__(self, request, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.fields[""lang""].choices += Language.objects.have_translation().as_choices()
        self.fields[""project""].choices += [
            (project.slug, project.name) for project in request.user.allowed_projects
        ]


class LabelForm(forms.ModelForm):
    class Meta:
        model = Label
        fields = (""name"", ""color"")
        widgets = {""color"": ColorWidget()}

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.helper = FormHelper(self)
        self.helper.form_tag = False


class ProjectTokenDeleteForm(forms.Form):
    token = forms.ModelChoiceField(
        ProjectToken.objects.none(),
        widget=forms.HiddenInput,
        required=True,
    )

    def __init__(self, project, *args, **kwargs):
        self.project = project
        super().__init__(*args, **kwargs)
        self.fields[""token""].queryset = project.projecttoken_set.all()


class ProjectTokenCreateForm(forms.ModelForm):
    class Meta:
        model = ProjectToken
        fields = [""name"", ""expires"", ""project""]
        widgets = {
            ""expires"": WeblateDateInput(),
            ""project"": forms.HiddenInput,
        }

    def __init__(self, project, *args, **kwargs):
        self.project = project
        kwargs[""initial""] = {""project"": project}
        super().__init__(*args, **kwargs)

    def clean_project(self):
        if self.project != self.cleaned_data[""project""]:
            raise ValidationError(""Invalid project!"")
        return self.cleaned_data[""project""]

    def clean_expires(self):
        expires = self.cleaned_data[""expires""]
        expires = expires.replace(hour=23, minute=59, second=59, microsecond=999999)
        if expires < timezone.now():
            raise forms.ValidationError(gettext(""Expiry cannot be in the past!""))
        return expires


class ProjectGroupDeleteForm(forms.Form):
    group = forms.ModelChoiceField(
        Group.objects.none(),
        widget=forms.HiddenInput,
        required=True,
    )

    def __init__(self, project, *args, **kwargs):
        self.project = project
        super().__init__(*args, **kwargs)
        self.fields[""group""].queryset = project.defined_groups.all()


class ProjectUserGroupForm(UserManageForm):
    groups = forms.ModelMultipleChoiceField(
        Group.objects.none(),
        widget=forms.CheckboxSelectMultiple,
        label=_(""Teams""),
        required=False,
    )

    def __init__(self, project, *args, **kwargs):
        self.project = project
        super().__init__(*args, **kwargs)
        self.fields[""user""].widget = forms.HiddenInput()
        self.fields[""groups""].queryset = project.defined_groups.all()
","#
# Copyright © 2012–2022 Michal Čihař <michal@cihar.com>
#
# This file is part of Weblate <https://weblate.org/>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
#

import copy
import json
import re
from datetime import date, datetime, timedelta
from typing import Dict, List

from crispy_forms.bootstrap import InlineCheckboxes, InlineRadios, Tab, TabHolder
from crispy_forms.helper import FormHelper
from crispy_forms.layout import Div, Field, Fieldset, Layout
from django import forms
from django.conf import settings
from django.core.exceptions import NON_FIELD_ERRORS, PermissionDenied, ValidationError
from django.core.validators import FileExtensionValidator
from django.db.models import Q
from django.forms import model_to_dict
from django.forms.models import ModelChoiceIterator
from django.forms.utils import from_current_timezone
from django.template.loader import render_to_string
from django.urls import reverse
from django.utils import timezone
from django.utils.html import escape
from django.utils.http import urlencode
from django.utils.safestring import mark_safe
from django.utils.translation import gettext
from django.utils.translation import gettext_lazy as _
from translation_finder import DiscoveryResult, discover

from weblate.auth.models import Group, User
from weblate.checks.flags import Flags
from weblate.checks.models import CHECKS
from weblate.checks.utils import highlight_string
from weblate.formats.models import EXPORTERS, FILE_FORMATS
from weblate.glossary.forms import GlossaryAddMixin
from weblate.lang.data import BASIC_LANGUAGES
from weblate.lang.models import Language
from weblate.machinery import MACHINE_TRANSLATION_SERVICES
from weblate.trans.defines import COMPONENT_NAME_LENGTH, REPO_LENGTH
from weblate.trans.filter import FILTERS, get_filter_choice
from weblate.trans.models import (
    Announcement,
    Change,
    Component,
    Label,
    Project,
    ProjectToken,
    Unit,
)
from weblate.trans.specialchars import RTL_CHARS_DATA, get_special_chars
from weblate.trans.util import check_upload_method_permissions, is_repo_link
from weblate.trans.validators import validate_check_flags
from weblate.utils.antispam import is_spam
from weblate.utils.errors import report_error
from weblate.utils.forms import (
    ColorWidget,
    ContextDiv,
    EmailField,
    SearchField,
    SortedSelect,
    SortedSelectMultiple,
    UsernameField,
)
from weblate.utils.hash import checksum_to_hash, hash_to_checksum
from weblate.utils.search import parse_query
from weblate.utils.state import (
    STATE_APPROVED,
    STATE_CHOICES,
    STATE_EMPTY,
    STATE_FUZZY,
    STATE_READONLY,
    STATE_TRANSLATED,
)
from weblate.utils.validators import validate_file_extension
from weblate.vcs.models import VCS_REGISTRY

BUTTON_TEMPLATE = """"""
<button class=""btn btn-default {0}"" title=""{1}"" {2}>{3}</button>
""""""
RADIO_TEMPLATE = """"""
<label class=""btn btn-default {0}"" title=""{1}"">
<input type=""radio"" name=""{2}"" value=""{3}"" {4}/>
{5}
</label>
""""""
GROUP_TEMPLATE = """"""
<div class=""btn-group btn-group-xs"" {0}>{1}</div>
""""""
TOOLBAR_TEMPLATE = """"""
<div class=""btn-toolbar pull-right flip editor-toolbar"">{0}</div>
""""""


class MarkdownTextarea(forms.Textarea):
    def __init__(self, **kwargs):
        kwargs[""attrs""] = {
            ""dir"": ""auto"",
            ""class"": ""markdown-editor highlight-editor"",
            ""data-mode"": ""markdown"",
        }
        super().__init__(**kwargs)


class WeblateDateInput(forms.DateInput):
    def __init__(self, datepicker=True, **kwargs):
        attrs = {""type"": ""date""}
        if datepicker:
            attrs[""data-provide""] = ""datepicker""
            attrs[""data-date-format""] = ""yyyy-mm-dd""
        super().__init__(attrs=attrs, format=""%Y-%m-%d"", **kwargs)


class WeblateDateField(forms.DateField):
    def __init__(self, datepicker=True, **kwargs):
        if ""widget"" not in kwargs:
            kwargs[""widget""] = WeblateDateInput(datepicker=datepicker)
        super().__init__(**kwargs)

    def to_python(self, value):
        """"""Produce timezone aware datetime with 00:00:00 as time.""""""
        value = super().to_python(value)
        if isinstance(value, date):
            return from_current_timezone(
                datetime(value.year, value.month, value.day, 0, 0, 0)
            )
        return value


class ChecksumField(forms.CharField):
    """"""Field for handling checksum IDs for translation.""""""

    def __init__(self, *args, **kwargs):
        kwargs[""widget""] = forms.HiddenInput
        super().__init__(*args, **kwargs)

    def clean(self, value):
        super().clean(value)
        if not value:
            return None
        try:
            return checksum_to_hash(value)
        except ValueError:
            raise ValidationError(_(""Invalid checksum specified!""))


class UserField(forms.CharField):
    def clean(self, value):
        if not value:
            return None
        try:
            return User.objects.get(Q(username=value) | Q(email=value))
        except User.DoesNotExist:
            raise ValidationError(_(""Could not find any such user.""))
        except User.MultipleObjectsReturned:
            raise ValidationError(_(""More possible users were found.""))


class QueryField(forms.CharField):
    def __init__(self, **kwargs):
        if ""label"" not in kwargs:
            kwargs[""label""] = _(""Query"")
        if ""required"" not in kwargs:
            kwargs[""required""] = False
        super().__init__(**kwargs)

    def clean(self, value):
        if not value:
            if self.required:
                raise ValidationError(_(""Missing query string.""))
            return """"
        try:
            parse_query(value)
            return value
        except Exception as error:
            report_error()
            raise ValidationError(_(""Could not parse query string: {}"").format(error))


class FlagField(forms.CharField):
    default_validators = [validate_check_flags]


class PluralTextarea(forms.Textarea):
    """"""Text-area extension which possibly handles plurals.""""""

    def __init__(self, *args, **kwargs):
        self.profile = None
        super().__init__(*args, **kwargs)

    def get_rtl_toolbar(self, fieldname):
        groups = []

        # Special chars
        chars = []
        for name, char, value in RTL_CHARS_DATA:
            chars.append(
                BUTTON_TEMPLATE.format(
                    ""specialchar"",
                    name,
                    'data-value=""{}""'.format(
                        value.encode(""ascii"", ""xmlcharrefreplace"").decode(""ascii"")
                    ),
                    char,
                )
            )

        groups.append(GROUP_TEMPLATE.format("""", ""\n"".join(chars)))
        return TOOLBAR_TEMPLATE.format(""\n"".join(groups))

    def get_rtl_toggle(self, language, fieldname):
        if language.direction != ""rtl"":
            return """"

        # RTL/LTR switch
        rtl_name = f""rtl-{fieldname}""
        rtl_switch = [
            RADIO_TEMPLATE.format(
                ""direction-toggle active"",
                gettext(""Toggle text direction""),
                rtl_name,
                ""rtl"",
                'checked=""checked""',
                ""RTL"",
            ),
            RADIO_TEMPLATE.format(
                ""direction-toggle"",
                gettext(""Toggle text direction""),
                rtl_name,
                ""ltr"",
                """",
                ""LTR"",
            ),
        ]
        groups = [GROUP_TEMPLATE.format('data-toggle=""buttons""', ""\n"".join(rtl_switch))]
        return mark_safe(TOOLBAR_TEMPLATE.format(""\n"".join(groups)))

    def get_toolbar(self, language, fieldname, unit, idx, source):
        """"""Return toolbar HTML code.""""""
        profile = self.profile
        groups = []

        # Special chars
        chars = [
            BUTTON_TEMPLATE.format(
                ""specialchar"",
                name,
                'data-value=""{}""'.format(
                    value.encode(""ascii"", ""xmlcharrefreplace"").decode(""ascii"")
                ),
                char,
            )
            for name, char, value in get_special_chars(
                language, profile.special_chars, unit.source
            )
        ]

        groups.append(GROUP_TEMPLATE.format("""", ""\n"".join(chars)))

        result = TOOLBAR_TEMPLATE.format(""\n"".join(groups))

        if language.direction == ""rtl"":
            result = self.get_rtl_toolbar(fieldname) + result

        return mark_safe(result)

    def render(self, name, value, attrs=None, renderer=None, **kwargs):
        """"""Render all textareas with correct plural labels.""""""
        unit = value
        values = unit.get_target_plurals()
        lang = unit.translation.language
        plural = unit.translation.plural
        tabindex = self.attrs[""tabindex""]
        placeables = [hl[2] for hl in highlight_string(unit.source_string, unit)]

        # Need to add extra class
        attrs[""class""] = ""translation-editor form-control highlight-editor""
        attrs[""tabindex""] = tabindex
        attrs[""lang""] = lang.code
        attrs[""dir""] = lang.direction
        attrs[""rows""] = 3
        attrs[""data-max""] = unit.get_max_length()
        attrs[""data-mode""] = unit.edit_mode
        attrs[""data-placeables""] = ""|"".join(re.escape(pl) for pl in placeables if pl)
        if unit.readonly:
            attrs[""readonly""] = 1

        # Okay we have more strings
        ret = []
        plurals = unit.get_source_plurals()
        base_id = f""id_{unit.checksum}""
        for idx, val in enumerate(values):
            # Generate ID
            fieldname = f""{name}_{idx}""
            fieldid = f""{base_id}_{idx}""
            attrs[""id""] = fieldid
            attrs[""tabindex""] = tabindex + idx
            if idx and len(plurals) > 1:
                source = plurals[1]
            else:
                source = plurals[0]

            # Render textare
            textarea = super().render(fieldname, val, attrs, renderer, **kwargs)
            # Label for plural
            label = escape(unit.translation.language)
            if len(values) != 1:
                label = f""{label}, {plural.get_plural_label(idx)}""
            ret.append(
                render_to_string(
                    ""snippets/editor.html"",
                    {
                        ""toolbar"": self.get_toolbar(lang, fieldid, unit, idx, source),
                        ""fieldid"": fieldid,
                        ""label"": mark_safe(label),
                        ""textarea"": textarea,
                        ""max_length"": attrs[""data-max""],
                        ""length"": len(val),
                        ""source_length"": len(source),
                        ""rtl_toggle"": self.get_rtl_toggle(lang, fieldid),
                    },
                )
            )

        # Show plural formula for more strings
        if len(values) > 1:
            ret.append(
                render_to_string(
                    ""snippets/plural-formula.html"",
                    {""plural"": plural, ""user"": self.profile.user},
                )
            )

        # Join output
        return mark_safe("""".join(ret))

    def value_from_datadict(self, data, files, name):
        """"""Return processed plurals as a list.""""""
        ret = []
        for idx in range(0, 10):
            fieldname = f""{name}_{idx:d}""
            if fieldname not in data:
                break
            ret.append(data.get(fieldname, """"))
        return [r.replace(""\r"", """") for r in ret]


class PluralField(forms.CharField):
    """"""Renderer for the plural field.

    The only difference from CharField is that it does not force value to be string.
    """"""

    def __init__(self, max_length=None, min_length=None, **kwargs):
        kwargs[""label""] = """"
        super().__init__(widget=PluralTextarea, **kwargs)

    def to_python(self, value):
        """"""Return list or string as returned by PluralTextarea.""""""
        return value

    def clean(self, value):
        value = super().clean(value)
        if not value or (self.required and not any(value)):
            raise ValidationError(_(""Missing translated string!""))
        return value


class FilterField(forms.ChoiceField):
    def __init__(self, *args, **kwargs):
        kwargs[""label""] = _(""Search filter"")
        if ""required"" not in kwargs:
            kwargs[""required""] = False
        kwargs[""choices""] = get_filter_choice()
        kwargs[""error_messages""] = {
            ""invalid_choice"": _(""Please choose a valid filter type."")
        }
        super().__init__(*args, **kwargs)

    def to_python(self, value):
        if value == ""untranslated"":
            return ""todo""
        return super().to_python(value)


class ChecksumForm(forms.Form):
    """"""Form for handling checksum IDs for translation.""""""

    checksum = ChecksumField(required=True)

    def __init__(self, unit_set, *args, **kwargs):
        self.unit_set = unit_set
        super().__init__(*args, **kwargs)

    def clean_checksum(self):
        """"""Validate whether checksum is valid and fetches unit for it.""""""
        if ""checksum"" not in self.cleaned_data:
            return

        unit_set = self.unit_set

        try:
            self.cleaned_data[""unit""] = unit_set.filter(
                id_hash=self.cleaned_data[""checksum""]
            )[0]
        except (Unit.DoesNotExist, IndexError):
            raise ValidationError(
                _(""The string you wanted to translate is no longer available."")
            )


class UnitForm(forms.Form):
    def __init__(self, unit: Unit, *args, **kwargs):
        self.unit = unit
        super().__init__(*args, **kwargs)


class FuzzyField(forms.BooleanField):
    help_as_icon = True

    def __init__(self, *args, **kwargs):
        kwargs[""label""] = _(""Needs editing"")
        kwargs[""help_text""] = _(
            'Strings are usually marked as ""Needs editing"" after the source '
            ""string is updated, or when marked as such manually.""
        )
        super().__init__(*args, **kwargs)
        self.widget.attrs[""class""] = ""fuzzy_checkbox""


class TranslationForm(UnitForm):
    """"""Form used for translation of single string.""""""

    contentsum = ChecksumField(required=True)
    translationsum = ChecksumField(required=True)
    target = PluralField(required=False)
    fuzzy = FuzzyField(required=False)
    review = forms.ChoiceField(
        label=_(""Review state""),
        choices=[
            (STATE_FUZZY, _(""Needs editing"")),
            (STATE_TRANSLATED, _(""Waiting for review"")),
            (STATE_APPROVED, _(""Approved"")),
        ],
        required=False,
        widget=forms.RadioSelect,
    )
    explanation = forms.CharField(
        widget=MarkdownTextarea,
        label=_(""Explanation""),
        help_text=_(
            ""Additional explanation to clarify meaning or usage of the string.""
        ),
        max_length=1000,
        required=False,
    )

    def __init__(self, user, unit: Unit, *args, **kwargs):
        if unit is not None:
            kwargs[""initial""] = {
                ""checksum"": unit.checksum,
                ""contentsum"": hash_to_checksum(unit.content_hash),
                ""translationsum"": hash_to_checksum(unit.get_target_hash()),
                ""target"": unit,
                ""fuzzy"": unit.fuzzy,
                ""review"": unit.state,
                ""explanation"": unit.explanation,
            }
            kwargs[""auto_id""] = f""id_{unit.checksum}_%s""
        tabindex = kwargs.pop(""tabindex"", 100)
        super().__init__(unit, *args, **kwargs)
        if unit.readonly:
            for field in [""target"", ""fuzzy"", ""review""]:
                self.fields[field].widget.attrs[""readonly""] = 1
            self.fields[""review""].choices = [
                (STATE_READONLY, _(""Read only"")),
            ]
        self.user = user
        self.fields[""target""].widget.attrs[""tabindex""] = tabindex
        self.fields[""target""].widget.profile = user.profile
        self.fields[""review""].widget.attrs[""class""] = ""review_radio""
        # Avoid failing validation on untranslated string
        if args:
            self.fields[""review""].choices.append((STATE_EMPTY, """"))
        self.helper = FormHelper()
        self.helper.form_method = ""post""
        self.helper.form_tag = False
        self.helper.disable_csrf = True
        self.helper.layout = Layout(
            Field(""target""),
            Field(""fuzzy""),
            Field(""contentsum""),
            Field(""translationsum""),
            InlineRadios(""review""),
            Field(""explanation""),
        )
        if unit and user.has_perm(""unit.review"", unit.translation):
            self.fields[""fuzzy""].widget = forms.HiddenInput()
        else:
            self.fields[""review""].widget = forms.HiddenInput()
        if not unit.translation.component.is_glossary:
            self.fields[""explanation""].widget = forms.HiddenInput()

    def clean(self):
        super().clean()

        # Check required fields
        required = {""target"", ""contentsum"", ""translationsum""}
        if not required.issubset(self.cleaned_data):
            return

        unit = self.unit

        if self.cleaned_data[""contentsum""] != unit.content_hash:
            raise ValidationError(
                _(
                    ""Source string has been changed meanwhile. ""
                    ""Please check your changes.""
                )
            )

        if self.cleaned_data[""translationsum""] != unit.get_target_hash():
            raise ValidationError(
                _(
                    ""Translation of the string has been changed meanwhile. ""
                    ""Please check your changes.""
                )
            )

        max_length = unit.get_max_length()
        for text in self.cleaned_data[""target""]:
            if len(text) > max_length:
                raise ValidationError(_(""Translation text too long!""))
        if self.user.has_perm(
            ""unit.review"", unit.translation
        ) and self.cleaned_data.get(""review""):
            self.cleaned_data[""state""] = int(self.cleaned_data[""review""])
        elif self.cleaned_data[""fuzzy""]:
            self.cleaned_data[""state""] = STATE_FUZZY
        else:
            self.cleaned_data[""state""] = STATE_TRANSLATED


class ZenTranslationForm(TranslationForm):
    checksum = ChecksumField(required=True)

    def __init__(self, user, unit, *args, **kwargs):
        super().__init__(user, unit, *args, **kwargs)
        self.helper.form_action = reverse(
            ""save_zen"", kwargs=unit.translation.get_reverse_url_kwargs()
        )
        self.helper.form_tag = True
        self.helper.disable_csrf = False
        self.helper.layout.append(Field(""checksum""))


class DownloadForm(forms.Form):
    q = QueryField()
    format = forms.ChoiceField(
        label=_(""File format""),
        choices=[(x.name, x.verbose) for x in EXPORTERS.values()],
        initial=""po"",
        required=True,
        widget=forms.RadioSelect,
    )

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.helper = FormHelper(self)
        self.helper.form_tag = False
        self.helper.layout = Layout(
            SearchField(""q""),
            InlineRadios(""format""),
        )


class SimpleUploadForm(forms.Form):
    """"""Base form for uploading a file.""""""

    file = forms.FileField(label=_(""File""), validators=[validate_file_extension])
    method = forms.ChoiceField(
        label=_(""File upload mode""),
        choices=(
            (""translate"", _(""Add as translation"")),
            (""approve"", _(""Add as approved translation"")),
            (""suggest"", _(""Add as suggestion"")),
            (""fuzzy"", _(""Add as translation needing edit"")),
            (""replace"", _(""Replace existing translation file"")),
            (""source"", _(""Update source strings"")),
            (""add"", _(""Add new strings"")),
        ),
        widget=forms.RadioSelect,
        required=True,
    )
    fuzzy = forms.ChoiceField(
        label=_(""Processing of strings needing edit""),
        choices=(
            ("""", _(""Do not import"")),
            (""process"", _(""Import as string needing edit"")),
            (""approve"", _(""Import as translated"")),
        ),
        required=False,
    )

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.helper = FormHelper(self)
        self.helper.form_tag = False

    @staticmethod
    def get_field_doc(field):
        return (""user/files"", f""upload-{field.name}"")

    def remove_translation_choice(self, value):
        """"""Remove add as translation choice.""""""
        choices = self.fields[""method""].choices
        self.fields[""method""].choices = [
            choice for choice in choices if choice[0] != value
        ]


class UploadForm(SimpleUploadForm):
    """"""Upload form with the option to overwrite current messages.""""""

    conflicts = forms.ChoiceField(
        label=_(""Conflict handling""),
        help_text=_(
            ""Whether to overwrite existing translations if the string is ""
            ""already translated.""
        ),
        choices=(
            ("""", _(""Update only untranslated strings"")),
            (""replace-translated"", _(""Update translated strings"")),
            (""replace-approved"", _(""Update translated and approved strings"")),
        ),
        required=False,
        initial=""replace-translated"",
    )


class ExtraUploadForm(UploadForm):
    """"""Advanced upload form for users who can override authorship.""""""

    author_name = forms.CharField(label=_(""Author name""))
    author_email = EmailField(label=_(""Author e-mail""))


def get_upload_form(user, translation, *args, **kwargs):
    """"""Return correct upload form based on user permissions.""""""
    if user.has_perm(""upload.authorship"", translation):
        form = ExtraUploadForm
        kwargs[""initial""] = {""author_name"": user.full_name, ""author_email"": user.email}
    elif user.has_perm(""upload.overwrite"", translation):
        form = UploadForm
    else:
        form = SimpleUploadForm
    result = form(*args, **kwargs)
    for method in [x[0] for x in result.fields[""method""].choices]:
        if not check_upload_method_permissions(user, translation, method):
            result.remove_translation_choice(method)
    # Remove approved choice for non review projects
    if not user.has_perm(""unit.review"", translation) and not form == SimpleUploadForm:
        result.fields[""conflicts""].choices = [
            choice
            for choice in result.fields[""conflicts""].choices
            if choice[0] != ""approved""
        ]
    return result


class SearchForm(forms.Form):
    """"""Text searching form.""""""

    # pylint: disable=invalid-name
    q = QueryField()
    sort_by = forms.CharField(required=False, widget=forms.HiddenInput)
    checksum = ChecksumField(required=False)
    offset = forms.IntegerField(min_value=-1, required=False, widget=forms.HiddenInput)
    offset_kwargs = {}

    def __init__(self, user, language=None, show_builder=True, **kwargs):
        """"""Generate choices for other component in same project.""""""
        self.user = user
        self.language = language
        super().__init__(**kwargs)

        self.helper = FormHelper(self)
        self.helper.disable_csrf = True
        self.helper.form_tag = False
        self.helper.layout = Layout(
            Div(
                Field(""offset"", **self.offset_kwargs),
                SearchField(""q""),
                Field(""sort_by"", template=""snippets/sort-field.html""),
                css_class=""btn-toolbar"",
                role=""toolbar"",
            ),
            ContextDiv(
                template=""snippets/query-builder.html"",
                context={
                    ""user"": self.user,
                    ""month_ago"": timezone.now() - timedelta(days=31),
                    ""show_builder"": show_builder,
                    ""language"": self.language,
                },
            ),
            Field(""checksum""),
        )

    def get_name(self):
        """"""Return verbose name for a search.""""""
        return FILTERS.get_search_name(self.cleaned_data.get(""q"", """"))

    def get_search_query(self):
        return self.cleaned_data[""q""]

    def clean_offset(self):
        if self.cleaned_data.get(""offset"") is None:
            self.cleaned_data[""offset""] = 1
        return self.cleaned_data[""offset""]

    def items(self):
        items = []
        # Skip checksum and offset as these change
        ignored = {""offset"", ""checksum""}
        for param in sorted(self.cleaned_data):
            value = self.cleaned_data[param]
            # We don't care about empty values or ignored
            if value is None or param in ignored:
                continue
            if isinstance(value, bool):
                # Only store true values
                if value:
                    items.append((param, ""1""))
            elif isinstance(value, int):
                # Avoid storing 0 values
                if value > 0:
                    items.append((param, str(value)))
            elif isinstance(value, datetime):
                # Convert date to string
                items.append((param, value.date().isoformat()))
            elif isinstance(value, list):
                for val in value:
                    items.append((param, val))
            elif isinstance(value, User):
                items.append((param, value.username))
            else:
                # It should be string here
                if value:
                    items.append((param, value))
        return items

    def urlencode(self):
        return urlencode(self.items())

    def reset_offset(self):
        """"""Reset offset to avoid using form as default for new search.""""""
        data = copy.copy(self.data)
        data[""offset""] = ""1""
        data[""checksum""] = """"
        self.data = data
        return self


class PositionSearchForm(SearchForm):
    offset = forms.IntegerField(min_value=-1, required=False)
    offset_kwargs = {""template"": ""snippets/position-field.html""}


class MergeForm(UnitForm):
    """"""Simple form for merging translation of two units.""""""

    merge = forms.IntegerField()

    def clean(self):
        super().clean()
        if ""merge"" not in self.cleaned_data:
            return None
        try:
            unit = self.unit
            translation = unit.translation
            project = translation.component.project
            self.cleaned_data[""merge_unit""] = merge_unit = Unit.objects.get(
                pk=self.cleaned_data[""merge""],
                translation__component__project=project,
                translation__language=translation.language,
            )
            # Compare in Python to ensure case sensitiveness on MySQL
            if not translation.is_source and unit.source != merge_unit.source:
                raise ValidationError(_(""Could not find merged string.""))
        except Unit.DoesNotExist:
            raise ValidationError(_(""Could not find merged string.""))
        return self.cleaned_data


class RevertForm(UnitForm):
    """"""Form for reverting edits.""""""

    revert = forms.IntegerField()

    def clean(self):
        super().clean()
        if ""revert"" not in self.cleaned_data:
            return None
        try:
            self.cleaned_data[""revert_change""] = Change.objects.get(
                pk=self.cleaned_data[""revert""], unit=self.unit
            )
        except Change.DoesNotExist:
            raise ValidationError(_(""Could not find reverted change.""))
        return self.cleaned_data


class AutoForm(forms.Form):
    """"""Automatic translation form.""""""

    mode = forms.ChoiceField(
        label=_(""Automatic translation mode""),
        choices=[
            (""suggest"", _(""Add as suggestion"")),
            (""translate"", _(""Add as translation"")),
            (""fuzzy"", _(""Add as needing edit"")),
        ],
        initial=""suggest"",
    )
    filter_type = FilterField(
        required=True,
        initial=""todo"",
        help_text=_(
            ""Please note that translating all strings will ""
            ""discard all existing translations.""
        ),
    )
    auto_source = forms.ChoiceField(
        label=_(""Automatic translation source""),
        choices=[
            (""others"", _(""Other translation components"")),
            (""mt"", _(""Machine translation"")),
        ],
        initial=""others"",
    )
    component = forms.ChoiceField(
        label=_(""Components""),
        required=False,
        help_text=_(
            ""Turn on contribution to shared translation memory for the project to ""
            ""get access to additional components.""
        ),
        initial="""",
    )
    engines = forms.MultipleChoiceField(
        label=_(""Machine translation engines""), choices=[], required=False
    )
    threshold = forms.IntegerField(
        label=_(""Score threshold""), initial=80, min_value=1, max_value=100
    )

    def __init__(self, obj, *args, **kwargs):
        """"""Generate choices for other component in same project.""""""
        super().__init__(*args, **kwargs)
        self.obj = obj

        # Add components from other projects with enabled shared TM
        self.components = obj.project.component_set.filter(
            source_language=obj.source_language
        ) | Component.objects.filter(
            source_language_id=obj.source_language_id,
            project__contribute_shared_tm=True,
        ).exclude(
            project=obj.project
        )

        # Fetching is faster than doing count on possibly thousands of components
        if len(self.components.values_list(""id"")[:30]) == 30:
            # Do not show choices when too many
            self.fields[""component""] = forms.CharField(
                required=False,
                label=_(""Components""),
                help_text=_(
                    ""Enter component to use as source, ""
                    ""keep blank to use all components in current project.""
                ),
            )
        else:
            choices = [
                (s.id, str(s))
                for s in self.components.order_project().prefetch_related(""project"")
            ]

            self.fields[""component""].choices = [
                ("""", _(""All components in current project""))
            ] + choices

        self.fields[""engines""].choices = [
            (key, mt.name) for key, mt in MACHINE_TRANSLATION_SERVICES.items()
        ]
        if ""weblate"" in MACHINE_TRANSLATION_SERVICES.keys():
            self.fields[""engines""].initial = ""weblate""

        use_types = {""all"", ""nottranslated"", ""todo"", ""fuzzy"", ""check:inconsistent""}

        self.fields[""filter_type""].choices = [
            x for x in self.fields[""filter_type""].choices if x[0] in use_types
        ]

        self.helper = FormHelper(self)
        self.helper.layout = Layout(
            Field(""mode""),
            Field(""filter_type""),
            InlineRadios(""auto_source"", id=""select_auto_source""),
            Div(""component"", css_id=""auto_source_others""),
            Div(""engines"", ""threshold"", css_id=""auto_source_mt""),
        )

    def clean_component(self):
        component = self.cleaned_data[""component""]
        if not component:
            return None
        if component.isdigit():
            try:
                result = self.components.get(pk=component)
            except Component.DoesNotExist:
                raise ValidationError(_(""Component not found!""))
        else:
            slashes = component.count(""/"")
            if slashes == 0:
                try:
                    result = self.components.get(
                        slug=component, project=self.obj.project
                    )
                except Component.DoesNotExist:
                    raise ValidationError(_(""Component not found!""))
            elif slashes == 1:
                project_slug, component_slug = component.split(""/"")
                try:
                    result = self.components.get(
                        slug=component_slug, project__slug=project_slug
                    )
                except Component.DoesNotExist:
                    raise ValidationError(_(""Component not found!""))
            else:
                raise ValidationError(_(""Please provide valid component slug!""))
        return result.pk


class CommentForm(forms.Form):
    """"""Simple commenting form.""""""

    scope = forms.ChoiceField(
        label=_(""Scope""),
        help_text=_(
            ""Is your comment specific to this ""
            ""translation or generic for all of them?""
        ),
        choices=(
            (
                ""report"",
                _(""Report issue with the source string""),
            ),
            (
                ""global"",
                _(""Source string comment, suggestions for changes to this string""),
            ),
            (
                ""translation"",
                _(""Translation comment, discussions with other translators""),
            ),
        ),
    )
    comment = forms.CharField(
        widget=MarkdownTextarea,
        label=_(""New comment""),
        help_text=_(""You can use Markdown and mention users by @username.""),
        max_length=1000,
    )

    def __init__(self, project, *args, **kwargs):
        super().__init__(*args, **kwargs)
        # Remove bug report in case source review is not enabled
        if not project.source_review:
            self.fields[""scope""].choices = self.fields[""scope""].choices[1:]


class EngageForm(forms.Form):
    """"""Form to choose language for engagement widgets.""""""

    lang = forms.ChoiceField(required=False, choices=[("""", _(""All languages""))])
    component = forms.ChoiceField(required=False, choices=[("""", _(""All components""))])

    def __init__(self, user, project, *args, **kwargs):
        """"""Dynamically generate choices for used languages in project.""""""
        super().__init__(*args, **kwargs)

        self.fields[""lang""].choices += project.languages.as_choices()
        self.fields[""component""].choices += (
            project.component_set.filter_access(user)
            .order()
            .values_list(""slug"", ""name"")
        )


class NewLanguageOwnerForm(forms.Form):
    """"""Form for requesting new language.""""""

    lang = forms.MultipleChoiceField(
        label=_(""Languages""), choices=[], widget=forms.SelectMultiple
    )

    def get_lang_objects(self):
        return Language.objects.exclude(
            Q(translation__component=self.component) | Q(component=self.component)
        )

    def __init__(self, component, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.component = component
        languages = self.get_lang_objects()
        self.fields[""lang""].choices = languages.as_choices()


class NewLanguageForm(NewLanguageOwnerForm):
    """"""Form for requesting new language.""""""

    lang = forms.ChoiceField(label=_(""Language""), choices=[], widget=forms.Select)

    def get_lang_objects(self):
        codes = BASIC_LANGUAGES
        if settings.BASIC_LANGUAGES is not None:
            codes = settings.BASIC_LANGUAGES
        return super().get_lang_objects().filter(code__in=codes)

    def __init__(self, component, *args, **kwargs):
        super().__init__(component, *args, **kwargs)
        self.fields[""lang""].choices = [("""", _(""Please choose""))] + self.fields[
            ""lang""
        ].choices

    def clean_lang(self):
        # Compatibility with NewLanguageOwnerForm
        return [self.cleaned_data[""lang""]]


def get_new_language_form(request, component):
    """"""Return new language form for user.""""""
    if not request.user.has_perm(""translation.add"", component):
        raise PermissionDenied()
    if request.user.has_perm(""translation.add_more"", component):
        return NewLanguageOwnerForm
    return NewLanguageForm


class ContextForm(forms.ModelForm):
    class Meta:
        model = Unit
        fields = (""explanation"", ""labels"", ""extra_flags"")
        widgets = {
            ""labels"": forms.CheckboxSelectMultiple(),
            ""explanation"": MarkdownTextarea,
        }

    doc_links = {
        ""explanation"": (""admin/translating"", ""additional-explanation""),
        ""labels"": (""devel/translations"", ""labels""),
        ""extra_flags"": (""admin/translating"", ""additional-flags""),
    }

    def get_field_doc(self, field):
        return self.doc_links[field.name]

    def __init__(self, data=None, instance=None, user=None, **kwargs):
        kwargs[""initial""] = {
            ""labels"": Label.objects.filter(
                Q(unit=instance) | Q(unit__source_unit=instance)
            )
        }
        super().__init__(data=data, instance=instance, **kwargs)
        project = instance.translation.component.project
        self.fields[""labels""].queryset = project.label_set.all()
        self.helper = FormHelper(self)
        self.helper.disable_csrf = True
        self.helper.form_tag = False
        self.helper.layout = Layout(
            Field(""explanation""),
            Field(""labels""),
            ContextDiv(
                template=""snippets/labels_description.html"",
                context={""project"": project, ""user"": user},
            ),
            Field(""extra_flags""),
        )

    def save(self, commit=True):
        if commit:
            self.instance.save(same_content=True)
            self._save_m2m()
            return self.instance
        return super().save(commit)


class UserManageForm(forms.Form):
    user = UserField(
        label=_(""User to add""),
        help_text=_(
            ""Please type in an existing Weblate account name or e-mail address.""
        ),
    )


class UserBlockForm(forms.Form):
    user = UserField(
        label=_(""User to block""),
        help_text=_(
            ""Please type in an existing Weblate account name or e-mail address.""
        ),
    )
    expiry = forms.ChoiceField(
        label=_(""Block duration""),
        choices=(
            ("""", _(""Block user until I unblock them"")),
            (""1"", _(""Block user for one day"")),
            (""7"", _(""Block user for one week"")),
            (""30"", _(""Block user for one month"")),
        ),
        required=False,
    )


class ReportsForm(forms.Form):
    style = forms.ChoiceField(
        label=_(""Report format""),
        help_text=_(""Choose file format for the report""),
        choices=(
            (""rst"", _(""reStructuredText"")),
            (""json"", _(""JSON"")),
            (""html"", _(""HTML"")),
        ),
    )
    period = forms.ChoiceField(
        label=_(""Report period""),
        choices=(
            (""30days"", _(""Last 30 days"")),
            (""this-month"", _(""This month"")),
            (""month"", _(""Last month"")),
            (""this-year"", _(""This year"")),
            (""year"", _(""Last year"")),
            ("""", _(""As specified"")),
        ),
        required=False,
    )
    start_date = WeblateDateField(
        label=_(""Starting date""), required=False, datepicker=False
    )
    end_date = WeblateDateField(
        label=_(""Ending date""), required=False, datepicker=False
    )

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.helper = FormHelper(self)
        self.helper.form_tag = False
        self.helper.layout = Layout(
            Field(""style""),
            Field(""period""),
            Div(
                ""start_date"",
                ""end_date"",
                css_class=""input-group input-daterange"",
                data_provide=""datepicker"",
                data_date_format=""yyyy-mm-dd"",
            ),
        )

    def clean(self):
        super().clean()
        # Invalid value, skip rest of the validation
        if ""period"" not in self.cleaned_data:
            return

        # Handle predefined periods
        if self.cleaned_data[""period""] == ""30days"":
            end = timezone.now()
            start = end - timedelta(days=30)
        elif self.cleaned_data[""period""] == ""month"":
            end = timezone.now().replace(day=1) - timedelta(days=1)
            start = end.replace(day=1)
        elif self.cleaned_data[""period""] == ""this-month"":
            end = timezone.now().replace(day=1) + timedelta(days=31)
            end = end.replace(day=1) - timedelta(days=1)
            start = end.replace(day=1)
        elif self.cleaned_data[""period""] == ""year"":
            year = timezone.now().year - 1
            end = timezone.make_aware(datetime(year, 12, 31))
            start = timezone.make_aware(datetime(year, 1, 1))
        elif self.cleaned_data[""period""] == ""this-year"":
            year = timezone.now().year
            end = timezone.make_aware(datetime(year, 12, 31))
            start = timezone.make_aware(datetime(year, 1, 1))
        else:
            # Validate custom period
            if not self.cleaned_data.get(""start_date""):
                raise ValidationError({""start_date"": _(""Missing date!"")})
            if not self.cleaned_data.get(""end_date""):
                raise ValidationError({""end_date"": _(""Missing date!"")})
            start = self.cleaned_data[""start_date""]
            end = self.cleaned_data[""end_date""]
        # Sanitize timestamps
        self.cleaned_data[""start_date""] = start.replace(
            hour=0, minute=0, second=0, microsecond=0
        )
        self.cleaned_data[""end_date""] = end.replace(
            hour=23, minute=59, second=59, microsecond=999999
        )
        # Final validation
        if self.cleaned_data[""start_date""] > self.cleaned_data[""end_date""]:
            msg = _(""Starting date has to be before ending date!"")
            raise ValidationError({""start_date"": msg, ""end_date"": msg})


class CleanRepoMixin:
    def clean_repo(self):
        repo = self.cleaned_data.get(""repo"")
        if not repo or not is_repo_link(repo) or ""/"" not in repo[10:]:
            return repo
        project, component = repo[10:].split(""/"", 1)
        try:
            obj = Component.objects.get(
                slug__iexact=component, project__slug__iexact=project
            )
        except Component.DoesNotExist:
            return repo
        if not self.request.user.has_perm(""component.edit"", obj):
            raise ValidationError(
                _(""You do not have permission to access this component!"")
            )
        return repo


class SettingsBaseForm(CleanRepoMixin, forms.ModelForm):
    """"""Component base form.""""""

    class Meta:
        model = Component
        fields = []

    def __init__(self, request, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.request = request
        self.helper = FormHelper()
        self.helper.form_tag = False


class SelectChecksWidget(SortedSelectMultiple):
    def __init__(self, attrs=None, choices=()):
        choices = CHECKS.get_choices()
        super().__init__(attrs=attrs, choices=choices)

    def value_from_datadict(self, data, files, name):
        value = super().value_from_datadict(data, files, name)
        if isinstance(value, str):
            return json.loads(value)
        return value

    def format_value(self, value):
        value = super().format_value(value)
        if isinstance(value, str):
            return value
        return json.dumps(value)


class SelectChecksField(forms.CharField):
    def to_python(self, value):
        return value


class ComponentDocsMixin:
    @staticmethod
    def get_field_doc(field):
        return (""admin/projects"", f""component-{field.name}"")


class ProjectDocsMixin:
    @staticmethod
    def get_field_doc(field):
        return (""admin/projects"", f""project-{field.name}"")


class SpamCheckMixin:
    def spam_check(self, value):
        if is_spam(value, self.request):
            raise ValidationError(_(""This field has been identified as spam!""))


class ComponentAntispamMixin(SpamCheckMixin):
    def clean_agreement(self):
        value = self.cleaned_data[""agreement""]
        self.spam_check(value)
        return value


class ProjectAntispamMixin(SpamCheckMixin):
    def clean_web(self):
        value = self.cleaned_data[""web""]
        self.spam_check(value)
        return value

    def clean_instructions(self):
        value = self.cleaned_data[""instructions""]
        self.spam_check(value)
        return value


class ComponentSettingsForm(
    SettingsBaseForm, ComponentDocsMixin, ComponentAntispamMixin
):
    """"""Component settings form.""""""

    class Meta:
        model = Component
        fields = (
            ""name"",
            ""report_source_bugs"",
            ""license"",
            ""agreement"",
            ""allow_translation_propagation"",
            ""enable_suggestions"",
            ""suggestion_voting"",
            ""suggestion_autoaccept"",
            ""priority"",
            ""check_flags"",
            ""enforced_checks"",
            ""commit_message"",
            ""add_message"",
            ""delete_message"",
            ""merge_message"",
            ""addon_message"",
            ""vcs"",
            ""repo"",
            ""branch"",
            ""push"",
            ""push_branch"",
            ""repoweb"",
            ""push_on_commit"",
            ""commit_pending_age"",
            ""merge_style"",
            ""file_format"",
            ""edit_template"",
            ""new_lang"",
            ""language_code_style"",
            ""source_language"",
            ""new_base"",
            ""filemask"",
            ""template"",
            ""intermediate"",
            ""language_regex"",
            ""variant_regex"",
            ""restricted"",
            ""auto_lock_error"",
            ""links"",
            ""manage_units"",
            ""is_glossary"",
            ""glossary_color"",
        )
        widgets = {
            ""enforced_checks"": SelectChecksWidget,
            ""source_language"": SortedSelect,
        }
        field_classes = {""enforced_checks"": SelectChecksField}

    def __init__(self, request, *args, **kwargs):
        super().__init__(request, *args, **kwargs)
        if self.hide_restricted:
            self.fields[""restricted""].widget = forms.HiddenInput()
        self.fields[""links""].queryset = request.user.managed_projects.exclude(
            pk=self.instance.pk
        )
        self.helper.layout = Layout(
            TabHolder(
                Tab(
                    _(""Basic""),
                    Fieldset(_(""Name""), ""name""),
                    Fieldset(_(""License""), ""license"", ""agreement""),
                    Fieldset(_(""Upstream links""), ""report_source_bugs""),
                    Fieldset(
                        _(""Listing and access""),
                        ""priority"",
                        ""restricted"",
                        ""links"",
                    ),
                    Fieldset(
                        _(""Glossary""),
                        ""is_glossary"",
                        ""glossary_color"",
                    ),
                    css_id=""basic"",
                ),
                Tab(
                    _(""Translation""),
                    Fieldset(
                        _(""Suggestions""),
                        ""enable_suggestions"",
                        ""suggestion_voting"",
                        ""suggestion_autoaccept"",
                    ),
                    Fieldset(
                        _(""Translation settings""),
                        ""allow_translation_propagation"",
                        ""manage_units"",
                        ""check_flags"",
                        ""variant_regex"",
                        ""enforced_checks"",
                    ),
                    css_id=""translation"",
                ),
                Tab(
                    _(""Version control""),
                    Fieldset(
                        _(""Locations""),
                        Div(template=""trans/repo_help.html""),
                        ""vcs"",
                        ""repo"",
                        ""branch"",
                        ""push"",
                        ""push_branch"",
                        ""repoweb"",
                    ),
                    Fieldset(
                        _(""Version control settings""),
                        ""push_on_commit"",
                        ""commit_pending_age"",
                        ""merge_style"",
                        ""auto_lock_error"",
                    ),
                    css_id=""vcs"",
                ),
                Tab(
                    _(""Commit messages""),
                    Fieldset(
                        _(""Commit messages""),
                        ContextDiv(
                            template=""trans/messages_help.html"",
                            context={""user"": request.user},
                        ),
                        ""commit_message"",
                        ""add_message"",
                        ""delete_message"",
                        ""merge_message"",
                        ""addon_message"",
                    ),
                    css_id=""messages"",
                ),
                Tab(
                    _(""Files""),
                    Fieldset(
                        _(""Translation files""),
                        ""file_format"",
                        ""filemask"",
                        ""language_regex"",
                        ""source_language"",
                    ),
                    Fieldset(
                        _(""Monolingual translations""),
                        ""template"",
                        ""edit_template"",
                        ""intermediate"",
                    ),
                    Fieldset(
                        _(""Adding new languages""),
                        ""new_base"",
                        ""new_lang"",
                        ""language_code_style"",
                    ),
                    css_id=""files"",
                ),
                template=""layout/pills.html"",
            )
        )
        vcses = (
            ""git"",
            ""gerrit"",
            ""github"",
            ""gitlab"",
            ""pagure"",
            ""local"",
            ""git-force-push"",
        )
        if self.instance.vcs not in vcses:
            vcses = (self.instance.vcs,)
        self.fields[""vcs""].choices = [
            c for c in self.fields[""vcs""].choices if c[0] in vcses
        ]

    @property
    def hide_restricted(self):
        user = self.request.user
        if user.is_superuser:
            return False
        if settings.OFFER_HOSTING:
            return True
        return not any(
            ""component.edit"" in permissions
            for permissions, _langs in user.component_permissions[self.instance.pk]
        )

    def clean(self):
        data = self.cleaned_data
        if self.hide_restricted:
            data[""restricted""] = self.instance.restricted


class ComponentCreateForm(SettingsBaseForm, ComponentDocsMixin, ComponentAntispamMixin):
    """"""Component creation form.""""""

    class Meta:
        model = Component
        fields = [
            ""project"",
            ""name"",
            ""slug"",
            ""vcs"",
            ""repo"",
            ""branch"",
            ""push"",
            ""push_branch"",
            ""repoweb"",
            ""file_format"",
            ""filemask"",
            ""template"",
            ""edit_template"",
            ""intermediate"",
            ""new_base"",
            ""license"",
            ""new_lang"",
            ""language_code_style"",
            ""language_regex"",
            ""source_language"",
            ""is_glossary"",
        ]
        widgets = {""source_language"": SortedSelect}


class ComponentNameForm(forms.Form, ComponentDocsMixin, ComponentAntispamMixin):
    name = forms.CharField(
        label=_(""Component name""),
        max_length=COMPONENT_NAME_LENGTH,
        help_text=_(""Display name""),
    )
    slug = forms.SlugField(
        label=_(""URL slug""),
        max_length=COMPONENT_NAME_LENGTH,
        help_text=_(""Name used in URLs and filenames.""),
    )
    is_glossary = forms.BooleanField(
        label=_(""Use as a glossary""),
        required=False,
    )

    def __init__(self, request, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.helper = FormHelper()
        self.helper.form_tag = False
        self.request = request


class ComponentSelectForm(ComponentNameForm):
    component = forms.ModelChoiceField(
        queryset=Component.objects.none(),
        label=_(""Component""),
        help_text=_(""Select existing component to copy configuration from.""),
    )

    def __init__(self, request, *args, **kwargs):
        if ""instance"" in kwargs:
            kwargs.pop(""instance"")
        if ""auto_id"" not in kwargs:
            kwargs[""auto_id""] = ""id_existing_%s""
        super().__init__(request, *args, **kwargs)


class ComponentBranchForm(ComponentSelectForm):
    branch = forms.ChoiceField(label=_(""Repository branch""))

    branch_data: Dict[int, List[str]] = {}
    instance = None

    def __init__(self, *args, **kwargs):
        kwargs[""auto_id""] = ""id_branch_%s""
        super().__init__(*args, **kwargs)

    def clean_component(self):
        component = self.cleaned_data[""component""]
        self.fields[""branch""].choices = [(x, x) for x in self.branch_data[component.pk]]
        return component

    def clean(self):
        form_fields = (""branch"", ""slug"", ""name"")
        data = self.cleaned_data
        component = data.get(""component"")
        if not component or any(field not in data for field in form_fields):
            return
        kwargs = model_to_dict(component, exclude=[""id"", ""links""])
        # We need a object, not integer here
        kwargs[""source_language""] = component.source_language
        kwargs[""project""] = component.project
        for field in form_fields:
            kwargs[field] = data[field]
        self.instance = Component(**kwargs)
        try:
            self.instance.full_clean()
        except ValidationError as error:
            # Can not raise directly as this will contain errors
            # from fields not present here
            result = {NON_FIELD_ERRORS: []}
            for key, value in error.message_dict.items():
                if key in self.fields:
                    result[key] = value
                else:
                    result[NON_FIELD_ERRORS].extend(value)
            raise ValidationError(error.messages)


class ComponentProjectForm(ComponentNameForm):
    project = forms.ModelChoiceField(
        queryset=Project.objects.none(), label=_(""Project"")
    )
    source_language = forms.ModelChoiceField(
        widget=SortedSelect,
        label=_(""Source language""),
        help_text=_(""Language used for source strings in all components""),
        queryset=Language.objects.all(),
    )

    def __init__(self, request, *args, **kwargs):
        if ""instance"" in kwargs:
            kwargs.pop(""instance"")
        super().__init__(request, *args, **kwargs)
        # It might be overriden based on preset project
        self.fields[""source_language""].initial = Language.objects.default_language
        self.request = request
        self.helper = FormHelper()
        self.helper.form_tag = False
        self.instance = None

    def clean(self):
        if ""project"" not in self.cleaned_data:
            return
        project = self.cleaned_data[""project""]
        name = self.cleaned_data.get(""name"")
        if name and project.component_set.filter(name__iexact=name).exists():
            raise ValidationError(
                {""name"": _(""Component with the same name already exists."")}
            )
        slug = self.cleaned_data.get(""slug"")
        if slug and project.component_set.filter(slug__iexact=slug).exists():
            raise ValidationError(
                {""slug"": _(""Component with the same name already exists."")}
            )


class ComponentScratchCreateForm(ComponentProjectForm):
    file_format = forms.ChoiceField(
        label=_(""File format""),
        initial=""po-mono"",
        choices=FILE_FORMATS.get_choices(
            cond=lambda x: bool(x.new_translation) or hasattr(x, ""update_bilingual"")
        ),
    )

    def __init__(self, *args, **kwargs):
        kwargs[""auto_id""] = ""id_scratchcreate_%s""
        super().__init__(*args, **kwargs)


class ComponentZipCreateForm(ComponentProjectForm):
    zipfile = forms.FileField(
        label=_(""ZIP file containing translations""),
        validators=[FileExtensionValidator(allowed_extensions=[""zip""])],
        widget=forms.FileInput(attrs={""accept"": "".zip,application/zip""}),
    )

    field_order = [""zipfile"", ""project"", ""name"", ""slug""]

    def __init__(self, *args, **kwargs):
        kwargs[""auto_id""] = ""id_zipcreate_%s""
        super().__init__(*args, **kwargs)


class ComponentDocCreateForm(ComponentProjectForm):
    docfile = forms.FileField(
        label=_(""Document to translate""),
        validators=[validate_file_extension],
    )

    field_order = [""docfile"", ""project"", ""name"", ""slug""]

    def __init__(self, *args, **kwargs):
        kwargs[""auto_id""] = ""id_doccreate_%s""
        super().__init__(*args, **kwargs)


class ComponentInitCreateForm(CleanRepoMixin, ComponentProjectForm):
    """"""Component creation form.

    This is mostly copy from Component model. Probably should be extracted to standalone
    Repository model...
    """"""

    project = forms.ModelChoiceField(
        queryset=Project.objects.none(), label=_(""Project"")
    )
    vcs = forms.ChoiceField(
        label=_(""Version control system""),
        help_text=_(
            ""Version control system to use to access your ""
            ""repository with translations.""
        ),
        choices=VCS_REGISTRY.get_choices(exclude={""local""}),
        initial=settings.DEFAULT_VCS,
    )
    repo = forms.CharField(
        label=_(""Source code repository""),
        max_length=REPO_LENGTH,
        help_text=_(
            ""URL of a repository, use weblate://project/component ""
            ""for sharing with other component.""
        ),
    )
    branch = forms.CharField(
        label=_(""Repository branch""),
        max_length=REPO_LENGTH,
        help_text=_(""Repository branch to translate""),
        required=False,
    )

    def clean_instance(self, data):
        params = copy.copy(data)
        if ""discovery"" in params:
            params.pop(""discovery"")

        instance = Component(**params)
        instance.clean_fields(exclude=(""filemask"", ""file_format"", ""license""))
        instance.validate_unique()
        instance.clean_repo()
        self.instance = instance

        # Create linked repos automatically
        repo = instance.suggest_repo_link()
        if repo:
            data[""repo""] = repo
            data[""branch""] = """"
            self.clean_instance(data)

    def clean(self):
        self.clean_instance(self.cleaned_data)


class ComponentDiscoverForm(ComponentInitCreateForm):
    discovery = forms.ChoiceField(
        label=_(""Choose translation files to import""),
        choices=[(""manual"", _(""Specify configuration manually""))],
        required=True,
        widget=forms.RadioSelect,
    )

    def render_choice(self, value):
        context = copy.copy(value)
        try:
            format_cls = FILE_FORMATS[value[""file_format""]]
            context[""file_format_name""] = format_cls.name
            context[""valid""] = True
        except KeyError:
            context[""file_format_name""] = value[""file_format""]
            context[""valid""] = False
        context[""origin""] = value.meta[""origin""]
        return render_to_string(""trans/discover-choice.html"", context)

    def __init__(self, request, *args, **kwargs):
        super().__init__(request, *args, **kwargs)
        for field, value in self.fields.items():
            if field == ""discovery"":
                continue
            value.widget = forms.HiddenInput()
        # Allow all VCS now (to handle zip file upload case)
        self.fields[""vcs""].choices = VCS_REGISTRY.get_choices()
        self.discovered = self.perform_discovery(request, kwargs)
        for i, value in enumerate(self.discovered):
            self.fields[""discovery""].choices.append((i, self.render_choice(value)))

    def perform_discovery(self, request, kwargs):
        if ""data"" in kwargs and ""create_discovery"" in request.session:
            discovered = []
            for i, data in enumerate(request.session[""create_discovery""]):
                item = DiscoveryResult(data)
                item.meta = request.session[""create_discovery_meta""][i]
                discovered.append(item)
            return discovered
        try:
            self.clean_instance(kwargs[""initial""])
            discovered = self.discover()
            if not discovered:
                discovered = self.discover(eager=True)
        except ValidationError:
            discovered = []
        request.session[""create_discovery""] = discovered
        request.session[""create_discovery_meta""] = [x.meta for x in discovered]
        return discovered

    def discover(self, eager: bool = False):
        return discover(
            self.instance.full_path,
            source_language=self.instance.source_language.code,
            eager=eager,
        )

    def clean(self):
        super().clean()
        discovery = self.cleaned_data.get(""discovery"")
        if discovery and discovery != ""manual"":
            self.cleaned_data.update(self.discovered[int(discovery)])


class ComponentRenameForm(SettingsBaseForm, ComponentDocsMixin):
    """"""Component rename form.""""""

    class Meta:
        model = Component
        fields = [""slug""]


class ComponentMoveForm(SettingsBaseForm, ComponentDocsMixin):
    """"""Component rename form.""""""

    class Meta:
        model = Component
        fields = [""project""]

    def __init__(self, request, *args, **kwargs):
        super().__init__(request, *args, **kwargs)
        self.fields[""project""].queryset = request.user.managed_projects


class ProjectSettingsForm(SettingsBaseForm, ProjectDocsMixin, ProjectAntispamMixin):
    """"""Project settings form.""""""

    class Meta:
        model = Project
        fields = (
            ""name"",
            ""web"",
            ""instructions"",
            ""set_language_team"",
            ""use_shared_tm"",
            ""contribute_shared_tm"",
            ""enable_hooks"",
            ""language_aliases"",
            ""access_control"",
            ""translation_review"",
            ""source_review"",
        )
        widgets = {
            ""access_control"": forms.RadioSelect,
            ""instructions"": MarkdownTextarea,
            ""language_aliases"": forms.TextInput,
        }

    def clean(self):
        data = self.cleaned_data
        if settings.OFFER_HOSTING:
            data[""contribute_shared_tm""] = data[""use_shared_tm""]
        if (
            ""access_control"" not in data
            or data[""access_control""] is None
            or data[""access_control""] == """"
        ):
            data[""access_control""] = self.instance.access_control
        access = data[""access_control""]

        self.changed_access = access != self.instance.access_control

        if self.changed_access and not self.user_can_change_access:
            raise ValidationError(
                {
                    ""access_control"": _(
                        ""You do not have permission to change project access control.""
                    )
                }
            )
        if self.changed_access and access in (
            Project.ACCESS_PUBLIC,
            Project.ACCESS_PROTECTED,
        ):
            unlicensed = self.instance.component_set.filter(license="""")
            if unlicensed:
                raise ValidationError(
                    {
                        ""access_control"": _(
                            ""You must specify a license for these components ""
                            ""to make them publicly accessible: %s""
                        )
                        % "", "".join(unlicensed.values_list(""name"", flat=True))
                    }
                )

    def save(self, commit: bool = True):
        super().save(commit=commit)
        if self.changed_access:
            Change.objects.create(
                project=self.instance,
                action=Change.ACTION_ACCESS_EDIT,
                user=self.user,
                details={""access_control"": self.instance.access_control},
            )

    def __init__(self, request, *args, **kwargs):
        super().__init__(request, *args, **kwargs)
        self.user = request.user
        self.user_can_change_access = request.user.has_perm(
            ""billing:project.permissions"", self.instance
        )
        self.changed_access = False
        self.helper.form_tag = False
        if not self.user_can_change_access:
            disabled = {""disabled"": True}
            self.fields[""access_control""].required = False
            self.fields[""access_control""].help_text = _(
                ""You do not have permission to change project access control.""
            )
        else:
            disabled = {}
        self.helper.layout = Layout(
            TabHolder(
                Tab(
                    _(""Basic""),
                    ""name"",
                    ""web"",
                    ""instructions"",
                    css_id=""basic"",
                ),
                Tab(
                    _(""Access""),
                    InlineRadios(
                        ""access_control"",
                        template=""%s/layout/radioselect_access.html"",
                        **disabled,
                    ),
                    css_id=""access"",
                ),
                Tab(
                    _(""Workflow""),
                    ""set_language_team"",
                    ""use_shared_tm"",
                    ""contribute_shared_tm"",
                    ""enable_hooks"",
                    ""language_aliases"",
                    ""translation_review"",
                    ""source_review"",
                    css_id=""workflow"",
                ),
                Tab(
                    _(""Components""),
                    ContextDiv(
                        template=""snippets/project-component-settings.html"",
                        context={""object"": self.instance, ""user"": request.user},
                    ),
                    css_id=""components"",
                ),
                template=""layout/pills.html"",
            )
        )

        if settings.OFFER_HOSTING:
            self.fields[""contribute_shared_tm""].widget = forms.HiddenInput()
            self.fields[""use_shared_tm""].help_text = _(
                ""Uses and contributes to the pool of shared translations ""
                ""between projects.""
            )
            self.fields[""access_control""].choices = [
                choice
                for choice in self.fields[""access_control""].choices
                if choice[0] != Project.ACCESS_CUSTOM
            ]


class ProjectRenameForm(SettingsBaseForm, ProjectDocsMixin):
    """"""Project rename form.""""""

    class Meta:
        model = Project
        fields = [""slug""]


class ProjectCreateForm(SettingsBaseForm, ProjectDocsMixin, ProjectAntispamMixin):
    """"""Project creation form.""""""

    # This is fake field with is either hidden or configured
    # in the view
    billing = forms.ModelChoiceField(
        label=_(""Billing""),
        queryset=User.objects.none(),
        required=True,
        empty_label=None,
    )

    class Meta:
        model = Project
        fields = (""name"", ""slug"", ""web"", ""instructions"")


class ReplaceForm(forms.Form):
    q = QueryField(
        required=False, help_text=_(""Optional additional filter on the strings"")
    )
    search = forms.CharField(
        label=_(""Search string""),
        min_length=1,
        required=True,
        strip=False,
        help_text=_(""Case sensitive string to search for and replace.""),
    )
    replacement = forms.CharField(
        label=_(""Replacement string""), min_length=1, required=True, strip=False
    )

    def __init__(self, *args, **kwargs):
        kwargs[""auto_id""] = ""id_replace_%s""
        super().__init__(*args, **kwargs)
        self.helper = FormHelper(self)
        self.helper.form_tag = False
        self.helper.layout = Layout(
            SearchField(""q""),
            Field(""search""),
            Field(""replacement""),
            Div(template=""snippets/replace-help.html""),
        )


class ReplaceConfirmForm(forms.Form):
    units = forms.ModelMultipleChoiceField(queryset=Unit.objects.none(), required=False)
    confirm = forms.BooleanField(required=True, initial=True, widget=forms.HiddenInput)

    def __init__(self, units, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.fields[""units""].queryset = units


class MatrixLanguageForm(forms.Form):
    """"""Form for requesting new language.""""""

    lang = forms.MultipleChoiceField(
        label=_(""Languages""), choices=[], widget=forms.SelectMultiple
    )

    def __init__(self, component, *args, **kwargs):
        super().__init__(*args, **kwargs)
        languages = Language.objects.filter(translation__component=component).exclude(
            pk=component.source_language_id
        )
        self.fields[""lang""].choices = languages.as_choices()


class NewUnitBaseForm(forms.Form):
    variant = forms.ModelChoiceField(
        Unit.objects.none(),
        widget=forms.HiddenInput,
        required=False,
    )

    def __init__(self, translation, user, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.translation = translation
        self.fields[""variant""].queryset = translation.unit_set.all()
        self.user = user

    def clean(self):
        try:
            data = self.as_kwargs()
        except KeyError:
            # Probably some fields validation has failed
            return
        self.translation.validate_new_unit_data(**data)

    def get_glossary_flags(self):
        return """"

    def as_kwargs(self):
        flags = Flags()
        flags.merge(self.get_glossary_flags())
        variant = self.cleaned_data.get(""variant"")
        if variant:
            flags.set_value(""variant"", variant.source)
        return {
            ""context"": self.cleaned_data.get(""context"", """"),
            ""source"": self.cleaned_data[""source""],
            ""target"": self.cleaned_data.get(""target""),
            ""extra_flags"": flags.format(),
            ""explanation"": self.cleaned_data.get(""explanation"", """"),
            ""auto_context"": self.cleaned_data.get(""auto_context"", False),
        }


class NewMonolingualUnitForm(NewUnitBaseForm):
    context = forms.CharField(
        label=_(""Translation key""),
        help_text=_(
            ""Key used to identify string in translation file. ""
            ""File format specific rules might apply.""
        ),
        required=True,
    )
    source = PluralField(
        label=_(""Source language text""),
        help_text=_(
            ""You can edit this later, as with any other string in ""
            ""the source language.""
        ),
        required=True,
    )

    def __init__(self, translation, user, *args, **kwargs):
        super().__init__(translation, user, *args, **kwargs)
        self.fields[""context""].widget.attrs[""tabindex""] = 99
        self.fields[""source""].widget.attrs[""tabindex""] = 100
        self.fields[""source""].widget.profile = user.profile
        self.fields[""source""].initial = Unit(translation=translation, id_hash=0)


class NewBilingualSourceUnitForm(NewUnitBaseForm):
    context = forms.CharField(
        label=_(""Context""),
        help_text=_(""Optional context to clarify the source strings.""),
        required=False,
    )
    auto_context = forms.BooleanField(
        required=False,
        initial=True,
        label=_(""Automatically adjust context when same string already exists.""),
    )
    source = PluralField(
        label=_(""Source string""),
        required=True,
    )

    def __init__(self, translation, user, *args, **kwargs):
        super().__init__(translation, user, *args, **kwargs)
        self.fields[""context""].widget.attrs[""tabindex""] = 99
        self.fields[""context""].label = translation.component.context_label
        self.fields[""source""].widget.attrs[""tabindex""] = 100
        self.fields[""source""].widget.profile = user.profile
        self.fields[""source""].initial = Unit(
            translation=translation.component.source_translation, id_hash=0
        )


class NewBilingualUnitForm(NewBilingualSourceUnitForm):
    target = PluralField(
        label=_(""Translated string""),
        help_text=_(
            ""You can edit this later, as with any other string in the translation.""
        ),
        required=True,
    )

    def __init__(self, translation, user, *args, **kwargs):
        super().__init__(translation, user, *args, **kwargs)
        self.fields[""target""].widget.attrs[""tabindex""] = 101
        self.fields[""target""].widget.profile = user.profile
        self.fields[""target""].initial = Unit(translation=translation, id_hash=0)


class NewBilingualGlossarySourceUnitForm(GlossaryAddMixin, NewBilingualSourceUnitForm):
    def __init__(self, translation, user, *args, **kwargs):
        if kwargs[""initial""] is None:
            kwargs[""initial""] = {}
        kwargs[""initial""][""terminology""] = True
        super().__init__(translation, user, *args, **kwargs)


class NewBilingualGlossaryUnitForm(GlossaryAddMixin, NewBilingualUnitForm):
    pass


def get_new_unit_form(translation, user, data=None, initial=None):
    if translation.component.has_template():
        return NewMonolingualUnitForm(translation, user, data=data, initial=initial)
    if translation.component.is_glossary:
        if translation.is_source:
            return NewBilingualGlossarySourceUnitForm(
                translation, user, data=data, initial=initial
            )
        return NewBilingualGlossaryUnitForm(
            translation, user, data=data, initial=initial
        )
    if translation.is_source:
        return NewBilingualSourceUnitForm(translation, user, data=data, initial=initial)
    return NewBilingualUnitForm(translation, user, data=data, initial=initial)


class CachedQueryIterator(ModelChoiceIterator):
    """"""
    Choice iterator for cached querysets.

    It assumes the queryset is reused and avoids using iterator or count queries.
    """"""

    def __iter__(self):
        if self.field.empty_label is not None:
            yield ("""", self.field.empty_label)
        for obj in self.queryset:
            yield self.choice(obj)

    def __len__(self):
        return len(self.queryset) + (1 if self.field.empty_label is not None else 0)

    def __bool__(self):
        return self.field.empty_label is not None or bool(self.queryset)


class CachedModelMultipleChoiceField(forms.ModelMultipleChoiceField):
    iterator = CachedQueryIterator

    def _get_queryset(self):
        return self._queryset

    def _set_queryset(self, queryset):
        self._queryset = queryset
        self.widget.choices = self.choices

    queryset = property(_get_queryset, _set_queryset)


class BulkEditForm(forms.Form):
    q = QueryField(required=True)
    state = forms.ChoiceField(
        label=_(""State to set""), choices=((-1, _(""Do not change"")),) + STATE_CHOICES
    )
    add_flags = FlagField(label=_(""Translation flags to add""), required=False)
    remove_flags = FlagField(label=_(""Translation flags to remove""), required=False)
    add_labels = CachedModelMultipleChoiceField(
        queryset=Label.objects.none(),
        label=_(""Labels to add""),
        widget=forms.CheckboxSelectMultiple(),
        required=False,
    )
    remove_labels = CachedModelMultipleChoiceField(
        queryset=Label.objects.none(),
        label=_(""Labels to remove""),
        widget=forms.CheckboxSelectMultiple(),
        required=False,
    )

    def __init__(self, user, obj, *args, **kwargs):
        project = kwargs.pop(""project"")
        kwargs[""auto_id""] = ""id_bulk_%s""
        super().__init__(*args, **kwargs)
        labels = project.label_set.all()
        if labels:
            self.fields[""remove_labels""].queryset = labels
            self.fields[""add_labels""].queryset = labels

        excluded = {STATE_EMPTY, STATE_READONLY}
        if user is not None and not user.has_perm(""unit.review"", obj):
            excluded.add(STATE_APPROVED)

        # Filter offered states
        self.fields[""state""].choices = [
            x for x in self.fields[""state""].choices if x[0] not in excluded
        ]

        self.helper = FormHelper(self)
        self.helper.form_tag = False
        self.helper.layout = Layout(
            Div(template=""snippets/bulk-help.html""),
            SearchField(""q""),
            Field(""state""),
            Field(""add_flags""),
            Field(""remove_flags""),
        )
        if labels:
            self.helper.layout.append(InlineCheckboxes(""add_labels""))
            self.helper.layout.append(InlineCheckboxes(""remove_labels""))


class ContributorAgreementForm(forms.Form):
    confirm = forms.BooleanField(
        label=_(""I accept the contributor agreement""), required=True
    )
    next = forms.CharField(required=False, widget=forms.HiddenInput)


class BaseDeleteForm(forms.Form):
    confirm = forms.CharField(required=True)
    warning_template = """"

    def __init__(self, obj, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.obj = obj
        self.helper = FormHelper(self)
        self.helper.layout = Layout(
            ContextDiv(
                template=self.warning_template,
                css_class=""form-group"",
                context={""object"": obj},
            ),
            Field(""confirm""),
        )
        self.helper.form_tag = False

    def clean(self):
        if self.cleaned_data.get(""confirm"") != self.obj.full_slug:
            raise ValidationError(
                _(""The slug does not match the one marked for deletion!"")
            )


class TranslationDeleteForm(BaseDeleteForm):
    confirm = forms.CharField(
        label=_(""Removal confirmation""),
        help_text=_(""Please type in the full slug of the translation to confirm.""),
        required=True,
    )
    warning_template = ""trans/delete-translation.html""


class ComponentDeleteForm(BaseDeleteForm):
    confirm = forms.CharField(
        label=_(""Removal confirmation""),
        help_text=_(""Please type in the full slug of the component to confirm.""),
        required=True,
    )
    warning_template = ""trans/delete-component.html""


class ProjectDeleteForm(BaseDeleteForm):
    confirm = forms.CharField(
        label=_(""Removal confirmation""),
        help_text=_(""Please type in the slug of the project to confirm.""),
        required=True,
    )
    warning_template = ""trans/delete-project.html""


class ProjectLanguageDeleteForm(BaseDeleteForm):
    confirm = forms.CharField(
        label=_(""Removal confirmation""),
        help_text=_(""Please type in the slug of the project and language to confirm.""),
        required=True,
    )
    warning_template = ""trans/delete-project-language.html""


class AnnouncementForm(forms.ModelForm):
    """"""Component base form.""""""

    class Meta:
        model = Announcement
        fields = [""message"", ""category"", ""expiry"", ""notify""]
        widgets = {
            ""expiry"": WeblateDateInput(),
            ""message"": MarkdownTextarea,
        }


class ChangesForm(forms.Form):
    project = forms.ChoiceField(label=_(""Project""), choices=[("""", """")], required=False)
    lang = forms.ChoiceField(label=_(""Language""), choices=[("""", """")], required=False)
    action = forms.MultipleChoiceField(
        label=_(""Action""),
        required=False,
        widget=SortedSelectMultiple,
        choices=Change.ACTION_CHOICES,
    )
    user = UsernameField(label=_(""Author username""), required=False, help_text=None)
    start_date = WeblateDateField(
        label=_(""Starting date""), required=False, datepicker=False
    )
    end_date = WeblateDateField(
        label=_(""Ending date""), required=False, datepicker=False
    )

    def __init__(self, request, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.fields[""lang""].choices += Language.objects.have_translation().as_choices()
        self.fields[""project""].choices += [
            (project.slug, project.name) for project in request.user.allowed_projects
        ]


class LabelForm(forms.ModelForm):
    class Meta:
        model = Label
        fields = (""name"", ""color"")
        widgets = {""color"": ColorWidget()}

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.helper = FormHelper(self)
        self.helper.form_tag = False


class ProjectTokenDeleteForm(forms.Form):
    token = forms.ModelChoiceField(
        ProjectToken.objects.none(),
        widget=forms.HiddenInput,
        required=True,
    )

    def __init__(self, project, *args, **kwargs):
        self.project = project
        super().__init__(*args, **kwargs)
        self.fields[""token""].queryset = project.projecttoken_set.all()


class ProjectTokenCreateForm(forms.ModelForm):
    class Meta:
        model = ProjectToken
        fields = [""name"", ""expires"", ""project""]
        widgets = {
            ""expires"": WeblateDateInput(),
            ""project"": forms.HiddenInput,
        }

    def __init__(self, project, *args, **kwargs):
        self.project = project
        kwargs[""initial""] = {""project"": project}
        super().__init__(*args, **kwargs)

    def clean_project(self):
        if self.project != self.cleaned_data[""project""]:
            raise ValidationError(""Invalid project!"")
        return self.cleaned_data[""project""]

    def clean_expires(self):
        expires = self.cleaned_data[""expires""]
        expires = expires.replace(hour=23, minute=59, second=59, microsecond=999999)
        if expires < timezone.now():
            raise forms.ValidationError(gettext(""Expiry cannot be in the past!""))
        return expires


class ProjectGroupDeleteForm(forms.Form):
    group = forms.ModelChoiceField(
        Group.objects.none(),
        widget=forms.HiddenInput,
        required=True,
    )

    def __init__(self, project, *args, **kwargs):
        self.project = project
        super().__init__(*args, **kwargs)
        self.fields[""group""].queryset = project.defined_groups.all()


class ProjectUserGroupForm(UserManageForm):
    groups = forms.ModelMultipleChoiceField(
        Group.objects.none(),
        widget=forms.CheckboxSelectMultiple,
        label=_(""Teams""),
        required=False,
    )

    def __init__(self, project, *args, **kwargs):
        self.project = project
        super().__init__(*args, **kwargs)
        self.fields[""user""].widget = forms.HiddenInput()
        self.fields[""groups""].queryset = project.defined_groups.all()
"
"# Copyright Red Hat 2017, Jake Hunsaker <jhunsake@redhat.com>
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

import fnmatch
import inspect
import logging
import os
import random
import re
import string
import tarfile
import threading
import tempfile
import shutil
import subprocess
import sys

from datetime import datetime
from concurrent.futures import ThreadPoolExecutor
from .sosnode import SosNode
from distutils.sysconfig import get_python_lib
from getpass import getpass
from six.moves import input
from textwrap import fill
from soscollector import __version__


class SosCollector():
    '''Main sos-collector class'''

    def __init__(self, config):
        self.config = config
        self.threads = []
        self.workers = []
        self.client_list = []
        self.node_list = []
        self.master = False
        self.retrieved = 0
        self.need_local_sudo = False
        if not self.config['list_options']:
            try:
                if not self.config['tmp_dir']:
                    self.create_tmp_dir()
                self._setup_logging()
                self.log_debug('Executing %s' % ' '.join(s for s in sys.argv))
                self._load_clusters()
                self._parse_options()
                self.prep()
            except KeyboardInterrupt:
                self._exit('Exiting on user cancel', 130)
        else:
            self._load_clusters()

    def _setup_logging(self):
        # behind the scenes logging
        self.logger = logging.getLogger('sos_collector')
        self.logger.setLevel(logging.DEBUG)
        self.logfile = tempfile.NamedTemporaryFile(
            mode=""w+"",
            dir=self.config['tmp_dir'])
        hndlr = logging.StreamHandler(self.logfile)
        hndlr.setFormatter(logging.Formatter(
            '%(asctime)s %(levelname)s: %(message)s'))
        hndlr.setLevel(logging.DEBUG)
        self.logger.addHandler(hndlr)

        console = logging.StreamHandler(sys.stderr)
        console.setFormatter(logging.Formatter('%(message)s'))

        # ui logging
        self.console = logging.getLogger('sos_collector_console')
        self.console.setLevel(logging.DEBUG)
        self.console_log_file = tempfile.NamedTemporaryFile(
            mode=""w+"",
            dir=self.config['tmp_dir'])
        chandler = logging.StreamHandler(self.console_log_file)
        cfmt = logging.Formatter('%(asctime)s %(levelname)s: %(message)s')
        chandler.setFormatter(cfmt)
        self.console.addHandler(chandler)

        # also print to console
        ui = logging.StreamHandler()
        fmt = logging.Formatter('%(message)s')
        ui.setFormatter(fmt)
        if self.config['verbose']:
            ui.setLevel(logging.DEBUG)
        else:
            ui.setLevel(logging.INFO)
        self.console.addHandler(ui)

    def _exit(self, msg, error=1):
        '''Used to safely terminate if sos-collector encounters an error'''
        self.log_error(msg)
        try:
            self.close_all_connections()
        except Exception:
            pass
        sys.exit(error)

    def _parse_options(self):
        '''If there are cluster options set on the CLI, override the defaults
        '''
        if self.config['cluster_options']:
            for opt in self.config['cluster_options']:
                match = False
                for option in self.clusters[opt.cluster].options:
                    if opt.name == option.name:
                        match = True
                        # override the default from CLI
                        option.value = self._validate_option(option, opt)
                if not match:
                    self._exit('Unknown option provided: %s.%s' % (
                        opt.cluster, opt.name
                    ))

    def _validate_option(self, default, cli):
        '''Checks to make sure that the option given on the CLI is valid.
        Valid in this sense means that the type of value given matches what a
        cluster profile expects (str for str, bool for bool, etc).

        For bool options, this will also convert the string equivalent to an
        actual boolean value
        '''
        if not default.opt_type == bool:
            if not default.opt_type == cli.opt_type:
                msg = ""Invalid option type for %s. Expected %s got %s""
                self._exit(msg % (cli.name, default.opt_type, cli.opt_type))
            return cli.value
        else:
            val = cli.value.lower()
            if val not in ['true', 'on', 'false', 'off']:
                msg = (""Invalid value for %s. Accepted values are: 'true', ""
                       ""'false', 'on', 'off'"")
                self._exit(msg % cli.name)
            else:
                if val in ['true', 'on']:
                    return True
                else:
                    return False

    def log_info(self, msg):
        '''Log info messages to both console and log file'''
        self.logger.info(msg)
        self.console.info(msg)

    def log_error(self, msg):
        '''Log error messages to both console and log file'''
        self.logger.error(msg)
        self.console.error(msg)

    def log_debug(self, msg):
        '''Log debug message to both console and log file'''
        caller = inspect.stack()[1][3]
        msg = '[sos_collector:%s] %s' % (caller, msg)
        self.logger.debug(msg)
        if self.config['verbose']:
            self.console.debug(msg)

    def create_tmp_dir(self):
        '''Creates a temp directory to transfer sosreports to'''
        tmpdir = tempfile.mkdtemp(prefix='sos-collector-', dir='/var/tmp')
        self.config['tmp_dir'] = tmpdir
        self.config['tmp_dir_created'] = True

    def list_options(self):
        '''Display options for available clusters'''
        print('\nThe following cluster options are available:\n')
        print('{:15} {:15} {:<10} {:10} {:<}'.format(
            'Cluster',
            'Option Name',
            'Type',
            'Default',
            'Description'
        ))

        for cluster in self.clusters:
            for opt in self.clusters[cluster].options:
                optln = '{:15} {:15} {:<10} {:<10} {:<10}'.format(
                    opt.cluster,
                    opt.name,
                    opt.opt_type.__name__,
                    str(opt.value),
                    opt.description
                )
                print(optln)
        print('\nOptions take the form of cluster.name=value'
              '\nE.G. ""ovirt.no-database=True"" or ""pacemaker.offline=False""')

    def delete_tmp_dir(self):
        '''Removes the temp directory and all collected sosreports'''
        shutil.rmtree(self.config['tmp_dir'])

    def _load_clusters(self):
        '''Load an instance of each cluster so that sos-collector can later
        determine what type of cluster is in use
        '''
        if 'soscollector' not in os.listdir(os.getcwd()):
            p = get_python_lib()
            path = p + '/soscollector/clusters/'
        else:
            path = 'soscollector/clusters'
        self.clusters = {}
        sys.path.insert(0, path)
        for f in sorted(os.listdir(path)):
            fname, ext = os.path.splitext(f)
            if ext == '.py' and fname not in ['__init__', 'cluster']:
                mods = inspect.getmembers(__import__(fname), inspect.isclass)
                for cluster in mods[1:]:
                    self.clusters[cluster[0]] = cluster[1](self.config)
        self.log_debug('Found cluster profiles: %s'
                       % list(self.clusters.keys()))
        sys.path.pop(0)

    def _get_archive_name(self):
        '''Generates a name for the tarball archive'''
        nstr = 'sos-collector'
        if self.config['label']:
            nstr += '-%s' % self.config['label']
        if self.config['case_id']:
            nstr += '-%s' % self.config['case_id']
        dt = datetime.strftime(datetime.now(), '%Y-%m-%d')

        try:
            string.lowercase = string.ascii_lowercase
        except NameError:
            pass

        rand = ''.join(random.choice(string.lowercase) for x in range(5))
        return '%s-%s-%s' % (nstr, dt, rand)

    def _get_archive_path(self):
        '''Returns the path, including filename, of the tarball we build
        that contains the collected sosreports
        '''
        self.arc_name = self._get_archive_name()
        compr = 'gz'
        return self.config['out_dir'] + self.arc_name + '.tar.' + compr

    def _fmt_msg(self, msg):
        width = 80
        _fmt = ''
        for line in msg.splitlines():
            _fmt = _fmt + fill(line, width, replace_whitespace=False) + '\n'
        return _fmt

    def prep(self):
        '''Based on configuration, performs setup for collection'''
        disclaimer = (""""""\
This utility is used to collect sosreports from multiple \
nodes simultaneously. It uses the python-paramiko library \
to manage the SSH connections to remote systems. If this \
library is not acceptable for use in your environment, \
you should not use this utility.

An archive of sosreport tarballs collected from the nodes will be \
generated in %s and may be provided to an appropriate support representative.

The generated archive may contain data considered sensitive \
and its content should be reviewed by the originating \
organization before being passed to any third party.

No configuration changes will be made to the system running \
this utility or remote systems that it connects to.
"""""")
        self.console.info(""\nsos-collector (version %s)\n"" % __version__)
        intro_msg = self._fmt_msg(disclaimer % self.config['tmp_dir'])
        self.console.info(intro_msg)
        prompt = ""\nPress ENTER to continue, or CTRL-C to quit\n""
        if not self.config['batch']:
            input(prompt)

        if not self.config['password']:
            self.log_debug('password not specified, assuming SSH keys')
            msg = ('sos-collector ASSUMES that SSH keys are installed on all '
                   'nodes unless the --password option is provided.\n')
            self.console.info(self._fmt_msg(msg))

        if self.config['password']:
            self.log_debug('password specified, not using SSH keys')
            msg = ('Provide the SSH password for user %s: '
                   % self.config['ssh_user'])
            self.config['password'] = getpass(prompt=msg)

        if self.config['need_sudo'] and not self.config['insecure_sudo']:
            if not self.config['password']:
                self.log_debug('non-root user specified, will request '
                               'sudo password')
                msg = ('A non-root user has been provided. Provide sudo '
                       'password for %s on remote nodes: '
                       % self.config['ssh_user'])
                self.config['sudo_pw'] = getpass(prompt=msg)
            else:
                if not self.config['insecure_sudo']:
                    self.config['sudo_pw'] = self.config['password']

        if self.config['become_root']:
            if not self.config['ssh_user'] == 'root':
                self.log_debug('non-root user asking to become root remotely')
                msg = ('User %s will attempt to become root. '
                       'Provide root password: ' % self.config['ssh_user'])
                self.config['root_password'] = getpass(prompt=msg)
                self.config['need_sudo'] = False
            else:
                self.log_info('Option to become root but ssh user is root.'
                              ' Ignoring request to change user on node')
                self.config['become_root'] = False

        if self.config['master']:
            self.connect_to_master()
            self.config['no_local'] = True
        else:
            self.master = SosNode('localhost', self.config)
        if self.config['cluster_type']:
            self.config['cluster'] = self.clusters[self.config['cluster_type']]
        else:
            self.determine_cluster()
        if self.config['cluster'] is None and not self.config['nodes']:
            msg = ('Cluster type could not be determined and no nodes provided'
                   '\nAborting...')
            self._exit(msg, 1)
        self.config['cluster'].setup()
        self.get_nodes()
        self.intro()
        self.configure_sos_cmd()

    def intro(self):
        '''Prints initial messages and collects user and case if not
        provided already.
        '''
        self.console.info('')

        if not self.node_list and not self.master.connected:
            self._exit('No nodes were detected, or nodes do not have sos '
                       'installed.\nAborting...')

        self.console.info('The following is a list of nodes to collect from:')
        if self.master.connected:
            self.console.info('\t%-*s' % (self.config['hostlen'],
                                          self.config['master']))

        for node in sorted(self.node_list):
            self.console.info(""\t%-*s"" % (self.config['hostlen'], node))

        self.console.info('')

        if not self.config['case_id'] and not self.config['batch']:
            msg = 'Please enter the case id you are collecting reports for: '
            self.config['case_id'] = input(msg)

    def configure_sos_cmd(self):
        '''Configures the sosreport command that is run on the nodes'''
        if self.config['sos_opt_line']:
            self.config['sos_cmd'] += self.config['sos_opt_line']
            self.log_debug(""User specified manual sosreport command line. ""
                           ""sos command set to %s"" % self.config['sos_cmd'])
            return True
        if self.config['case_id']:
            self.config['sos_cmd'] += ' --case-id=%s' % self.config['case_id']
        if self.config['alloptions']:
            self.config['sos_cmd'] += ' --alloptions'
        if self.config['verify']:
            self.config['sos_cmd'] += ' --verify'
        if self.config['log_size']:
            self.config['sos_cmd'] += (' --log-size=%s'
                                       % self.config['log_size'])
        if self.config['sysroot']:
            self.config['sos_cmd'] += ' -s %s' % self.config['sysroot']
        if self.config['chroot']:
            self.config['sos_cmd'] += ' -c %s' % self.config['chroot']
        if self.config['compression']:
            self.config['sos_cmd'] += ' -z %s' % self.config['compression']
        if self.config['cluster_type']:
            self.config['cluster'].modify_sos_cmd()
        self.log_debug('Initial sos cmd set to %s' % self.config['sos_cmd'])

    def connect_to_master(self):
        '''If run with --master, we will run cluster checks again that
        instead of the localhost.
        '''
        try:
            self.master = SosNode(self.config['master'], self.config)
        except Exception as e:
            self.log_debug('Failed to connect to master: %s' % e)
            self._exit('Could not connect to master node.\nAborting...', 1)

    def determine_cluster(self):
        '''This sets the cluster type and loads that cluster's cluster.

        If no cluster type is matched and no list of nodes is provided by
        the user, then we abort.

        If a list of nodes is given, this is not run, however the cluster
        can still be run if the user sets a --cluster-type manually
        '''

        for clus in self.clusters:
            self.clusters[clus].master = self.master
            if self.clusters[clus].check_enabled():
                self.config['cluster'] = self.clusters[clus]
                name = str(self.clusters[clus].__class__.__name__).lower()
                self.config['cluster_type'] = name
                self.log_info(
                    'Cluster type set to %s' % self.config['cluster_type'])
                break

    def get_nodes_from_cluster(self):
        '''Collects the list of nodes from the determined cluster cluster'''
        nodes = self.config['cluster']._get_nodes()
        self.log_debug('Node list: %s' % nodes)
        return nodes

    def reduce_node_list(self):
        '''Reduce duplicate entries of the localhost and/or master node
        if applicable'''
        if (self.config['hostname'] in self.node_list and
                self.config['no_local']):
            self.node_list.remove(self.config['hostname'])
        for i in self.config['ip_addrs']:
            if i in self.node_list:
                self.node_list.remove(i)
        # remove the master node from the list, since we already have
        # an open session to it.
        if self.config['master']:
            for n in self.node_list:
                if n == self.master.hostname or n == self.config['master']:
                    self.node_list.remove(n)
        self.node_list = list(set(n for n in self.node_list if n))
        self.log_debug('Node list reduced to %s' % self.node_list)

    def compare_node_to_regex(self, node):
        '''Compares a discovered node name to a provided list of nodes from
        the user. If there is not a match, the node is removed from the list'''
        for regex in self.config['nodes']:
            try:
                if re.match(regex, node):
                    return True
            except re.error as err:
                msg = 'Error comparing %s to provided node regex %s: %s'
                self.log_debug(msg % (node, regex, err))
        return False

    def get_nodes(self):
        ''' Sets the list of nodes to collect sosreports from '''
        if not self.config['master'] and not self.config['cluster']:
            msg = ('Could not determine a cluster type and no list of '
                   'nodes or master node was provided.\nAborting...'
                   )
            self._exit(msg)

        try:
            nodes = self.get_nodes_from_cluster()
            if self.config['nodes']:
                for node in nodes:
                    if self.compare_node_to_regex(node):
                        self.node_list.append(node)
            else:
                self.node_list = nodes
        except Exception as e:
            self.log_debug(""Error parsing node list: %s"" % e)
            self.log_debug('Setting node list to --nodes option')
            self.node_list = self.config['nodes']
            for node in self.node_list:
                if any(i in node for i in ('*', '\\', '?', '(', ')', '/')):
                    self.node_list.remove(node)

        # force add any non-regex node strings from nodes option
        if self.config['nodes']:
            for node in self.config['nodes']:
                if any(i in node for i in ('*', '\\', '?', '(', ')', '/')):
                    continue
                if node not in self.node_list:
                    self.log_debug(""Force adding %s to node list"" % node)
                    self.node_list.append(node)

        if not self.config['master']:
            host = self.config['hostname'].split('.')[0]
            # trust the local hostname before the node report from cluster
            for node in self.node_list:
                if host == node.split('.')[0]:
                    self.node_list.remove(node)
            self.node_list.append(self.config['hostname'])
        self.reduce_node_list()
        try:
            self.config['hostlen'] = len(max(self.node_list, key=len))
        except (TypeError, ValueError):
            self.config['hostlen'] = len(self.config['master'])

    def can_run_local_sos(self):
        '''Check if sosreport can be run as the current user, or if we need
        to invoke sudo'''
        if os.geteuid() != 0:
            self.log_debug('Not running as root. Need sudo for local sos')
            self.need_local_sudo = True
            msg = ('\nLocal sosreport requires root. Provide sudo password'
                   'or press ENTER to skip: ')
            self.local_sudopw = getpass(prompt=msg)
            self.console.info('\n')
            if not self.local_sudopw:
                self.logger.info('Will not collect local sos, no password')
                return False
        self.log_debug('Able to collect local sos')
        return True

    def _connect_to_node(self, node):
        '''Try to connect to the node, and if we can add to the client list to
        run sosreport on
        '''
        try:
            client = SosNode(node, self.config)
            if client.connected:
                self.client_list.append(client)
            else:
                client.close_ssh_session()
        except Exception:
            pass

    def collect(self):
        ''' For each node, start a collection thread and then tar all
        collected sosreports '''
        if self.master.connected:
            self.client_list.append(self.master)
        self.console.info(""\nConnecting to nodes..."")
        filters = [self.master.address, self.master.hostname]
        nodes = [n for n in self.node_list if n not in filters]

        try:
            pool = ThreadPoolExecutor(self.config['threads'])
            pool.map(self._connect_to_node, nodes, chunksize=1)
            pool.shutdown(wait=True)

            self.report_num = len(self.client_list)

            self.console.info(""\nBeginning collection of sosreports from %s ""
                              ""nodes, collecting a maximum of %s ""
                              ""concurrently\n""
                              % (len(self.client_list), self.config['threads'])
                              )

            pool = ThreadPoolExecutor(self.config['threads'])
            pool.map(self._collect, self.client_list, chunksize=1)
            pool.shutdown(wait=True)
        except KeyboardInterrupt:
            self.log_error('Exiting on user cancel\n')
            os._exit(130)

        if hasattr(self.config['cluster'], 'run_extra_cmd'):
            self.console.info('Collecting additional data from master node...')
            f = self.config['cluster'].run_extra_cmd()
            if f:
                self.master.collect_extra_cmd(f)
        msg = '\nSuccessfully captured %s of %s sosreports'
        self.log_info(msg % (self.retrieved, self.report_num))
        if self.retrieved > 0:
            self.create_cluster_archive()
        else:
            msg = 'No sosreports were collected, nothing to archive...'
            self._exit(msg, 1)
        self.close_all_connections()

    def _collect(self, client):
        '''Runs sosreport on each node'''
        if not client.local:
            client.sosreport()
        else:
            if not self.config['no_local']:
                client.sosreport()
        if client.retrieved:
            self.retrieved += 1

    def close_all_connections(self):
        '''Close all ssh sessions for nodes'''
        for client in self.client_list:
            self.log_debug('Closing SSH connection to %s' % client.address)
            client.close_ssh_session()

    def create_cluster_archive(self):
        '''Calls for creation of tar archive then cleans up the temporary
        files created by sos-collector'''
        self.log_info('Creating archive of sosreports...')
        self.create_sos_archive()
        if self.archive:
            self.logger.info('Archive created as %s' % self.archive)
            self.cleanup()
            self.console.info('\nThe following archive has been created. '
                              'Please provide it to your support team.')
            self.console.info('    %s' % self.archive)

    def create_sos_archive(self):
        '''Creates a tar archive containing all collected sosreports'''
        try:
            self.archive = self._get_archive_path()
            with tarfile.open(self.archive, ""w:gz"") as tar:
                for fname in os.listdir(self.config['tmp_dir']):
                    arcname = fname
                    if fname == self.logfile.name.split('/')[-1]:
                        arcname = 'sos-collector.log'
                    if fname == self.console_log_file.name.split('/')[-1]:
                        arcname = 'ui.log'
                    tar.add(os.path.join(self.config['tmp_dir'], fname),
                            arcname=self.arc_name + '/' + arcname)
                tar.close()
        except Exception as e:
            msg = 'Could not create archive: %s' % e
            self._exit(msg, 2)

    def cleanup(self):
        ''' Removes the tmp dir and all sosarchives therein.

            If tmp dir was supplied by user, only the sos archives within
            that dir are removed.
        '''
        if self.config['tmp_dir_created']:
            self.delete_tmp_dir()
        else:
            for f in os.listdir(self.config['tmp_dir']):
                if re.search('*sosreport-*tar*', f):
                    os.remove(os.path.join(self.config['tmp_dir'], f))
","# Copyright Red Hat 2017, Jake Hunsaker <jhunsake@redhat.com>
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

import fnmatch
import inspect
import logging
import os
import random
import re
import string
import tarfile
import threading
import tempfile
import shutil
import subprocess
import sys

from datetime import datetime
from concurrent.futures import ThreadPoolExecutor
from .sosnode import SosNode
from distutils.sysconfig import get_python_lib
from getpass import getpass
from six.moves import input
from textwrap import fill
from soscollector import __version__


class SosCollector():
    '''Main sos-collector class'''

    def __init__(self, config):
        os.umask(0077)
        self.config = config
        self.threads = []
        self.workers = []
        self.client_list = []
        self.node_list = []
        self.master = False
        self.retrieved = 0
        self.need_local_sudo = False
        if not self.config['list_options']:
            try:
                if not self.config['tmp_dir']:
                    self.create_tmp_dir()
                self._setup_logging()
                self.log_debug('Executing %s' % ' '.join(s for s in sys.argv))
                self._load_clusters()
                self._parse_options()
                self.prep()
            except KeyboardInterrupt:
                self._exit('Exiting on user cancel', 130)
        else:
            self._load_clusters()

    def _setup_logging(self):
        # behind the scenes logging
        self.logger = logging.getLogger('sos_collector')
        self.logger.setLevel(logging.DEBUG)
        self.logfile = tempfile.NamedTemporaryFile(
            mode=""w+"",
            dir=self.config['tmp_dir'])
        hndlr = logging.StreamHandler(self.logfile)
        hndlr.setFormatter(logging.Formatter(
            '%(asctime)s %(levelname)s: %(message)s'))
        hndlr.setLevel(logging.DEBUG)
        self.logger.addHandler(hndlr)

        console = logging.StreamHandler(sys.stderr)
        console.setFormatter(logging.Formatter('%(message)s'))

        # ui logging
        self.console = logging.getLogger('sos_collector_console')
        self.console.setLevel(logging.DEBUG)
        self.console_log_file = tempfile.NamedTemporaryFile(
            mode=""w+"",
            dir=self.config['tmp_dir'])
        chandler = logging.StreamHandler(self.console_log_file)
        cfmt = logging.Formatter('%(asctime)s %(levelname)s: %(message)s')
        chandler.setFormatter(cfmt)
        self.console.addHandler(chandler)

        # also print to console
        ui = logging.StreamHandler()
        fmt = logging.Formatter('%(message)s')
        ui.setFormatter(fmt)
        if self.config['verbose']:
            ui.setLevel(logging.DEBUG)
        else:
            ui.setLevel(logging.INFO)
        self.console.addHandler(ui)

    def _exit(self, msg, error=1):
        '''Used to safely terminate if sos-collector encounters an error'''
        self.log_error(msg)
        try:
            self.close_all_connections()
        except Exception:
            pass
        sys.exit(error)

    def _parse_options(self):
        '''If there are cluster options set on the CLI, override the defaults
        '''
        if self.config['cluster_options']:
            for opt in self.config['cluster_options']:
                match = False
                for option in self.clusters[opt.cluster].options:
                    if opt.name == option.name:
                        match = True
                        # override the default from CLI
                        option.value = self._validate_option(option, opt)
                if not match:
                    self._exit('Unknown option provided: %s.%s' % (
                        opt.cluster, opt.name
                    ))

    def _validate_option(self, default, cli):
        '''Checks to make sure that the option given on the CLI is valid.
        Valid in this sense means that the type of value given matches what a
        cluster profile expects (str for str, bool for bool, etc).

        For bool options, this will also convert the string equivalent to an
        actual boolean value
        '''
        if not default.opt_type == bool:
            if not default.opt_type == cli.opt_type:
                msg = ""Invalid option type for %s. Expected %s got %s""
                self._exit(msg % (cli.name, default.opt_type, cli.opt_type))
            return cli.value
        else:
            val = cli.value.lower()
            if val not in ['true', 'on', 'false', 'off']:
                msg = (""Invalid value for %s. Accepted values are: 'true', ""
                       ""'false', 'on', 'off'"")
                self._exit(msg % cli.name)
            else:
                if val in ['true', 'on']:
                    return True
                else:
                    return False

    def log_info(self, msg):
        '''Log info messages to both console and log file'''
        self.logger.info(msg)
        self.console.info(msg)

    def log_error(self, msg):
        '''Log error messages to both console and log file'''
        self.logger.error(msg)
        self.console.error(msg)

    def log_debug(self, msg):
        '''Log debug message to both console and log file'''
        caller = inspect.stack()[1][3]
        msg = '[sos_collector:%s] %s' % (caller, msg)
        self.logger.debug(msg)
        if self.config['verbose']:
            self.console.debug(msg)

    def create_tmp_dir(self):
        '''Creates a temp directory to transfer sosreports to'''
        tmpdir = tempfile.mkdtemp(prefix='sos-collector-', dir='/var/tmp')
        self.config['tmp_dir'] = tmpdir
        self.config['tmp_dir_created'] = True

    def list_options(self):
        '''Display options for available clusters'''
        print('\nThe following cluster options are available:\n')
        print('{:15} {:15} {:<10} {:10} {:<}'.format(
            'Cluster',
            'Option Name',
            'Type',
            'Default',
            'Description'
        ))

        for cluster in self.clusters:
            for opt in self.clusters[cluster].options:
                optln = '{:15} {:15} {:<10} {:<10} {:<10}'.format(
                    opt.cluster,
                    opt.name,
                    opt.opt_type.__name__,
                    str(opt.value),
                    opt.description
                )
                print(optln)
        print('\nOptions take the form of cluster.name=value'
              '\nE.G. ""ovirt.no-database=True"" or ""pacemaker.offline=False""')

    def delete_tmp_dir(self):
        '''Removes the temp directory and all collected sosreports'''
        shutil.rmtree(self.config['tmp_dir'])

    def _load_clusters(self):
        '''Load an instance of each cluster so that sos-collector can later
        determine what type of cluster is in use
        '''
        if 'soscollector' not in os.listdir(os.getcwd()):
            p = get_python_lib()
            path = p + '/soscollector/clusters/'
        else:
            path = 'soscollector/clusters'
        self.clusters = {}
        sys.path.insert(0, path)
        for f in sorted(os.listdir(path)):
            fname, ext = os.path.splitext(f)
            if ext == '.py' and fname not in ['__init__', 'cluster']:
                mods = inspect.getmembers(__import__(fname), inspect.isclass)
                for cluster in mods[1:]:
                    self.clusters[cluster[0]] = cluster[1](self.config)
        self.log_debug('Found cluster profiles: %s'
                       % list(self.clusters.keys()))
        sys.path.pop(0)

    def _get_archive_name(self):
        '''Generates a name for the tarball archive'''
        nstr = 'sos-collector'
        if self.config['label']:
            nstr += '-%s' % self.config['label']
        if self.config['case_id']:
            nstr += '-%s' % self.config['case_id']
        dt = datetime.strftime(datetime.now(), '%Y-%m-%d')

        try:
            string.lowercase = string.ascii_lowercase
        except NameError:
            pass

        rand = ''.join(random.choice(string.lowercase) for x in range(5))
        return '%s-%s-%s' % (nstr, dt, rand)

    def _get_archive_path(self):
        '''Returns the path, including filename, of the tarball we build
        that contains the collected sosreports
        '''
        self.arc_name = self._get_archive_name()
        compr = 'gz'
        return self.config['out_dir'] + self.arc_name + '.tar.' + compr

    def _fmt_msg(self, msg):
        width = 80
        _fmt = ''
        for line in msg.splitlines():
            _fmt = _fmt + fill(line, width, replace_whitespace=False) + '\n'
        return _fmt

    def prep(self):
        '''Based on configuration, performs setup for collection'''
        disclaimer = (""""""\
This utility is used to collect sosreports from multiple \
nodes simultaneously. It uses the python-paramiko library \
to manage the SSH connections to remote systems. If this \
library is not acceptable for use in your environment, \
you should not use this utility.

An archive of sosreport tarballs collected from the nodes will be \
generated in %s and may be provided to an appropriate support representative.

The generated archive may contain data considered sensitive \
and its content should be reviewed by the originating \
organization before being passed to any third party.

No configuration changes will be made to the system running \
this utility or remote systems that it connects to.
"""""")
        self.console.info(""\nsos-collector (version %s)\n"" % __version__)
        intro_msg = self._fmt_msg(disclaimer % self.config['tmp_dir'])
        self.console.info(intro_msg)
        prompt = ""\nPress ENTER to continue, or CTRL-C to quit\n""
        if not self.config['batch']:
            input(prompt)

        if not self.config['password']:
            self.log_debug('password not specified, assuming SSH keys')
            msg = ('sos-collector ASSUMES that SSH keys are installed on all '
                   'nodes unless the --password option is provided.\n')
            self.console.info(self._fmt_msg(msg))

        if self.config['password']:
            self.log_debug('password specified, not using SSH keys')
            msg = ('Provide the SSH password for user %s: '
                   % self.config['ssh_user'])
            self.config['password'] = getpass(prompt=msg)

        if self.config['need_sudo'] and not self.config['insecure_sudo']:
            if not self.config['password']:
                self.log_debug('non-root user specified, will request '
                               'sudo password')
                msg = ('A non-root user has been provided. Provide sudo '
                       'password for %s on remote nodes: '
                       % self.config['ssh_user'])
                self.config['sudo_pw'] = getpass(prompt=msg)
            else:
                if not self.config['insecure_sudo']:
                    self.config['sudo_pw'] = self.config['password']

        if self.config['become_root']:
            if not self.config['ssh_user'] == 'root':
                self.log_debug('non-root user asking to become root remotely')
                msg = ('User %s will attempt to become root. '
                       'Provide root password: ' % self.config['ssh_user'])
                self.config['root_password'] = getpass(prompt=msg)
                self.config['need_sudo'] = False
            else:
                self.log_info('Option to become root but ssh user is root.'
                              ' Ignoring request to change user on node')
                self.config['become_root'] = False

        if self.config['master']:
            self.connect_to_master()
            self.config['no_local'] = True
        else:
            self.master = SosNode('localhost', self.config)
        if self.config['cluster_type']:
            self.config['cluster'] = self.clusters[self.config['cluster_type']]
        else:
            self.determine_cluster()
        if self.config['cluster'] is None and not self.config['nodes']:
            msg = ('Cluster type could not be determined and no nodes provided'
                   '\nAborting...')
            self._exit(msg, 1)
        self.config['cluster'].setup()
        self.get_nodes()
        self.intro()
        self.configure_sos_cmd()

    def intro(self):
        '''Prints initial messages and collects user and case if not
        provided already.
        '''
        self.console.info('')

        if not self.node_list and not self.master.connected:
            self._exit('No nodes were detected, or nodes do not have sos '
                       'installed.\nAborting...')

        self.console.info('The following is a list of nodes to collect from:')
        if self.master.connected:
            self.console.info('\t%-*s' % (self.config['hostlen'],
                                          self.config['master']))

        for node in sorted(self.node_list):
            self.console.info(""\t%-*s"" % (self.config['hostlen'], node))

        self.console.info('')

        if not self.config['case_id'] and not self.config['batch']:
            msg = 'Please enter the case id you are collecting reports for: '
            self.config['case_id'] = input(msg)

    def configure_sos_cmd(self):
        '''Configures the sosreport command that is run on the nodes'''
        if self.config['sos_opt_line']:
            self.config['sos_cmd'] += self.config['sos_opt_line']
            self.log_debug(""User specified manual sosreport command line. ""
                           ""sos command set to %s"" % self.config['sos_cmd'])
            return True
        if self.config['case_id']:
            self.config['sos_cmd'] += ' --case-id=%s' % self.config['case_id']
        if self.config['alloptions']:
            self.config['sos_cmd'] += ' --alloptions'
        if self.config['verify']:
            self.config['sos_cmd'] += ' --verify'
        if self.config['log_size']:
            self.config['sos_cmd'] += (' --log-size=%s'
                                       % self.config['log_size'])
        if self.config['sysroot']:
            self.config['sos_cmd'] += ' -s %s' % self.config['sysroot']
        if self.config['chroot']:
            self.config['sos_cmd'] += ' -c %s' % self.config['chroot']
        if self.config['compression']:
            self.config['sos_cmd'] += ' -z %s' % self.config['compression']
        if self.config['cluster_type']:
            self.config['cluster'].modify_sos_cmd()
        self.log_debug('Initial sos cmd set to %s' % self.config['sos_cmd'])

    def connect_to_master(self):
        '''If run with --master, we will run cluster checks again that
        instead of the localhost.
        '''
        try:
            self.master = SosNode(self.config['master'], self.config)
        except Exception as e:
            self.log_debug('Failed to connect to master: %s' % e)
            self._exit('Could not connect to master node.\nAborting...', 1)

    def determine_cluster(self):
        '''This sets the cluster type and loads that cluster's cluster.

        If no cluster type is matched and no list of nodes is provided by
        the user, then we abort.

        If a list of nodes is given, this is not run, however the cluster
        can still be run if the user sets a --cluster-type manually
        '''

        for clus in self.clusters:
            self.clusters[clus].master = self.master
            if self.clusters[clus].check_enabled():
                self.config['cluster'] = self.clusters[clus]
                name = str(self.clusters[clus].__class__.__name__).lower()
                self.config['cluster_type'] = name
                self.log_info(
                    'Cluster type set to %s' % self.config['cluster_type'])
                break

    def get_nodes_from_cluster(self):
        '''Collects the list of nodes from the determined cluster cluster'''
        nodes = self.config['cluster']._get_nodes()
        self.log_debug('Node list: %s' % nodes)
        return nodes

    def reduce_node_list(self):
        '''Reduce duplicate entries of the localhost and/or master node
        if applicable'''
        if (self.config['hostname'] in self.node_list and
                self.config['no_local']):
            self.node_list.remove(self.config['hostname'])
        for i in self.config['ip_addrs']:
            if i in self.node_list:
                self.node_list.remove(i)
        # remove the master node from the list, since we already have
        # an open session to it.
        if self.config['master']:
            for n in self.node_list:
                if n == self.master.hostname or n == self.config['master']:
                    self.node_list.remove(n)
        self.node_list = list(set(n for n in self.node_list if n))
        self.log_debug('Node list reduced to %s' % self.node_list)

    def compare_node_to_regex(self, node):
        '''Compares a discovered node name to a provided list of nodes from
        the user. If there is not a match, the node is removed from the list'''
        for regex in self.config['nodes']:
            try:
                if re.match(regex, node):
                    return True
            except re.error as err:
                msg = 'Error comparing %s to provided node regex %s: %s'
                self.log_debug(msg % (node, regex, err))
        return False

    def get_nodes(self):
        ''' Sets the list of nodes to collect sosreports from '''
        if not self.config['master'] and not self.config['cluster']:
            msg = ('Could not determine a cluster type and no list of '
                   'nodes or master node was provided.\nAborting...'
                   )
            self._exit(msg)

        try:
            nodes = self.get_nodes_from_cluster()
            if self.config['nodes']:
                for node in nodes:
                    if self.compare_node_to_regex(node):
                        self.node_list.append(node)
            else:
                self.node_list = nodes
        except Exception as e:
            self.log_debug(""Error parsing node list: %s"" % e)
            self.log_debug('Setting node list to --nodes option')
            self.node_list = self.config['nodes']
            for node in self.node_list:
                if any(i in node for i in ('*', '\\', '?', '(', ')', '/')):
                    self.node_list.remove(node)

        # force add any non-regex node strings from nodes option
        if self.config['nodes']:
            for node in self.config['nodes']:
                if any(i in node for i in ('*', '\\', '?', '(', ')', '/')):
                    continue
                if node not in self.node_list:
                    self.log_debug(""Force adding %s to node list"" % node)
                    self.node_list.append(node)

        if not self.config['master']:
            host = self.config['hostname'].split('.')[0]
            # trust the local hostname before the node report from cluster
            for node in self.node_list:
                if host == node.split('.')[0]:
                    self.node_list.remove(node)
            self.node_list.append(self.config['hostname'])
        self.reduce_node_list()
        try:
            self.config['hostlen'] = len(max(self.node_list, key=len))
        except (TypeError, ValueError):
            self.config['hostlen'] = len(self.config['master'])

    def can_run_local_sos(self):
        '''Check if sosreport can be run as the current user, or if we need
        to invoke sudo'''
        if os.geteuid() != 0:
            self.log_debug('Not running as root. Need sudo for local sos')
            self.need_local_sudo = True
            msg = ('\nLocal sosreport requires root. Provide sudo password'
                   'or press ENTER to skip: ')
            self.local_sudopw = getpass(prompt=msg)
            self.console.info('\n')
            if not self.local_sudopw:
                self.logger.info('Will not collect local sos, no password')
                return False
        self.log_debug('Able to collect local sos')
        return True

    def _connect_to_node(self, node):
        '''Try to connect to the node, and if we can add to the client list to
        run sosreport on
        '''
        try:
            client = SosNode(node, self.config)
            if client.connected:
                self.client_list.append(client)
            else:
                client.close_ssh_session()
        except Exception:
            pass

    def collect(self):
        ''' For each node, start a collection thread and then tar all
        collected sosreports '''
        if self.master.connected:
            self.client_list.append(self.master)
        self.console.info(""\nConnecting to nodes..."")
        filters = [self.master.address, self.master.hostname]
        nodes = [n for n in self.node_list if n not in filters]

        try:
            pool = ThreadPoolExecutor(self.config['threads'])
            pool.map(self._connect_to_node, nodes, chunksize=1)
            pool.shutdown(wait=True)

            self.report_num = len(self.client_list)

            self.console.info(""\nBeginning collection of sosreports from %s ""
                              ""nodes, collecting a maximum of %s ""
                              ""concurrently\n""
                              % (len(self.client_list), self.config['threads'])
                              )

            pool = ThreadPoolExecutor(self.config['threads'])
            pool.map(self._collect, self.client_list, chunksize=1)
            pool.shutdown(wait=True)
        except KeyboardInterrupt:
            self.log_error('Exiting on user cancel\n')
            os._exit(130)

        if hasattr(self.config['cluster'], 'run_extra_cmd'):
            self.console.info('Collecting additional data from master node...')
            f = self.config['cluster'].run_extra_cmd()
            if f:
                self.master.collect_extra_cmd(f)
        msg = '\nSuccessfully captured %s of %s sosreports'
        self.log_info(msg % (self.retrieved, self.report_num))
        if self.retrieved > 0:
            self.create_cluster_archive()
        else:
            msg = 'No sosreports were collected, nothing to archive...'
            self._exit(msg, 1)
        self.close_all_connections()

    def _collect(self, client):
        '''Runs sosreport on each node'''
        if not client.local:
            client.sosreport()
        else:
            if not self.config['no_local']:
                client.sosreport()
        if client.retrieved:
            self.retrieved += 1

    def close_all_connections(self):
        '''Close all ssh sessions for nodes'''
        for client in self.client_list:
            self.log_debug('Closing SSH connection to %s' % client.address)
            client.close_ssh_session()

    def create_cluster_archive(self):
        '''Calls for creation of tar archive then cleans up the temporary
        files created by sos-collector'''
        self.log_info('Creating archive of sosreports...')
        self.create_sos_archive()
        if self.archive:
            self.logger.info('Archive created as %s' % self.archive)
            self.cleanup()
            self.console.info('\nThe following archive has been created. '
                              'Please provide it to your support team.')
            self.console.info('    %s' % self.archive)

    def create_sos_archive(self):
        '''Creates a tar archive containing all collected sosreports'''
        try:
            self.archive = self._get_archive_path()
            with tarfile.open(self.archive, ""w:gz"") as tar:
                for fname in os.listdir(self.config['tmp_dir']):
                    arcname = fname
                    if fname == self.logfile.name.split('/')[-1]:
                        arcname = 'sos-collector.log'
                    if fname == self.console_log_file.name.split('/')[-1]:
                        arcname = 'ui.log'
                    tar.add(os.path.join(self.config['tmp_dir'], fname),
                            arcname=self.arc_name + '/' + arcname)
                tar.close()
        except Exception as e:
            msg = 'Could not create archive: %s' % e
            self._exit(msg, 2)

    def cleanup(self):
        ''' Removes the tmp dir and all sosarchives therein.

            If tmp dir was supplied by user, only the sos archives within
            that dir are removed.
        '''
        if self.config['tmp_dir_created']:
            self.delete_tmp_dir()
        else:
            for f in os.listdir(self.config['tmp_dir']):
                if re.search('*sosreport-*tar*', f):
                    os.remove(os.path.join(self.config['tmp_dir'], f))
"
"# (from BackInTime)
# Copyright (C) 2015-2017 Germar Reitze
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

# (from jockey)
# (c) 2008 Canonical Ltd.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

# (from python-dbus-docs)
# Copyright (C) 2004-2006 Red Hat Inc. <http://www.redhat.com/>
# Copyright (C) 2005-2007 Collabora Ltd. <http://www.collabora.co.uk/>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation
# files (the ""Software""), to deal in the Software without
# restriction, including without limitation the rights to use, copy,
# modify, merge, publish, distribute, sublicense, and/or sell copies
# of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
#
# This file was modified by David D. Lowe in 2009.
# To the extent possible under law, David D. Lowe has waived all
# copyright and related or neighboring rights to his modifications to
# this file under this license: http://creativecommons.org/publicdomain/zero/1.0/

import os
import re
from subprocess import Popen, PIPE
try:
    import pwd
except ImportError:
    pwd = None

import dbus
import dbus.service
import dbus.mainloop.pyqt5
from PyQt5.QtCore import QCoreApplication

UDEV_RULES_PATH = '/etc/udev/rules.d/99-backintime-%s.rules'

class InvalidChar(dbus.DBusException):
    _dbus_error_name = 'net.launchpad.backintime.InvalidChar'

class InvalidCmd(dbus.DBusException):
    _dbus_error_name = 'net.launchpad.backintime.InvalidCmd'

class LimitExceeded(dbus.DBusException):
    _dbus_error_name = 'net.launchpad.backintime.LimitExceeded'

class PermissionDeniedByPolicy(dbus.DBusException):
    _dbus_error_name = 'com.ubuntu.DeviceDriver.PermissionDeniedByPolicy'

class UdevRules(dbus.service.Object):
    def __init__(self, conn=None, object_path=None, bus_name=None):
        super(UdevRules, self).__init__(conn, object_path, bus_name)

        # the following variables are used by _checkPolkitPrivilege
        self.polkit = None
        self.enforce_polkit = True

        self.tmpDict = {}

        #find su path
        self.su = self._which('su', '/bin/su')
        self.backintime = self._which('backintime', '/usr/bin/backintime')
        self.nice = self._which('nice', '/usr/bin/nice')
        self.ionice = self._which('ionice', '/usr/bin/ionice')
        self.max_rules = 100
        self.max_users = 20
        self.max_cmd_len = 100

    def _which(self, exe, fallback):
        proc = Popen(['which', exe], stdout = PIPE)
        ret = proc.communicate()[0].strip().decode()
        if proc.returncode or not ret:
            return fallback

        return ret

    def _validateCmd(self, cmd):

        if cmd.find(""&&"") != -1:
            raise InvalidCmd(""Parameter 'cmd' contains '&&' concatenation"")
        # make sure it starts with an absolute path
        elif not cmd.startswith(os.path.sep):
            raise InvalidCmd(""Parameter 'cmd' does not start with '/'"")

        parts = cmd.split()

        # make sure only well known commands and switches are used
        whitelist = (
            (self.nice, (""-n"")),
            (self.ionice, (""-c"", ""-n"")),
        )

        for c, switches in whitelist:
            if parts and parts[0] == c:
                parts.pop(0)
                for sw in switches:
                    while parts and parts[0].startswith(sw):
                        parts.pop(0)

        if not parts:
            raise InvalidCmd(""Parameter 'cmd' does not contain the backintime command"")
        elif parts[0] != self.backintime:
            raise InvalidCmd(""Parameter 'cmd' contains non-whitelisted cmd/parameter (%s)"" % parts[0])

    def _checkLimits(self, owner, cmd):

        if len(self.tmpDict.get(owner, [])) >= self.max_rules:
            raise LimitExceeded(""Maximum number of cached rules reached (%d)""
                            % self.max_rules)
        elif len(self.tmpDict) >= self.max_users:
            raise LimitExceeded(""Maximum number of cached users reached (%d)""
                            % self.max_users)
        elif len(cmd) > self.max_cmd_len:
            raise LimitExceeded(""Maximum length of command line reached (%d)""
                            % self.max_cmd_len)

    @dbus.service.method(""net.launchpad.backintime.serviceHelper.UdevRules"",
                         in_signature='ss', out_signature='',
                         sender_keyword='sender', connection_keyword='conn')
    def addRule(self, cmd, uuid, sender=None, conn=None):
        """"""
        Receive command and uuid and create an Udev rule out of this.
        This is done on the service side to prevent malicious code to
        run as root.
        """"""
        #prevent breaking out of su command
        chars = re.findall(r'[^a-zA-Z0-9-/\.>& ]', cmd)
        if chars:
            raise InvalidChar(""Parameter 'cmd' contains invalid character(s) %s""
                              % '|'.join(set(chars)))
        #only allow relevant chars in uuid
        chars = re.findall(r'[^a-zA-Z0-9-]', uuid)
        if chars:
            raise InvalidChar(""Parameter 'uuid' contains invalid character(s) %s""
                              % '|'.join(set(chars)))

        self._validateCmd(cmd)

        info = SenderInfo(sender, conn)
        user = info.connectionUnixUser()
        owner = info.nameOwner()

        self._checkLimits(owner, cmd)

        #create su command
        sucmd = ""%s - '%s' -c '%s'"" %(self.su, user, cmd)
        #create Udev rule
        rule = 'ACTION==""add|change"", ENV{ID_FS_UUID}==""%s"", RUN+=""%s""\n' %(uuid, sucmd)

        #store rule
        if not owner in self.tmpDict:
            self.tmpDict[owner] = []
        self.tmpDict[owner].append(rule)

    @dbus.service.method(""net.launchpad.backintime.serviceHelper.UdevRules"",
                         in_signature='', out_signature='b',
                         sender_keyword='sender', connection_keyword='conn')
    def save(self, sender=None, conn=None):
        """"""
        Save rules to destiantion file after user authenticated as admin.
        This will first check if there are any changes between
        temporary added rules and current rules in destiantion file.
        Returns False if files are identical or no rules to be installed.
        """"""
        info = SenderInfo(sender, conn)
        user = info.connectionUnixUser()
        owner = info.nameOwner()

        #delete rule if no rules in tmp
        if not owner in self.tmpDict or not self.tmpDict[owner]:
            self.delete(sender, conn)
            return False
        #return False if rule already exist.
        if os.path.exists(UDEV_RULES_PATH % user):
            with open(UDEV_RULES_PATH % user, 'r') as f:
                if self.tmpDict[owner] == f.readlines():
                    self._clean(owner)
                    return False
        #auth to save changes
        self._checkPolkitPrivilege(sender, conn, 'net.launchpad.backintime.UdevRuleSave')
        with open(UDEV_RULES_PATH % user, 'w') as f:
            f.writelines(self.tmpDict[owner])
        self._clean(owner)
        return True

    @dbus.service.method(""net.launchpad.backintime.serviceHelper.UdevRules"",
                         in_signature='', out_signature='',
                         sender_keyword='sender', connection_keyword='conn')
    def delete(self, sender=None, conn=None):
        """"""
        Delete existing Udev rule
        """"""
        info = SenderInfo(sender, conn)
        user = info.connectionUnixUser()
        owner = info.nameOwner()
        self._clean(owner)
        if os.path.exists(UDEV_RULES_PATH % user):
            #auth to delete rule
            self._checkPolkitPrivilege(sender, conn, 'net.launchpad.backintime.UdevRuleDelete')
            os.remove(UDEV_RULES_PATH % user)

    @dbus.service.method(""net.launchpad.backintime.serviceHelper.UdevRules"",
                         in_signature='', out_signature='',
                         sender_keyword='sender', connection_keyword='conn')
    def clean(self, sender=None, conn=None):
        """"""
        clean up previous cached rules
        """"""
        info = SenderInfo(sender, conn)
        self._clean(info.nameOwner())

    def _clean(self, owner):
        if owner in self.tmpDict:
            del self.tmpDict[owner]

    def _initPolkit(self):
        if self.polkit is None:
            self.polkit = dbus.Interface(dbus.SystemBus().get_object(
                'org.freedesktop.PolicyKit1',
                '/org/freedesktop/PolicyKit1/Authority', False),
                'org.freedesktop.PolicyKit1.Authority')

    def _checkPolkitPrivilege(self, sender, conn, privilege):
        # from jockey
        """"""
        Verify that sender has a given PolicyKit privilege.

        sender is the sender's (private) D-BUS name, such as "":1:42""
        (sender_keyword in @dbus.service.methods). conn is
        the dbus.Connection object (connection_keyword in
        @dbus.service.methods). privilege is the PolicyKit privilege string.

        This method returns if the caller is privileged, and otherwise throws a
        PermissionDeniedByPolicy exception.
        """"""
        if sender is None and conn is None:
            # called locally, not through D-BUS
            return
        if not self.enforce_polkit:
            # that happens for testing purposes when running on the session
            # bus, and it does not make sense to restrict operations here
            return

        info = SenderInfo(sender, conn)

        # get peer PID
        pid = info.connectionPid()

        # query PolicyKit
        self._initPolkit()
        try:
            # we don't need is_challenge return here, since we call with AllowUserInteraction
            (is_auth, _, details) = self.polkit.CheckAuthorization(
                    ('unix-process', {'pid': dbus.UInt32(pid, variant_level=1),
                    'start-time': dbus.UInt64(0, variant_level=1)}),
                    privilege, {'': ''}, dbus.UInt32(1), '', timeout=3000)
        except dbus.DBusException as e:
            if e._dbus_error_name == 'org.freedesktop.DBus.Error.ServiceUnknown':
                # polkitd timed out, connect again
                self.polkit = None
                return self._checkPolkitPrivilege(sender, conn, privilege)
            else:
                raise

        if not is_auth:
            raise PermissionDeniedByPolicy(privilege)

class SenderInfo(object):
    def __init__(self, sender, conn):
        self.sender = sender
        self.dbus_info = dbus.Interface(conn.get_object('org.freedesktop.DBus',
                '/org/freedesktop/DBus/Bus', False), 'org.freedesktop.DBus')

    def connectionUnixUser(self):
        uid = self.dbus_info.GetConnectionUnixUser(self.sender)
        if pwd:
            return pwd.getpwuid(uid).pw_name
        else:
            return uid

    def nameOwner(self):
        return self.dbus_info.GetNameOwner(self.sender)

    def connectionPid(self):
        return self.dbus_info.GetConnectionUnixProcessID(self.sender)

if __name__ == '__main__':
    dbus.mainloop.pyqt5.DBusQtMainLoop(set_as_default=True)

    app = QCoreApplication([])

    bus = dbus.SystemBus()
    name = dbus.service.BusName(""net.launchpad.backintime.serviceHelper"", bus)
    object = UdevRules(bus, '/UdevRules')

    print(""Running BIT service."")
    app.exec_()
","# (from BackInTime)
# Copyright (C) 2015-2017 Germar Reitze
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

# (from jockey)
# (c) 2008 Canonical Ltd.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

# (from python-dbus-docs)
# Copyright (C) 2004-2006 Red Hat Inc. <http://www.redhat.com/>
# Copyright (C) 2005-2007 Collabora Ltd. <http://www.collabora.co.uk/>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation
# files (the ""Software""), to deal in the Software without
# restriction, including without limitation the rights to use, copy,
# modify, merge, publish, distribute, sublicense, and/or sell copies
# of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
#
# This file was modified by David D. Lowe in 2009.
# To the extent possible under law, David D. Lowe has waived all
# copyright and related or neighboring rights to his modifications to
# this file under this license: http://creativecommons.org/publicdomain/zero/1.0/

import os
import re
from subprocess import Popen, PIPE
try:
    import pwd
except ImportError:
    pwd = None

import dbus
import dbus.service
import dbus.mainloop.pyqt5
from PyQt5.QtCore import QCoreApplication

UDEV_RULES_PATH = '/etc/udev/rules.d/99-backintime-%s.rules'

class InvalidChar(dbus.DBusException):
    _dbus_error_name = 'net.launchpad.backintime.InvalidChar'

class InvalidCmd(dbus.DBusException):
    _dbus_error_name = 'net.launchpad.backintime.InvalidCmd'

class LimitExceeded(dbus.DBusException):
    _dbus_error_name = 'net.launchpad.backintime.LimitExceeded'

class PermissionDeniedByPolicy(dbus.DBusException):
    _dbus_error_name = 'com.ubuntu.DeviceDriver.PermissionDeniedByPolicy'

class UdevRules(dbus.service.Object):
    def __init__(self, conn=None, object_path=None, bus_name=None):
        super(UdevRules, self).__init__(conn, object_path, bus_name)

        # the following variables are used by _checkPolkitPrivilege
        self.polkit = None
        self.enforce_polkit = True

        self.tmpDict = {}

        #find su path
        self.su = self._which('su', '/bin/su')
        self.backintime = self._which('backintime', '/usr/bin/backintime')
        self.nice = self._which('nice', '/usr/bin/nice')
        self.ionice = self._which('ionice', '/usr/bin/ionice')
        self.max_rules = 100
        self.max_users = 20
        self.max_cmd_len = 100

    def _which(self, exe, fallback):
        proc = Popen(['which', exe], stdout = PIPE)
        ret = proc.communicate()[0].strip().decode()
        if proc.returncode or not ret:
            return fallback

        return ret

    def _validateCmd(self, cmd):

        if cmd.find(""&&"") != -1:
            raise InvalidCmd(""Parameter 'cmd' contains '&&' concatenation"")
        # make sure it starts with an absolute path
        elif not cmd.startswith(os.path.sep):
            raise InvalidCmd(""Parameter 'cmd' does not start with '/'"")

        parts = cmd.split()

        # make sure only well known commands and switches are used
        whitelist = (
            (self.nice, (""-n"")),
            (self.ionice, (""-c"", ""-n"")),
        )

        for c, switches in whitelist:
            if parts and parts[0] == c:
                parts.pop(0)
                for sw in switches:
                    while parts and parts[0].startswith(sw):
                        parts.pop(0)

        if not parts:
            raise InvalidCmd(""Parameter 'cmd' does not contain the backintime command"")
        elif parts[0] != self.backintime:
            raise InvalidCmd(""Parameter 'cmd' contains non-whitelisted cmd/parameter (%s)"" % parts[0])

    def _checkLimits(self, owner, cmd):

        if len(self.tmpDict.get(owner, [])) >= self.max_rules:
            raise LimitExceeded(""Maximum number of cached rules reached (%d)""
                            % self.max_rules)
        elif len(self.tmpDict) >= self.max_users:
            raise LimitExceeded(""Maximum number of cached users reached (%d)""
                            % self.max_users)
        elif len(cmd) > self.max_cmd_len:
            raise LimitExceeded(""Maximum length of command line reached (%d)""
                            % self.max_cmd_len)

    @dbus.service.method(""net.launchpad.backintime.serviceHelper.UdevRules"",
                         in_signature='ss', out_signature='',
                         sender_keyword='sender', connection_keyword='conn')
    def addRule(self, cmd, uuid, sender=None, conn=None):
        """"""
        Receive command and uuid and create an Udev rule out of this.
        This is done on the service side to prevent malicious code to
        run as root.
        """"""
        #prevent breaking out of su command
        chars = re.findall(r'[^a-zA-Z0-9-/\.>& ]', cmd)
        if chars:
            raise InvalidChar(""Parameter 'cmd' contains invalid character(s) %s""
                              % '|'.join(set(chars)))
        #only allow relevant chars in uuid
        chars = re.findall(r'[^a-zA-Z0-9-]', uuid)
        if chars:
            raise InvalidChar(""Parameter 'uuid' contains invalid character(s) %s""
                              % '|'.join(set(chars)))

        self._validateCmd(cmd)

        info = SenderInfo(sender, conn)
        user = info.connectionUnixUser()
        owner = info.nameOwner()

        self._checkLimits(owner, cmd)

        #create su command
        sucmd = ""%s - '%s' -c '%s'"" %(self.su, user, cmd)
        #create Udev rule
        rule = 'ACTION==""add|change"", ENV{ID_FS_UUID}==""%s"", RUN+=""%s""\n' %(uuid, sucmd)

        #store rule
        if not owner in self.tmpDict:
            self.tmpDict[owner] = []
        self.tmpDict[owner].append(rule)

    @dbus.service.method(""net.launchpad.backintime.serviceHelper.UdevRules"",
                         in_signature='', out_signature='b',
                         sender_keyword='sender', connection_keyword='conn')
    def save(self, sender=None, conn=None):
        """"""
        Save rules to destiantion file after user authenticated as admin.
        This will first check if there are any changes between
        temporary added rules and current rules in destiantion file.
        Returns False if files are identical or no rules to be installed.
        """"""
        info = SenderInfo(sender, conn)
        user = info.connectionUnixUser()
        owner = info.nameOwner()

        #delete rule if no rules in tmp
        if not owner in self.tmpDict or not self.tmpDict[owner]:
            self.delete(sender, conn)
            return False
        #return False if rule already exist.
        if os.path.exists(UDEV_RULES_PATH % user):
            with open(UDEV_RULES_PATH % user, 'r') as f:
                if self.tmpDict[owner] == f.readlines():
                    self._clean(owner)
                    return False
        #auth to save changes
        self._checkPolkitPrivilege(sender, conn, 'net.launchpad.backintime.UdevRuleSave')
        with open(UDEV_RULES_PATH % user, 'w') as f:
            f.writelines(self.tmpDict[owner])
        self._clean(owner)
        return True

    @dbus.service.method(""net.launchpad.backintime.serviceHelper.UdevRules"",
                         in_signature='', out_signature='',
                         sender_keyword='sender', connection_keyword='conn')
    def delete(self, sender=None, conn=None):
        """"""
        Delete existing Udev rule
        """"""
        info = SenderInfo(sender, conn)
        user = info.connectionUnixUser()
        owner = info.nameOwner()
        self._clean(owner)
        if os.path.exists(UDEV_RULES_PATH % user):
            #auth to delete rule
            self._checkPolkitPrivilege(sender, conn, 'net.launchpad.backintime.UdevRuleDelete')
            os.remove(UDEV_RULES_PATH % user)

    @dbus.service.method(""net.launchpad.backintime.serviceHelper.UdevRules"",
                         in_signature='', out_signature='',
                         sender_keyword='sender', connection_keyword='conn')
    def clean(self, sender=None, conn=None):
        """"""
        clean up previous cached rules
        """"""
        info = SenderInfo(sender, conn)
        self._clean(info.nameOwner())

    def _clean(self, owner):
        if owner in self.tmpDict:
            del self.tmpDict[owner]

    def _initPolkit(self):
        if self.polkit is None:
            self.polkit = dbus.Interface(dbus.SystemBus().get_object(
                'org.freedesktop.PolicyKit1',
                '/org/freedesktop/PolicyKit1/Authority', False),
                'org.freedesktop.PolicyKit1.Authority')

    def _checkPolkitPrivilege(self, sender, conn, privilege):
        # from jockey
        """"""
        Verify that sender has a given PolicyKit privilege.

        sender is the sender's (private) D-BUS name, such as "":1:42""
        (sender_keyword in @dbus.service.methods). conn is
        the dbus.Connection object (connection_keyword in
        @dbus.service.methods). privilege is the PolicyKit privilege string.

        This method returns if the caller is privileged, and otherwise throws a
        PermissionDeniedByPolicy exception.
        """"""
        if sender is None and conn is None:
            # called locally, not through D-BUS
            return
        if not self.enforce_polkit:
            # that happens for testing purposes when running on the session
            # bus, and it does not make sense to restrict operations here
            return

        # query PolicyKit
        self._initPolkit()
        try:
            # we don't need is_challenge return here, since we call with AllowUserInteraction
            (is_auth, _, details) = self.polkit.CheckAuthorization(
                    ('system-bus-name', {'name': dbus.String(sender, variant_level=1)}),
                    privilege, {'': ''}, dbus.UInt32(1), '', timeout=3000)
        except dbus.DBusException as e:
            if e._dbus_error_name == 'org.freedesktop.DBus.Error.ServiceUnknown':
                # polkitd timed out, connect again
                self.polkit = None
                return self._checkPolkitPrivilege(sender, conn, privilege)
            else:
                raise

        if not is_auth:
            raise PermissionDeniedByPolicy(privilege)

class SenderInfo(object):
    def __init__(self, sender, conn):
        self.sender = sender
        self.dbus_info = dbus.Interface(conn.get_object('org.freedesktop.DBus',
                '/org/freedesktop/DBus/Bus', False), 'org.freedesktop.DBus')

    def connectionUnixUser(self):
        uid = self.dbus_info.GetConnectionUnixUser(self.sender)
        if pwd:
            return pwd.getpwuid(uid).pw_name
        else:
            return uid

    def nameOwner(self):
        return self.dbus_info.GetNameOwner(self.sender)

    def connectionPid(self):
        return self.dbus_info.GetConnectionUnixProcessID(self.sender)

if __name__ == '__main__':
    dbus.mainloop.pyqt5.DBusQtMainLoop(set_as_default=True)

    app = QCoreApplication([])

    bus = dbus.SystemBus()
    name = dbus.service.BusName(""net.launchpad.backintime.serviceHelper"", bus)
    object = UdevRules(bus, '/UdevRules')

    print(""Running BIT service."")
    app.exec_()
"
"import copy
import datetime
from functools import partial
import json
import threading
import sys
import traceback
import math

from PyQt5.QtCore import *
from PyQt5.QtGui import *
from PyQt5.QtWidgets import *

from electroncash.address import Address, PublicKey
from electroncash.bitcoin import base_encode, TYPE_ADDRESS
from electroncash.i18n import _
from electroncash.plugins import run_hook

from .util import *

from electroncash.util import bfh, format_satoshis_nofloat, format_satoshis_plain_nofloat, NotEnoughFunds, ExcessiveFee, PrintError, finalization_print_error
from electroncash.transaction import Transaction
from electroncash.slp import SlpMessage, SlpNoMintingBatonFound, SlpUnsupportedSlpTokenType, SlpInvalidOutputMessage, buildMintOpReturnOutput_V1

from .amountedit import SLPAmountEdit
from .transaction_dialog import show_transaction

from electroncash import networks

dialogs = []  # Otherwise python randomly garbage collects the dialogs...

class SlpCreateTokenMintDialog(QDialog, MessageBoxMixin, PrintError):

    def __init__(self, main_window, token_id_hex):
        # We want to be a top-level window
        QDialog.__init__(self, parent=None)
        from .main_window import ElectrumWindow

        assert isinstance(main_window, ElectrumWindow)
        main_window._slp_dialogs.add(self)
        finalization_print_error(self)  # Track object lifecycle

        self.main_window = main_window
        self.wallet = main_window.wallet
        self.network = main_window.network
        self.app = main_window.app

        if self.main_window.gui_object.warn_if_no_network(self.main_window):
            return

        self.setWindowTitle(_(""Mint Additional Tokens""))

        vbox = QVBoxLayout()
        self.setLayout(vbox)

        grid = QGridLayout()
        grid.setColumnStretch(1, 1)
        vbox.addLayout(grid)
        row = 0

        msg = _('Unique identifier for the token.')
        grid.addWidget(HelpLabel(_('Token ID:'), msg), row, 0)

        self.token_id_e = QLineEdit()
        self.token_id_e.setFixedWidth(490)
        self.token_id_e.setText(token_id_hex)
        self.token_id_e.setDisabled(True)
        grid.addWidget(self.token_id_e, row, 1)
        row += 1

        msg = _('The number of decimal places used in the token quantity.')
        grid.addWidget(HelpLabel(_('Decimals:'), msg), row, 0)
        self.token_dec = QDoubleSpinBox()
        decimals = self.main_window.wallet.token_types.get(token_id_hex)['decimals']
        self.token_dec.setRange(0, 9)
        self.token_dec.setValue(decimals)
        self.token_dec.setDecimals(0)
        self.token_dec.setFixedWidth(50)
        self.token_dec.setDisabled(True)
        grid.addWidget(self.token_dec, row, 1)
        row += 1

        msg = _('The number of tokens created during token minting transaction, send to the receiver address provided below.')
        grid.addWidget(HelpLabel(_('Additional Token Quantity:'), msg), row, 0)
        name = self.main_window.wallet.token_types.get(token_id_hex)['name']
        self.token_qty_e = SLPAmountEdit(name, int(decimals))
        self.token_qty_e.setFixedWidth(200)
        self.token_qty_e.textChanged.connect(self.check_token_qty)
        grid.addWidget(self.token_qty_e, row, 1)
        row += 1

        msg = _('The simpleledger formatted bitcoin address for the genesis receiver of all genesis tokens.')
        grid.addWidget(HelpLabel(_('Token Receiver Address:'), msg), row, 0)
        self.token_pay_to_e = ButtonsLineEdit()
        self.token_pay_to_e.setFixedWidth(490)
        grid.addWidget(self.token_pay_to_e, row, 1)
        row += 1

        msg = _('The simpleledger formatted bitcoin address for the genesis baton receiver.')
        self.token_baton_label = HelpLabel(_('Mint Baton Address:'), msg)
        grid.addWidget(self.token_baton_label, row, 0)
        self.token_baton_to_e = ButtonsLineEdit()
        self.token_baton_to_e.setFixedWidth(490)
        grid.addWidget(self.token_baton_to_e, row, 1)
        row += 1

        try:
            slpAddr = self.wallet.get_unused_address().to_slpaddr()
            self.token_pay_to_e.setText(Address.prefix_from_address_string(slpAddr) + "":"" + slpAddr)
            self.token_baton_to_e.setText(Address.prefix_from_address_string(slpAddr) + "":"" + slpAddr)
        except Exception as e:
            pass

        self.token_fixed_supply_cb = cb = QCheckBox(_('Permanently end issuance'))
        self.token_fixed_supply_cb.setChecked(False)
        grid.addWidget(self.token_fixed_supply_cb, row, 0)
        cb.clicked.connect(self.show_mint_baton_address)
        row += 1

        hbox = QHBoxLayout()
        vbox.addLayout(hbox)

        self.cancel_button = b = QPushButton(_(""Cancel""))
        self.cancel_button.setAutoDefault(False)
        self.cancel_button.setDefault(False)
        b.clicked.connect(self.close)
        b.setDefault(True)
        hbox.addWidget(self.cancel_button)

        hbox.addStretch(1)

        self.preview_button = EnterButton(_(""Preview""), self.do_preview)
        self.mint_button = b = QPushButton(_(""Create Additional Tokens""))
        b.clicked.connect(self.mint_token)
        self.mint_button.setAutoDefault(True)
        self.mint_button.setDefault(True)
        hbox.addWidget(self.preview_button)
        hbox.addWidget(self.mint_button)

        dialogs.append(self)
        self.show()
        self.token_qty_e.setFocus()

    def do_preview(self):
        self.mint_token(preview = True)

    def show_mint_baton_address(self):
        self.token_baton_to_e.setHidden(self.token_fixed_supply_cb.isChecked())
        self.token_baton_label.setHidden(self.token_fixed_supply_cb.isChecked())

    def parse_address(self, address):
        if networks.net.SLPADDR_PREFIX not in address:
            address = networks.net.SLPADDR_PREFIX + "":"" + address
        return Address.from_string(address)

    def mint_token(self, preview=False):
        decimals = int(self.token_dec.value())
        mint_baton_vout = 2 if self.token_baton_to_e.text() != '' and not self.token_fixed_supply_cb.isChecked() else None
        init_mint_qty = self.token_qty_e.get_amount()
        if init_mint_qty is None:
            self.show_message(_(""Invalid token quantity entered.""))
            return
        if init_mint_qty > (2 ** 64) - 1:
            maxqty = format_satoshis_plain_nofloat((2 ** 64) - 1, decimals)
            self.show_message(_(""Token output quantity is too large. Maximum %s."")%(maxqty,))
            return

        outputs = []
        try:
            token_id_hex = self.token_id_e.text()
            token_type = self.wallet.token_types[token_id_hex]['class']
            slp_op_return_msg = buildMintOpReturnOutput_V1(token_id_hex, mint_baton_vout, init_mint_qty, token_type)
            outputs.append(slp_op_return_msg)
        except OPReturnTooLarge:
            self.show_message(_(""Optional string text causiing OP_RETURN greater than 223 bytes.""))
            return
        except Exception as e:
            traceback.print_exc(file=sys.stdout)
            self.show_message(str(e))
            return

        try:
            addr = self.parse_address(self.token_pay_to_e.text())
            outputs.append((TYPE_ADDRESS, addr, 546))
        except:
            self.show_message(_(""Enter a Mint Receiver Address in SLP address format.""))
            return

        if not self.token_fixed_supply_cb.isChecked():
            try:
                addr = self.parse_address(self.token_baton_to_e.text())
                outputs.append((TYPE_ADDRESS, addr, 546))
            except:
                self.show_message(_(""Enter a Baton Address in SLP address format.""))
                return

        # IMPORTANT: set wallet.sedn_slpTokenId to None to guard tokens during this transaction
        self.main_window.token_type_combo.setCurrentIndex(0)
        assert self.main_window.slp_token_id == None

        coins = self.main_window.get_coins()
        fee = None

        try:
            baton_input = self.main_window.wallet.get_slp_token_baton(self.token_id_e.text())
        except SlpNoMintingBatonFound as e:
            self.show_message(_(""No baton exists for this token.""))
            return

        desired_fee_rate = 1.0  # sats/B, just init this value for paranoia
        try:
            tx = self.main_window.wallet.make_unsigned_transaction(coins, outputs, self.main_window.config, fee, None)
            desired_fee_rate = tx.get_fee() / tx.estimated_size()  # remember the fee coin chooser & wallet gave us as a fee rate so we may use it below after adding baton to adjust fee downward to this rate.
        except NotEnoughFunds:
            self.show_message(_(""Insufficient funds""))
            return
        except ExcessiveFee:
            self.show_message(_(""Your fee is too high.  Max is 50 sat/byte.""))
            return
        except BaseException as e:
            traceback.print_exc(file=sys.stdout)
            self.show_message(str(e))
            return

        # Find & Add baton to tx inputs
        try:
            baton_utxo = self.main_window.wallet.get_slp_token_baton(self.token_id_e.text())
        except SlpNoMintingBatonFound:
            self.show_message(_(""There is no minting baton found for this token.""))
            return

        tx.add_inputs([baton_utxo])
        for txin in tx._inputs:
            self.main_window.wallet.add_input_info(txin)

        def tx_adjust_change_amount_based_on_baton_amount(tx, desired_fee_rate):
            ''' adjust change amount (based on amount added from baton) '''
            if len(tx._outputs) not in (3,4):
                # no change, or a tx shape we don't know about
                self.print_error(f""Unkown tx shape, not adjusting fee!"")
                return
            chg = tx._outputs[-1]  # change is always the last output due to BIP_LI01 sorting
            assert len(chg) == 3, ""Expected tx output to be of length 3""
            if not self.main_window.wallet.is_mine(chg[1]):
                self.print_error(f""Unkown change address {chg[1]}, not adjusting fee!"")
                return
            chg_amt = chg[2]
            if chg_amt <= 546:
                # if change is 546, then the BIP_LI01 sorting doesn't guarantee
                # change output is at the end.. so we don't know which was
                # changed based on the heuristics this code relies on.. so..
                # Abort! Abort!
                self.print_error(""Could not determine change output, not adjusting fee!"")
                return
            curr_fee, curr_size = tx.get_fee(), tx.estimated_size()
            fee_rate = curr_fee / curr_size
            diff = math.ceil((fee_rate - desired_fee_rate) * curr_size)
            if diff > 0:
                tx._outputs[-1] = (chg[0], chg[1], chg[2] + diff)  # adjust the output
                self.print_error(f""Added {diff} sats to change to maintain fee rate of {desired_fee_rate:0.2f}, new fee: {tx.get_fee()}"")

        tx_adjust_change_amount_based_on_baton_amount(tx, desired_fee_rate)

        if preview:
            show_transaction(tx, self.main_window, None, False, self)
            return

        msg = []

        if self.main_window.wallet.has_password():
            msg.append("""")
            msg.append(_(""Enter your password to proceed""))
            password = self.main_window.password_dialog('\n'.join(msg))
            if not password:
                return
        else:
            password = None

        tx_desc = None

        def sign_done(success):
            if success:
                if not tx.is_complete():
                    show_transaction(tx, self.main_window, None, False, self)
                    self.main_window.do_clear()
                else:
                    self.main_window.broadcast_transaction(tx, tx_desc)

        self.main_window.sign_tx_with_password(tx, sign_done, password)

        self.mint_button.setDisabled(True)
        self.close()

    def closeEvent(self, event):
        super().closeEvent(event)
        event.accept()
        def remove_self():
            try: dialogs.remove(self)
            except ValueError: pass  # wasn't in list.
        QTimer.singleShot(0, remove_self)  # need to do this some time later. Doing it from within this function causes crashes. See #35

    def update(self):
        return

    def check_token_qty(self):
        try:
            if self.token_qty_e.get_amount() > (10 ** 19):
                self.show_warning(_('If you issue this much, users will may find it awkward to transfer large amounts as each transaction output may only take up to ~2 x 10^(19-decimals) tokens, thus requiring multiple outputs for very large amounts.'))
        except:
            pass
","import copy
import datetime
from functools import partial
import json
import threading
import sys
import traceback
import math

from PyQt5.QtCore import *
from PyQt5.QtGui import *
from PyQt5.QtWidgets import *

from electroncash.address import Address, PublicKey
from electroncash.bitcoin import base_encode, TYPE_ADDRESS
from electroncash.i18n import _
from electroncash.plugins import run_hook

from .util import *

from electroncash.util import bfh, format_satoshis_nofloat, format_satoshis_plain_nofloat, NotEnoughFunds, ExcessiveFee, PrintError, finalization_print_error
from electroncash.transaction import Transaction
from electroncash.slp import SlpMessage, SlpNoMintingBatonFound, SlpUnsupportedSlpTokenType, SlpInvalidOutputMessage, buildMintOpReturnOutput_V1

from .amountedit import SLPAmountEdit
from .transaction_dialog import show_transaction

from electroncash import networks

dialogs = []  # Otherwise python randomly garbage collects the dialogs...

class SlpCreateTokenMintDialog(QDialog, MessageBoxMixin, PrintError):

    def __init__(self, main_window, token_id_hex):
        # We want to be a top-level window
        QDialog.__init__(self, parent=None)
        from .main_window import ElectrumWindow

        assert isinstance(main_window, ElectrumWindow)
        main_window._slp_dialogs.add(self)
        finalization_print_error(self)  # Track object lifecycle

        self.main_window = main_window
        self.wallet = main_window.wallet
        self.network = main_window.network
        self.app = main_window.app

        if self.main_window.gui_object.warn_if_no_network(self.main_window):
            return

        self.setWindowTitle(_(""Mint Additional Tokens""))

        vbox = QVBoxLayout()
        self.setLayout(vbox)

        grid = QGridLayout()
        grid.setColumnStretch(1, 1)
        vbox.addLayout(grid)
        row = 0

        msg = _('Unique identifier for the token.')
        grid.addWidget(HelpLabel(_('Token ID:'), msg), row, 0)

        self.token_id_e = QLineEdit()
        self.token_id_e.setFixedWidth(490)
        self.token_id_e.setText(token_id_hex)
        self.token_id_e.setDisabled(True)
        grid.addWidget(self.token_id_e, row, 1)
        row += 1

        msg = _('The number of decimal places used in the token quantity.')
        grid.addWidget(HelpLabel(_('Decimals:'), msg), row, 0)
        self.token_dec = QDoubleSpinBox()
        decimals = self.main_window.wallet.token_types.get(token_id_hex)['decimals']
        self.token_dec.setRange(0, 9)
        self.token_dec.setValue(decimals)
        self.token_dec.setDecimals(0)
        self.token_dec.setFixedWidth(50)
        self.token_dec.setDisabled(True)
        grid.addWidget(self.token_dec, row, 1)
        row += 1

        msg = _('The number of tokens created during token minting transaction, send to the receiver address provided below.')
        grid.addWidget(HelpLabel(_('Additional Token Quantity:'), msg), row, 0)
        name = self.main_window.wallet.token_types.get(token_id_hex)['name']
        self.token_qty_e = SLPAmountEdit(name, int(decimals))
        self.token_qty_e.setFixedWidth(200)
        self.token_qty_e.textChanged.connect(self.check_token_qty)
        grid.addWidget(self.token_qty_e, row, 1)
        row += 1

        msg = _('The simpleledger formatted bitcoin address for the genesis receiver of all genesis tokens.')
        grid.addWidget(HelpLabel(_('Token Receiver Address:'), msg), row, 0)
        self.token_pay_to_e = ButtonsLineEdit()
        self.token_pay_to_e.setFixedWidth(490)
        grid.addWidget(self.token_pay_to_e, row, 1)
        row += 1

        msg = _('The simpleledger formatted bitcoin address for the genesis baton receiver.')
        self.token_baton_label = HelpLabel(_('Mint Baton Address:'), msg)
        grid.addWidget(self.token_baton_label, row, 0)
        self.token_baton_to_e = ButtonsLineEdit()
        self.token_baton_to_e.setFixedWidth(490)
        grid.addWidget(self.token_baton_to_e, row, 1)
        row += 1

        try:
            slpAddr = self.wallet.get_unused_address().to_slpaddr()
            self.token_pay_to_e.setText(Address.prefix_from_address_string(slpAddr) + "":"" + slpAddr)
            self.token_baton_to_e.setText(Address.prefix_from_address_string(slpAddr) + "":"" + slpAddr)
        except Exception as e:
            pass

        self.token_fixed_supply_cb = cb = QCheckBox(_('Permanently end issuance'))
        self.token_fixed_supply_cb.setChecked(False)
        grid.addWidget(self.token_fixed_supply_cb, row, 0)
        cb.clicked.connect(self.show_mint_baton_address)
        row += 1

        hbox = QHBoxLayout()
        vbox.addLayout(hbox)

        self.cancel_button = b = QPushButton(_(""Cancel""))
        self.cancel_button.setAutoDefault(False)
        self.cancel_button.setDefault(False)
        b.clicked.connect(self.close)
        b.setDefault(True)
        hbox.addWidget(self.cancel_button)

        hbox.addStretch(1)

        self.preview_button = EnterButton(_(""Preview""), self.do_preview)
        self.mint_button = b = QPushButton(_(""Create Additional Tokens""))
        b.clicked.connect(self.mint_token)
        self.mint_button.setAutoDefault(True)
        self.mint_button.setDefault(True)
        hbox.addWidget(self.preview_button)
        hbox.addWidget(self.mint_button)

        dialogs.append(self)
        self.show()
        self.token_qty_e.setFocus()

    def do_preview(self):
        self.mint_token(preview = True)

    def show_mint_baton_address(self):
        self.token_baton_to_e.setHidden(self.token_fixed_supply_cb.isChecked())
        self.token_baton_label.setHidden(self.token_fixed_supply_cb.isChecked())

    def parse_address(self, address):
        if networks.net.SLPADDR_PREFIX not in address:
            address = networks.net.SLPADDR_PREFIX + "":"" + address
        return Address.from_string(address)

    def mint_token(self, preview=False):
        decimals = int(self.token_dec.value())
        mint_baton_vout = 2 if self.token_baton_to_e.text() != '' and not self.token_fixed_supply_cb.isChecked() else None
        init_mint_qty = self.token_qty_e.get_amount()
        if init_mint_qty is None:
            self.show_message(_(""Invalid token quantity entered.""))
            return
        if init_mint_qty > (2 ** 64) - 1:
            maxqty = format_satoshis_plain_nofloat((2 ** 64) - 1, decimals)
            self.show_message(_(""Token output quantity is too large. Maximum %s."")%(maxqty,))
            return

        outputs = []
        try:
            token_id_hex = self.token_id_e.text()
            token_type = self.wallet.token_types[token_id_hex]['class']
            slp_op_return_msg = buildMintOpReturnOutput_V1(token_id_hex, mint_baton_vout, init_mint_qty, token_type)
            outputs.append(slp_op_return_msg)
        except OPReturnTooLarge:
            self.show_message(_(""Optional string text causiing OP_RETURN greater than 223 bytes.""))
            return
        except Exception as e:
            traceback.print_exc(file=sys.stdout)
            self.show_message(str(e))
            return

        try:
            addr = self.parse_address(self.token_pay_to_e.text())
            outputs.append((TYPE_ADDRESS, addr, 546))
        except:
            self.show_message(_(""Enter a Mint Receiver Address in SLP address format.""))
            return

        if not self.token_fixed_supply_cb.isChecked():
            try:
                addr = self.parse_address(self.token_baton_to_e.text())
                outputs.append((TYPE_ADDRESS, addr, 546))
            except:
                self.show_message(_(""Enter a Baton Address in SLP address format.""))
                return

        # IMPORTANT: set wallet.sedn_slpTokenId to None to guard tokens during this transaction
        self.main_window.token_type_combo.setCurrentIndex(0)
        assert self.main_window.slp_token_id == None

        coins = self.main_window.get_coins()
        fee = None

        try:
            baton_input = self.main_window.wallet.get_slp_token_baton(self.token_id_e.text())
        except SlpNoMintingBatonFound as e:
            self.show_message(_(""No baton exists for this token.""))
            return

        desired_fee_rate = 1.0  # sats/B, just init this value for paranoia
        try:
            tx = self.main_window.wallet.make_unsigned_transaction(coins, outputs, self.main_window.config, fee, None, mandatory_coins=[baton_input])
            desired_fee_rate = tx.get_fee() / tx.estimated_size()  # remember the fee coin chooser & wallet gave us as a fee rate so we may use it below after adding baton to adjust fee downward to this rate.
        except NotEnoughFunds:
            self.show_message(_(""Insufficient funds""))
            return
        except ExcessiveFee:
            self.show_message(_(""Your fee is too high.  Max is 50 sat/byte.""))
            return
        except BaseException as e:
            traceback.print_exc(file=sys.stdout)
            self.show_message(str(e))
            return


        def tx_adjust_change_amount_based_on_baton_amount(tx, desired_fee_rate):
            ''' adjust change amount (based on amount added from baton) '''
            if len(tx._outputs) not in (3,4):
                # no change, or a tx shape we don't know about
                self.print_error(f""Unkown tx shape, not adjusting fee!"")
                return
            chg = tx._outputs[-1]  # change is always the last output due to BIP_LI01 sorting
            assert len(chg) == 3, ""Expected tx output to be of length 3""
            if not self.main_window.wallet.is_mine(chg[1]):
                self.print_error(f""Unkown change address {chg[1]}, not adjusting fee!"")
                return
            chg_amt = chg[2]
            if chg_amt <= 546:
                # if change is 546, then the BIP_LI01 sorting doesn't guarantee
                # change output is at the end.. so we don't know which was
                # changed based on the heuristics this code relies on.. so..
                # Abort! Abort!
                self.print_error(""Could not determine change output, not adjusting fee!"")
                return
            curr_fee, curr_size = tx.get_fee(), tx.estimated_size()
            fee_rate = curr_fee / curr_size
            diff = math.ceil((fee_rate - desired_fee_rate) * curr_size)
            if diff > 0:
                tx._outputs[-1] = (chg[0], chg[1], chg[2] + diff)  # adjust the output
                self.print_error(f""Added {diff} sats to change to maintain fee rate of {desired_fee_rate:0.2f}, new fee: {tx.get_fee()}"")

        tx_adjust_change_amount_based_on_baton_amount(tx, desired_fee_rate)

        if preview:
            show_transaction(tx, self.main_window, None, False, self)
            return

        msg = []

        if self.main_window.wallet.has_password():
            msg.append("""")
            msg.append(_(""Enter your password to proceed""))
            password = self.main_window.password_dialog('\n'.join(msg))
            if not password:
                return
        else:
            password = None

        tx_desc = None

        def sign_done(success):
            if success:
                if not tx.is_complete():
                    show_transaction(tx, self.main_window, None, False, self)
                    self.main_window.do_clear()
                else:
                    self.main_window.broadcast_transaction(tx, tx_desc)

        self.main_window.sign_tx_with_password(tx, sign_done, password)

        self.mint_button.setDisabled(True)
        self.close()

    def closeEvent(self, event):
        super().closeEvent(event)
        event.accept()
        def remove_self():
            try: dialogs.remove(self)
            except ValueError: pass  # wasn't in list.
        QTimer.singleShot(0, remove_self)  # need to do this some time later. Doing it from within this function causes crashes. See #35

    def update(self):
        return

    def check_token_qty(self):
        try:
            if self.token_qty_e.get_amount() > (10 ** 19):
                self.show_warning(_('If you issue this much, users will may find it awkward to transfer large amounts as each transaction output may only take up to ~2 x 10^(19-decimals) tokens, thus requiring multiple outputs for very large amounts.'))
        except:
            pass
"
"#!/usr/bin/env python
# -*- coding: utf-8 -*-

""""""
| This file is part of the web2py Web Framework
| Copyrighted by Massimo Di Pierro <mdipierro@cs.depaul.edu>
| License: LGPLv3 (http://www.gnu.org/licenses/lgpl.html)

Contains the classes for the global used variables:

- Request
- Response
- Session

""""""

from gluon.storage import Storage, List
from gluon.streamer import streamer, stream_file_or_304_or_206, DEFAULT_CHUNK_SIZE
from gluon.xmlrpc import handler
from gluon.contenttype import contenttype
from gluon.html import xmlescape, TABLE, TR, PRE, URL
from gluon.http import HTTP, redirect
from gluon.fileutils import up
from gluon.serializers import json, custom_json
import gluon.settings as settings
from gluon.utils import web2py_uuid, secure_dumps, secure_loads
from gluon.settings import global_settings
from gluon import recfile
from gluon.cache import CacheInRam
from gluon.fileutils import copystream
import hashlib
import portalocker
try:
    import cPickle as pickle
except:
    import pickle
from pickle import Pickler, MARK, DICT, EMPTY_DICT
from types import DictionaryType
import cStringIO
import datetime
import re
import copy_reg
import Cookie
import os
import sys
import traceback
import threading
import cgi
import urlparse
import copy
import tempfile


FMT = '%a, %d-%b-%Y %H:%M:%S PST'
PAST = 'Sat, 1-Jan-1971 00:00:00'
FUTURE = 'Tue, 1-Dec-2999 23:59:59'

try:
    from gluon.contrib.minify import minify
    have_minify = True
except ImportError:
    have_minify = False

try:
    import simplejson as sj  # external installed library
except:
    try:
        import json as sj  # standard installed library
    except:
        import gluon.contrib.simplejson as sj  # pure python library

regex_session_id = re.compile('^([\w\-]+/)?[\w\-\.]+$')

__all__ = ['Request', 'Response', 'Session']

current = threading.local()  # thread-local storage for request-scope globals

css_template = '<link href=""%s"" rel=""stylesheet"" type=""text/css"" />'
js_template = '<script src=""%s"" type=""text/javascript""></script>'
coffee_template = '<script src=""%s"" type=""text/coffee""></script>'
typescript_template = '<script src=""%s"" type=""text/typescript""></script>'
less_template = '<link href=""%s"" rel=""stylesheet/less"" type=""text/css"" />'
css_inline = '<style type=""text/css"">\n%s\n</style>'
js_inline = '<script type=""text/javascript"">\n%s\n</script>'

template_mapping = {
    'css': css_template,
    'js': js_template,
    'coffee': coffee_template,
    'ts': typescript_template,
    'less': less_template,
    'css:inline': css_inline,
    'js:inline': js_inline
}

# IMPORTANT:
# this is required so that pickled dict(s) and class.__dict__
# are sorted and web2py can detect without ambiguity when a session changes
class SortingPickler(Pickler):
    def save_dict(self, obj):
        self.write(EMPTY_DICT if self.bin else MARK + DICT)
        self.memoize(obj)
        self._batch_setitems([(key, obj[key]) for key in sorted(obj)])

SortingPickler.dispatch = copy.copy(Pickler.dispatch)
SortingPickler.dispatch[DictionaryType] = SortingPickler.save_dict


def sorting_dumps(obj, protocol=None):
    file = cStringIO.StringIO()
    SortingPickler(file, protocol).dump(obj)
    return file.getvalue()
# END #####################################################################


def copystream_progress(request, chunk_size=10 ** 5):
    """"""
    Copies request.env.wsgi_input into request.body
    and stores progress upload status in cache_ram
    X-Progress-ID:length and X-Progress-ID:uploaded
    """"""
    env = request.env
    if not env.get('CONTENT_LENGTH', None):
        return cStringIO.StringIO()
    source = env['wsgi.input']
    try:
        size = int(env['CONTENT_LENGTH'])
    except ValueError:
        raise HTTP(400, ""Invalid Content-Length header"")
    try:  # Android requires this
        dest = tempfile.NamedTemporaryFile()
    except NotImplementedError:  # and GAE this
        dest = tempfile.TemporaryFile()
    if not 'X-Progress-ID' in request.get_vars:
        copystream(source, dest, size, chunk_size)
        return dest
    cache_key = 'X-Progress-ID:' + request.get_vars['X-Progress-ID']
    cache_ram = CacheInRam(request)  # same as cache.ram because meta_storage
    cache_ram(cache_key + ':length', lambda: size, 0)
    cache_ram(cache_key + ':uploaded', lambda: 0, 0)
    while size > 0:
        if size < chunk_size:
            data = source.read(size)
            cache_ram.increment(cache_key + ':uploaded', size)
        else:
            data = source.read(chunk_size)
            cache_ram.increment(cache_key + ':uploaded', chunk_size)
        length = len(data)
        if length > size:
            (data, length) = (data[:size], size)
        size -= length
        if length == 0:
            break
        dest.write(data)
        if length < chunk_size:
            break
    dest.seek(0)
    cache_ram(cache_key + ':length', None)
    cache_ram(cache_key + ':uploaded', None)
    return dest


class Request(Storage):

    """"""
    Defines the request object and the default values of its members

    - env: environment variables, by gluon.main.wsgibase()
    - cookies
    - get_vars
    - post_vars
    - vars
    - folder
    - application
    - function
    - args
    - extension
    - now: datetime.datetime.now()
    - utcnow : datetime.datetime.utcnow()
    - is_local
    - is_https
    - restful()
    """"""

    def __init__(self, env):
        Storage.__init__(self)
        self.env = Storage(env)
        self.env.web2py_path = global_settings.applications_parent
        self.env.update(global_settings)
        self.cookies = Cookie.SimpleCookie()
        self._get_vars = None
        self._post_vars = None
        self._vars = None
        self._body = None
        self.folder = None
        self.application = None
        self.function = None
        self.args = List()
        self.extension = 'html'
        self.now = datetime.datetime.now()
        self.utcnow = datetime.datetime.utcnow()
        self.is_restful = False
        self.is_https = False
        self.is_local = False
        self.global_settings = settings.global_settings
        self._uuid = None

    def parse_get_vars(self):
        """"""Takes the QUERY_STRING and unpacks it to get_vars
        """"""
        query_string = self.env.get('query_string', '')
        dget = urlparse.parse_qs(query_string, keep_blank_values=1)  # Ref: https://docs.python.org/2/library/cgi.html#cgi.parse_qs
        get_vars = self._get_vars = Storage(dget)
        for (key, value) in get_vars.iteritems():
            if isinstance(value, list) and len(value) == 1:
                get_vars[key] = value[0]

    def parse_post_vars(self):
        """"""Takes the body of the request and unpacks it into
        post_vars. application/json is also automatically parsed
        """"""
        env = self.env
        post_vars = self._post_vars = Storage()
        body = self.body
        # if content-type is application/json, we must read the body
        is_json = env.get('content_type', '')[:16] == 'application/json'

        if is_json:
            try:
                json_vars = sj.load(body)
            except:
                # incoherent request bodies can still be parsed ""ad-hoc""
                json_vars = {}
                pass
            # update vars and get_vars with what was posted as json
            if isinstance(json_vars, dict):
                post_vars.update(json_vars)

            body.seek(0)

        # parse POST variables on POST, PUT, BOTH only in post_vars
        if (body and not is_json
            and env.request_method in ('POST', 'PUT', 'DELETE', 'BOTH')):
            query_string = env.pop('QUERY_STRING', None)
            dpost = cgi.FieldStorage(fp=body, environ=env, keep_blank_values=1)
            try:
                post_vars.update(dpost)
            except:
                pass
            if query_string is not None:
                env['QUERY_STRING'] = query_string
            # The same detection used by FieldStorage to detect multipart POSTs
            body.seek(0)

            def listify(a):
                return (not isinstance(a, list) and [a]) or a
            try:
                keys = sorted(dpost)
            except TypeError:
                keys = []
            for key in keys:
                if key is None:
                    continue  # not sure why cgi.FieldStorage returns None key
                dpk = dpost[key]
                # if an element is not a file replace it with
                # its value else leave it alone

                pvalue = listify([(_dpk if _dpk.filename else _dpk.value)
                                  for _dpk in dpk]
                                 if isinstance(dpk, list) else
                                 (dpk if dpk.filename else dpk.value))
                if len(pvalue):
                    post_vars[key] = (len(pvalue) > 1 and pvalue) or pvalue[0]

    @property
    def body(self):
        if self._body is None:
            try:
                self._body = copystream_progress(self)
            except IOError:
                raise HTTP(400, ""Bad Request - HTTP body is incomplete"")
        return self._body

    def parse_all_vars(self):
        """"""Merges get_vars and post_vars to vars
        """"""
        self._vars = copy.copy(self.get_vars)
        for key, value in self.post_vars.iteritems():
            if key not in self._vars:
                self._vars[key] = value
            else:
                if not isinstance(self._vars[key], list):
                    self._vars[key] = [self._vars[key]]
                self._vars[key] += value if isinstance(value, list) else [value]

    @property
    def get_vars(self):
        """"""Lazily parses the query string into get_vars
        """"""
        if self._get_vars is None:
            self.parse_get_vars()
        return self._get_vars

    @property
    def post_vars(self):
        """"""Lazily parse the body into post_vars
        """"""
        if self._post_vars is None:
            self.parse_post_vars()
        return self._post_vars

    @property
    def vars(self):
        """"""Lazily parses all get_vars and post_vars to fill vars
        """"""
        if self._vars is None:
            self.parse_all_vars()
        return self._vars

    @property
    def uuid(self):
        """"""Lazily uuid
        """"""
        if self._uuid is None:
            self.compute_uuid()
        return self._uuid

    def compute_uuid(self):
        self._uuid = '%s/%s.%s.%s' % (
            self.application,
            self.client.replace(':', '_'),
            self.now.strftime('%Y-%m-%d.%H-%M-%S'),
            web2py_uuid())
        return self._uuid

    def user_agent(self):
        from gluon.contrib import user_agent_parser
        session = current.session
        user_agent = session._user_agent
        if user_agent:
            return user_agent
        user_agent = user_agent_parser.detect(self.env.http_user_agent)
        for key, value in user_agent.items():
            if isinstance(value, dict):
                user_agent[key] = Storage(value)
        user_agent = session._user_agent = Storage(user_agent)
        return user_agent

    def requires_https(self):
        """"""
        If request comes in over HTTP, redirects it to HTTPS
        and secures the session.
        """"""
        cmd_opts = global_settings.cmd_options
        # checking if this is called within the scheduler or within the shell
        # in addition to checking if it's not a cronjob
        if ((cmd_opts and (cmd_opts.shell or cmd_opts.scheduler))
                or global_settings.cronjob or self.is_https):
            current.session.secure()
        else:
            current.session.forget()
            redirect(URL(scheme='https', args=self.args, vars=self.vars))

    def restful(self):
        def wrapper(action, request=self):
            def f(_action=action, *a, **b):
                request.is_restful = True
                env = request.env
                is_json = env.content_type=='application/json'
                method = env.request_method
                if len(request.args) and '.' in request.args[-1]:
                    request.args[-1], _, request.extension = request.args[-1].rpartition('.')
                    current.response.headers['Content-Type'] = \
                        contenttype('.' + request.extension.lower())
                rest_action = _action().get(method, None)
                if not (rest_action and method == method.upper()
                        and callable(rest_action)):
                    raise HTTP(405, ""method not allowed"")
                try:
                    vars = request.vars
                    if method == 'POST' and is_json:
                        body = request.body.read()
                        if len(body):
                            vars = sj.loads(body)
                    res = rest_action(*request.args, **vars)
                    if is_json and not isinstance(res, str):
                        res = json(res)
                    return res
                except TypeError, e:
                    exc_type, exc_value, exc_traceback = sys.exc_info()
                    if len(traceback.extract_tb(exc_traceback)) == 1:
                        raise HTTP(400, ""invalid arguments"")
                    else:
                        raise
            f.__doc__ = action.__doc__
            f.__name__ = action.__name__
            return f
        return wrapper


class Response(Storage):

    """"""
    Defines the response object and the default values of its members
    response.write(   ) can be used to write in the output html
    """"""

    def __init__(self):
        Storage.__init__(self)
        self.status = 200
        self.headers = dict()
        self.headers['X-Powered-By'] = 'web2py'
        self.body = cStringIO.StringIO()
        self.session_id = None
        self.cookies = Cookie.SimpleCookie()
        self.postprocessing = []
        self.flash = ''            # used by the default view layout
        self.meta = Storage()      # used by web2py_ajax.html
        self.menu = []             # used by the default view layout
        self.files = []            # used by web2py_ajax.html
        self._vars = None
        self._caller = lambda f: f()
        self._view_environment = None
        self._custom_commit = None
        self._custom_rollback = None
        self.generic_patterns = ['*']
        self.delimiters = ('{{', '}}')
        self.formstyle = 'table3cols'
        self.form_label_separator = ': '

    def write(self, data, escape=True):
        if not escape:
            self.body.write(str(data))
        else:
            self.body.write(xmlescape(data))

    def render(self, *a, **b):
        from compileapp import run_view_in
        if len(a) > 2:
            raise SyntaxError(
                'Response.render can be called with two arguments, at most')
        elif len(a) == 2:
            (view, self._vars) = (a[0], a[1])
        elif len(a) == 1 and isinstance(a[0], str):
            (view, self._vars) = (a[0], {})
        elif len(a) == 1 and hasattr(a[0], 'read') and callable(a[0].read):
            (view, self._vars) = (a[0], {})
        elif len(a) == 1 and isinstance(a[0], dict):
            (view, self._vars) = (None, a[0])
        else:
            (view, self._vars) = (None, {})
        self._vars.update(b)
        self._view_environment.update(self._vars)
        if view:
            import cStringIO
            (obody, oview) = (self.body, self.view)
            (self.body, self.view) = (cStringIO.StringIO(), view)
            run_view_in(self._view_environment)
            page = self.body.getvalue()
            self.body.close()
            (self.body, self.view) = (obody, oview)
        else:
            run_view_in(self._view_environment)
            page = self.body.getvalue()
        return page

    def include_meta(self):
        s = ""\n""
        for meta in (self.meta or {}).iteritems():
            k, v = meta
            if isinstance(v, dict):
                s += '<meta' + ''.join(' %s=""%s""' % (xmlescape(key), xmlescape(v[key])) for key in v) +' />\n'
            else:
                s += '<meta name=""%s"" content=""%s"" />\n' % (k, xmlescape(v))
        self.write(s, escape=False)

    def include_files(self, extensions=None):

        """"""
        Includes files (usually in the head).
        Can minify and cache local files
        By default, caches in ram for 5 minutes. To change,
        response.cache_includes = (cache_method, time_expire).
        Example: (cache.disk, 60) # caches to disk for 1 minute.
        """"""
        files = []
        ext_files = []
        has_js = has_css = False
        for item in self.files:
            if isinstance(item, (list, tuple)):
                ext_files.append(item)
                continue
            if extensions and not item.rpartition('.')[2] in extensions:
                continue
            if item in files:
                continue
            if item.endswith('.js'):
                has_js = True
            if item.endswith('.css'):
                has_css = True
            files.append(item)

        if have_minify and ((self.optimize_css and has_css) or (self.optimize_js and has_js)):
            # cache for 5 minutes by default
            key = hashlib.md5(repr(files)).hexdigest()

            cache = self.cache_includes or (current.cache.ram, 60 * 5)

            def call_minify(files=files):
                return minify.minify(files,
                                     URL('static', 'temp'),
                                     current.request.folder,
                                     self.optimize_css,
                                     self.optimize_js)
            if cache:
                cache_model, time_expire = cache
                files = cache_model('response.files.minified/' + key,
                                    call_minify,
                                    time_expire)
            else:
                files = call_minify()

        files.extend(ext_files)
        s = []
        for item in files:
            if isinstance(item, str):
                f = item.lower().split('?')[0]
                ext = f.rpartition('.')[2]
                # if static_version we need also to check for
                # static_version_urls. In that case, the _.x.x.x
                # bit would have already been added by the URL()
                # function
                if self.static_version and not self.static_version_urls:
                    item = item.replace(
                        '/static/', '/static/_%s/' % self.static_version, 1)
                tmpl = template_mapping.get(ext)
                if tmpl:
                    s.append(tmpl % item)
            elif isinstance(item, (list, tuple)):
                f = item[0]
                tmpl = template_mapping.get(f)
                if tmpl:
                    s.append(tmpl % item[1])
        self.write(''.join(s), escape=False)

    def stream(self,
               stream,
               chunk_size=DEFAULT_CHUNK_SIZE,
               request=None,
               attachment=False,
               filename=None
               ):
        """"""
        If in a controller function::

            return response.stream(file, 100)

        the file content will be streamed at 100 bytes at the time

        Args:
            stream: filename or read()able content
            chunk_size(int): Buffer size
            request: the request object
            attachment(bool): prepares the correct headers to download the file
                as an attachment. Usually creates a pop-up download window
                on browsers
            filename(str): the name for the attachment

        Note:
            for using the stream name (filename) with attachments
            the option must be explicitly set as function parameter (will
            default to the last request argument otherwise)
        """"""

        headers = self.headers
        # for attachment settings and backward compatibility
        keys = [item.lower() for item in headers]
        if attachment:
            if filename is None:
                attname = """"
            else:
                attname = filename
            headers[""Content-Disposition""] = \
                'attachment;filename=""%s""' % attname

        if not request:
            request = current.request
        if isinstance(stream, (str, unicode)):
            stream_file_or_304_or_206(stream,
                                      chunk_size=chunk_size,
                                      request=request,
                                      headers=headers,
                                      status=self.status)

        # ## the following is for backward compatibility
        if hasattr(stream, 'name'):
            filename = stream.name

        if filename and not 'content-type' in keys:
            headers['Content-Type'] = contenttype(filename)
        if filename and not 'content-length' in keys:
            try:
                headers['Content-Length'] = \
                    os.path.getsize(filename)
            except OSError:
                pass

        env = request.env
        # Internet Explorer < 9.0 will not allow downloads over SSL unless caching is enabled
        if request.is_https and isinstance(env.http_user_agent, str) and \
                not re.search(r'Opera', env.http_user_agent) and \
                re.search(r'MSIE [5-8][^0-9]', env.http_user_agent):
            headers['Pragma'] = 'cache'
            headers['Cache-Control'] = 'private'

        if request and env.web2py_use_wsgi_file_wrapper:
            wrapped = env.wsgi_file_wrapper(stream, chunk_size)
        else:
            wrapped = streamer(stream, chunk_size=chunk_size)
        return wrapped

    def download(self, request, db, chunk_size=DEFAULT_CHUNK_SIZE, attachment=True, download_filename=None):
        """"""
        Example of usage in controller::

            def download():
                return response.download(request, db)

        Downloads from http://..../download/filename
        """"""
        from pydal.exceptions import NotAuthorizedException, NotFoundException

        current.session.forget(current.response)

        if not request.args:
            raise HTTP(404)
        name = request.args[-1]
        items = re.compile('(?P<table>.*?)\.(?P<field>.*?)\..*').match(name)
        if not items:
            raise HTTP(404)
        (t, f) = (items.group('table'), items.group('field'))
        try:
            field = db[t][f]
        except AttributeError:
            raise HTTP(404)
        try:
            (filename, stream) = field.retrieve(name, nameonly=True)
        except NotAuthorizedException:
            raise HTTP(403)
        except NotFoundException:
            raise HTTP(404)
        except IOError:
            raise HTTP(404)
        headers = self.headers
        headers['Content-Type'] = contenttype(name)
        if download_filename is None:
            download_filename = filename
        if attachment:
            headers['Content-Disposition'] = \
                'attachment; filename=""%s""' % download_filename.replace('""', '\""')
        return self.stream(stream, chunk_size=chunk_size, request=request)

    def json(self, data, default=None):
        if 'Content-Type' not in self.headers:
            self.headers['Content-Type'] = 'application/json'
        return json(data, default=default or custom_json)

    def xmlrpc(self, request, methods):
        """"""
        assuming::

            def add(a, b):
                return a+b

        if a controller function \""func\""::

            return response.xmlrpc(request, [add])

        the controller will be able to handle xmlrpc requests for
        the add function. Example::

            import xmlrpclib
            connection = xmlrpclib.ServerProxy(
                'http://hostname/app/contr/func')
            print connection.add(3, 4)

        """"""

        return handler(request, self, methods)

    def toolbar(self):
        from gluon.html import DIV, SCRIPT, BEAUTIFY, TAG, A
        BUTTON = TAG.button
        admin = URL(""admin"", ""default"", ""design"", extension='html',
                    args=current.request.application)
        from gluon.dal import DAL
        dbstats = []
        dbtables = {}
        infos = DAL.get_instances()
        for k, v in infos.iteritems():
            dbstats.append(TABLE(*[TR(PRE(row[0]), '%.2fms' % (row[1]*1000))
                                   for row in v['dbstats']]))
            dbtables[k] = dict(defined=v['dbtables']['defined'] or '[no defined tables]',
                               lazy=v['dbtables']['lazy'] or '[no lazy tables]')
        u = web2py_uuid()
        backtotop = A('Back to top', _href=""#totop-%s"" % u)
        # Convert lazy request.vars from property to Storage so they
        # will be displayed in the toolbar.
        request = copy.copy(current.request)
        request.update(vars=current.request.vars,
                       get_vars=current.request.get_vars,
                       post_vars=current.request.post_vars)
        return DIV(
            BUTTON('design', _onclick=""document.location='%s'"" % admin),
            BUTTON('request',
                   _onclick=""jQuery('#request-%s').slideToggle()"" % u),
            BUTTON('response',
                   _onclick=""jQuery('#response-%s').slideToggle()"" % u),
            BUTTON('session',
                   _onclick=""jQuery('#session-%s').slideToggle()"" % u),
            BUTTON('db tables',
                   _onclick=""jQuery('#db-tables-%s').slideToggle()"" % u),
            BUTTON('db stats',
                   _onclick=""jQuery('#db-stats-%s').slideToggle()"" % u),
            DIV(BEAUTIFY(request), backtotop,
                _class=""w2p-toolbar-hidden"", _id=""request-%s"" % u),
            DIV(BEAUTIFY(current.session), backtotop,
                _class=""w2p-toolbar-hidden"", _id=""session-%s"" % u),
            DIV(BEAUTIFY(current.response), backtotop,
                _class=""w2p-toolbar-hidden"", _id=""response-%s"" % u),
            DIV(BEAUTIFY(dbtables), backtotop,
                _class=""w2p-toolbar-hidden"", _id=""db-tables-%s"" % u),
            DIV(BEAUTIFY(dbstats), backtotop,
                _class=""w2p-toolbar-hidden"", _id=""db-stats-%s"" % u),
            SCRIPT(""jQuery('.w2p-toolbar-hidden').hide()""),
            _id=""totop-%s"" % u
        )


class Session(Storage):
    """"""
    Defines the session object and the default values of its members (None)

    - session_storage_type   : 'file', 'db', or 'cookie'
    - session_cookie_compression_level :
    - session_cookie_expires : cookie expiration
    - session_cookie_key     : for encrypted sessions in cookies
    - session_id             : a number or None if no session
    - session_id_name        :
    - session_locked         :
    - session_masterapp      :
    - session_new            : a new session obj is being created
    - session_hash           : hash of the pickled loaded session
    - session_pickled        : picked session

    if session in cookie:

    - session_data_name      : name of the cookie for session data

    if session in db:

    - session_db_record_id
    - session_db_table
    - session_db_unique_key

    if session in file:

    - session_file
    - session_filename
    """"""

    def connect(self,
                request=None,
                response=None,
                db=None,
                tablename='web2py_session',
                masterapp=None,
                migrate=True,
                separate=None,
                check_client=False,
                cookie_key=None,
                cookie_expires=None,
                compression_level=None
                ):
        """"""
        Used in models, allows to customize Session handling

        Args:
            request: the request object
            response: the response object
            db: to store/retrieve sessions in db (a table is created)
            tablename(str): table name
            masterapp(str): points to another's app sessions. This enables a
                ""SSO"" environment among apps
            migrate: passed to the underlying db
            separate: with True, creates a folder with the 2 initials of the
                session id. Can also be a function, e.g. ::

                    separate=lambda(session_name): session_name[-2:]

            check_client: if True, sessions can only come from the same ip
            cookie_key(str): secret for cookie encryption
            cookie_expires: sets the expiration of the cookie
            compression_level(int): 0-9, sets zlib compression on the data
                before the encryption
        """"""
        from gluon.dal import Field
        request = request or current.request
        response = response or current.response
        masterapp = masterapp or request.application
        cookies = request.cookies

        self._unlock(response)

        response.session_masterapp = masterapp
        response.session_id_name = 'session_id_%s' % masterapp.lower()
        response.session_data_name = 'session_data_%s' % masterapp.lower()
        response.session_cookie_expires = cookie_expires
        response.session_client = str(request.client).replace(':', '.')
        response.session_cookie_key = cookie_key
        response.session_cookie_compression_level = compression_level

        # check if there is a session_id in cookies
        try:
            old_session_id = cookies[response.session_id_name].value
        except KeyError:
            old_session_id = None
        response.session_id = old_session_id

        # if we are supposed to use cookie based session data
        if cookie_key:
            response.session_storage_type = 'cookie'
        elif db:
            response.session_storage_type = 'db'
        else:
            response.session_storage_type = 'file'
            # why do we do this?
            # because connect may be called twice, by web2py and in models.
            # the first time there is no db yet so it should do nothing
            if (global_settings.db_sessions is True
                    or masterapp in global_settings.db_sessions):
                return

        if response.session_storage_type == 'cookie':
            # check if there is session data in cookies
            if response.session_data_name in cookies:
                session_cookie_data = cookies[response.session_data_name].value
            else:
                session_cookie_data = None
            if session_cookie_data:
                data = secure_loads(session_cookie_data, cookie_key,
                                    compression_level=compression_level)
                if data:
                    self.update(data)
            response.session_id = True

        # else if we are supposed to use file based sessions
        elif response.session_storage_type == 'file':
            response.session_new = False
            response.session_file = None
            # check if the session_id points to a valid sesion filename
            if response.session_id:
                if not regex_session_id.match(response.session_id):
                    response.session_id = None
                else:
                    response.session_filename = \
                        os.path.join(up(request.folder), masterapp,
                                     'sessions', response.session_id)
                    try:
                        response.session_file = \
                            recfile.open(response.session_filename, 'rb+')
                        portalocker.lock(response.session_file,
                                         portalocker.LOCK_EX)
                        response.session_locked = True
                        self.update(pickle.load(response.session_file))
                        response.session_file.seek(0)
                        oc = response.session_filename.split('/')[-1].split('-')[0]
                        if check_client and response.session_client != oc:
                            raise Exception(""cookie attack"")
                    except:
                        response.session_id = None
            if not response.session_id:
                uuid = web2py_uuid()
                response.session_id = '%s-%s' % (response.session_client, uuid)
                separate = separate and (lambda session_name: session_name[-2:])
                if separate:
                    prefix = separate(response.session_id)
                    response.session_id = '%s/%s' % (prefix, response.session_id)
                response.session_filename = \
                    os.path.join(up(request.folder), masterapp,
                                 'sessions', response.session_id)
                response.session_new = True

        # else the session goes in db
        elif response.session_storage_type == 'db':
            if global_settings.db_sessions is not True:
                global_settings.db_sessions.add(masterapp)
            # if had a session on file alreday, close it (yes, can happen)
            if response.session_file:
                self._close(response)
            # if on GAE tickets go also in DB
            if settings.global_settings.web2py_runtime_gae:
                request.tickets_db = db
            if masterapp == request.application:
                table_migrate = migrate
            else:
                table_migrate = False
            tname = tablename + '_' + masterapp
            table = db.get(tname, None)
            # Field = db.Field
            if table is None:
                db.define_table(
                    tname,
                    Field('locked', 'boolean', default=False),
                    Field('client_ip', length=64),
                    Field('created_datetime', 'datetime',
                          default=request.now),
                    Field('modified_datetime', 'datetime'),
                    Field('unique_key', length=64),
                    Field('session_data', 'blob'),
                    migrate=table_migrate,
                )
                table = db[tname]  # to allow for lazy table
            response.session_db_table = table
            if response.session_id:
                # Get session data out of the database
                try:
                    (record_id, unique_key) = response.session_id.split(':')
                    record_id = long(record_id)
                except (TypeError, ValueError):
                    record_id = None

                # Select from database
                if record_id:
                    row = table(record_id, unique_key=unique_key)
                    # Make sure the session data exists in the database
                    if row:
                        # rows[0].update_record(locked=True)
                        # Unpickle the data
                        session_data = pickle.loads(row.session_data)
                        self.update(session_data)
                        response.session_new = False
                    else:
                        record_id = None
                if record_id:
                    response.session_id = '%s:%s' % (record_id, unique_key)
                    response.session_db_unique_key = unique_key
                    response.session_db_record_id = record_id
                else:
                    response.session_id = None
                    response.session_new = True
            # if there is no session id yet, we'll need to create a
            # new session
            else:
                response.session_new = True

        # set the cookie now if you know the session_id so user can set
        # cookie attributes in controllers/models
        # cookie will be reset later
        # yet cookie may be reset later
        #   Removed comparison between old and new session ids - should send
        #    the cookie all the time
        if isinstance(response.session_id, str):
            response.cookies[response.session_id_name] = response.session_id
            response.cookies[response.session_id_name]['path'] = '/'
            if cookie_expires:
                response.cookies[response.session_id_name]['expires'] = \
                    cookie_expires.strftime(FMT)

        session_pickled = pickle.dumps(self, pickle.HIGHEST_PROTOCOL)
        response.session_hash = hashlib.md5(session_pickled).hexdigest()

        if self.flash:
            (response.flash, self.flash) = (self.flash, None)

    def renew(self, clear_session=False):

        if clear_session:
            self.clear()

        request = current.request
        response = current.response
        session = response.session
        masterapp = response.session_masterapp
        cookies = request.cookies

        if response.session_storage_type == 'cookie':
            return

        # if the session goes in file
        if response.session_storage_type == 'file':
            self._close(response)
            uuid = web2py_uuid()
            response.session_id = '%s-%s' % (response.session_client, uuid)
            separate = (lambda s: s[-2:]) if session and response.session_id[2:3] == ""/"" else None
            if separate:
                prefix = separate(response.session_id)
                response.session_id = '%s/%s' % \
                    (prefix, response.session_id)
            response.session_filename = \
                os.path.join(up(request.folder), masterapp,
                             'sessions', response.session_id)
            response.session_new = True

        # else the session goes in db
        elif response.session_storage_type == 'db':
            table = response.session_db_table

            # verify that session_id exists
            if response.session_file:
                self._close(response)
            if response.session_new:
                return
            # Get session data out of the database
            if response.session_id is None:
                return
            (record_id, sep, unique_key) = response.session_id.partition(':')

            if record_id.isdigit() and long(record_id) > 0:
                new_unique_key = web2py_uuid()
                row = table(record_id)
                if row and row.unique_key == unique_key:
                    table._db(table.id == record_id).update(unique_key=new_unique_key)
                else:
                    record_id = None
            if record_id:
                response.session_id = '%s:%s' % (record_id, new_unique_key)
                response.session_db_record_id = record_id
                response.session_db_unique_key = new_unique_key
            else:
                response.session_new = True

    def _fixup_before_save(self):
        response = current.response
        rcookies = response.cookies
        scookies = rcookies.get(response.session_id_name)
        if not scookies:
            return
        if self._forget:
            del rcookies[response.session_id_name]
            return
        if self.get('httponly_cookies',True):
            scookies['HttpOnly'] = True
        if self._secure:
            scookies['secure'] = True

    def clear_session_cookies(self):
        request = current.request
        response = current.response
        session = response.session
        masterapp = response.session_masterapp
        cookies = request.cookies
        rcookies = response.cookies
        # if not cookie_key, but session_data_name in cookies
        # expire session_data_name from cookies
        if response.session_data_name in cookies:
            rcookies[response.session_data_name] = 'expired'
            rcookies[response.session_data_name]['path'] = '/'
            rcookies[response.session_data_name]['expires'] = PAST
        if response.session_id_name in rcookies:
            del rcookies[response.session_id_name]

    def save_session_id_cookie(self):
        request = current.request
        response = current.response
        session = response.session
        masterapp = response.session_masterapp
        cookies = request.cookies
        rcookies = response.cookies

        # if not cookie_key, but session_data_name in cookies
        # expire session_data_name from cookies
        if not response.session_cookie_key:
            if response.session_data_name in cookies:
                rcookies[response.session_data_name] = 'expired'
                rcookies[response.session_data_name]['path'] = '/'
                rcookies[response.session_data_name]['expires'] = PAST
        if response.session_id:
            rcookies[response.session_id_name] = response.session_id
            rcookies[response.session_id_name]['path'] = '/'
            expires = response.session_cookie_expires
            if isinstance(expires, datetime.datetime):
                expires = expires.strftime(FMT)
            if expires:
                rcookies[response.session_id_name]['expires'] = expires

    def clear(self):
        # see https://github.com/web2py/web2py/issues/735
        response = current.response
        if response.session_storage_type == 'file':
            target = recfile.generate(response.session_filename)
            try:
                self._close(response)
                os.unlink(target)
            except:
                pass
        elif response.session_storage_type == 'db':
            table = response.session_db_table
            if response.session_id:
                (record_id, sep, unique_key) = response.session_id.partition(':')
                if record_id.isdigit() and long(record_id) > 0:
                    table._db(table.id == record_id).delete()
        Storage.clear(self)

    def is_new(self):
        if self._start_timestamp:
            return False
        else:
            self._start_timestamp = datetime.datetime.today()
            return True

    def is_expired(self, seconds=3600):
        now = datetime.datetime.today()
        if not self._last_timestamp or \
                self._last_timestamp + datetime.timedelta(seconds=seconds) > now:
            self._last_timestamp = now
            return False
        else:
            return True

    def secure(self):
        self._secure = True

    def forget(self, response=None):
        self._close(response)
        self._forget = True

    def _try_store_in_cookie(self, request, response):
        if self._forget or self._unchanged(response):
            # self.clear_session_cookies()
            self.save_session_id_cookie()
            return False
        name = response.session_data_name
        compression_level = response.session_cookie_compression_level
        value = secure_dumps(dict(self),
                             response.session_cookie_key,
                             compression_level=compression_level)
        rcookies = response.cookies
        rcookies.pop(name, None)
        rcookies[name] = value
        rcookies[name]['path'] = '/'
        expires = response.session_cookie_expires
        if isinstance(expires, datetime.datetime):
            expires = expires.strftime(FMT)
        if expires:
            rcookies[name]['expires'] = expires
        return True

    def _unchanged(self, response):
        session_pickled = pickle.dumps(self, pickle.HIGHEST_PROTOCOL)
        response.session_pickled = session_pickled
        session_hash = hashlib.md5(session_pickled).hexdigest()
        return response.session_hash == session_hash

    def _try_store_in_db(self, request, response):
        # don't save if file-based sessions,
        # no session id, or session being forgotten
        # or no changes to session (Unless the session is new)
        if (not response.session_db_table
                or self._forget
                or (self._unchanged(response) and not response.session_new)):
            if (not response.session_db_table
                    and global_settings.db_sessions is not True
                    and response.session_masterapp in global_settings.db_sessions):
                global_settings.db_sessions.remove(response.session_masterapp)
            # self.clear_session_cookies()
            self.save_session_id_cookie()
            return False

        table = response.session_db_table
        record_id = response.session_db_record_id
        if response.session_new:
            unique_key = web2py_uuid()
        else:
            unique_key = response.session_db_unique_key

        session_pickled = response.session_pickled or pickle.dumps(self, pickle.HIGHEST_PROTOCOL)

        dd = dict(locked=False,
                  client_ip=response.session_client,
                  modified_datetime=request.now,
                  session_data=session_pickled,
                  unique_key=unique_key)
        if record_id:
            if not table._db(table.id == record_id).update(**dd):
                record_id = None
        if not record_id:
            record_id = table.insert(**dd)
            response.session_id = '%s:%s' % (record_id, unique_key)
            response.session_db_unique_key = unique_key
            response.session_db_record_id = record_id

        self.save_session_id_cookie()
        return True

    def _try_store_in_cookie_or_file(self, request, response):
        if response.session_storage_type == 'file':
            return self._try_store_in_file(request, response)
        if response.session_storage_type == 'cookie':
            return self._try_store_in_cookie(request, response)

    def _try_store_in_file(self, request, response):
        try:
            if (not response.session_id or self._forget
                    or self._unchanged(response)):
                # self.clear_session_cookies()
                self.save_session_id_cookie()
                return False
            if response.session_new or not response.session_file:
                # Tests if the session sub-folder exists, if not, create it
                session_folder = os.path.dirname(response.session_filename)
                if not os.path.exists(session_folder):
                    os.mkdir(session_folder)
                response.session_file = recfile.open(response.session_filename, 'wb')
                portalocker.lock(response.session_file, portalocker.LOCK_EX)
                response.session_locked = True
            if response.session_file:
                session_pickled = response.session_pickled or pickle.dumps(self, pickle.HIGHEST_PROTOCOL)
                response.session_file.write(session_pickled)
                response.session_file.truncate()
        finally:
            self._close(response)

        self.save_session_id_cookie()
        return True

    def _unlock(self, response):
        if response and response.session_file and response.session_locked:
            try:
                portalocker.unlock(response.session_file)
                response.session_locked = False
            except:  # this should never happen but happens in Windows
                pass

    def _close(self, response):
        if response and response.session_file:
            self._unlock(response)
            try:
                response.session_file.close()
                del response.session_file
            except:
                pass


def pickle_session(s):
    return Session, (dict(s),)

copy_reg.pickle(Session, pickle_session)
","#!/usr/bin/env python
# -*- coding: utf-8 -*-

""""""
| This file is part of the web2py Web Framework
| Copyrighted by Massimo Di Pierro <mdipierro@cs.depaul.edu>
| License: LGPLv3 (http://www.gnu.org/licenses/lgpl.html)

Contains the classes for the global used variables:

- Request
- Response
- Session

""""""

from gluon.storage import Storage, List
from gluon.streamer import streamer, stream_file_or_304_or_206, DEFAULT_CHUNK_SIZE
from gluon.xmlrpc import handler
from gluon.contenttype import contenttype
from gluon.html import xmlescape, TABLE, TR, PRE, URL
from gluon.http import HTTP, redirect
from gluon.fileutils import up
from gluon.serializers import json, custom_json
import gluon.settings as settings
from gluon.utils import web2py_uuid, secure_dumps, secure_loads
from gluon.settings import global_settings
from gluon import recfile
from gluon.cache import CacheInRam
from gluon.fileutils import copystream
import hashlib
import portalocker
try:
    import cPickle as pickle
except:
    import pickle
from pickle import Pickler, MARK, DICT, EMPTY_DICT
from types import DictionaryType
import cStringIO
import datetime
import re
import copy_reg
import Cookie
import os
import sys
import traceback
import threading
import cgi
import urlparse
import copy
import tempfile


FMT = '%a, %d-%b-%Y %H:%M:%S PST'
PAST = 'Sat, 1-Jan-1971 00:00:00'
FUTURE = 'Tue, 1-Dec-2999 23:59:59'

try:
    from gluon.contrib.minify import minify
    have_minify = True
except ImportError:
    have_minify = False

try:
    import simplejson as sj  # external installed library
except:
    try:
        import json as sj  # standard installed library
    except:
        import gluon.contrib.simplejson as sj  # pure python library

regex_session_id = re.compile('^([\w\-]+/)?[\w\-\.]+$')

__all__ = ['Request', 'Response', 'Session']

current = threading.local()  # thread-local storage for request-scope globals

css_template = '<link href=""%s"" rel=""stylesheet"" type=""text/css"" />'
js_template = '<script src=""%s"" type=""text/javascript""></script>'
coffee_template = '<script src=""%s"" type=""text/coffee""></script>'
typescript_template = '<script src=""%s"" type=""text/typescript""></script>'
less_template = '<link href=""%s"" rel=""stylesheet/less"" type=""text/css"" />'
css_inline = '<style type=""text/css"">\n%s\n</style>'
js_inline = '<script type=""text/javascript"">\n%s\n</script>'

template_mapping = {
    'css': css_template,
    'js': js_template,
    'coffee': coffee_template,
    'ts': typescript_template,
    'less': less_template,
    'css:inline': css_inline,
    'js:inline': js_inline
}

# IMPORTANT:
# this is required so that pickled dict(s) and class.__dict__
# are sorted and web2py can detect without ambiguity when a session changes
class SortingPickler(Pickler):
    def save_dict(self, obj):
        self.write(EMPTY_DICT if self.bin else MARK + DICT)
        self.memoize(obj)
        self._batch_setitems([(key, obj[key]) for key in sorted(obj)])

SortingPickler.dispatch = copy.copy(Pickler.dispatch)
SortingPickler.dispatch[DictionaryType] = SortingPickler.save_dict


def sorting_dumps(obj, protocol=None):
    file = cStringIO.StringIO()
    SortingPickler(file, protocol).dump(obj)
    return file.getvalue()
# END #####################################################################


def copystream_progress(request, chunk_size=10 ** 5):
    """"""
    Copies request.env.wsgi_input into request.body
    and stores progress upload status in cache_ram
    X-Progress-ID:length and X-Progress-ID:uploaded
    """"""
    env = request.env
    if not env.get('CONTENT_LENGTH', None):
        return cStringIO.StringIO()
    source = env['wsgi.input']
    try:
        size = int(env['CONTENT_LENGTH'])
    except ValueError:
        raise HTTP(400, ""Invalid Content-Length header"")
    try:  # Android requires this
        dest = tempfile.NamedTemporaryFile()
    except NotImplementedError:  # and GAE this
        dest = tempfile.TemporaryFile()
    if not 'X-Progress-ID' in request.get_vars:
        copystream(source, dest, size, chunk_size)
        return dest
    cache_key = 'X-Progress-ID:' + request.get_vars['X-Progress-ID']
    cache_ram = CacheInRam(request)  # same as cache.ram because meta_storage
    cache_ram(cache_key + ':length', lambda: size, 0)
    cache_ram(cache_key + ':uploaded', lambda: 0, 0)
    while size > 0:
        if size < chunk_size:
            data = source.read(size)
            cache_ram.increment(cache_key + ':uploaded', size)
        else:
            data = source.read(chunk_size)
            cache_ram.increment(cache_key + ':uploaded', chunk_size)
        length = len(data)
        if length > size:
            (data, length) = (data[:size], size)
        size -= length
        if length == 0:
            break
        dest.write(data)
        if length < chunk_size:
            break
    dest.seek(0)
    cache_ram(cache_key + ':length', None)
    cache_ram(cache_key + ':uploaded', None)
    return dest


class Request(Storage):

    """"""
    Defines the request object and the default values of its members

    - env: environment variables, by gluon.main.wsgibase()
    - cookies
    - get_vars
    - post_vars
    - vars
    - folder
    - application
    - function
    - args
    - extension
    - now: datetime.datetime.now()
    - utcnow : datetime.datetime.utcnow()
    - is_local
    - is_https
    - restful()
    """"""

    def __init__(self, env):
        Storage.__init__(self)
        self.env = Storage(env)
        self.env.web2py_path = global_settings.applications_parent
        self.cookies = Cookie.SimpleCookie()
        self._get_vars = None
        self._post_vars = None
        self._vars = None
        self._body = None
        self.folder = None
        self.application = None
        self.function = None
        self.args = List()
        self.extension = 'html'
        self.now = datetime.datetime.now()
        self.utcnow = datetime.datetime.utcnow()
        self.is_restful = False
        self.is_https = False
        self.is_local = False
        self._uuid = None

    def parse_get_vars(self):
        """"""Takes the QUERY_STRING and unpacks it to get_vars
        """"""
        query_string = self.env.get('query_string', '')
        dget = urlparse.parse_qs(query_string, keep_blank_values=1)  # Ref: https://docs.python.org/2/library/cgi.html#cgi.parse_qs
        get_vars = self._get_vars = Storage(dget)
        for (key, value) in get_vars.iteritems():
            if isinstance(value, list) and len(value) == 1:
                get_vars[key] = value[0]

    def parse_post_vars(self):
        """"""Takes the body of the request and unpacks it into
        post_vars. application/json is also automatically parsed
        """"""
        env = self.env
        post_vars = self._post_vars = Storage()
        body = self.body
        # if content-type is application/json, we must read the body
        is_json = env.get('content_type', '')[:16] == 'application/json'

        if is_json:
            try:
                json_vars = sj.load(body)
            except:
                # incoherent request bodies can still be parsed ""ad-hoc""
                json_vars = {}
                pass
            # update vars and get_vars with what was posted as json
            if isinstance(json_vars, dict):
                post_vars.update(json_vars)

            body.seek(0)

        # parse POST variables on POST, PUT, BOTH only in post_vars
        if (body and not is_json
            and env.request_method in ('POST', 'PUT', 'DELETE', 'BOTH')):
            query_string = env.pop('QUERY_STRING', None)
            dpost = cgi.FieldStorage(fp=body, environ=env, keep_blank_values=1)
            try:
                post_vars.update(dpost)
            except:
                pass
            if query_string is not None:
                env['QUERY_STRING'] = query_string
            # The same detection used by FieldStorage to detect multipart POSTs
            body.seek(0)

            def listify(a):
                return (not isinstance(a, list) and [a]) or a
            try:
                keys = sorted(dpost)
            except TypeError:
                keys = []
            for key in keys:
                if key is None:
                    continue  # not sure why cgi.FieldStorage returns None key
                dpk = dpost[key]
                # if an element is not a file replace it with
                # its value else leave it alone

                pvalue = listify([(_dpk if _dpk.filename else _dpk.value)
                                  for _dpk in dpk]
                                 if isinstance(dpk, list) else
                                 (dpk if dpk.filename else dpk.value))
                if len(pvalue):
                    post_vars[key] = (len(pvalue) > 1 and pvalue) or pvalue[0]

    @property
    def body(self):
        if self._body is None:
            try:
                self._body = copystream_progress(self)
            except IOError:
                raise HTTP(400, ""Bad Request - HTTP body is incomplete"")
        return self._body

    def parse_all_vars(self):
        """"""Merges get_vars and post_vars to vars
        """"""
        self._vars = copy.copy(self.get_vars)
        for key, value in self.post_vars.iteritems():
            if key not in self._vars:
                self._vars[key] = value
            else:
                if not isinstance(self._vars[key], list):
                    self._vars[key] = [self._vars[key]]
                self._vars[key] += value if isinstance(value, list) else [value]

    @property
    def get_vars(self):
        """"""Lazily parses the query string into get_vars
        """"""
        if self._get_vars is None:
            self.parse_get_vars()
        return self._get_vars

    @property
    def post_vars(self):
        """"""Lazily parse the body into post_vars
        """"""
        if self._post_vars is None:
            self.parse_post_vars()
        return self._post_vars

    @property
    def vars(self):
        """"""Lazily parses all get_vars and post_vars to fill vars
        """"""
        if self._vars is None:
            self.parse_all_vars()
        return self._vars

    @property
    def uuid(self):
        """"""Lazily uuid
        """"""
        if self._uuid is None:
            self.compute_uuid()
        return self._uuid

    def compute_uuid(self):
        self._uuid = '%s/%s.%s.%s' % (
            self.application,
            self.client.replace(':', '_'),
            self.now.strftime('%Y-%m-%d.%H-%M-%S'),
            web2py_uuid())
        return self._uuid

    def user_agent(self):
        from gluon.contrib import user_agent_parser
        session = current.session
        user_agent = session._user_agent
        if user_agent:
            return user_agent
        user_agent = user_agent_parser.detect(self.env.http_user_agent)
        for key, value in user_agent.items():
            if isinstance(value, dict):
                user_agent[key] = Storage(value)
        user_agent = session._user_agent = Storage(user_agent)
        return user_agent

    def requires_https(self):
        """"""
        If request comes in over HTTP, redirects it to HTTPS
        and secures the session.
        """"""
        cmd_opts = global_settings.cmd_options
        # checking if this is called within the scheduler or within the shell
        # in addition to checking if it's not a cronjob
        if ((cmd_opts and (cmd_opts.shell or cmd_opts.scheduler))
                or global_settings.cronjob or self.is_https):
            current.session.secure()
        else:
            current.session.forget()
            redirect(URL(scheme='https', args=self.args, vars=self.vars))

    def restful(self):
        def wrapper(action, request=self):
            def f(_action=action, *a, **b):
                request.is_restful = True
                env = request.env
                is_json = env.content_type=='application/json'
                method = env.request_method
                if len(request.args) and '.' in request.args[-1]:
                    request.args[-1], _, request.extension = request.args[-1].rpartition('.')
                    current.response.headers['Content-Type'] = \
                        contenttype('.' + request.extension.lower())
                rest_action = _action().get(method, None)
                if not (rest_action and method == method.upper()
                        and callable(rest_action)):
                    raise HTTP(405, ""method not allowed"")
                try:
                    vars = request.vars
                    if method == 'POST' and is_json:
                        body = request.body.read()
                        if len(body):
                            vars = sj.loads(body)
                    res = rest_action(*request.args, **vars)
                    if is_json and not isinstance(res, str):
                        res = json(res)
                    return res
                except TypeError, e:
                    exc_type, exc_value, exc_traceback = sys.exc_info()
                    if len(traceback.extract_tb(exc_traceback)) == 1:
                        raise HTTP(400, ""invalid arguments"")
                    else:
                        raise
            f.__doc__ = action.__doc__
            f.__name__ = action.__name__
            return f
        return wrapper


class Response(Storage):

    """"""
    Defines the response object and the default values of its members
    response.write(   ) can be used to write in the output html
    """"""

    def __init__(self):
        Storage.__init__(self)
        self.status = 200
        self.headers = dict()
        self.headers['X-Powered-By'] = 'web2py'
        self.body = cStringIO.StringIO()
        self.session_id = None
        self.cookies = Cookie.SimpleCookie()
        self.postprocessing = []
        self.flash = ''            # used by the default view layout
        self.meta = Storage()      # used by web2py_ajax.html
        self.menu = []             # used by the default view layout
        self.files = []            # used by web2py_ajax.html
        self._vars = None
        self._caller = lambda f: f()
        self._view_environment = None
        self._custom_commit = None
        self._custom_rollback = None
        self.generic_patterns = ['*']
        self.delimiters = ('{{', '}}')
        self.formstyle = 'table3cols'
        self.form_label_separator = ': '

    def write(self, data, escape=True):
        if not escape:
            self.body.write(str(data))
        else:
            self.body.write(xmlescape(data))

    def render(self, *a, **b):
        from compileapp import run_view_in
        if len(a) > 2:
            raise SyntaxError(
                'Response.render can be called with two arguments, at most')
        elif len(a) == 2:
            (view, self._vars) = (a[0], a[1])
        elif len(a) == 1 and isinstance(a[0], str):
            (view, self._vars) = (a[0], {})
        elif len(a) == 1 and hasattr(a[0], 'read') and callable(a[0].read):
            (view, self._vars) = (a[0], {})
        elif len(a) == 1 and isinstance(a[0], dict):
            (view, self._vars) = (None, a[0])
        else:
            (view, self._vars) = (None, {})
        self._vars.update(b)
        self._view_environment.update(self._vars)
        if view:
            import cStringIO
            (obody, oview) = (self.body, self.view)
            (self.body, self.view) = (cStringIO.StringIO(), view)
            run_view_in(self._view_environment)
            page = self.body.getvalue()
            self.body.close()
            (self.body, self.view) = (obody, oview)
        else:
            run_view_in(self._view_environment)
            page = self.body.getvalue()
        return page

    def include_meta(self):
        s = ""\n""
        for meta in (self.meta or {}).iteritems():
            k, v = meta
            if isinstance(v, dict):
                s += '<meta' + ''.join(' %s=""%s""' % (xmlescape(key), xmlescape(v[key])) for key in v) +' />\n'
            else:
                s += '<meta name=""%s"" content=""%s"" />\n' % (k, xmlescape(v))
        self.write(s, escape=False)

    def include_files(self, extensions=None):

        """"""
        Includes files (usually in the head).
        Can minify and cache local files
        By default, caches in ram for 5 minutes. To change,
        response.cache_includes = (cache_method, time_expire).
        Example: (cache.disk, 60) # caches to disk for 1 minute.
        """"""
        files = []
        ext_files = []
        has_js = has_css = False
        for item in self.files:
            if isinstance(item, (list, tuple)):
                ext_files.append(item)
                continue
            if extensions and not item.rpartition('.')[2] in extensions:
                continue
            if item in files:
                continue
            if item.endswith('.js'):
                has_js = True
            if item.endswith('.css'):
                has_css = True
            files.append(item)

        if have_minify and ((self.optimize_css and has_css) or (self.optimize_js and has_js)):
            # cache for 5 minutes by default
            key = hashlib.md5(repr(files)).hexdigest()

            cache = self.cache_includes or (current.cache.ram, 60 * 5)

            def call_minify(files=files):
                return minify.minify(files,
                                     URL('static', 'temp'),
                                     current.request.folder,
                                     self.optimize_css,
                                     self.optimize_js)
            if cache:
                cache_model, time_expire = cache
                files = cache_model('response.files.minified/' + key,
                                    call_minify,
                                    time_expire)
            else:
                files = call_minify()

        files.extend(ext_files)
        s = []
        for item in files:
            if isinstance(item, str):
                f = item.lower().split('?')[0]
                ext = f.rpartition('.')[2]
                # if static_version we need also to check for
                # static_version_urls. In that case, the _.x.x.x
                # bit would have already been added by the URL()
                # function
                if self.static_version and not self.static_version_urls:
                    item = item.replace(
                        '/static/', '/static/_%s/' % self.static_version, 1)
                tmpl = template_mapping.get(ext)
                if tmpl:
                    s.append(tmpl % item)
            elif isinstance(item, (list, tuple)):
                f = item[0]
                tmpl = template_mapping.get(f)
                if tmpl:
                    s.append(tmpl % item[1])
        self.write(''.join(s), escape=False)

    def stream(self,
               stream,
               chunk_size=DEFAULT_CHUNK_SIZE,
               request=None,
               attachment=False,
               filename=None
               ):
        """"""
        If in a controller function::

            return response.stream(file, 100)

        the file content will be streamed at 100 bytes at the time

        Args:
            stream: filename or read()able content
            chunk_size(int): Buffer size
            request: the request object
            attachment(bool): prepares the correct headers to download the file
                as an attachment. Usually creates a pop-up download window
                on browsers
            filename(str): the name for the attachment

        Note:
            for using the stream name (filename) with attachments
            the option must be explicitly set as function parameter (will
            default to the last request argument otherwise)
        """"""

        headers = self.headers
        # for attachment settings and backward compatibility
        keys = [item.lower() for item in headers]
        if attachment:
            if filename is None:
                attname = """"
            else:
                attname = filename
            headers[""Content-Disposition""] = \
                'attachment;filename=""%s""' % attname

        if not request:
            request = current.request
        if isinstance(stream, (str, unicode)):
            stream_file_or_304_or_206(stream,
                                      chunk_size=chunk_size,
                                      request=request,
                                      headers=headers,
                                      status=self.status)

        # ## the following is for backward compatibility
        if hasattr(stream, 'name'):
            filename = stream.name

        if filename and not 'content-type' in keys:
            headers['Content-Type'] = contenttype(filename)
        if filename and not 'content-length' in keys:
            try:
                headers['Content-Length'] = \
                    os.path.getsize(filename)
            except OSError:
                pass

        env = request.env
        # Internet Explorer < 9.0 will not allow downloads over SSL unless caching is enabled
        if request.is_https and isinstance(env.http_user_agent, str) and \
                not re.search(r'Opera', env.http_user_agent) and \
                re.search(r'MSIE [5-8][^0-9]', env.http_user_agent):
            headers['Pragma'] = 'cache'
            headers['Cache-Control'] = 'private'

        if request and env.web2py_use_wsgi_file_wrapper:
            wrapped = env.wsgi_file_wrapper(stream, chunk_size)
        else:
            wrapped = streamer(stream, chunk_size=chunk_size)
        return wrapped

    def download(self, request, db, chunk_size=DEFAULT_CHUNK_SIZE, attachment=True, download_filename=None):
        """"""
        Example of usage in controller::

            def download():
                return response.download(request, db)

        Downloads from http://..../download/filename
        """"""
        from pydal.exceptions import NotAuthorizedException, NotFoundException

        current.session.forget(current.response)

        if not request.args:
            raise HTTP(404)
        name = request.args[-1]
        items = re.compile('(?P<table>.*?)\.(?P<field>.*?)\..*').match(name)
        if not items:
            raise HTTP(404)
        (t, f) = (items.group('table'), items.group('field'))
        try:
            field = db[t][f]
        except AttributeError:
            raise HTTP(404)
        try:
            (filename, stream) = field.retrieve(name, nameonly=True)
        except NotAuthorizedException:
            raise HTTP(403)
        except NotFoundException:
            raise HTTP(404)
        except IOError:
            raise HTTP(404)
        headers = self.headers
        headers['Content-Type'] = contenttype(name)
        if download_filename is None:
            download_filename = filename
        if attachment:
            headers['Content-Disposition'] = \
                'attachment; filename=""%s""' % download_filename.replace('""', '\""')
        return self.stream(stream, chunk_size=chunk_size, request=request)

    def json(self, data, default=None):
        if 'Content-Type' not in self.headers:
            self.headers['Content-Type'] = 'application/json'
        return json(data, default=default or custom_json)

    def xmlrpc(self, request, methods):
        """"""
        assuming::

            def add(a, b):
                return a+b

        if a controller function \""func\""::

            return response.xmlrpc(request, [add])

        the controller will be able to handle xmlrpc requests for
        the add function. Example::

            import xmlrpclib
            connection = xmlrpclib.ServerProxy(
                'http://hostname/app/contr/func')
            print connection.add(3, 4)

        """"""

        return handler(request, self, methods)

    def toolbar(self):
        from gluon.html import DIV, SCRIPT, BEAUTIFY, TAG, A
        BUTTON = TAG.button
        admin = URL(""admin"", ""default"", ""design"", extension='html',
                    args=current.request.application)
        from gluon.dal import DAL
        dbstats = []
        dbtables = {}
        infos = DAL.get_instances()
        for k, v in infos.iteritems():
            dbstats.append(TABLE(*[TR(PRE(row[0]), '%.2fms' % (row[1]*1000))
                                   for row in v['dbstats']]))
            dbtables[k] = dict(defined=v['dbtables']['defined'] or '[no defined tables]',
                               lazy=v['dbtables']['lazy'] or '[no lazy tables]')
        u = web2py_uuid()
        backtotop = A('Back to top', _href=""#totop-%s"" % u)
        # Convert lazy request.vars from property to Storage so they
        # will be displayed in the toolbar.
        request = copy.copy(current.request)
        request.update(vars=current.request.vars,
                       get_vars=current.request.get_vars,
                       post_vars=current.request.post_vars)
        return DIV(
            BUTTON('design', _onclick=""document.location='%s'"" % admin),
            BUTTON('request',
                   _onclick=""jQuery('#request-%s').slideToggle()"" % u),
            BUTTON('response',
                   _onclick=""jQuery('#response-%s').slideToggle()"" % u),
            BUTTON('session',
                   _onclick=""jQuery('#session-%s').slideToggle()"" % u),
            BUTTON('db tables',
                   _onclick=""jQuery('#db-tables-%s').slideToggle()"" % u),
            BUTTON('db stats',
                   _onclick=""jQuery('#db-stats-%s').slideToggle()"" % u),
            DIV(BEAUTIFY(request), backtotop,
                _class=""w2p-toolbar-hidden"", _id=""request-%s"" % u),
            DIV(BEAUTIFY(current.session), backtotop,
                _class=""w2p-toolbar-hidden"", _id=""session-%s"" % u),
            DIV(BEAUTIFY(current.response), backtotop,
                _class=""w2p-toolbar-hidden"", _id=""response-%s"" % u),
            DIV(BEAUTIFY(dbtables), backtotop,
                _class=""w2p-toolbar-hidden"", _id=""db-tables-%s"" % u),
            DIV(BEAUTIFY(dbstats), backtotop,
                _class=""w2p-toolbar-hidden"", _id=""db-stats-%s"" % u),
            SCRIPT(""jQuery('.w2p-toolbar-hidden').hide()""),
            _id=""totop-%s"" % u
        )


class Session(Storage):
    """"""
    Defines the session object and the default values of its members (None)

    - session_storage_type   : 'file', 'db', or 'cookie'
    - session_cookie_compression_level :
    - session_cookie_expires : cookie expiration
    - session_cookie_key     : for encrypted sessions in cookies
    - session_id             : a number or None if no session
    - session_id_name        :
    - session_locked         :
    - session_masterapp      :
    - session_new            : a new session obj is being created
    - session_hash           : hash of the pickled loaded session
    - session_pickled        : picked session

    if session in cookie:

    - session_data_name      : name of the cookie for session data

    if session in db:

    - session_db_record_id
    - session_db_table
    - session_db_unique_key

    if session in file:

    - session_file
    - session_filename
    """"""

    def connect(self,
                request=None,
                response=None,
                db=None,
                tablename='web2py_session',
                masterapp=None,
                migrate=True,
                separate=None,
                check_client=False,
                cookie_key=None,
                cookie_expires=None,
                compression_level=None
                ):
        """"""
        Used in models, allows to customize Session handling

        Args:
            request: the request object
            response: the response object
            db: to store/retrieve sessions in db (a table is created)
            tablename(str): table name
            masterapp(str): points to another's app sessions. This enables a
                ""SSO"" environment among apps
            migrate: passed to the underlying db
            separate: with True, creates a folder with the 2 initials of the
                session id. Can also be a function, e.g. ::

                    separate=lambda(session_name): session_name[-2:]

            check_client: if True, sessions can only come from the same ip
            cookie_key(str): secret for cookie encryption
            cookie_expires: sets the expiration of the cookie
            compression_level(int): 0-9, sets zlib compression on the data
                before the encryption
        """"""
        from gluon.dal import Field
        request = request or current.request
        response = response or current.response
        masterapp = masterapp or request.application
        cookies = request.cookies

        self._unlock(response)

        response.session_masterapp = masterapp
        response.session_id_name = 'session_id_%s' % masterapp.lower()
        response.session_data_name = 'session_data_%s' % masterapp.lower()
        response.session_cookie_expires = cookie_expires
        response.session_client = str(request.client).replace(':', '.')
        response.session_cookie_key = cookie_key
        response.session_cookie_compression_level = compression_level

        # check if there is a session_id in cookies
        try:
            old_session_id = cookies[response.session_id_name].value
        except KeyError:
            old_session_id = None
        response.session_id = old_session_id

        # if we are supposed to use cookie based session data
        if cookie_key:
            response.session_storage_type = 'cookie'
        elif db:
            response.session_storage_type = 'db'
        else:
            response.session_storage_type = 'file'
            # why do we do this?
            # because connect may be called twice, by web2py and in models.
            # the first time there is no db yet so it should do nothing
            if (global_settings.db_sessions is True
                    or masterapp in global_settings.db_sessions):
                return

        if response.session_storage_type == 'cookie':
            # check if there is session data in cookies
            if response.session_data_name in cookies:
                session_cookie_data = cookies[response.session_data_name].value
            else:
                session_cookie_data = None
            if session_cookie_data:
                data = secure_loads(session_cookie_data, cookie_key,
                                    compression_level=compression_level)
                if data:
                    self.update(data)
            response.session_id = True

        # else if we are supposed to use file based sessions
        elif response.session_storage_type == 'file':
            response.session_new = False
            response.session_file = None
            # check if the session_id points to a valid sesion filename
            if response.session_id:
                if not regex_session_id.match(response.session_id):
                    response.session_id = None
                else:
                    response.session_filename = \
                        os.path.join(up(request.folder), masterapp,
                                     'sessions', response.session_id)
                    try:
                        response.session_file = \
                            recfile.open(response.session_filename, 'rb+')
                        portalocker.lock(response.session_file,
                                         portalocker.LOCK_EX)
                        response.session_locked = True
                        self.update(pickle.load(response.session_file))
                        response.session_file.seek(0)
                        oc = response.session_filename.split('/')[-1].split('-')[0]
                        if check_client and response.session_client != oc:
                            raise Exception(""cookie attack"")
                    except:
                        response.session_id = None
            if not response.session_id:
                uuid = web2py_uuid()
                response.session_id = '%s-%s' % (response.session_client, uuid)
                separate = separate and (lambda session_name: session_name[-2:])
                if separate:
                    prefix = separate(response.session_id)
                    response.session_id = '%s/%s' % (prefix, response.session_id)
                response.session_filename = \
                    os.path.join(up(request.folder), masterapp,
                                 'sessions', response.session_id)
                response.session_new = True

        # else the session goes in db
        elif response.session_storage_type == 'db':
            if global_settings.db_sessions is not True:
                global_settings.db_sessions.add(masterapp)
            # if had a session on file alreday, close it (yes, can happen)
            if response.session_file:
                self._close(response)
            # if on GAE tickets go also in DB
            if settings.global_settings.web2py_runtime_gae:
                request.tickets_db = db
            if masterapp == request.application:
                table_migrate = migrate
            else:
                table_migrate = False
            tname = tablename + '_' + masterapp
            table = db.get(tname, None)
            # Field = db.Field
            if table is None:
                db.define_table(
                    tname,
                    Field('locked', 'boolean', default=False),
                    Field('client_ip', length=64),
                    Field('created_datetime', 'datetime',
                          default=request.now),
                    Field('modified_datetime', 'datetime'),
                    Field('unique_key', length=64),
                    Field('session_data', 'blob'),
                    migrate=table_migrate,
                )
                table = db[tname]  # to allow for lazy table
            response.session_db_table = table
            if response.session_id:
                # Get session data out of the database
                try:
                    (record_id, unique_key) = response.session_id.split(':')
                    record_id = long(record_id)
                except (TypeError, ValueError):
                    record_id = None

                # Select from database
                if record_id:
                    row = table(record_id, unique_key=unique_key)
                    # Make sure the session data exists in the database
                    if row:
                        # rows[0].update_record(locked=True)
                        # Unpickle the data
                        session_data = pickle.loads(row.session_data)
                        self.update(session_data)
                        response.session_new = False
                    else:
                        record_id = None
                if record_id:
                    response.session_id = '%s:%s' % (record_id, unique_key)
                    response.session_db_unique_key = unique_key
                    response.session_db_record_id = record_id
                else:
                    response.session_id = None
                    response.session_new = True
            # if there is no session id yet, we'll need to create a
            # new session
            else:
                response.session_new = True

        # set the cookie now if you know the session_id so user can set
        # cookie attributes in controllers/models
        # cookie will be reset later
        # yet cookie may be reset later
        #   Removed comparison between old and new session ids - should send
        #    the cookie all the time
        if isinstance(response.session_id, str):
            response.cookies[response.session_id_name] = response.session_id
            response.cookies[response.session_id_name]['path'] = '/'
            if cookie_expires:
                response.cookies[response.session_id_name]['expires'] = \
                    cookie_expires.strftime(FMT)

        session_pickled = pickle.dumps(self, pickle.HIGHEST_PROTOCOL)
        response.session_hash = hashlib.md5(session_pickled).hexdigest()

        if self.flash:
            (response.flash, self.flash) = (self.flash, None)

    def renew(self, clear_session=False):

        if clear_session:
            self.clear()

        request = current.request
        response = current.response
        session = response.session
        masterapp = response.session_masterapp
        cookies = request.cookies

        if response.session_storage_type == 'cookie':
            return

        # if the session goes in file
        if response.session_storage_type == 'file':
            self._close(response)
            uuid = web2py_uuid()
            response.session_id = '%s-%s' % (response.session_client, uuid)
            separate = (lambda s: s[-2:]) if session and response.session_id[2:3] == ""/"" else None
            if separate:
                prefix = separate(response.session_id)
                response.session_id = '%s/%s' % \
                    (prefix, response.session_id)
            response.session_filename = \
                os.path.join(up(request.folder), masterapp,
                             'sessions', response.session_id)
            response.session_new = True

        # else the session goes in db
        elif response.session_storage_type == 'db':
            table = response.session_db_table

            # verify that session_id exists
            if response.session_file:
                self._close(response)
            if response.session_new:
                return
            # Get session data out of the database
            if response.session_id is None:
                return
            (record_id, sep, unique_key) = response.session_id.partition(':')

            if record_id.isdigit() and long(record_id) > 0:
                new_unique_key = web2py_uuid()
                row = table(record_id)
                if row and row.unique_key == unique_key:
                    table._db(table.id == record_id).update(unique_key=new_unique_key)
                else:
                    record_id = None
            if record_id:
                response.session_id = '%s:%s' % (record_id, new_unique_key)
                response.session_db_record_id = record_id
                response.session_db_unique_key = new_unique_key
            else:
                response.session_new = True

    def _fixup_before_save(self):
        response = current.response
        rcookies = response.cookies
        scookies = rcookies.get(response.session_id_name)
        if not scookies:
            return
        if self._forget:
            del rcookies[response.session_id_name]
            return
        if self.get('httponly_cookies',True):
            scookies['HttpOnly'] = True
        if self._secure:
            scookies['secure'] = True

    def clear_session_cookies(self):
        request = current.request
        response = current.response
        session = response.session
        masterapp = response.session_masterapp
        cookies = request.cookies
        rcookies = response.cookies
        # if not cookie_key, but session_data_name in cookies
        # expire session_data_name from cookies
        if response.session_data_name in cookies:
            rcookies[response.session_data_name] = 'expired'
            rcookies[response.session_data_name]['path'] = '/'
            rcookies[response.session_data_name]['expires'] = PAST
        if response.session_id_name in rcookies:
            del rcookies[response.session_id_name]

    def save_session_id_cookie(self):
        request = current.request
        response = current.response
        session = response.session
        masterapp = response.session_masterapp
        cookies = request.cookies
        rcookies = response.cookies

        # if not cookie_key, but session_data_name in cookies
        # expire session_data_name from cookies
        if not response.session_cookie_key:
            if response.session_data_name in cookies:
                rcookies[response.session_data_name] = 'expired'
                rcookies[response.session_data_name]['path'] = '/'
                rcookies[response.session_data_name]['expires'] = PAST
        if response.session_id:
            rcookies[response.session_id_name] = response.session_id
            rcookies[response.session_id_name]['path'] = '/'
            expires = response.session_cookie_expires
            if isinstance(expires, datetime.datetime):
                expires = expires.strftime(FMT)
            if expires:
                rcookies[response.session_id_name]['expires'] = expires

    def clear(self):
        # see https://github.com/web2py/web2py/issues/735
        response = current.response
        if response.session_storage_type == 'file':
            target = recfile.generate(response.session_filename)
            try:
                self._close(response)
                os.unlink(target)
            except:
                pass
        elif response.session_storage_type == 'db':
            table = response.session_db_table
            if response.session_id:
                (record_id, sep, unique_key) = response.session_id.partition(':')
                if record_id.isdigit() and long(record_id) > 0:
                    table._db(table.id == record_id).delete()
        Storage.clear(self)

    def is_new(self):
        if self._start_timestamp:
            return False
        else:
            self._start_timestamp = datetime.datetime.today()
            return True

    def is_expired(self, seconds=3600):
        now = datetime.datetime.today()
        if not self._last_timestamp or \
                self._last_timestamp + datetime.timedelta(seconds=seconds) > now:
            self._last_timestamp = now
            return False
        else:
            return True

    def secure(self):
        self._secure = True

    def forget(self, response=None):
        self._close(response)
        self._forget = True

    def _try_store_in_cookie(self, request, response):
        if self._forget or self._unchanged(response):
            # self.clear_session_cookies()
            self.save_session_id_cookie()
            return False
        name = response.session_data_name
        compression_level = response.session_cookie_compression_level
        value = secure_dumps(dict(self),
                             response.session_cookie_key,
                             compression_level=compression_level)
        rcookies = response.cookies
        rcookies.pop(name, None)
        rcookies[name] = value
        rcookies[name]['path'] = '/'
        expires = response.session_cookie_expires
        if isinstance(expires, datetime.datetime):
            expires = expires.strftime(FMT)
        if expires:
            rcookies[name]['expires'] = expires
        return True

    def _unchanged(self, response):
        session_pickled = pickle.dumps(self, pickle.HIGHEST_PROTOCOL)
        response.session_pickled = session_pickled
        session_hash = hashlib.md5(session_pickled).hexdigest()
        return response.session_hash == session_hash

    def _try_store_in_db(self, request, response):
        # don't save if file-based sessions,
        # no session id, or session being forgotten
        # or no changes to session (Unless the session is new)
        if (not response.session_db_table
                or self._forget
                or (self._unchanged(response) and not response.session_new)):
            if (not response.session_db_table
                    and global_settings.db_sessions is not True
                    and response.session_masterapp in global_settings.db_sessions):
                global_settings.db_sessions.remove(response.session_masterapp)
            # self.clear_session_cookies()
            self.save_session_id_cookie()
            return False

        table = response.session_db_table
        record_id = response.session_db_record_id
        if response.session_new:
            unique_key = web2py_uuid()
        else:
            unique_key = response.session_db_unique_key

        session_pickled = response.session_pickled or pickle.dumps(self, pickle.HIGHEST_PROTOCOL)

        dd = dict(locked=False,
                  client_ip=response.session_client,
                  modified_datetime=request.now,
                  session_data=session_pickled,
                  unique_key=unique_key)
        if record_id:
            if not table._db(table.id == record_id).update(**dd):
                record_id = None
        if not record_id:
            record_id = table.insert(**dd)
            response.session_id = '%s:%s' % (record_id, unique_key)
            response.session_db_unique_key = unique_key
            response.session_db_record_id = record_id

        self.save_session_id_cookie()
        return True

    def _try_store_in_cookie_or_file(self, request, response):
        if response.session_storage_type == 'file':
            return self._try_store_in_file(request, response)
        if response.session_storage_type == 'cookie':
            return self._try_store_in_cookie(request, response)

    def _try_store_in_file(self, request, response):
        try:
            if (not response.session_id or self._forget
                    or self._unchanged(response)):
                # self.clear_session_cookies()
                self.save_session_id_cookie()
                return False
            if response.session_new or not response.session_file:
                # Tests if the session sub-folder exists, if not, create it
                session_folder = os.path.dirname(response.session_filename)
                if not os.path.exists(session_folder):
                    os.mkdir(session_folder)
                response.session_file = recfile.open(response.session_filename, 'wb')
                portalocker.lock(response.session_file, portalocker.LOCK_EX)
                response.session_locked = True
            if response.session_file:
                session_pickled = response.session_pickled or pickle.dumps(self, pickle.HIGHEST_PROTOCOL)
                response.session_file.write(session_pickled)
                response.session_file.truncate()
        finally:
            self._close(response)

        self.save_session_id_cookie()
        return True

    def _unlock(self, response):
        if response and response.session_file and response.session_locked:
            try:
                portalocker.unlock(response.session_file)
                response.session_locked = False
            except:  # this should never happen but happens in Windows
                pass

    def _close(self, response):
        if response and response.session_file:
            self._unlock(response)
            try:
                response.session_file.close()
                del response.session_file
            except:
                pass


def pickle_session(s):
    return Session, (dict(s),)

copy_reg.pickle(Session, pickle_session)
"
"#!/usr/bin/python3

import threading
import gettext
import math
import logging
import os
import socket
import traceback
from concurrent.futures import ThreadPoolExecutor

from gi.repository import GLib, Gtk, Gdk, GObject, GdkPixbuf, Gio

import prefs
import config

_ = gettext.gettext

# Not sure what the ideal count is, too few and there will be waits if a lot of
# transfers are happening.  The server runs on its own thread, and has its own thread
# pool to service incoming rpcs. Each remote uses one thread for its connection loop,
# and all remotes share this thread pool for outgoing calls. It could be we may need
# to limit the number of simultaneous ops in the gui.
#
# Both server and remote thread pool sizes can be adjusted in dconf.
global_rpc_threadpool = None

# Initializing in thie function avoids a circular import due to prefs.get_thread_count()
def initialize_rpc_threadpool():
    global global_rpc_threadpool
    global_rpc_threadpool = ThreadPoolExecutor(max_workers=prefs.get_remote_pool_max_threads())

from enum import IntEnum
TransferDirection = IntEnum('TransferDirection', 'TO_REMOTE_MACHINE \
                                                  FROM_REMOTE_MACHINE')

# Using Gio enums fails for some unknown reason when collecting file info sometimes.
# Avoid introspection.
FileType = IntEnum('FileType', (('REGULAR', Gio.FileType.REGULAR),
                                ('DIRECTORY', Gio.FileType.DIRECTORY),
                                ('SYMBOLIC_LINK', Gio.FileType.SYMBOLIC_LINK)))

# Online - all ok
# Offline - no presence at all
# Init connecting - we've just discovered you
# Unreachable - we've either tried and failed after initial discovery, or something went wrong during the session

RemoteStatus = IntEnum('RemoteStatus', 'ONLINE \
                                        OFFLINE \
                                        INIT_CONNECTING \
                                        UNREACHABLE \
                                        AWAITING_DUPLEX')

OpStatus = IntEnum('OpStatus', 'INIT \
                                CALCULATING \
                                WAITING_PERMISSION \
                                CANCELLED_PERMISSION_BY_SENDER \
                                CANCELLED_PERMISSION_BY_RECEIVER \
                                TRANSFERRING \
                                PAUSED \
                                STOPPED_BY_SENDER \
                                STOPPED_BY_RECEIVER \
                                FAILED \
                                FAILED_UNRECOVERABLE \
                                FILE_NOT_FOUND \
                                FINISHED')

OpCommand = IntEnum('OpCommand', 'START_TRANSFER \
                                  UPDATE_PROGRESS \
                                  CANCEL_PERMISSION_BY_SENDER \
                                  CANCEL_PERMISSION_BY_RECEIVER \
                                  PAUSE_TRANSFER \
                                  RETRY_TRANSFER \
                                  STOP_TRANSFER_BY_SENDER \
                                  STOP_TRANSFER_BY_RECEIVER \
                                  REMOVE_TRANSFER')

class InterfaceInfo():
    def __init__(self, ip4, ip6, iface=None):
        self.iface = iface
        # netifaces AF_INET and AF_INET6 dicts
        self.ip4 = ip4
        self.ip4_address = self.ip4[""addr""]

        try:
            self.ip6 = ip6
            self.ip6_address = self.ip6[""addr""]
        except:
            self.ip6 = None
            self.ip6_address = None

    def __eq__(self, other):
        if other == None:
            return False

        return self.ip4_address == other.ip4_address

    def as_binary_list(self):
        blist = []

        if self.ip4:
            try:
                blist.append(socket.inet_pton(GLib.SYSDEF_AF_INET, self.ip4_address))
            except:
                pass
        if self.ip6:
            try:
                blist.append(socket.inet_pton(GLib.SYSDEF_AF_INET6, self.ip6_address))
            except:
                pass

        return blist

class RemoteInterfaceInfo():
    def __init__(self, blist):
        ip4 = None
        ip6 = None

        for item in blist:
            try:
                ip4 = socket.inet_ntop(socket.AF_INET, item)
            except ValueError:
                ip6 = socket.inet_ntop(socket.AF_INET6, item)

        if ip4:
            self.ip4_address = ip4
        if ip6:
            self.ip6_address = ip6

    def __eq__(self, other):
        if other == None:
            return False

        return self.ip4_address == other.ip4_address

last_location = Gio.File.new_for_path(GLib.get_home_dir())
# A normal GtkFileChooserDialog only lets you pick folders OR files, not
# both in the same dialog.  This does.

class FolderFileChooserDialog(Gtk.Dialog):
    def __init__(self, window_title, transient_parent, starting_location):
        super(FolderFileChooserDialog, self).__init__(title=window_title,
                                                      parent=transient_parent,
                                                      default_width=750,
                                                      default_height=500)

        self.add_buttons(_(""Cancel""), Gtk.ResponseType.CANCEL,
                         _(""Add""), Gtk.ResponseType.OK)

        self.chooser = Gtk.FileChooserWidget(action=Gtk.FileChooserAction.OPEN, select_multiple=True)
        self.chooser.set_current_folder_file(starting_location)
        self.chooser.connect(""file-activated"", lambda chooser: self.response(Gtk.ResponseType.OK))
        self.chooser.show_all()

        self.get_content_area().add(self.chooser)
        self.get_content_area().set_border_width(0)
        self.get_uris = self.chooser.get_uris
        self.get_current_folder_file = self.chooser.get_current_folder_file
        self.connect(""key-press-event"", self.on_button_press)

    def on_button_press(self, widget, event, data=None):
        multi = len(self.chooser.get_uris()) != 1
        if event.keyval in (Gdk.KEY_KP_Enter, Gdk.KEY_Return) and multi:
            self.response(Gtk.ResponseType.OK)
            return Gdk.EVENT_STOP

        return Gdk.EVENT_PROPAGATE

def create_file_and_folder_picker(dialog_parent=None):
    chooser = FolderFileChooserDialog(_(""Select file(s) to send""), dialog_parent, last_location)

    def update_last_location(dialog, response_id, data=None):
        if response_id != Gtk.ResponseType.OK:
            return

        global last_location
        last_location = chooser.get_current_folder_file()

    chooser.connect(""response"", update_last_location)
    return chooser

# Used as a decorator to run things in the background
def _async(func):
    def wrapper(*args, **kwargs):
        thread = threading.Thread(target=func, args=args, kwargs=kwargs)
        thread.daemon = True
        thread.start()
        return thread
    return wrapper

# Used as a decorator to run things in the main loop, from another thread
def _idle(func):
    def wrapper(*args, **kwargs):
        GLib.idle_add(func, *args, **kwargs)
    return wrapper

def print_stack():
    traceback.print_stack()

def open_save_folder(filename=None):
    bus = Gio.Application.get_default().get_dbus_connection()

    if filename != None:
        abs_path = os.path.join(prefs.get_save_path(), filename)

        if os.path.isfile(abs_path):
            file = Gio.File.new_for_path(abs_path)

            startup_id = str(os.getpid())

            try:
                bus.call_sync(""org.freedesktop.FileManager1"",
                              ""/org/freedesktop/FileManager1"",
                              ""org.freedesktop.FileManager1"",
                              ""ShowItems"",
                              GLib.Variant(""(ass)"",
                                           ([file.get_uri()], startup_id)),
                              None,
                              Gio.DBusCallFlags.NONE,
                              1000,
                              None)
                logging.debug(""Opening save folder using dbus"")
                return
            except GLib.Error as e:
                pass

    app = Gio.AppInfo.get_default_for_type(""inode/directory"", True)

    try:
        logging.debug(""Opening save folder using Gio (mimetype)"")
        Gio.AppInfo.launch_default_for_uri(prefs.get_save_uri(), None)
    except GLib.Error as e:
        logging.critical(""Could not open received files location: %s"" % e.message)

def verify_save_folder(transient_for=None):
    return os.access(prefs.get_save_path(), os.R_OK | os.W_OK)

def save_folder_is_native_fs():
    file = Gio.File.new_for_path(prefs.get_save_path())
    return file.is_native()

def have_free_space(size):
    save_file = Gio.File.new_for_path(prefs.get_save_path())

    try:
        info = save_file.query_filesystem_info(Gio.FILE_ATTRIBUTE_FILESYSTEM_FREE, None)
    except GLib.Error:
        logging.warning(""Unable to check free space in save location (%s), but proceeding anyhow"" % prefs.get_save_path())
        return True

    free = info.get_attribute_uint64(Gio.FILE_ATTRIBUTE_FILESYSTEM_FREE)

    # I guess we could have exactly 0 bytes free, but I think you'd have larger problems.  I want to make sure
    # here that we don't fail because we didn't get a valid number.
    if free == 0:
        return True

    logging.debug(""need: %s, have %s"" % (GLib.format_size(size), GLib.format_size(free)))

    return size < free

def files_exist(base_names):
    for name in base_names:
        path = os.path.join(prefs.get_save_path(), name)
        logging.debug(""(server side) Checking if file or folder %s already exists."" % (path,))
        if GLib.file_test(path, GLib.FileTest.EXISTS):
            return True

    return False

def check_ml(fid):
    on_ml = threading.current_thread() == threading.main_thread()
    print(""%s on mainloop: "" % fid, on_ml)

def get_hostname():
    return GLib.get_host_name()

def get_local_name(hostname=get_hostname()):
    local_name = ""%s@%s"" % (GLib.get_user_name(), hostname)
    real_name = GLib.get_real_name()
    if real_name is not None and real_name != """" and real_name != ""Unknown"":
        # according to glib's doc, it can actually return ""Unknown""
        local_name = ""%s - %s"" % (real_name, local_name)
    return local_name

def relpath_from_uri(child_uri, base_uri):
    child_uri = GLib.uri_unescape_string(child_uri)
    base_uri = GLib.uri_unescape_string(base_uri)

    if child_uri.startswith(base_uri):
        return child_uri.replace(base_uri + ""/"", """")
    else:
        return None

def sort_remote_machines(am, bm):
    if am.favorite and not bm.favorite:
        return -1
    elif bm.favorite and not am.favorite:
        return +1
    elif am.recent_time > bm.recent_time:
        return -1
    elif bm.recent_time > am.recent_time:
        return +1
    elif am.display_name and not bm.display_name:
        return -1
    elif bm.display_name and not am.display_name:
        return +1
    elif not am.display_name and not bm.display_name:
        return -1 if am.hostname < bm.hostname else +1

    return -1 if am.display_name < bm.display_name else +1

# adapted from nemo-file-operations.c: format_time()
def format_time_span(seconds):
    if seconds < 0:
        seconds = 0

    if (seconds < 10):
        return _(""A few seconds remaining"")

    if (seconds < 60):
        return _(""%d seconds remaining"") % seconds

    if (seconds < 60 * 60):
        minutes = round(seconds / 60)
        return gettext.ngettext(""%d minute"", ""%d minutes"", minutes) % minutes

    hours = math.floor(seconds / (60 * 60))

    if seconds < (60 * 60 * 4):
        minutes = int((seconds - hours * 60 * 60) / 60)

        h = gettext.ngettext (""%d hour"", ""%d hours"", hours) % hours
        m = gettext.ngettext (""%d minute"", ""%d minutes"", minutes) % minutes
        res = ""%s, %s"" % (h, m)
        return res;

    return gettext.ngettext(""approximately %d hour"", ""approximately %d hours"", hours) % hours


# adapted from nemo-file-operations.c: format_time()
def precise_format_time_span(micro):
    sdec, total_seconds = math.modf(micro / 1000 / 1000)
    seconds = total_seconds % 60
    mdec, total_minutes = math.modf(total_seconds / 60)
    minutes = total_minutes % 60
    hdec, total_hours = math.modf(total_minutes / 60)
    hours = total_hours % 60
    return (""%02d:%02d:%02d.%s"" % (hours, minutes, seconds, str(sdec)[2:5]))

def get_global_scale_factor():
    screen = Gdk.Screen.get_default()

    v = GObject.Value(int)

    if screen.get_setting(""gdk-window-scaling-factor"", v):
        return v.get_value()

    return 1

class CairoSurfaceLoader(GObject.Object):
    __gsignals__ = {
        'error': (GObject.SignalFlags.RUN_LAST, None, ())
    }

    def __init__(self, icon_size=Gtk.IconSize.DND):
        self.loader =GdkPixbuf.PixbufLoader()
        self.loader.connect(""size-prepared"", self.on_loader_size_prepared)

        s, w, h = Gtk.IconSize.lookup(icon_size)

        self.surface_size = w
        self.pixbuf_size = w * get_global_scale_factor()

    def on_loader_size_prepared(self, loader, width, height, data=None):
        new_width = self.pixbuf_size
        new_height = self.pixbuf_size

        if width != height:
            if width > height:
                aspect_ratio = height / width

                new_width = self.pixbuf_size
                new_height = new_width * aspect_ratio
            else:
                aspect_ratio = width / height

                new_height = self.pixbuf_size
                new_width = new_height * aspect_ratio

        self.loader.set_size(new_width, new_height)

    def add_bytes(self, _bytes):
        try:
            self.loader.write_bytes(GLib.Bytes(_bytes))
        except GLib.Error:
            try:
                self.loader.close()
            except:
                pass

            self.emit(""error"")

    def get_surface(self):
        try:
            self.loader.close()
            pixbuf = self.loader.get_pixbuf()

            if pixbuf:
                surface = Gdk.cairo_surface_create_from_pixbuf(pixbuf,
                                                               get_global_scale_factor(),
                                                               None)
                return surface
        except:
            self.emit(""error"")

class AboutDialog():
    def __init__(self, parent):
        # Maybe this can be configured during the build? But this works.
        if config.FLATPAK_BUILD:
            name = ""Warpinator (Flatpak)""
        else:
            name = ""Warpinator""

        dialog = Gtk.AboutDialog(parent=parent,
                                 title=_(""About""),
                                 program_name=name,
                                 icon_name=""org.x.Warpinator"",
                                 logo_icon_name=""org.x.Warpinator"",
                                 comments=_(""Send and Receive Files across the Network""),
                                 website=""https://github.com/linuxmint/warpinator"",
                                 version=config.VERSION,
                                 license_type=Gtk.License.GPL_3_0)

        dialog.run()
        dialog.destroy()

class WarpLogFormatter(logging.Formatter):
    dbg_crit_format = ""%(asctime)-15s::warpinator::%(levelname)s: %(message)s -- %(filename)s (line %(lineno)d)""
    info_format = ""%(asctime)-15s::warpinator: %(message)s""

    def __init__(self):
        super().__init__()

    def format(self, record):
        if record.levelno in (logging.DEBUG, logging.ERROR):
            self._style._fmt = WarpLogFormatter.dbg_crit_format

        elif record.levelno == logging.INFO:
            self._style._fmt = WarpLogFormatter.info_format

        result = logging.Formatter.format(self, record)

        return result


recent_manager = Gtk.RecentManager()

def add_to_recents_if_single_selection(uri_list):
    if len(uri_list) == 1:
        try:
            recent_manager.add_item(uri_list[0])
        except Exception as e:
            logging.warning(""Could not add '%s' single item to recent files: %s"" % e)

def get_recent_chooser_menu():
    chooser = Gtk.RecentChooserMenu(show_tips=True,
                                    sort_type=Gtk.RecentSortType.MRU,
                                    show_not_found=False)

    return chooser
","#!/usr/bin/python3

import threading
import gettext
import math
import logging
import os
import socket
import traceback
from concurrent.futures import ThreadPoolExecutor

from gi.repository import GLib, Gtk, Gdk, GObject, GdkPixbuf, Gio

import prefs
import config

_ = gettext.gettext

# Not sure what the ideal count is, too few and there will be waits if a lot of
# transfers are happening.  The server runs on its own thread, and has its own thread
# pool to service incoming rpcs. Each remote uses one thread for its connection loop,
# and all remotes share this thread pool for outgoing calls. It could be we may need
# to limit the number of simultaneous ops in the gui.
#
# Both server and remote thread pool sizes can be adjusted in dconf.
global_rpc_threadpool = None

# Initializing in thie function avoids a circular import due to prefs.get_thread_count()
def initialize_rpc_threadpool():
    global global_rpc_threadpool
    global_rpc_threadpool = ThreadPoolExecutor(max_workers=prefs.get_remote_pool_max_threads())

from enum import IntEnum
TransferDirection = IntEnum('TransferDirection', 'TO_REMOTE_MACHINE \
                                                  FROM_REMOTE_MACHINE')

# Using Gio enums fails for some unknown reason when collecting file info sometimes.
# Avoid introspection.
FileType = IntEnum('FileType', (('REGULAR', Gio.FileType.REGULAR),
                                ('DIRECTORY', Gio.FileType.DIRECTORY),
                                ('SYMBOLIC_LINK', Gio.FileType.SYMBOLIC_LINK)))

# Online - all ok
# Offline - no presence at all
# Init connecting - we've just discovered you
# Unreachable - we've either tried and failed after initial discovery, or something went wrong during the session

RemoteStatus = IntEnum('RemoteStatus', 'ONLINE \
                                        OFFLINE \
                                        INIT_CONNECTING \
                                        UNREACHABLE \
                                        AWAITING_DUPLEX')

OpStatus = IntEnum('OpStatus', 'INIT \
                                CALCULATING \
                                WAITING_PERMISSION \
                                CANCELLED_PERMISSION_BY_SENDER \
                                CANCELLED_PERMISSION_BY_RECEIVER \
                                TRANSFERRING \
                                PAUSED \
                                STOPPED_BY_SENDER \
                                STOPPED_BY_RECEIVER \
                                FAILED \
                                FAILED_UNRECOVERABLE \
                                FILE_NOT_FOUND \
                                FINISHED')

OpCommand = IntEnum('OpCommand', 'START_TRANSFER \
                                  UPDATE_PROGRESS \
                                  CANCEL_PERMISSION_BY_SENDER \
                                  CANCEL_PERMISSION_BY_RECEIVER \
                                  PAUSE_TRANSFER \
                                  RETRY_TRANSFER \
                                  STOP_TRANSFER_BY_SENDER \
                                  STOP_TRANSFER_BY_RECEIVER \
                                  REMOVE_TRANSFER')

class InterfaceInfo():
    def __init__(self, ip4, ip6, iface=None):
        self.iface = iface
        # netifaces AF_INET and AF_INET6 dicts
        self.ip4 = ip4
        self.ip4_address = self.ip4[""addr""]

        try:
            self.ip6 = ip6
            self.ip6_address = self.ip6[""addr""]
        except:
            self.ip6 = None
            self.ip6_address = None

    def __eq__(self, other):
        if other == None:
            return False

        return self.ip4_address == other.ip4_address

    def as_binary_list(self):
        blist = []

        if self.ip4:
            try:
                blist.append(socket.inet_pton(GLib.SYSDEF_AF_INET, self.ip4_address))
            except:
                pass
        if self.ip6:
            try:
                blist.append(socket.inet_pton(GLib.SYSDEF_AF_INET6, self.ip6_address))
            except:
                pass

        return blist

class RemoteInterfaceInfo():
    def __init__(self, blist):
        ip4 = None
        ip6 = None

        for item in blist:
            try:
                ip4 = socket.inet_ntop(socket.AF_INET, item)
            except ValueError:
                ip6 = socket.inet_ntop(socket.AF_INET6, item)

        if ip4:
            self.ip4_address = ip4
        if ip6:
            self.ip6_address = ip6

    def __eq__(self, other):
        if other == None:
            return False

        return self.ip4_address == other.ip4_address

last_location = Gio.File.new_for_path(GLib.get_home_dir())
# A normal GtkFileChooserDialog only lets you pick folders OR files, not
# both in the same dialog.  This does.

class FolderFileChooserDialog(Gtk.Dialog):
    def __init__(self, window_title, transient_parent, starting_location):
        super(FolderFileChooserDialog, self).__init__(title=window_title,
                                                      parent=transient_parent,
                                                      default_width=750,
                                                      default_height=500)

        self.add_buttons(_(""Cancel""), Gtk.ResponseType.CANCEL,
                         _(""Add""), Gtk.ResponseType.OK)

        self.chooser = Gtk.FileChooserWidget(action=Gtk.FileChooserAction.OPEN, select_multiple=True)
        self.chooser.set_current_folder_file(starting_location)
        self.chooser.connect(""file-activated"", lambda chooser: self.response(Gtk.ResponseType.OK))
        self.chooser.show_all()

        self.get_content_area().add(self.chooser)
        self.get_content_area().set_border_width(0)
        self.get_uris = self.chooser.get_uris
        self.get_current_folder_file = self.chooser.get_current_folder_file
        self.connect(""key-press-event"", self.on_button_press)

    def on_button_press(self, widget, event, data=None):
        multi = len(self.chooser.get_uris()) != 1
        if event.keyval in (Gdk.KEY_KP_Enter, Gdk.KEY_Return) and multi:
            self.response(Gtk.ResponseType.OK)
            return Gdk.EVENT_STOP

        return Gdk.EVENT_PROPAGATE

def create_file_and_folder_picker(dialog_parent=None):
    chooser = FolderFileChooserDialog(_(""Select file(s) to send""), dialog_parent, last_location)

    def update_last_location(dialog, response_id, data=None):
        if response_id != Gtk.ResponseType.OK:
            return

        global last_location
        last_location = chooser.get_current_folder_file()

    chooser.connect(""response"", update_last_location)
    return chooser

# Used as a decorator to run things in the background
def _async(func):
    def wrapper(*args, **kwargs):
        thread = threading.Thread(target=func, args=args, kwargs=kwargs)
        thread.daemon = True
        thread.start()
        return thread
    return wrapper

# Used as a decorator to run things in the main loop, from another thread
def _idle(func):
    def wrapper(*args, **kwargs):
        GLib.idle_add(func, *args, **kwargs)
    return wrapper

def print_stack():
    traceback.print_stack()

def open_save_folder(filename=None):
    bus = Gio.Application.get_default().get_dbus_connection()

    if filename != None:
        abs_path = os.path.join(prefs.get_save_path(), filename)

        if os.path.isfile(abs_path):
            file = Gio.File.new_for_path(abs_path)

            startup_id = str(os.getpid())

            try:
                bus.call_sync(""org.freedesktop.FileManager1"",
                              ""/org/freedesktop/FileManager1"",
                              ""org.freedesktop.FileManager1"",
                              ""ShowItems"",
                              GLib.Variant(""(ass)"",
                                           ([file.get_uri()], startup_id)),
                              None,
                              Gio.DBusCallFlags.NONE,
                              1000,
                              None)
                logging.debug(""Opening save folder using dbus"")
                return
            except GLib.Error as e:
                pass

    app = Gio.AppInfo.get_default_for_type(""inode/directory"", True)

    try:
        logging.debug(""Opening save folder using Gio (mimetype)"")
        Gio.AppInfo.launch_default_for_uri(prefs.get_save_uri(), None)
    except GLib.Error as e:
        logging.critical(""Could not open received files location: %s"" % e.message)

def verify_save_folder(transient_for=None):
    return os.access(prefs.get_save_path(), os.R_OK | os.W_OK)

def save_folder_is_native_fs():
    file = Gio.File.new_for_path(prefs.get_save_path())
    return file.is_native()

def have_free_space(size):
    save_file = Gio.File.new_for_path(prefs.get_save_path())

    try:
        info = save_file.query_filesystem_info(Gio.FILE_ATTRIBUTE_FILESYSTEM_FREE, None)
    except GLib.Error:
        logging.warning(""Unable to check free space in save location (%s), but proceeding anyhow"" % prefs.get_save_path())
        return True

    free = info.get_attribute_uint64(Gio.FILE_ATTRIBUTE_FILESYSTEM_FREE)

    # I guess we could have exactly 0 bytes free, but I think you'd have larger problems.  I want to make sure
    # here that we don't fail because we didn't get a valid number.
    if free == 0:
        return True

    logging.debug(""need: %s, have %s"" % (GLib.format_size(size), GLib.format_size(free)))

    return size < free

def files_exist(base_names):
    for name in base_names:
        path = os.path.join(prefs.get_save_path(), name)
        logging.debug(""(server side) Checking if file or folder %s already exists."" % (path,))
        file = Gio.File.new_for_path(path)
        if file.query_exists(None):
            return True

    return False

def check_ml(fid):
    on_ml = threading.current_thread() == threading.main_thread()
    print(""%s on mainloop: "" % fid, on_ml)

def get_hostname():
    return GLib.get_host_name()

def get_local_name(hostname=get_hostname()):
    local_name = ""%s@%s"" % (GLib.get_user_name(), hostname)
    real_name = GLib.get_real_name()
    if real_name is not None and real_name != """" and real_name != ""Unknown"":
        # according to glib's doc, it can actually return ""Unknown""
        local_name = ""%s - %s"" % (real_name, local_name)
    return local_name

def relpath_from_uri(child_uri, base_uri):
    child_uri = GLib.uri_unescape_string(child_uri)
    base_uri = GLib.uri_unescape_string(base_uri)

    if child_uri.startswith(base_uri):
        return child_uri.replace(base_uri + ""/"", """")
    else:
        return None

def sort_remote_machines(am, bm):
    if am.favorite and not bm.favorite:
        return -1
    elif bm.favorite and not am.favorite:
        return +1
    elif am.recent_time > bm.recent_time:
        return -1
    elif bm.recent_time > am.recent_time:
        return +1
    elif am.display_name and not bm.display_name:
        return -1
    elif bm.display_name and not am.display_name:
        return +1
    elif not am.display_name and not bm.display_name:
        return -1 if am.hostname < bm.hostname else +1

    return -1 if am.display_name < bm.display_name else +1

# adapted from nemo-file-operations.c: format_time()
def format_time_span(seconds):
    if seconds < 0:
        seconds = 0

    if (seconds < 10):
        return _(""A few seconds remaining"")

    if (seconds < 60):
        return _(""%d seconds remaining"") % seconds

    if (seconds < 60 * 60):
        minutes = round(seconds / 60)
        return gettext.ngettext(""%d minute"", ""%d minutes"", minutes) % minutes

    hours = math.floor(seconds / (60 * 60))

    if seconds < (60 * 60 * 4):
        minutes = int((seconds - hours * 60 * 60) / 60)

        h = gettext.ngettext (""%d hour"", ""%d hours"", hours) % hours
        m = gettext.ngettext (""%d minute"", ""%d minutes"", minutes) % minutes
        res = ""%s, %s"" % (h, m)
        return res;

    return gettext.ngettext(""approximately %d hour"", ""approximately %d hours"", hours) % hours


# adapted from nemo-file-operations.c: format_time()
def precise_format_time_span(micro):
    sdec, total_seconds = math.modf(micro / 1000 / 1000)
    seconds = total_seconds % 60
    mdec, total_minutes = math.modf(total_seconds / 60)
    minutes = total_minutes % 60
    hdec, total_hours = math.modf(total_minutes / 60)
    hours = total_hours % 60
    return (""%02d:%02d:%02d.%s"" % (hours, minutes, seconds, str(sdec)[2:5]))

def get_global_scale_factor():
    screen = Gdk.Screen.get_default()

    v = GObject.Value(int)

    if screen.get_setting(""gdk-window-scaling-factor"", v):
        return v.get_value()

    return 1

class CairoSurfaceLoader(GObject.Object):
    __gsignals__ = {
        'error': (GObject.SignalFlags.RUN_LAST, None, ())
    }

    def __init__(self, icon_size=Gtk.IconSize.DND):
        self.loader =GdkPixbuf.PixbufLoader()
        self.loader.connect(""size-prepared"", self.on_loader_size_prepared)

        s, w, h = Gtk.IconSize.lookup(icon_size)

        self.surface_size = w
        self.pixbuf_size = w * get_global_scale_factor()

    def on_loader_size_prepared(self, loader, width, height, data=None):
        new_width = self.pixbuf_size
        new_height = self.pixbuf_size

        if width != height:
            if width > height:
                aspect_ratio = height / width

                new_width = self.pixbuf_size
                new_height = new_width * aspect_ratio
            else:
                aspect_ratio = width / height

                new_height = self.pixbuf_size
                new_width = new_height * aspect_ratio

        self.loader.set_size(new_width, new_height)

    def add_bytes(self, _bytes):
        try:
            self.loader.write_bytes(GLib.Bytes(_bytes))
        except GLib.Error:
            try:
                self.loader.close()
            except:
                pass

            self.emit(""error"")

    def get_surface(self):
        try:
            self.loader.close()
            pixbuf = self.loader.get_pixbuf()

            if pixbuf:
                surface = Gdk.cairo_surface_create_from_pixbuf(pixbuf,
                                                               get_global_scale_factor(),
                                                               None)
                return surface
        except:
            self.emit(""error"")

class AboutDialog():
    def __init__(self, parent):
        # Maybe this can be configured during the build? But this works.
        if config.FLATPAK_BUILD:
            name = ""Warpinator (Flatpak)""
        else:
            name = ""Warpinator""

        dialog = Gtk.AboutDialog(parent=parent,
                                 title=_(""About""),
                                 program_name=name,
                                 icon_name=""org.x.Warpinator"",
                                 logo_icon_name=""org.x.Warpinator"",
                                 comments=_(""Send and Receive Files across the Network""),
                                 website=""https://github.com/linuxmint/warpinator"",
                                 version=config.VERSION,
                                 license_type=Gtk.License.GPL_3_0)

        dialog.run()
        dialog.destroy()

class WarpLogFormatter(logging.Formatter):
    dbg_crit_format = ""%(asctime)-15s::warpinator::%(levelname)s: %(message)s -- %(filename)s (line %(lineno)d)""
    info_format = ""%(asctime)-15s::warpinator: %(message)s""

    def __init__(self):
        super().__init__()

    def format(self, record):
        if record.levelno in (logging.DEBUG, logging.ERROR):
            self._style._fmt = WarpLogFormatter.dbg_crit_format

        elif record.levelno == logging.INFO:
            self._style._fmt = WarpLogFormatter.info_format

        result = logging.Formatter.format(self, record)

        return result


recent_manager = Gtk.RecentManager()

def add_to_recents_if_single_selection(uri_list):
    if len(uri_list) == 1:
        try:
            recent_manager.add_item(uri_list[0])
        except Exception as e:
            logging.warning(""Could not add '%s' single item to recent files: %s"" % e)

def get_recent_chooser_menu():
    chooser = Gtk.RecentChooserMenu(show_tips=True,
                                    sort_type=Gtk.RecentSortType.MRU,
                                    show_not_found=False)

    return chooser
"
"import hashlib, base64, uuid
from cryptography.hazmat.primitives import hashes
from typing import Any, final
class Hashing():
    def __init__(self) -> None:
        self.salt = None
    def __call__(self, *args:Any):
        self.salt = args[0]
    def __str__(self) -> str:
        return ""Hashing Funcitions In Here""

    def Standard_Multi_Hash(self,Data:str):
        '''Inreversable Salted Hash Function Don't Use If U Want To Get The Content Back'''
        a = hashlib.sha256(); a.update(bytes(Data.encode())); b = []
        base = hashlib.sha512()
        md = hashlib.md5()
        b.append(str(a.digest()).split(""'"")[1])
        b[0] = str(base64.urlsafe_b64encode(bytes(b[0].encode()))).split(""'"")[1]
        base.update(bytes(b[0].encode()))
        md.update(base.digest())
        b[0]=str(base64.urlsafe_b64encode(base64.standard_b64encode(md.digest()))).split(""'"")[1]
        salt = ['H', 'c', 'D', 'L', 'b', 'M', 'S', 'a', 'N', 'q', 'K', 'j', 'V', 'd', 'O', 'W', 'x']
        c = (b[0].split(""G""))or(b[0].split(""g""))or(b[0].split(""v""))or(b[0].split(""x"")); d=[]; e=[]
        for i in range(len(c)): a = salt[i]; b = c[i]; c[i] = b+a
        for i in range(len(c)):
            try: d.append(c[i+1])
            except: d.append(c[0])
            e.append(''.join(d))
            final = self.BLAKE2(bytes(str(e[0]).encode()))
            return(final)

    def __Salt(self,data,salt:bytes = None):
        if not salt:
            salts = []
            salts.append(str(hashlib.sha256(uuid.uuid4().bytes).digest()).split(""'"")[1])
            salts.append(str(data).split(""'"")[1])
            salts.append(str(hashlib.sha256(uuid.uuid4().bytes).digest()).split(""'"")[1])
            salts.append(str(hashlib.sha256(uuid.uuid4().bytes).digest()).split(""'"")[1])
            salts.append(str(data).split(""'"")[1])
            salts.append(str(data).split(""'"")[1])
            salts.append(str(hashlib.sha256(uuid.uuid4().bytes).digest()).split(""'"")[1])
            return base64.standard_b64encode(bytes((str(base64.urlsafe_b64encode(bytes(''.join(salts).encode()))).split(""'"")[1]+str(base64.urlsafe_b64encode(base64.standard_b64encode((bytes(''.join(salts).encode()))))).split(""'"")[1]).encode()))
        if salt:
            salts = []
            salts.append(str(hashlib.sha256(salt).digest()).split(""'"")[1])
            salts.append(str(data).split(""'"")[1])
            salts.append(str(hashlib.sha256(salt).digest()).split(""'"")[1])
            salts.append(str(hashlib.sha256(salt).digest()).split(""'"")[1])
            salts.append(str(data).split(""'"")[1])
            salts.append(str(data).split(""'"")[1])
            salts.append(str(hashlib.sha256(salt).digest()).split(""'"")[1])
            return base64.standard_b64encode(bytes((str(base64.urlsafe_b64encode(bytes(''.join(salts).encode()))).split(""'"")[1]+str(base64.urlsafe_b64encode(base64.standard_b64encode((bytes(''.join(salts).encode()))))).split(""'"")[1]).encode()))
        
    def SHA256(self,data:str):
        sha = hashlib.sha256(bytes(data.encode()))
        hash = sha.digest()
        return self.__Salt(hash,salt=self.salt)

    def SHA512(self,data:str):
        sha = hashlib.sha512(bytes(data.encode()))
        hash = str(sha.digest())
        return self.__Salt(hash,salt=self.salt)

    def SHA244(self,data:str):
        sha = hashlib.sha224(bytes(data.encode()))
        hash = str(sha.digest())
        return self.__Salt(hash,salt=self.salt)

    def MD5(self,data:str):
        sha = hashlib.md5(bytes(data.encode()))
        hash = str(sha.digest())
        return self.__Salt(hash,salt=self.salt)

    def SHA384(self,data:str):
        sha = hashlib.sha384(bytes(data.encode()))
        hash = str(sha.digest())
        return self.__Salt(hash,salt=self.salt)

    def BLAKE2(self,data:bytes):
        a = hashes.Hash(hashes.BLAKE2s(32))
        a.update(data)
        return self.__Salt(a.finalize(),salt=self.salt)
        ","import hashlib, base64, uuid
from cryptography.hazmat.primitives import hashes
from typing import Any, final
class Hashing():
    def __init__(self) -> None:
        self.salt = None
    def __call__(self, *args:Any):
        self.salt = args[0]
    def __str__(self) -> str:
        return ""Hashing Funcitions In Here""

    def Standard_Multi_Hash(self,Data:str):
        '''Inreversable Salted Hash Function Don't Use If U Want To Get The Content Back'''
        a = hashlib.sha256(); a.update(bytes(Data.encode())); b = []
        base = hashlib.sha512()
        md = hashlib.md5()
        b.append(str(a.digest()).split(""'"")[1])
        b[0] = str(base64.urlsafe_b64encode(bytes(b[0].encode()))).split(""'"")[1]
        base.update(bytes(b[0].encode()))
        md.update(base.digest())
        b[0]=str(base64.urlsafe_b64encode(base64.standard_b64encode(md.digest()))).split(""'"")[1]
        salt = ['H', 'c', 'D', 'L', 'b', 'M', 'S', 'a', 'N', 'q', 'K', 'j', 'V', 'd', 'O', 'W', 'x']
        c = (b[0].split(""G""))or(b[0].split(""g""))or(b[0].split(""v""))or(b[0].split(""x"")); d=[]; e=[]
        for i in range(len(c)): a = salt[i]; b = c[i]; c[i] = b+a
        for i in range(len(c)):
            try: d.append(c[i+1])
            except: d.append(c[0])
            e.append(''.join(d))
            final = self.BLAKE2(bytes(str(e[0]).encode()))
            return(final)

    def __Salt(self,data,salt:bytes = None):
        if not salt:
            salts = []
            salts.append(str(hashlib.sha256(uuid.uuid4().bytes).digest()).split(""'"")[1])
            salts.append(str(data).split(""'"")[1])
            salts.append(str(hashlib.sha256(uuid.uuid4().bytes).digest()).split(""'"")[1])
            salts.append(str(hashlib.sha256(uuid.uuid4().bytes).digest()).split(""'"")[1])
            salts.append(str(data).split(""'"")[1])
            salts.append(str(data).split(""'"")[1])
            salts.append(str(hashlib.sha256(uuid.uuid4().bytes).digest()).split(""'"")[1])
            return base64.standard_b64encode(bytes((str(base64.urlsafe_b64encode(bytes(''.join(salts).encode()))).split(""'"")[1]+str(base64.urlsafe_b64encode(base64.standard_b64encode((bytes(''.join(salts).encode()))))).split(""'"")[1]).encode()))
        if salt:
            salts = []
            salts.append(str(hashlib.sha256(salt).digest()).split(""'"")[1])
            salts.append(str(data).split(""'"")[1])
            salts.append(str(hashlib.sha256(salt).digest()).split(""'"")[1])
            salts.append(str(hashlib.sha256(salt).digest()).split(""'"")[1])
            salts.append(str(data).split(""'"")[1])
            salts.append(str(data).split(""'"")[1])
            salts.append(str(hashlib.sha256(salt).digest()).split(""'"")[1])
            return base64.standard_b64encode(bytes((str(base64.urlsafe_b64encode(bytes(''.join(salts).encode()))).split(""'"")[1]+str(base64.urlsafe_b64encode(base64.standard_b64encode((bytes(''.join(salts).encode()))))).split(""'"")[1]).encode()))
        
    def SHA256(self,data:str):
        sha = hashlib.sha256(bytes(data.encode()))
        hash = sha.digest()
        return self.__Salt(hash,salt=self.salt)

    def SHA512(self,data:str):
        sha = hashlib.sha512(bytes(data.encode()))
        hash = str(sha.digest())
        return self.__Salt(hash,salt=self.salt)

    def SHA244(self,data:str):
        sha = hashlib.sha224(bytes(data.encode()))
        hash = str(sha.digest())
        return self.__Salt(hash,salt=self.salt)

    def SHA384(self,data:str):
        sha = hashlib.sha384(bytes(data.encode()))
        hash = str(sha.digest())
        return self.__Salt(hash,salt=self.salt)

    def BLAKE2(self,data:bytes):
        a = hashes.Hash(hashes.BLAKE2s(32))
        a.update(data)
        return self.__Salt(a.finalize(),salt=self.salt)
        "
